<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>parser/parse_jsontable.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>parser/parse_jsontable.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L34">JsonTableParseContext</a></li>
<li><a href="#L41">JsonTableParseContext</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L173">CheckDuplicateColumnOrPathNames</a></li>
<li><a href="#L216">LookupPathOrColumnName</a></li>
<li><a href="#L231">generateJsonTablePathName</a></li>
<li><a href="#L377">isCompositeType</a></li>
<li><a href="#L499">makeJsonTablePathScan</a></li>
<li><a href="#L534">makeJsonTableSiblingJoin</a></li>
<li><a href="#L76">transformJsonTable</a></li>
<li><a href="#L399">transformJsonTableColumn</a></li>
<li><a href="#L251">transformJsonTableColumns</a></li>
<li><a href="#L454">transformJsonTableNestedColumns</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * parse_jsontable.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; parsing of JSON_TABLE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/parser/parse_jsontable.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_collation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_clause.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_collate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_expr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_relation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/json.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Context for <a href="#L251" title="parser/parse_jsontable.c:251">transformJsonTableColumns</a>() */<br/></li>
<li><a id="L34">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">JsonTableParseContext</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParseState *pstate;<br/></li>
<li>&nbsp; &nbsp; JsonTable&nbsp; *jt;<br/></li>
<li>&nbsp; &nbsp; TableFunc&nbsp; *tf;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pathNames;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* list of all path and columns names */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathNameId;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* path name id counter */<br/></li>
<li><a id="L41">&#x200c;</a></span>} <span class="linkable">JsonTableParseContext</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> JsonTablePlan *<a href="#L251" title="parser/parse_jsontable.c:251">transformJsonTableColumns</a>(<a href="#L34" title="parser/parse_jsontable.c:34">JsonTableParseContext</a> *cxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *columns,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *passingArgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonTablePathSpec *pathspec);<br/></li>
<li><span class="Type">static</span> JsonTablePlan *<a href="#L454" title="parser/parse_jsontable.c:454">transformJsonTableNestedColumns</a>(<a href="#L34" title="parser/parse_jsontable.c:34">JsonTableParseContext</a> *cxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *passingArgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *columns);<br/></li>
<li><span class="Type">static</span> JsonFuncExpr *<a href="#L399" title="parser/parse_jsontable.c:399">transformJsonTableColumn</a>(JsonTableColumn *jtc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *contextItemExpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *passingArgs);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L377" title="parser/parse_jsontable.c:377">isCompositeType</a>(Oid typid);<br/></li>
<li><span class="Type">static</span> JsonTablePlan *<a href="#L499" title="parser/parse_jsontable.c:499">makeJsonTablePathScan</a>(JsonTablePathSpec *pathspec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> errorOnError,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> colMin, <span class="Type">int</span> colMax,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonTablePlan *childplan);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L173" title="parser/parse_jsontable.c:173">CheckDuplicateColumnOrPathNames</a>(<a href="#L34" title="parser/parse_jsontable.c:34">JsonTableParseContext</a> *cxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *columns);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L216" title="parser/parse_jsontable.c:216">LookupPathOrColumnName</a>(<a href="#L34" title="parser/parse_jsontable.c:34">JsonTableParseContext</a> *cxt, <span class="Type">char</span> *name);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L231" title="parser/parse_jsontable.c:231">generateJsonTablePathName</a>(<a href="#L34" title="parser/parse_jsontable.c:34">JsonTableParseContext</a> *cxt);<br/></li>
<li><span class="Type">static</span> JsonTablePlan *<a href="#L534" title="parser/parse_jsontable.c:534">makeJsonTableSiblingJoin</a>(JsonTablePlan *lplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JsonTablePlan *rplan);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L76" title="parser/parse_jsontable.c:76">transformJsonTable</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Transform a raw JsonTable into TableFunc<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Mainly, this transforms the JSON_TABLE() document-generating expression<br/></li>
<li></span><span class="Comment"> * (jt-&gt;context_item) and the column-generating expressions (jt-&gt;columns) to<br/></li>
<li></span><span class="Comment"> * populate TableFunc.docexpr and TableFunc.colvalexprs, respectively. Also,<br/></li>
<li></span><span class="Comment"> * the PASSING <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (jt-&gt;passing) are transformed and added into<br/></li>
<li></span><span class="Comment"> * TableFunc.passingvalexprs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ParseNamespaceItem *<br/></li>
<li><a id="L76">&#x200c;</a><span class="linkable">transformJsonTable</span>(ParseState *pstate, JsonTable *jt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TableFunc&nbsp; *tf;<br/></li>
<li>&nbsp; &nbsp; JsonFuncExpr *jfe;<br/></li>
<li>&nbsp; &nbsp; JsonExpr&nbsp;&nbsp; *je;<br/></li>
<li>&nbsp; &nbsp; JsonTablePathSpec *rootPathSpec = jt-&gt;pathspec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_lateral;<br/></li>
<li>&nbsp; &nbsp; <a href="#L34" title="parser/parse_jsontable.c:34">JsonTableParseContext</a> cxt = {pstate};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(IsA(rootPathSpec-&gt;string, A_Const) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; castNode(A_Const, rootPathSpec-&gt;string)-&gt;val.node.type == T_String);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (jt-&gt;on_error &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jt-&gt;on_error-&gt;btype != JSON_BEHAVIOR_ERROR &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jt-&gt;on_error-&gt;btype != JSON_BEHAVIOR_EMPTY &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jt-&gt;on_error-&gt;btype != JSON_BEHAVIOR_EMPTY_ARRAY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid ON ERROR behavior&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Only <a href="../regex/regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> or ERROR is allowed in the top-level ON ERROR clause.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, jt-&gt;on_error-&gt;location));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cxt.pathNameId = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rootPathSpec-&gt;name == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rootPathSpec-&gt;name = <a href="#L231" title="parser/parse_jsontable.c:231">generateJsonTablePathName</a>(&amp;cxt);<br/></li>
<li>&nbsp; &nbsp; cxt.pathNames = list_make1(rootPathSpec-&gt;name);<br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="parser/parse_jsontable.c:173">CheckDuplicateColumnOrPathNames</a>(&amp;cxt, jt-&gt;columns);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We make lateral_only names of this level visible, whether or not the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * RangeTableFunc is explicitly marked LATERAL.&nbsp; This is needed for SQL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * spec compliance and seems useful on convenience grounds for all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in FROM.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (LATERAL can't nest within a single pstate level, so we don't need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * save/restore logic here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!pstate-&gt;p_lateral_active);<br/></li>
<li>&nbsp; &nbsp; pstate-&gt;p_lateral_active = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tf = makeNode(TableFunc);<br/></li>
<li>&nbsp; &nbsp; tf-&gt;functype = TFT_JSON_TABLE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Transform JsonFuncExpr representing the top JSON_TABLE context_item and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pathspec into a dummy JSON_TABLE_OP JsonExpr.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; jfe = makeNode(JsonFuncExpr);<br/></li>
<li>&nbsp; &nbsp; jfe-&gt;op = JSON_TABLE_OP;<br/></li>
<li>&nbsp; &nbsp; jfe-&gt;context_item = jt-&gt;context_item;<br/></li>
<li>&nbsp; &nbsp; jfe-&gt;pathspec = (Node *) rootPathSpec-&gt;string;<br/></li>
<li>&nbsp; &nbsp; jfe-&gt;passing = jt-&gt;passing;<br/></li>
<li>&nbsp; &nbsp; jfe-&gt;on_empty = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; jfe-&gt;on_error = jt-&gt;on_error;<br/></li>
<li>&nbsp; &nbsp; jfe-&gt;location = jt-&gt;location;<br/></li>
<li>&nbsp; &nbsp; tf-&gt;docexpr = <a href="parse_expr.c.html#L121" title="parser/parse_expr.c:121">transformExpr</a>(pstate, (Node *) jfe, EXPR_KIND_FROM_FUNCTION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a JsonTablePlan that will generate row pattern that becomes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * source data for JSON path expressions in jt-&gt;columns.&nbsp; This also adds<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the columns' transformed JsonExpr nodes into tf-&gt;colvalexprs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cxt.jt = jt;<br/></li>
<li>&nbsp; &nbsp; cxt.tf = tf;<br/></li>
<li>&nbsp; &nbsp; tf-&gt;plan = (Node *) <a href="#L251" title="parser/parse_jsontable.c:251">transformJsonTableColumns</a>(&amp;cxt, jt-&gt;columns,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jt-&gt;passing,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rootPathSpec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy the transformed PASSING arguments into the TableFunc node, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they are evaluated separately from the JsonExpr that we just put in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * TableFunc.docexpr.&nbsp; JsonExpr.passing_values is still kept around for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/ruleutils.c.html#L11776" title="utils/adt/ruleutils.c:11776">get_json_table</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; je = (JsonExpr *) tf-&gt;docexpr;<br/></li>
<li>&nbsp; &nbsp; tf-&gt;passingvalexprs = copyObject(je-&gt;passing_values);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tf-&gt;ordinalitycol = -<span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* undefine ordinality column number */<br/></li>
<li></span>&nbsp; &nbsp; tf-&gt;location = jt-&gt;location;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pstate-&gt;p_lateral_active = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark the RTE as LATERAL if the user said LATERAL explicitly, or if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there are <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> lateral cross-references in it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; is_lateral = jt-&gt;lateral || <a href="../optimizer/util/var.c.html#L441" title="optimizer/util/var.c:441">contain_vars_of_level</a>((Node *) tf, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="parse_relation.c.html#L2049" title="parser/parse_relation.c:2049">addRangeTableEntryForTableFunc</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tf, jt-&gt;alias, is_lateral, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check if a column / path name is duplicated in the given shared list of<br/></li>
<li></span><span class="Comment"> * names.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L173">&#x200c;</a></span><span class="linkable">CheckDuplicateColumnOrPathNames</span>(<a href="#L34" title="parser/parse_jsontable.c:34">JsonTableParseContext</a> *cxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *columns)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc1, columns)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonTableColumn *jtc = castNode(JsonTableColumn, lfirst(lc1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (jtc-&gt;coltype == JTC_NESTED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (jtc-&gt;pathspec-&gt;name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L216" title="parser/parse_jsontable.c:216">LookupPathOrColumnName</a>(cxt, jtc-&gt;pathspec-&gt;name))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_ALIAS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;duplicate JSON_TABLE column or path name: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jtc-&gt;pathspec-&gt;name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jtc-&gt;pathspec-&gt;name_location));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;pathNames = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt-&gt;pathNames, jtc-&gt;pathspec-&gt;name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L173" title="parser/parse_jsontable.c:173">CheckDuplicateColumnOrPathNames</a>(cxt, jtc-&gt;columns);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L216" title="parser/parse_jsontable.c:216">LookupPathOrColumnName</a>(cxt, jtc-&gt;name))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_ALIAS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;duplicate JSON_TABLE column or path name: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jtc-&gt;name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, jtc-&gt;location));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;pathNames = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt-&gt;pathNames, jtc-&gt;name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Lookup a column/path name in the given name list, returning true if already<br/></li>
<li></span><span class="Comment"> * there.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L216">&#x200c;</a></span><span class="linkable">LookupPathOrColumnName</span>(<a href="#L34" title="parser/parse_jsontable.c:34">JsonTableParseContext</a> *cxt, <span class="Type">char</span> *name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, cxt-&gt;pathNames)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(name, (<span class="Type">const</span> <span class="Type">char</span> *) lfirst(lc)) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Generate a new unique JSON_TABLE path name. */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L231">&#x200c;</a><span class="linkable">generateJsonTablePathName</span>(<a href="#L34" title="parser/parse_jsontable.c:34">JsonTableParseContext</a> *cxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; namebuf[<span class="Constant">32</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *name = namebuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(namebuf, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(namebuf), <span class="Constant">&quot;json_table_path_</span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cxt-&gt;pathNameId++);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; name = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(name);<br/></li>
<li>&nbsp; &nbsp; cxt-&gt;pathNames = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt-&gt;pathNames, name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> name;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a JsonTablePlan that will supply the source row for 'columns'<br/></li>
<li></span><span class="Comment"> * using 'pathspec' and append the columns' transformed JsonExpr nodes and<br/></li>
<li></span><span class="Comment"> * their type/collation information to cxt-&gt;tf.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> JsonTablePlan *<br/></li>
<li><a id="L251">&#x200c;</a><span class="linkable">transformJsonTableColumns</span>(<a href="#L34" title="parser/parse_jsontable.c:34">JsonTableParseContext</a> *cxt, List *columns,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *passingArgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonTablePathSpec *pathspec)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParseState *pstate = cxt-&gt;pstate;<br/></li>
<li>&nbsp; &nbsp; JsonTable&nbsp; *jt = cxt-&gt;jt;<br/></li>
<li>&nbsp; &nbsp; TableFunc&nbsp; *tf = cxt-&gt;tf;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *col;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ordinality_found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; errorOnError = jt-&gt;on_error &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jt-&gt;on_error-&gt;btype == JSON_BEHAVIOR_ERROR;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; contextItemTypid = <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(tf-&gt;docexpr);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colMin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colMax;<br/></li>
<li>&nbsp; &nbsp; JsonTablePlan *childplan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Start of column <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; colMin = list_length(tf-&gt;colvalexprs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(col, columns)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonTableColumn *rawc = castNode(JsonTableColumn, lfirst(col));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typcoll = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *colexpr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rawc-&gt;coltype != JTC_NESTED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rawc-&gt;name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tf-&gt;colnames = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tf-&gt;colnames,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(<a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(rawc-&gt;name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Determine the type and typmod for the new column. FOR ORDINALITY<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * columns are INTEGER by standard; the others are user-specified.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (rawc-&gt;coltype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JTC_FOR_ORDINALITY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ordinality_found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot use more than one FOR ORDINALITY column&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, rawc-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ordinality_found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colexpr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typid = INT4OID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typmod = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JTC_REGULAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_type.c.html#L310" title="parser/parse_type.c:310">typenameTypeIdAndMod</a>(pstate, rawc-&gt;typeName, &amp;typid, &amp;typmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use JTC_FORMATTED so as to use JSON_QUERY for this column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if the specified type is one that's better handled using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * JSON_QUERY() or if non-default WRAPPER or QUOTES behavior<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is specified.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L377" title="parser/parse_jsontable.c:377">isCompositeType</a>(typid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rawc-&gt;quotes != JS_QUOTES_UNSPEC ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rawc-&gt;wrapper != JSW_UNSPEC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rawc-&gt;coltype = JTC_FORMATTED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALLTHROUGH */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JTC_FORMATTED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JTC_EXISTS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonFuncExpr *jfe;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CaseTestExpr *param = makeNode(CaseTestExpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; param-&gt;collation = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; param-&gt;typeId = contextItemTypid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; param-&gt;typeMod = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jfe = <a href="#L399" title="parser/parse_jsontable.c:399">transformJsonTableColumn</a>(rawc, (Node *) param,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; passingArgs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colexpr = <a href="parse_expr.c.html#L121" title="parser/parse_expr.c:121">transformExpr</a>(pstate, (Node *) jfe,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_FROM_FUNCTION);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_collate.c.html#L177" title="parser/parse_collate.c:177">assign_expr_collations</a>(pstate, colexpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typid = <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(colexpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typmod = <a href="../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>(colexpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typcoll = <a href="../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>(colexpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JTC_NESTED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unknown JSON_TABLE column type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) rawc-&gt;coltype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tf-&gt;coltypes = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(tf-&gt;coltypes, typid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tf-&gt;coltypmods = <a href="../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(tf-&gt;coltypmods, typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tf-&gt;colcollations = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(tf-&gt;colcollations, typcoll);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tf-&gt;colvalexprs = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tf-&gt;colvalexprs, colexpr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* End of column <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(tf-&gt;colvalexprs) == colMin)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No columns in this Scan beside the nested ones. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; colMax = colMin = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; colMax = list_length(tf-&gt;colvalexprs) - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Recursively transform nested columns */<br/></li>
<li></span>&nbsp; &nbsp; childplan = <a href="#L454" title="parser/parse_jsontable.c:454">transformJsonTableNestedColumns</a>(cxt, passingArgs, columns);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create a &quot;parent&quot; scan responsible for all columns handled above. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L499" title="parser/parse_jsontable.c:499">makeJsonTablePathScan</a>(pathspec, errorOnError, colMin, colMax,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; childplan);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check if the type is &quot;composite&quot; for the purpose of checking whether to use<br/></li>
<li></span><span class="Comment"> * JSON_VALUE() or JSON_QUERY() for a given JsonTableColumn.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L377">&#x200c;</a></span><span class="linkable">isCompositeType</span>(Oid typid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typtype = <a href="../utils/cache/lsyscache.c.html#L2629" title="utils/cache/lsyscache.c:2629">get_typtype</a>(typid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> typid == JSONOID ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typid == JSONBOID ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typid == RECORDOID ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; type_is_array(typid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typtype == TYPTYPE_COMPOSITE ||<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* domain over one of the above? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (typtype == TYPTYPE_DOMAIN &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L377" title="parser/parse_jsontable.c:377">isCompositeType</a>(<a href="../utils/cache/lsyscache.c.html#L2521" title="utils/cache/lsyscache.c:2521">getBaseType</a>(typid)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Transform JSON_TABLE column definition into a JsonFuncExpr<br/></li>
<li></span><span class="Comment"> * This turns:<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; - regular column into JSON_VALUE()<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; - FORMAT JSON column into JSON_QUERY()<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; - EXISTS column into JSON_EXISTS()<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> JsonFuncExpr *<br/></li>
<li><a id="L399">&#x200c;</a><span class="linkable">transformJsonTableColumn</span>(JsonTableColumn *jtc, Node *contextItemExpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *passingArgs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *pathspec;<br/></li>
<li>&nbsp; &nbsp; JsonFuncExpr *jfexpr = makeNode(JsonFuncExpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (jtc-&gt;coltype == JTC_REGULAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jfexpr-&gt;op = JSON_VALUE_OP;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (jtc-&gt;coltype == JTC_EXISTS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jfexpr-&gt;op = JSON_EXISTS_OP;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; jfexpr-&gt;op = JSON_QUERY_OP;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pass the column name so <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> runtime JsonExpr errors can <a href="../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> it. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(jtc-&gt;name != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; jfexpr-&gt;column_name = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(jtc-&gt;name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; jfexpr-&gt;context_item = <a href="../nodes/makefuncs.c.html#L863" title="nodes/makefuncs.c:863">makeJsonValueExpr</a>((Expr *) contextItemExpr, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/makefuncs.c.html#L847" title="nodes/makefuncs.c:847">makeJsonFormat</a>(JS_FORMAT_DEFAULT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JS_ENC_DEFAULT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (jtc-&gt;pathspec)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathspec = (Node *) jtc-&gt;pathspec-&gt;string;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Construct default path as '$.&quot;column_name&quot;' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;path, <span class="Constant">&quot;$.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/json.c.html#L1549" title="utils/adt/json.c:1549">escape_json</a>(&amp;path, jtc-&gt;name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathspec = <a href="../nodes/makefuncs.c.html#L545" title="nodes/makefuncs.c:545">makeStringConst</a>(path.data, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; jfexpr-&gt;pathspec = pathspec;<br/></li>
<li>&nbsp; &nbsp; jfexpr-&gt;passing = passingArgs;<br/></li>
<li>&nbsp; &nbsp; jfexpr-&gt;output = makeNode(JsonOutput);<br/></li>
<li>&nbsp; &nbsp; jfexpr-&gt;output-&gt;typeName = jtc-&gt;typeName;<br/></li>
<li>&nbsp; &nbsp; jfexpr-&gt;output-&gt;returning = makeNode(JsonReturning);<br/></li>
<li>&nbsp; &nbsp; jfexpr-&gt;output-&gt;returning-&gt;format = jtc-&gt;format;<br/></li>
<li>&nbsp; &nbsp; jfexpr-&gt;on_empty = jtc-&gt;on_empty;<br/></li>
<li>&nbsp; &nbsp; jfexpr-&gt;on_error = jtc-&gt;on_error;<br/></li>
<li>&nbsp; &nbsp; jfexpr-&gt;quotes = jtc-&gt;quotes;<br/></li>
<li>&nbsp; &nbsp; jfexpr-&gt;wrapper = jtc-&gt;wrapper;<br/></li>
<li>&nbsp; &nbsp; jfexpr-&gt;location = jtc-&gt;location;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> jfexpr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Recursively transform nested columns and create child plan(s) that will be<br/></li>
<li></span><span class="Comment"> * used to evaluate their row patterns.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> JsonTablePlan *<br/></li>
<li><a id="L454">&#x200c;</a><span class="linkable">transformJsonTableNestedColumns</span>(<a href="#L34" title="parser/parse_jsontable.c:34">JsonTableParseContext</a> *cxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *passingArgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *columns)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonTablePlan *plan = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are multiple NESTED COLUMNS clauses in 'columns', their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * respective plans will be combined using a &quot;sibling join&quot; plan, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * effectively does a UNION of the sets of rows coming from each nested<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, columns)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonTableColumn *jtc = castNode(JsonTableColumn, lfirst(lc));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonTablePlan *nested;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (jtc-&gt;coltype != JTC_NESTED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (jtc-&gt;pathspec-&gt;name == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtc-&gt;pathspec-&gt;name = <a href="#L231" title="parser/parse_jsontable.c:231">generateJsonTablePathName</a>(cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nested = <a href="#L251" title="parser/parse_jsontable.c:251">transformJsonTableColumns</a>(cxt, jtc-&gt;columns, passingArgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jtc-&gt;pathspec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = <a href="#L534" title="parser/parse_jsontable.c:534">makeJsonTableSiblingJoin</a>(plan, nested);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = nested;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a JsonTablePlan for given path and ON ERROR behavior.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * colMin and colMin give the <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of columns computed by this scan in the<br/></li>
<li></span><span class="Comment"> * global flat list of column expressions that will be passed to the<br/></li>
<li></span><span class="Comment"> * JSON_TABLE's TableFunc.&nbsp; Both are -1 when all of columns are nested and<br/></li>
<li></span><span class="Comment"> * thus computed by 'childplan'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> JsonTablePlan *<br/></li>
<li><a id="L499">&#x200c;</a><span class="linkable">makeJsonTablePathScan</span>(JsonTablePathSpec *pathspec, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> errorOnError,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> colMin, <span class="Type">int</span> colMax,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonTablePlan *childplan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonTablePathScan *scan = makeNode(JsonTablePathScan);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *pathstring;<br/></li>
<li>&nbsp; &nbsp; Const&nbsp; &nbsp; &nbsp;&nbsp; *value;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(IsA(pathspec-&gt;string, A_Const));<br/></li>
<li>&nbsp; &nbsp; pathstring = castNode(A_Const, pathspec-&gt;string)-&gt;val.sval.sval;<br/></li>
<li>&nbsp; &nbsp; value = <a href="../nodes/makefuncs.c.html#L301" title="nodes/makefuncs.c:301">makeConst</a>(JSONPATHOID, -<span class="Constant">1</span>, InvalidOid, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DirectFunctionCall1(<a href="../utils/adt/jsonpath.c.html#L98" title="utils/adt/jsonpath.c:98">jsonpath_in</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CStringGetDatum(pathstring)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan-&gt;plan.type = T_JsonTablePathScan;<br/></li>
<li>&nbsp; &nbsp; scan-&gt;path = <a href="../nodes/makefuncs.c.html#L951" title="nodes/makefuncs.c:951">makeJsonTablePath</a>(value, pathspec-&gt;name);<br/></li>
<li>&nbsp; &nbsp; scan-&gt;errorOnError = errorOnError;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan-&gt;child = childplan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan-&gt;colMin = colMin;<br/></li>
<li>&nbsp; &nbsp; scan-&gt;colMax = colMax;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (JsonTablePlan *) scan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a JsonTablePlan that will perform a join of the rows coming from<br/></li>
<li></span><span class="Comment"> * 'lplan' and 'rplan'.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The default way of &quot;joining&quot; the rows is to perform a UNION between the<br/></li>
<li></span><span class="Comment"> * sets of rows from 'lplan' and 'rplan'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> JsonTablePlan *<br/></li>
<li><a id="L534">&#x200c;</a><span class="linkable">makeJsonTableSiblingJoin</span>(JsonTablePlan *lplan, JsonTablePlan *rplan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonTableSiblingJoin *join = makeNode(JsonTableSiblingJoin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; join-&gt;plan.type = T_JsonTableSiblingJoin;<br/></li>
<li>&nbsp; &nbsp; join-&gt;lplan = lplan;<br/></li>
<li>&nbsp; &nbsp; join-&gt;rplan = rplan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (JsonTablePlan *) join;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
