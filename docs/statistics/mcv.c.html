<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>statistics/mcv.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>statistics/mcv.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L490">build_column_frequencies</a></li>
<li><a href="#L424">build_distinct_groups</a></li>
<li><a href="#L347">build_mss</a></li>
<li><a href="#L403">compare_sort_item_count</a></li>
<li><a href="#L379">count_distinct_groups</a></li>
<li><a href="#L148">get_mincount_for_mcv_list</a></li>
<li><a href="#L2126">mcv_clause_selectivity_or</a></li>
<li><a href="#L2048">mcv_clauselist_selectivity</a></li>
<li><a href="#L2006">mcv_combine_selectivities</a></li>
<li><a href="#L1599">mcv_get_match_bitmap</a></li>
<li><a href="#L1535">mcv_match_expression</a></li>
<li><a href="#L1472">pg_mcv_list_in</a></li>
<li><a href="#L1498">pg_mcv_list_out</a></li>
<li><a href="#L1507">pg_mcv_list_recv</a></li>
<li><a href="#L1523">pg_mcv_list_send</a></li>
<li><a href="#L1338">pg_stats_ext_mcvlist_items</a></li>
<li><a href="#L465">sort_item_compare</a></li>
<li><a href="#L180">statext_mcv_build</a></li>
<li><a href="#L996">statext_mcv_deserialize</a></li>
<li><a href="#L558">statext_mcv_load</a></li>
<li><a href="#L621">statext_mcv_serialize</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L53">ITEM_SIZE</a></li>
<li><a href="#L59">MinSizeOfMCVList</a></li>
<li><a href="#L100">RESULT_IS_FINAL</a></li>
<li><a href="#L88">RESULT_MERGE</a></li>
<li><a href="#L68">SizeOfMCVList</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * mcv.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; POSTGRES multivariate MCV lists<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/statistics/mcv.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_statistic_ext.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_statistic_ext_data.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;fmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;statistics/extended_stats_internal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;statistics/statistics.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/array.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/selfuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/typcache.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Computes size of a serialized MCV item, depending on the number of<br/></li>
<li></span><span class="Comment"> * dimensions (columns) the statistic is defined on. The datum <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are<br/></li>
<li></span><span class="Comment"> * stored in a separate array (deduplicated, to minimize the size), and<br/></li>
<li></span><span class="Comment"> * so the serialized items only store uint16 indexes into that array.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Each serialized item stores (in this order):<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * - indexes to <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>&nbsp; &nbsp; &nbsp; (ndim * <a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(uint16))<br/></li>
<li></span><span class="Comment"> * - null flags&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ndim * <a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(<a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a>))<br/></li>
<li></span><span class="Comment"> * - frequency&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(double))<br/></li>
<li></span><span class="Comment"> * - base_frequency&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(double))<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There is no alignment padding within an MCV item.<br/></li>
<li></span><span class="Comment"> * So in total each MCV item requires this many bytes:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; ndim * (<a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(uint16) + <a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(<a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a>)) + 2 * <a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(double)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L53">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ITEM_SIZE</span>(ndims)&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((ndims) * (</span><span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(uint16) + </span><span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(</span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span><span class="PreProc">)) + </span><span class="Constant">2</span><span class="PreProc"> * </span><span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(</span><span class="Type">double</span><span class="PreProc">))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Used to compute size of serialized MCV list representation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L59">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MinSizeOfMCVList</span>&nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (VARHDRSZ + </span><span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(uint32) * </span><span class="Constant">3</span><span class="PreProc"> + </span><span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(AttrNumber))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Size of the serialized MCV list, excluding the space needed for<br/></li>
<li></span><span class="Comment"> * deduplicated per-dimension <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. The macro is meant to be used<br/></li>
<li></span><span class="Comment"> * when it's not yet safe to access the serialized info about amount<br/></li>
<li></span><span class="Comment"> * of data for each column.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L68">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SizeOfMCVList</span>(ndims,nitems)&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((<a href="#L59" title="statistics/mcv.c:59">MinSizeOfMCVList</a> + </span><span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(Oid) * (ndims)) + \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; ((ndims) * </span><span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(DimensionInfo)) + \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; ((nitems) * <a href="#L53" title="statistics/mcv.c:53">ITEM_SIZE</a>(ndims)))<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> MultiSortSupport <a href="#L347" title="statistics/mcv.c:347">build_mss</a>(StatsBuildData *data);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> SortItem *<a href="#L424" title="statistics/mcv.c:424">build_distinct_groups</a>(<span class="Type">int</span> numrows, SortItem *items,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MultiSortSupport mss, <span class="Type">int</span> *ndistinct);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> SortItem **<a href="#L490" title="statistics/mcv.c:490">build_column_frequencies</a>(SortItem *groups, <span class="Type">int</span> ngroups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MultiSortSupport mss, <span class="Type">int</span> *ncounts);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L379" title="statistics/mcv.c:379">count_distinct_groups</a>(<span class="Type">int</span> numrows, SortItem *items,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MultiSortSupport mss);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute new value for bitmap item, considering whether it's used for<br/></li>
<li></span><span class="Comment"> * clauses connected by AND/OR.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L88">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RESULT_MERGE</span>(value, is_or, match) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((is_or) ? ((value) || (match)) : ((value) &amp;&amp; (match)))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * When processing a list of clauses, the bitmap item may get set to a value<br/></li>
<li></span><span class="Comment"> * such that additional clauses can't change it. For example, when processing<br/></li>
<li></span><span class="Comment"> * a list of clauses connected to AND, as soon as the item gets set to 'false'<br/></li>
<li></span><span class="Comment"> * then it'll remain like that. Similarly clauses connected by OR and 'true'.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true when the value in the bitmap can't change no matter how the<br/></li>
<li></span><span class="Comment"> * remaining clauses are evaluated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L100">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RESULT_IS_FINAL</span>(value, is_or)&nbsp; &nbsp; ((is_or) ? (value) : (!(value)))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L148" title="statistics/mcv.c:148">get_mincount_for_mcv_list</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Determine the minimum number of times a value needs to appear in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; the sample for it to be included in the MCV list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We want to keep only <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that appear sufficiently often in the<br/></li>
<li></span><span class="Comment"> * sample that it is reasonable to extrapolate their sample frequencies to<br/></li>
<li></span><span class="Comment"> * the entire table.&nbsp; We do this by placing an <a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound on the relative<br/></li>
<li></span><span class="Comment"> * standard error of the sample frequency, so that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> estimates the<br/></li>
<li></span><span class="Comment"> * <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> generates from the MCV statistics can be expected to be<br/></li>
<li></span><span class="Comment"> * reasonably accurate.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since we are sampling without replacement, the sample frequency of a<br/></li>
<li></span><span class="Comment"> * particular value is described by a hypergeometric distribution.&nbsp; A<br/></li>
<li></span><span class="Comment"> * common rule of thumb when estimating errors in this situation is to<br/></li>
<li></span><span class="Comment"> * require at least 10 instances of the value in the sample, in which case<br/></li>
<li></span><span class="Comment"> * the distribution can be approximated by a normal distribution, and<br/></li>
<li></span><span class="Comment"> * standard error analysis techniques can be applied.&nbsp; Given a sample size<br/></li>
<li></span><span class="Comment"> * of n, a population size of N, and a sample frequency of p=cnt/n, the<br/></li>
<li></span><span class="Comment"> * standard error of the proportion p is given by<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; SE = sqrt(p*(1-p)/n) * sqrt((N-n)/(N-1))<br/></li>
<li></span><span class="Comment"> * where the second term is the finite population correction.&nbsp; To get<br/></li>
<li></span><span class="Comment"> * reasonably accurate <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> estimates, we impose an <a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound on the<br/></li>
<li></span><span class="Comment"> * relative standard error of 20% -- i.e., SE/p &lt; 0.2.&nbsp; This 20% relative<br/></li>
<li></span><span class="Comment"> * error bound is fairly arbitrary, but has been found empirically to work<br/></li>
<li></span><span class="Comment"> * well.&nbsp; Rearranging this formula gives a <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound on the number of<br/></li>
<li></span><span class="Comment"> * instances of the value seen:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; cnt &gt; n*(N-n) / (N-n+0.04*n*(N-1))<br/></li>
<li></span><span class="Comment"> * This bound is at most 25, and approaches 0 as n approaches 0 or N. The<br/></li>
<li></span><span class="Comment"> * case where n approaches 0 cannot happen in practice, since the sample<br/></li>
<li></span><span class="Comment"> * size is at least 300.&nbsp; The case where n approaches N corresponds to<br/></li>
<li></span><span class="Comment"> * sampling the whole table, in which case it is reasonable to keep<br/></li>
<li></span><span class="Comment"> * the whole MCV list (have no <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound), so it makes sense to apply<br/></li>
<li></span><span class="Comment"> * this formula for all inputs, even though the above derivation is<br/></li>
<li></span><span class="Comment"> * technically only valid when the right hand side is at least around 10.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * An alternative way to look at this formula is as follows -- assume that<br/></li>
<li></span><span class="Comment"> * the number of instances of the value seen scales up to the entire<br/></li>
<li></span><span class="Comment"> * table, so that the population count is K=N*cnt/n. Then the distribution<br/></li>
<li></span><span class="Comment"> * in the sample is a hypergeometric distribution parameterised by N, n<br/></li>
<li></span><span class="Comment"> * and K, and the bound above is mathematically equivalent to demanding<br/></li>
<li></span><span class="Comment"> * that the standard deviation of that distribution is less than 20% of<br/></li>
<li></span><span class="Comment"> * its mean.&nbsp; Thus the relative errors in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> estimates produced<br/></li>
<li></span><span class="Comment"> * from the MCV statistics are likely to be not too large.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L148">&#x200c;</a></span><span class="linkable">get_mincount_for_mcv_list</span>(<span class="Type">int</span> samplerows, <span class="Type">double</span> totalrows)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; n = samplerows;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; N = totalrows;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; numer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; denom;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; numer = n * (N - n);<br/></li>
<li>&nbsp; &nbsp; denom = N - n + <span class="Constant">0.04</span> * n * (N - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Guard against division by zero (possible if n = N = 1) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (denom == <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> numer / denom;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Builds MCV list from the set of sampled rows.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The algorithm is quite simple:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; (1) sort the data (default collation, '&lt;' for the data type)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; (2) count distinct groups, decide how many to keep<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; (3) build the MCV list using the threshold determined in (2)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; (4) remove rows represented by the MCV from the sample<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MCVList *<br/></li>
<li><a id="L180">&#x200c;</a><span class="linkable">statext_mcv_build</span>(StatsBuildData *data, <span class="Type">double</span> totalrows, <span class="Type">int</span> stattarget)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numattrs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numrows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ngroups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; mincount;<br/></li>
<li>&nbsp; &nbsp; SortItem&nbsp;&nbsp; *items;<br/></li>
<li>&nbsp; &nbsp; SortItem&nbsp;&nbsp; *groups;<br/></li>
<li>&nbsp; &nbsp; MCVList&nbsp; &nbsp; *mcvlist = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; MultiSortSupport mss;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* comparator for all the columns */<br/></li>
<li></span>&nbsp; &nbsp; mss = <a href="#L347" title="statistics/mcv.c:347">build_mss</a>(data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sort the rows */<br/></li>
<li></span>&nbsp; &nbsp; items = <a href="extended_stats.c.html#L986" title="statistics/extended_stats.c:986">build_sorted_items</a>(data, &amp;nitems, mss,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; data-&gt;nattnums, data-&gt;attnums);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!items)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* for convenience */<br/></li>
<li></span>&nbsp; &nbsp; numattrs = data-&gt;nattnums;<br/></li>
<li>&nbsp; &nbsp; numrows = data-&gt;numrows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transform the sorted rows into groups (sorted by frequency) */<br/></li>
<li></span>&nbsp; &nbsp; groups = <a href="#L424" title="statistics/mcv.c:424">build_distinct_groups</a>(nitems, items, mss, &amp;ngroups);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The maximum number of MCV items to store, based on the statistics<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * target we computed for the statistics object (from the target set for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the object itself, attributes and the system default). In <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't keep more groups than we have available.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nitems = stattarget;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nitems &gt; ngroups)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nitems = ngroups;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Decide how many items to keep in the MCV list. We can't use the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * algorithm as per-column MCV lists, because that only considers the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * actual group frequency - but we're primarily interested in how the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * actual frequency differs from the base frequency (product of simple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * per-column frequencies, as if the columns were independent).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Using the same algorithm might exclude items that are close to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;average&quot; frequency of the sample. But that does not say whether the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * observed frequency is close to the base frequency or not. We also need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to consider unexpectedly uncommon items (again, compared to the base<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * frequency), and the single-column algorithm does not have to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We simply decide how many items to keep by computing the minimum count<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * using <a href="#L148" title="statistics/mcv.c:148">get_mincount_for_mcv_list</a>() and then keep all items that seem to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be more common than that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; mincount = <a href="#L148" title="statistics/mcv.c:148">get_mincount_for_mcv_list</a>(numrows, totalrows);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Walk the groups until we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the first group with a count below the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mincount threshold (the index of that group is the number of groups we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * want to keep).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nitems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (groups[i].count &lt; mincount)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At this point, we know the number of items for the MCV list. There<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might be <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> (for uniform distribution with many groups), and in that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case, there will be no MCV list. Otherwise, construct the MCV list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nitems &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortItem&nbsp; &nbsp; key;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MultiSortSupport tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* frequencies for <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in each attribute */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SortItem&nbsp; **freqs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *nfreqs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* used to search <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tmp = (MultiSortSupport) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(offsetof(MultiSortSupportData, ssup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortSupportData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* compute frequencies for <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in each column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nfreqs = (<span class="Type">int</span> *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * numattrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; freqs = <a href="#L490" title="statistics/mcv.c:490">build_column_frequencies</a>(groups, ngroups, mss, nfreqs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Allocate the MCV list structure, set the global parameters.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mcvlist = (MCVList *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(offsetof(MCVList, items) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MCVItem) * nitems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mcvlist-&gt;magic = STATS_MCV_MAGIC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mcvlist-&gt;type = STATS_MCV_TYPE_BASIC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mcvlist-&gt;ndimensions = numattrs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mcvlist-&gt;nitems = nitems;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* store info about data type OIDs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numattrs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mcvlist-&gt;types[i] = data-&gt;stats[i]-&gt;attrtypid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy the first chunk of groups into the result. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nitems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just point to the proper place in the list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MCVItem&nbsp; &nbsp; *item = &amp;mcvlist-&gt;items[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = (Datum *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * numattrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;isnull = (<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * numattrs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for the group */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(item-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, groups[i].<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * numattrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(item-&gt;isnull, groups[i].isnull, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * numattrs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* groups should be sorted by frequency in descending order */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert((i == <span class="Constant">0</span>) || (groups[i - <span class="Constant">1</span>].count &gt;= groups[i].count));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* group frequency */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;frequency = (<span class="Type">double</span>) groups[i].count / numrows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* base frequency, if the attributes were independent */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;base_frequency = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; numattrs; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortItem&nbsp;&nbsp; *freq;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* single dimension */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp-&gt;ndims = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp-&gt;ssup[<span class="Constant">0</span>] = mss-&gt;ssup[j];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fill search key */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key.<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = &amp;groups[i].<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key.isnull = &amp;groups[i].isnull[j];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freq = (SortItem *) bsearch_arg(&amp;key, freqs[j], nfreqs[j],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortItem),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="extended_stats.c.html#L865" title="statistics/extended_stats.c:865">multi_sort_compare</a>, tmp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;base_frequency *= ((<span class="Type">double</span>) freq-&gt;count) / numrows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nfreqs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(freqs);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(items);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(groups);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> mcvlist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L347" title="statistics/mcv.c:347">build_mss</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Build a MultiSortSupport for the given StatsBuildData.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> MultiSortSupport<br/></li>
<li><a id="L347">&#x200c;</a><span class="linkable">build_mss</span>(StatsBuildData *data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numattrs = data-&gt;nattnums;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort by multiple columns (using array of SortSupport) */<br/></li>
<li></span>&nbsp; &nbsp; MultiSortSupport mss = <a href="extended_stats.c.html#L832" title="statistics/extended_stats.c:832">multi_sort_init</a>(numattrs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* prepare the sort <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for all the attributes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numattrs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VacAttrStats *colstat = data-&gt;stats[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *type;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; type = <a href="../utils/cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(colstat-&gt;attrtypid, TYPECACHE_LT_OPR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (type-&gt;lt_opr == InvalidOid) <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for ordering operator for type </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; colstat-&gt;attrtypid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="extended_stats.c.html#L851" title="statistics/extended_stats.c:851">multi_sort_add_dimension</a>(mss, i, type-&gt;lt_opr, colstat-&gt;attrcollid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> mss;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L379" title="statistics/mcv.c:379">count_distinct_groups</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Count distinct combinations of SortItems in the array.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The array is assumed to be sorted according to the MultiSortSupport.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L379">&#x200c;</a></span><span class="linkable">count_distinct_groups</span>(<span class="Type">int</span> numrows, SortItem *items, MultiSortSupport mss)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndistinct;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ndistinct = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; numrows; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure the array really is sorted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="extended_stats.c.html#L865" title="statistics/extended_stats.c:865">multi_sort_compare</a>(&amp;items[i], &amp;items[i - <span class="Constant">1</span>], mss) &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="extended_stats.c.html#L865" title="statistics/extended_stats.c:865">multi_sort_compare</a>(&amp;items[i], &amp;items[i - <span class="Constant">1</span>], mss) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndistinct += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ndistinct;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L403" title="statistics/mcv.c:403">compare_sort_item_count</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Comparator for sorting items by count (frequencies) in descending<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; order.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L403">&#x200c;</a></span><span class="linkable">compare_sort_item_count</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SortItem&nbsp;&nbsp; *ia = (SortItem *) a;<br/></li>
<li>&nbsp; &nbsp; SortItem&nbsp;&nbsp; *ib = (SortItem *) b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ia-&gt;count == ib-&gt;count)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ia-&gt;count &gt; ib-&gt;count)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L424" title="statistics/mcv.c:424">build_distinct_groups</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Build an array of SortItems for distinct groups and counts matching<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; items.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The 'items' array is assumed to be sorted.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> SortItem *<br/></li>
<li><a id="L424">&#x200c;</a><span class="linkable">build_distinct_groups</span>(<span class="Type">int</span> numrows, SortItem *items, MultiSortSupport mss,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *ndistinct)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ngroups = <a href="#L379" title="statistics/mcv.c:379">count_distinct_groups</a>(numrows, items, mss);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SortItem&nbsp;&nbsp; *groups = (SortItem *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ngroups * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortItem));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; j = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; groups[<span class="Constant">0</span>] = items[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; groups[<span class="Constant">0</span>].count = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; numrows; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Assume sorted in ascending order. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="extended_stats.c.html#L865" title="statistics/extended_stats.c:865">multi_sort_compare</a>(&amp;items[i], &amp;items[i - <span class="Constant">1</span>], mss) &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* New distinct group detected. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="extended_stats.c.html#L865" title="statistics/extended_stats.c:865">multi_sort_compare</a>(&amp;items[i], &amp;items[i - <span class="Constant">1</span>], mss) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; groups[++j] = items[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; groups[j].count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; groups[j].count++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ensure we filled the expected number of distinct groups */<br/></li>
<li></span>&nbsp; &nbsp; Assert(j + <span class="Constant">1</span> == ngroups);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort the distinct groups by frequency (in descending order). */<br/></li>
<li></span>&nbsp; &nbsp; qsort_interruptible(groups, ngroups, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortItem),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L403" title="statistics/mcv.c:403">compare_sort_item_count</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *ndistinct = ngroups;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> groups;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> sort items (single dimension) */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L465">&#x200c;</a></span><span class="linkable">sort_item_compare</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SortSupport ssup = (SortSupport) arg;<br/></li>
<li>&nbsp; &nbsp; SortItem&nbsp;&nbsp; *ia = (SortItem *) a;<br/></li>
<li>&nbsp; &nbsp; SortItem&nbsp;&nbsp; *ib = (SortItem *) b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ApplySortComparator(ia-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>], ia-&gt;isnull[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ib-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>], ib-&gt;isnull[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ssup);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L490" title="statistics/mcv.c:490">build_column_frequencies</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Compute frequencies of <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in each column.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This returns an array of SortItems for each attribute the MCV is built<br/></li>
<li></span><span class="Comment"> * on, with a frequency (number of occurrences) for each value. This is<br/></li>
<li></span><span class="Comment"> * then used to compute &quot;base&quot; frequency of MCV items.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All the memory is allocated in a single chunk, so that a single <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a><br/></li>
<li></span><span class="Comment"> * is enough to release it. We do not allocate space for <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>/isnull<br/></li>
<li></span><span class="Comment"> * arrays in the SortItems, because we can simply point into the input<br/></li>
<li></span><span class="Comment"> * groups directly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> SortItem **<br/></li>
<li><a id="L490">&#x200c;</a><span class="linkable">build_column_frequencies</span>(SortItem *groups, <span class="Type">int</span> ngroups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MultiSortSupport mss, <span class="Type">int</span> *ncounts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dim;<br/></li>
<li>&nbsp; &nbsp; SortItem&nbsp; **result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(groups);<br/></li>
<li>&nbsp; &nbsp; Assert(ncounts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* allocate arrays for all columns as a single chunk */<br/></li>
<li></span>&nbsp; &nbsp; ptr = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(MAXALIGN(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortItem *) * mss-&gt;ndims) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mss-&gt;ndims * MAXALIGN(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortItem) * ngroups));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* initial array of pointers */<br/></li>
<li></span>&nbsp; &nbsp; result = (SortItem **) ptr;<br/></li>
<li>&nbsp; &nbsp; ptr += MAXALIGN(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortItem *) * mss-&gt;ndims);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (dim = <span class="Constant">0</span>; dim &lt; mss-&gt;ndims; dim++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortSupport ssup = &amp;mss-&gt;ssup[dim];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* array of <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for a single column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result[dim] = (SortItem *) ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr += MAXALIGN(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortItem) * ngroups);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* extract data for the dimension */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ngroups; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* point into the input groups */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result[dim][i].<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = &amp;groups[i].<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[dim];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result[dim][i].isnull = &amp;groups[i].isnull[dim];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result[dim][i].count = groups[i].count;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* sort the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, deduplicate */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qsort_interruptible(result[dim], ngroups, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortItem),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L465" title="statistics/mcv.c:465">sort_item_compare</a>, ssup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Identify distinct <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, compute frequency (there might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multiple MCV items containing this value, so we need to sum counts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from all of them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ncounts[dim] = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; ngroups; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L465" title="statistics/mcv.c:465">sort_item_compare</a>(&amp;result[dim][i - <span class="Constant">1</span>], &amp;result[dim][i], ssup) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result[dim][ncounts[dim] - <span class="Constant">1</span>].count += result[dim][i].count;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result[dim][ncounts[dim]] = result[dim][i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncounts[dim]++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L558" title="statistics/mcv.c:558">statext_mcv_load</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Load the MCV list for the indicated pg_statistic_ext_data tuple.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MCVList *<br/></li>
<li><a id="L558">&#x200c;</a><span class="linkable">statext_mcv_load</span>(Oid mvoid, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> inh)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MCVList&nbsp; &nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; mcvlist;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; htup = <a href="../utils/cache/syscache.c.html#L229" title="utils/cache/syscache.c:229">SearchSysCache2</a>(STATEXTDATASTXOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(mvoid), BoolGetDatum(inh));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(htup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for statistics object </span><span class="Special">%u</span><span class="Constant">&quot;</span>, mvoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mcvlist = <a href="../utils/cache/syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(STATEXTDATASTXOID, htup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_statistic_ext_data_stxdmcv, &amp;isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;requested statistics kind </span><span class="Special">\&quot;%c\&quot;</span><span class="Constant"> is not yet built for statistics object </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; STATS_EXT_MCV, mvoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L996" title="statistics/mcv.c:996">statext_mcv_deserialize</a>(DatumGetByteaP(mcvlist));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(htup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L621" title="statistics/mcv.c:621">statext_mcv_serialize</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Serialize MCV list into a pg_mcv_list value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The MCV items may include <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of various data types, and it's reasonable<br/></li>
<li></span><span class="Comment"> * to expect redundancy (<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for a given attribute, repeated for multiple<br/></li>
<li></span><span class="Comment"> * MCV list items). So we deduplicate the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> into arrays, and then replace<br/></li>
<li></span><span class="Comment"> * the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> by indexes into those arrays.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The overall structure of the serialized representation looks like this:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * +---------------+----------------+---------------------+-------+<br/></li>
<li></span><span class="Comment"> * | header fields | dimension info | deduplicated <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> | items |<br/></li>
<li></span><span class="Comment"> * +---------------+----------------+---------------------+-------+<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Where dimension info stores information about the type of the K-th<br/></li>
<li></span><span class="Comment"> * attribute (e.g. typlen, typbyval and length of deduplicated <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>).<br/></li>
<li></span><span class="Comment"> * Deduplicated <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> store deduplicated <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for each attribute.&nbsp; And<br/></li>
<li></span><span class="Comment"> * items store the actual MCV list items, with <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> replaced by indexes into<br/></li>
<li></span><span class="Comment"> * the arrays.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When serializing the items, we use uint16 indexes. The number of MCV items<br/></li>
<li></span><span class="Comment"> * is limited by the statistics target (which is capped to 10k at the moment).<br/></li>
<li></span><span class="Comment"> * We might increase this to 65k and still fit into uint16, so there's a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of<br/></li>
<li></span><span class="Comment"> * slack. Furthermore, this limit is on the number of distinct <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> per column,<br/></li>
<li></span><span class="Comment"> * and we usually have few of those (and various combinations of them for the<br/></li>
<li></span><span class="Comment"> * those MCV list). So uint16 seems fine for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We don't really expect the serialization to save as much space as for<br/></li>
<li></span><span class="Comment"> * histograms, as we are not doing <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> bucket splits (which is the source<br/></li>
<li></span><span class="Comment"> * of high redundancy in histograms).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">TODO</span><span class="Comment">: Consider packing boolean flags (NULL) for each item into a single char<br/></li>
<li></span><span class="Comment"> * (or a longer type) instead of using an array of <a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> items.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>bytea *<br/></li>
<li><a id="L621">&#x200c;</a><span class="linkable">statext_mcv_serialize</span>(MCVList *mcvlist, VacAttrStats **stats)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dim;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndims = mcvlist-&gt;ndimensions;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SortSupport ssup;<br/></li>
<li>&nbsp; &nbsp; DimensionInfo *info;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; total_length;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* serialized items (indexes into arrays, etc.) */<br/></li>
<li></span>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *raw;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *endptr <a href="../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> per dimension (and number of non-NULL <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>) */<br/></li>
<li></span>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; **<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = (Datum **) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum *) * ndims);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *counts = (<span class="Type">int</span> *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * ndims);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We'll include some rudimentary information about the attribute types<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (length, by-val flag), so that we don't have to look them up while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deserializing the MCV list (we already have the type OID in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * header).&nbsp; This is safe because when changing the type of the attribute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the statistics gets dropped automatically.&nbsp; We need to store the info<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * about the arrays of deduplicated <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; info = (DimensionInfo *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(DimensionInfo) * ndims);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sort support data for all attributes included in the MCV list */<br/></li>
<li></span>&nbsp; &nbsp; ssup = (SortSupport) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortSupportData) * ndims);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* collect and deduplicate <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for each dimension (attribute) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (dim = <span class="Constant">0</span>; dim &lt; ndims; dim++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndistinct;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Lookup the LT operator (can't get it from stats extra_data, as we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't know how to interpret that - scalar vs. array etc.).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; typentry = <a href="../utils/cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(stats[dim]-&gt;attrtypid, TYPECACHE_LT_OPR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy important info about the data type (length, by-value) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; info[dim].typlen = stats[dim]-&gt;attrtype-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; info[dim].typbyval = stats[dim]-&gt;attrtype-&gt;typbyval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allocate space for <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the attribute and collect them */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[dim] = (Datum *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * mcvlist-&gt;nitems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; mcvlist-&gt;nitems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> NULL <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> - we don't need to deduplicate those */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mcvlist-&gt;items[i].isnull[dim])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* append the value at the end */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[dim][counts[dim]] = mcvlist-&gt;items[i].<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[dim];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; counts[dim] += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if there are just NULL <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in this dimension, we're done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (counts[dim] == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* sort and deduplicate the data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ssup[dim].ssup_cxt = <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ssup[dim].ssup_collation = stats[dim]-&gt;attrcollid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ssup[dim].ssup_nulls_first = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/sortsupport.c.html#L134" title="utils/sort/sortsupport.c:134">PrepareSortSupportFromOrderingOp</a>(typentry-&gt;lt_opr, &amp;ssup[dim]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qsort_interruptible(<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[dim], counts[dim], <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="extended_stats.c.html#L919" title="statistics/extended_stats.c:919">compare_scalars_simple</a>, &amp;ssup[dim]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Walk through the array and eliminate duplicate <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, but keep the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ordering (so that we can do a binary search later). We know there's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * at least one item as (counts[dim] != 0), so we can <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ndistinct = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of distinct <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; counts[dim]; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* expect sorted array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="extended_stats.c.html#L927" title="statistics/extended_stats.c:927">compare_datums_simple</a>(<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[dim][i - <span class="Constant">1</span>], <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[dim][i], &amp;ssup[dim]) &lt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if the value is the same as the previous one, we can <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="extended_stats.c.html#L927" title="statistics/extended_stats.c:927">compare_datums_simple</a>(<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[dim][i - <span class="Constant">1</span>], <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[dim][i], &amp;ssup[dim]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[dim][ndistinct] = <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[dim][i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndistinct += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we must not exceed PG_UINT16_MAX, as we use uint16 indexes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ndistinct &lt;= PG_UINT16_MAX);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Store additional info about the attribute - number of deduplicated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, and also size of the serialized data. For fixed-length data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * types this is trivial to compute, for varwidth types we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * actually walk the array and sum the sizes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; info[dim].nvalues = ndistinct;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (info[dim].typbyval) <span class="Comment">/* by-value data types */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info[dim].nbytes = info[dim].nvalues * info[dim].typlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We copy the data into the MCV item during deserialization, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we don't need to allocate <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> extra space.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info[dim].nbytes_aligned = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info[dim].typlen &gt; <span class="Constant">0</span>)&nbsp; &nbsp; <span class="Comment">/* fixed-length by-ref */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't care about alignment in the serialized data, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pack the data as much as possible. But we also track how much<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * data will be needed after deserialization, and in that case we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to account for alignment of each item.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: As the items are fixed-length, we could easily compute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this during deserialization, but we do it here anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info[dim].nbytes = info[dim].nvalues * info[dim].typlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info[dim].nbytes_aligned = info[dim].nvalues * MAXALIGN(info[dim].typlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info[dim].typlen == -<span class="Constant">1</span>)&nbsp; &nbsp; <span class="Comment">/* varlena */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info[dim].nbytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info[dim].nbytes_aligned = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; info[dim].nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For varlena <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, we detoast the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> and store the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * length and data separately. We don't bother with alignment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here, which means that during deserialization we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * copy the fields and only access the copies.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[dim][i] = PointerGetDatum(PG_DETOAST_DATUM(<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[dim][i]));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* serialized length (uint32 length + data) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = VARSIZE_ANY_EXHDR(<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[dim][i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info[dim].nbytes += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32); <span class="Comment">/* length */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info[dim].nbytes += len;&nbsp; &nbsp; <span class="Comment">/* value (no header) */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * During deserialization we'll build regular varlena <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with full headers, and we need to align them properly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info[dim].nbytes_aligned += MAXALIGN(VARHDRSZ + len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info[dim].typlen == -<span class="Constant">2</span>)&nbsp; &nbsp; <span class="Comment">/* cstring */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info[dim].nbytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info[dim].nbytes_aligned = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; info[dim].nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cstring is handled similar to varlena - first we store the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * length as uint32 and then the data. We don't care about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * alignment, which means that during deserialization we need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to copy the fields and only access the copies.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* c-strings include terminator, so +1 byte */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = strlen(DatumGetCString(<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[dim][i])) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info[dim].nbytes += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32); <span class="Comment">/* length */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info[dim].nbytes += len;&nbsp; &nbsp; <span class="Comment">/* value */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* space needed for properly aligned deserialized copies */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info[dim].nbytes_aligned += MAXALIGN(len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we know (count&gt;0) so there must be some data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(info[dim].nbytes &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we can finally compute how much space we'll actually need for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whole serialized MCV list (varlena header, MCV header, dimension info<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for each attribute, deduplicated <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> and items).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; total_length = (<span class="Constant">3</span> * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32)) <span class="Comment">/* magic + type + nitems */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; + <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber)&nbsp; &nbsp; <span class="Comment">/* ndimensions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; + (ndims * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));&nbsp; &nbsp; <span class="Comment">/* attribute types */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* dimension info */<br/></li>
<li></span>&nbsp; &nbsp; total_length += ndims * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(DimensionInfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* add space for the arrays of deduplicated <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ndims; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; total_length += info[i].nbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And finally account for the items (those are fixed-length, thanks to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replacing <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> with uint16 indexes into the deduplicated arrays).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; total_length += mcvlist-&gt;nitems * <a href="#L53" title="statistics/mcv.c:53">ITEM_SIZE</a>(dim);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate space for the whole serialized MCV list (we'll <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> bytes, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we set them to zero to make the result more compressible).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; raw = (bytea *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(VARHDRSZ + total_length);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(raw, VARHDRSZ + total_length);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ptr = VARDATA(raw);<br/></li>
<li>&nbsp; &nbsp; endptr = ptr + total_length;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy the MCV list header fields, one by one */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(ptr, &amp;mcvlist-&gt;magic, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; ptr += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(ptr, &amp;mcvlist-&gt;type, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; ptr += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(ptr, &amp;mcvlist-&gt;nitems, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; ptr += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(ptr, &amp;mcvlist-&gt;ndimensions, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber));<br/></li>
<li>&nbsp; &nbsp; ptr += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(ptr, mcvlist-&gt;types, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * ndims);<br/></li>
<li>&nbsp; &nbsp; ptr += (<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * ndims);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* store information about the attributes (data amounts, ...) */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(ptr, info, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(DimensionInfo) * ndims);<br/></li>
<li>&nbsp; &nbsp; ptr += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(DimensionInfo) * ndims;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy the deduplicated <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for all attributes to the output. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (dim = <span class="Constant">0</span>; dim &lt; ndims; dim++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remember the starting point for Asserts later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *start <a href="../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a> = ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; info[dim].nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; value = <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[dim][i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (info[dim].typbyval) <span class="Comment">/* passed by value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For byval types, we need to copy just the significant bytes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * - we can't use memcpy directly, as that assumes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * little-endian behavior.&nbsp; store_att_byval does almost what<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we need, but it requires a properly aligned buffer - the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * output buffer does not guarantee that. So we simply use a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * local Datum variable (which guarantees proper alignment),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and then copy the value from it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; store_att_byval(&amp;tmp, value, info[dim].typlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, &amp;tmp, info[dim].typlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += info[dim].typlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info[dim].typlen &gt; <span class="Constant">0</span>)&nbsp; &nbsp; <span class="Comment">/* passed by reference */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no special alignment needed, treated as char array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, DatumGetPointer(value), info[dim].typlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += info[dim].typlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info[dim].typlen == -<span class="Constant">1</span>)&nbsp; &nbsp; <span class="Comment">/* varlena */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; len = VARSIZE_ANY_EXHDR(DatumGetPointer(value));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy the length */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, &amp;len, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* data from the varlena value (without the header) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, VARDATA_ANY(DatumGetPointer(value)), len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info[dim].typlen == -<span class="Constant">2</span>)&nbsp; &nbsp; <span class="Comment">/* cstring */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; len = (uint32) strlen(DatumGetCString(value)) + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy the length */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, &amp;len, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, DatumGetCString(value), len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no underflows or overflows */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert((ptr &gt; start) &amp;&amp; ((ptr - start) &lt;= info[dim].nbytes));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we should get exactly nbytes of data for this dimension */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert((ptr - start) == info[dim].nbytes);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Serialize the items, with uint16 indexes instead of the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; mcvlist-&gt;nitems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MCVItem&nbsp; &nbsp; *mcvitem = &amp;mcvlist-&gt;items[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't write beyond the allocated space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ptr &lt;= (endptr - <a href="#L53" title="statistics/mcv.c:53">ITEM_SIZE</a>(dim)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy NULL and frequency flags into the serialized MCV */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, mcvitem-&gt;isnull, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * ndims);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * ndims;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, &amp;mcvitem-&gt;frequency, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">double</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">double</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, &amp;mcvitem-&gt;base_frequency, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">double</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">double</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* store the indexes last */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (dim = <span class="Constant">0</span>; dim &lt; ndims; dim++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; index = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *value;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do the lookup only for non-NULL <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!mcvitem-&gt;isnull[dim])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = (Datum *) bsearch_arg(&amp;mcvitem-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[dim], <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[dim],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info[dim].nvalues, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="extended_stats.c.html#L919" title="statistics/extended_stats.c:919">compare_scalars_simple</a>, &amp;ssup[dim]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(value != <span class="Constant">NULL</span>);&nbsp; &nbsp; <span class="Comment">/* serialization or deduplication<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * error */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* compute index within the deduplicated array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index = (uint16) (value - <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[dim]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check the index is within expected bounds */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(index &lt; info[dim].nvalues);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy the index into the serialized MCV */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, &amp;index, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure we don't overflow the allocated value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ptr &lt;= endptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* at this point we expect to match the total_length exactly */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ptr == endptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(counts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> raw;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L996" title="statistics/mcv.c:996">statext_mcv_deserialize</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Reads serialized MCV list into MCVList structure.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All the memory needed by the MCV list is allocated as a single chunk, so<br/></li>
<li></span><span class="Comment"> * it's possible to simply <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>() it at once.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MCVList *<br/></li>
<li><a id="L996">&#x200c;</a><span class="linkable">statext_mcv_deserialize</span>(bytea *data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; expected_size;<br/></li>
<li>&nbsp; &nbsp; MCVList&nbsp; &nbsp; *mcvlist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *raw;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *endptr <a href="../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndims,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems;<br/></li>
<li>&nbsp; &nbsp; DimensionInfo *info = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* local allocation buffer (used only for deserialization) */<br/></li>
<li></span>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; **map = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* MCV list */<br/></li>
<li></span>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; mcvlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* buffer used for the result */<br/></li>
<li></span>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; datalen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *dataptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *valuesptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *isnullptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (data == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can't possibly deserialize a MCV list if there's not even a complete<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * header. We need an explicit formula here, because we serialize the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * header fields one by one, so we need to ignore struct alignment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (VARSIZE_ANY(data) &lt; <a href="#L59" title="statistics/mcv.c:59">MinSizeOfMCVList</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid MCV size </span><span class="Special">%zu</span><span class="Constant"> (expected at least </span><span class="Special">%zu</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY(data), <a href="#L59" title="statistics/mcv.c:59">MinSizeOfMCVList</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read the MCV list header */<br/></li>
<li></span>&nbsp; &nbsp; mcvlist = (MCVList *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(offsetof(MCVList, items));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pointer to the data part (<a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the varlena header) */<br/></li>
<li></span>&nbsp; &nbsp; raw = (<span class="Type">char</span> *) data;<br/></li>
<li>&nbsp; &nbsp; ptr = VARDATA_ANY(raw);<br/></li>
<li>&nbsp; &nbsp; endptr = (<span class="Type">char</span> *) raw + VARSIZE_ANY(data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* get the header and perform further sanity checks */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(&amp;mcvlist-&gt;magic, ptr, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; ptr += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(&amp;mcvlist-&gt;type, ptr, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; ptr += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(&amp;mcvlist-&gt;nitems, ptr, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; ptr += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(&amp;mcvlist-&gt;ndimensions, ptr, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber));<br/></li>
<li>&nbsp; &nbsp; ptr += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mcvlist-&gt;magic != STATS_MCV_MAGIC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid MCV magic </span><span class="Special">%u</span><span class="Constant"> (expected </span><span class="Special">%u</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mcvlist-&gt;magic, STATS_MCV_MAGIC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mcvlist-&gt;type != STATS_MCV_TYPE_BASIC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid MCV type </span><span class="Special">%u</span><span class="Constant"> (expected </span><span class="Special">%u</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mcvlist-&gt;type, STATS_MCV_TYPE_BASIC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mcvlist-&gt;ndimensions == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid zero-length dimension array in MCVList&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((mcvlist-&gt;ndimensions &gt; STATS_MAX_DIMENSIONS) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (mcvlist-&gt;ndimensions &lt; <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid length (</span><span class="Special">%d</span><span class="Constant">) dimension array in MCVList&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mcvlist-&gt;ndimensions);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mcvlist-&gt;nitems == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid zero-length item array in MCVList&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (mcvlist-&gt;nitems &gt; STATS_MCVLIST_MAX_ITEMS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid length (</span><span class="Special">%u</span><span class="Constant">) item array in MCVList&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mcvlist-&gt;nitems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nitems = mcvlist-&gt;nitems;<br/></li>
<li>&nbsp; &nbsp; ndims = mcvlist-&gt;ndimensions;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check amount of data including DimensionInfo for all dimensions and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * also the serialized items (including uint16 indexes). Also, walk<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * through the dimension information and add it to the sum.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; expected_size = <a href="#L68" title="statistics/mcv.c:68">SizeOfMCVList</a>(ndims, nitems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that we have at least the dimension and info <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>, along with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the items. We don't know the size of the serialized <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> yet. We need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to do this check first, <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> accessing the dimension info.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (VARSIZE_ANY(data) &lt; expected_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid MCV size </span><span class="Special">%zu</span><span class="Constant"> (expected </span><span class="Special">%zu</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY(data), expected_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now copy the array of type Oids. */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(mcvlist-&gt;types, ptr, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * ndims);<br/></li>
<li>&nbsp; &nbsp; ptr += (<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * ndims);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now it's safe to access the dimension info. */<br/></li>
<li></span>&nbsp; &nbsp; info = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ndims * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(DimensionInfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(info, ptr, ndims * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(DimensionInfo));<br/></li>
<li>&nbsp; &nbsp; ptr += (ndims * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(DimensionInfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* account for the value arrays */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (dim = <span class="Constant">0</span>; dim &lt; ndims; dim++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> I wonder if we can/should rely on asserts here. Maybe those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checks should be done every time?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(info[dim].nvalues &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(info[dim].nbytes &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; expected_size += info[dim].nbytes;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we know the total expected MCV size, including all the pieces<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (header, dimension info. items and deduplicated data). So do the final<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check on size.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (VARSIZE_ANY(data) != expected_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid MCV size </span><span class="Special">%zu</span><span class="Constant"> (expected </span><span class="Special">%zu</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY(data), expected_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need an array of Datum <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for each dimension, so that we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * easily <a href="../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> the uint16 indexes later. We also need a top-level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * array of pointers to those per-dimension arrays.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * While allocating the arrays for dimensions, compute how much space we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need for a copy of the by-ref data, as we can't simply point to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * original <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (it might go away).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; datalen = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* space for by-ref data */<br/></li>
<li></span>&nbsp; &nbsp; map = (Datum **) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ndims * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum *));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (dim = <span class="Constant">0</span>; dim &lt; ndims; dim++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; map[dim] = (Datum *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * info[dim].nvalues);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* space needed for a copy of data for by-ref types */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; datalen += info[dim].nbytes_aligned;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now <a href="../lib/dshash.c.html#L858" title="lib/dshash.c:858">resize</a> the MCV list so that the allocation includes all the data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate space for a copy of the data, as we can't simply reference the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * serialized data - it's not aligned properly, and it may disappear while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're still using the MCV list, e.g. due to catcache release.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do care about alignment here, because we will allocate all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pieces at once, but then use pointers to different parts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; mcvlen = MAXALIGN(offsetof(MCVList, items) + (<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MCVItem) * nitems));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* arrays of <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> and isnull flags for all MCV items */<br/></li>
<li></span>&nbsp; &nbsp; mcvlen += nitems * MAXALIGN(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * ndims);<br/></li>
<li>&nbsp; &nbsp; mcvlen += nitems * MAXALIGN(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * ndims);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we don't quite need to align this, but it makes some asserts easier */<br/></li>
<li></span>&nbsp; &nbsp; mcvlen += MAXALIGN(datalen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> <a href="../lib/dshash.c.html#L858" title="lib/dshash.c:858">resize</a> the deserialized MCV list, and compute pointers to parts */<br/></li>
<li></span>&nbsp; &nbsp; mcvlist = <a href="../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(mcvlist, mcvlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pointer to the beginning of <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>/isnull arrays */<br/></li>
<li></span>&nbsp; &nbsp; valuesptr = (<span class="Type">char</span> *) mcvlist<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; + MAXALIGN(offsetof(MCVList, items) + (<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MCVItem) * nitems));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; isnullptr = valuesptr + (nitems * MAXALIGN(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * ndims));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dataptr = isnullptr + (nitems * MAXALIGN(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * ndims));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build mapping (index =&gt; value) for translating the serialized data into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the in-memory representation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (dim = <span class="Constant">0</span>; dim &lt; ndims; dim++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remember start position in the input array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *start <a href="../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a> = ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (info[dim].typbyval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for by-val types we simply copy data into the mapping */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; info[dim].nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; v = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;v, ptr, info[dim].typlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += info[dim].typlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map[dim][i] = fetch_att(&amp;v, <span class="Constant">true</span>, info[dim].typlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no under/overflow of input array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ptr &lt;= (start + info[dim].nbytes));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for by-ref types we need to also make a copy of the data */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* passed by reference, but fixed length (name, tid, ...) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (info[dim].typlen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; info[dim].nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(dataptr, ptr, info[dim].typlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += info[dim].typlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just point into the array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map[dim][i] = PointerGetDatum(dataptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dataptr += MAXALIGN(info[dim].typlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info[dim].typlen == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* varlena */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; info[dim].nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* read the uint32 length */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;len, ptr, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the length is data-only */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(dataptr, len + VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(VARDATA(dataptr), ptr, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just point into the array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map[dim][i] = PointerGetDatum(dataptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> to place of the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> deserialized value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dataptr += MAXALIGN(len + VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info[dim].typlen == -<span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cstring */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; info[dim].nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;len, ptr, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(dataptr, ptr, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just point into the array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map[dim][i] = PointerGetDatum(dataptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dataptr += MAXALIGN(len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no under/overflow of input array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ptr &lt;= (start + info[dim].nbytes));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no overflow of the output mcv value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(dataptr &lt;= ((<span class="Type">char</span> *) mcvlist + mcvlen));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check we consumed input data for this dimension exactly */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ptr == (start + info[dim].nbytes));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we should have also filled the MCV list exactly */<br/></li>
<li></span>&nbsp; &nbsp; Assert(dataptr == ((<span class="Type">char</span> *) mcvlist + mcvlen));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* deserialize the MCV items and <a href="../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> the indexes to Datums */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nitems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MCVItem&nbsp; &nbsp; *item = &amp;mcvlist-&gt;items[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; item-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = (Datum *) valuesptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; valuesptr += MAXALIGN(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * ndims);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; item-&gt;isnull = (<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) isnullptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isnullptr += MAXALIGN(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * ndims);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(item-&gt;isnull, ptr, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * ndims);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * ndims;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;item-&gt;frequency, ptr, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">double</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">double</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;item-&gt;base_frequency, ptr, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">double</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">double</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* finally <a href="../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> the indexes (for non-NULL only) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (dim = <span class="Constant">0</span>; dim &lt; ndims; dim++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;index, ptr, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item-&gt;isnull[dim])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[dim] = map[dim][index];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check we're not overflowing the input */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ptr &lt;= endptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check that we processed all the data */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ptr == endptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* release the buffers used for mapping */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (dim = <span class="Constant">0</span>; dim &lt; ndims; dim++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(map[dim]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(map);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> mcvlist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SRF with details about buckets of a histogram:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * - item ID (0...nitems)<br/></li>
<li></span><span class="Comment"> * - <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (string array)<br/></li>
<li></span><span class="Comment"> * - nulls only (boolean array)<br/></li>
<li></span><span class="Comment"> * - frequency (double precision)<br/></li>
<li></span><span class="Comment"> * - base_frequency (double precision)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The input is the OID of the statistics, and there are no rows returned if<br/></li>
<li></span><span class="Comment"> * the statistics contains no histogram.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1338">&#x200c;</a><span class="linkable">pg_stats_ext_mcvlist_items</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FuncCallContext *funcctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* stuff done only on the first call of the function */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (SRF_IS_FIRSTCALL())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MCVList&nbsp; &nbsp; *mcvlist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* create a function context for cross-call persistence */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; funcctx = SRF_FIRSTCALL_INIT();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* switch to memory context appropriate for multiple function calls */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mcvlist = <a href="#L996" title="statistics/mcv.c:996">statext_mcv_deserialize</a>(PG_GETARG_BYTEA_P(<span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcctx-&gt;user_fctx = mcvlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* total number of tuples to be returned */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; funcctx-&gt;max_calls = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (funcctx-&gt;user_fctx != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; funcctx-&gt;max_calls = mcvlist-&gt;nitems;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Build a tuple descriptor for our result type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/fmgr/funcapi.c.html#L276" title="utils/fmgr/funcapi.c:276">get_call_result_type</a>(fcinfo, <span class="Constant">NULL</span>, &amp;tupdesc) != TYPEFUNC_COMPOSITE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;function returning record called in context &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;that cannot <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> type record&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupdesc = <a href="../executor/execTuples.c.html#L2158" title="executor/execTuples.c:2158">BlessTupleDesc</a>(tupdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * generate attribute metadata needed later to produce tuples from raw<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * C strings<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; funcctx-&gt;attinmeta = <a href="../executor/execTuples.c.html#L2173" title="executor/execTuples.c:2173">TupleDescGetAttInMetadata</a>(tupdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* stuff done on every call of the function */<br/></li>
<li></span>&nbsp; &nbsp; funcctx = SRF_PERCALL_SETUP();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (funcctx-&gt;call_cntr &lt; funcctx-&gt;max_calls)&nbsp; &nbsp; <span class="Comment">/* do when there is more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * left to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">5</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">5</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ArrayBuildState *astate_values = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ArrayBuildState *astate_nulls = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MCVList&nbsp; &nbsp; *mcvlist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MCVItem&nbsp; &nbsp; *item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mcvlist = (MCVList *) funcctx-&gt;user_fctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(funcctx-&gt;call_cntr &lt; mcvlist-&gt;nitems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; item = &amp;mcvlist-&gt;items[funcctx-&gt;call_cntr];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; mcvlist-&gt;ndimensions; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; astate_nulls = <a href="../utils/adt/arrayfuncs.c.html#L5331" title="utils/adt/arrayfuncs.c:5331">accumArrayResult</a>(astate_nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BoolGetDatum(item-&gt;isnull[i]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BOOLOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!item-&gt;isnull[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isvarlena;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outfunc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; fmgrinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *txt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* lookup output func for the type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L2907" title="utils/cache/lsyscache.c:2907">getTypeOutputInfo</a>(mcvlist-&gt;types[i], &amp;outfunc, &amp;isvarlena);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(outfunc, &amp;fmgrinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = FunctionCall1(&amp;fmgrinfo, item-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txt = <a href="../utils/adt/varlena.c.html#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(DatumGetPointer(val));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; astate_values = <a href="../utils/adt/arrayfuncs.c.html#L5331" title="utils/adt/arrayfuncs.c:5331">accumArrayResult</a>(astate_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(txt),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TEXTOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; astate_values = <a href="../utils/adt/arrayfuncs.c.html#L5331" title="utils/adt/arrayfuncs.c:5331">accumArrayResult</a>(astate_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TEXTOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = Int32GetDatum(funcctx-&gt;call_cntr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = <a href="../utils/adt/arrayfuncs.c.html#L5401" title="utils/adt/arrayfuncs.c:5401">makeArrayResult</a>(astate_values, <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>] = <a href="../utils/adt/arrayfuncs.c.html#L5401" title="utils/adt/arrayfuncs.c:5401">makeArrayResult</a>(astate_nulls, <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">3</span>] = <a href="../utils/fmgr/fmgr.c.html#L1816" title="utils/fmgr/fmgr.c:1816">Float8GetDatum</a>(item-&gt;frequency);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">4</span>] = <a href="../utils/fmgr/fmgr.c.html#L1816" title="utils/fmgr/fmgr.c:1816">Float8GetDatum</a>(item-&gt;base_frequency);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no NULLs in the tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memset(nulls, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(nulls));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* build a tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(funcctx-&gt;attinmeta-&gt;tupdesc, <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make the tuple into a datum */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = HeapTupleGetDatum(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_NEXT(funcctx, result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do when there is no more left */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_DONE(funcctx);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1472" title="statistics/mcv.c:1472">pg_mcv_list_in</a>&nbsp; &nbsp; &nbsp; &nbsp; - input routine for type pg_mcv_list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * pg_mcv_list is real enough to be a table column, but it has no operations<br/></li>
<li></span><span class="Comment"> * of its own, and disallows input too<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1472">&#x200c;</a><span class="linkable">pg_mcv_list_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_mcv_list stores the data in binary form and parsing text input is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not needed, so disallow this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> a value of type </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;pg_mcv_list&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1498" title="statistics/mcv.c:1498">pg_mcv_list_out</a>&nbsp; &nbsp; &nbsp; &nbsp; - output routine for type pg_mcv_list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * MCV lists are serialized into a bytea value, so we simply call <a href="../utils/adt/varlena.c.html#L388" title="utils/adt/varlena.c:388">byteaout</a>()<br/></li>
<li></span><span class="Comment"> * to serialize the value into text. But it'd be nice to serialize that into<br/></li>
<li></span><span class="Comment"> * a meaningful representation (e.g. for inspection by people).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> This should probably return something meaningful, similar to what<br/></li>
<li></span><span class="Comment"> * <a href="dependencies.c.html#L670" title="statistics/dependencies.c:670">pg_dependencies_out</a> does. Not sure how to deal with the deduplicated<br/></li>
<li></span><span class="Comment"> * <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, though - do we want to expand that or not?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1498">&#x200c;</a><span class="linkable">pg_mcv_list_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../utils/adt/varlena.c.html#L388" title="utils/adt/varlena.c:388">byteaout</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1507" title="statistics/mcv.c:1507">pg_mcv_list_recv</a>&nbsp; &nbsp; &nbsp; &nbsp; - binary input routine for type pg_mcv_list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1507">&#x200c;</a><span class="linkable">pg_mcv_list_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> a value of type </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;pg_mcv_list&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1523" title="statistics/mcv.c:1523">pg_mcv_list_send</a>&nbsp; &nbsp; &nbsp; &nbsp; - binary output routine for type pg_mcv_list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * MCV lists are serialized in a bytea value (although the type is named<br/></li>
<li></span><span class="Comment"> * differently), so let's just <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1523">&#x200c;</a><span class="linkable">pg_mcv_list_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../utils/adt/varlena.c.html#L490" title="utils/adt/varlena.c:490">byteasend</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * match the attribute/expression to a dimension of the statistic<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the zero-based index of the matching statistics dimension.<br/></li>
<li></span><span class="Comment"> * Optionally determines the collation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1535">&#x200c;</a></span><span class="linkable">mcv_match_expression</span>(Node *expr, Bitmapset *keys, List *exprs, Oid *collid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(expr, Var))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* simple Var, so just lookup using varattno */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (collid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *collid = var-&gt;varcollid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idx = <a href="../nodes/bitmapset.c.html#L539" title="nodes/bitmapset.c:539">bms_member_index</a>(keys, var-&gt;varattno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (idx &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;variable not found in statistics object&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* expression - lookup in stats expressions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (collid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *collid = <a href="../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>(expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* expressions are stored after the simple columns */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; idx = <a href="../nodes/bitmapset.c.html#L751" title="nodes/bitmapset.c:751">bms_num_members</a>(keys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, exprs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *stat_expr = (Node *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(expr, stat_expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;expression not found in statistics object&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> idx;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1599" title="statistics/mcv.c:1599">mcv_get_match_bitmap</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Evaluate clauses using the MCV list, and update the match bitmap.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A match bitmap keeps match/mismatch status for each MCV item, and we<br/></li>
<li></span><span class="Comment"> * update it based on additional clauses. We also use it to <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> items<br/></li>
<li></span><span class="Comment"> * that can't possibly match (e.g. item marked as &quot;mismatch&quot; can't change<br/></li>
<li></span><span class="Comment"> * to &quot;match&quot; when evaluating AND clause list).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The function also returns a flag indicating whether there was an<br/></li>
<li></span><span class="Comment"> * equality condition for all attributes, the minimum frequency in the MCV<br/></li>
<li></span><span class="Comment"> * list, and a total MCV frequency (sum of frequencies for all items).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> Currently the match bitmap uses a <a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> for each MCV item, which is<br/></li>
<li></span><span class="Comment"> * somewhat wasteful as we could do with just a single <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>, thus reducing<br/></li>
<li></span><span class="Comment"> * the size to ~1/8. It would also allow us to <a href="../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> bitmaps simply using<br/></li>
<li></span><span class="Comment"> * &amp; and |, which should be faster than min/max. The bitmaps are fairly<br/></li>
<li></span><span class="Comment"> * small, though (thanks to the cap on the MCV list size).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *<br/></li>
<li><a id="L1599">&#x200c;</a><span class="linkable">mcv_get_match_bitmap</span>(PlannerInfo *root, List *clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Bitmapset *keys, List *exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MCVList *mcvlist, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_or)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *matches;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The bitmap may be partially built. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(clauses != NIL);<br/></li>
<li>&nbsp; &nbsp; Assert(mcvlist != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(mcvlist-&gt;nitems &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(mcvlist-&gt;nitems &lt;= STATS_MCVLIST_MAX_ITEMS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; matches = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * mcvlist-&gt;nitems);<br/></li>
<li>&nbsp; &nbsp; memset(matches, !is_or, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * mcvlist-&gt;nitems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop through the list of clauses, and for each of them evaluate all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * MCV items not yet eliminated by the preceding clauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, clauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *clause = (Node *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if it's a RestrictInfo, then extract the clause */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(clause, RestrictInfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clause = (Node *) ((RestrictInfo *) clause)-&gt;clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Handle the various types of clauses - OpClause, NullTest and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * AND/OR/NOT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_opclause(clause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OpExpr&nbsp; &nbsp; &nbsp;&nbsp; *expr = (OpExpr *) clause;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; opproc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* valid only after <a href="extended_stats.c.html#L2055" title="statistics/extended_stats.c:2055">examine_opclause_args</a> returns true */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *clause_expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Const&nbsp; &nbsp; &nbsp;&nbsp; *cst;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; expronleft;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(<a href="../utils/cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(expr-&gt;opno), &amp;opproc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* extract the var/expr and const from the expression */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="extended_stats.c.html#L2055" title="statistics/extended_stats.c:2055">examine_opclause_args</a>(expr-&gt;args, &amp;clause_expr, &amp;cst, &amp;expronleft))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;incompatible clause&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* match the attribute/expression to a dimension of the statistic */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx = <a href="#L1535" title="statistics/mcv.c:1535">mcv_match_expression</a>(clause_expr, keys, exprs, &amp;collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Walk through the MCV items and evaluate the current clause. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> items that were already ruled out, and terminate if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there are no remaining MCV items that might possibly match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; mcvlist-&gt;nitems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; match = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MCVItem&nbsp; &nbsp; *item = &amp;mcvlist-&gt;items[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(idx &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When the MCV item or the Const value is NULL we can treat<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this as a mismatch. We must not call the operator because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of strictness.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item-&gt;isnull[idx] || cst-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches[i] = <a href="#L88" title="statistics/mcv.c:88">RESULT_MERGE</a>(matches[i], is_or, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Skip MCV items that can't change result in the bitmap. Once<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the value gets false for AND-lists, or true for OR-lists,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we don't need to look at more clauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L100" title="statistics/mcv.c:100">RESULT_IS_FINAL</a>(matches[i], is_or))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First check whether the constant is below the <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * boundary (in that case we can <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the bucket, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there's no overlap).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't store collations used to build the statistics, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we can use the collation for the attribute itself, as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stored in varcollid. We do reset the statistics after a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * type change (including collation change), so this is OK.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For expressions, we use the collation extracted from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expression itself.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (expronleft)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match = DatumGetBool(<a href="../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;opproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; item-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[idx],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cst-&gt;constvalue));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match = DatumGetBool(<a href="../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;opproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cst-&gt;constvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; item-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[idx]));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* update the match bitmap with the result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches[i] = <a href="#L88" title="statistics/mcv.c:88">RESULT_MERGE</a>(matches[i], is_or, match);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(clause, ScalarArrayOpExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScalarArrayOpExpr *expr = (ScalarArrayOpExpr *) clause;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; opproc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* valid only after <a href="extended_stats.c.html#L2055" title="statistics/extended_stats.c:2055">examine_opclause_args</a> returns true */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *clause_expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Const&nbsp; &nbsp; &nbsp;&nbsp; *cst;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; expronleft;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* array evaluation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ArrayType&nbsp; *arrayval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; elmlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; elmbyval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; elmalign;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_elems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *elem_values;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *elem_nulls;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(<a href="../utils/cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(expr-&gt;opno), &amp;opproc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* extract the var/expr and const from the expression */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="extended_stats.c.html#L2055" title="statistics/extended_stats.c:2055">examine_opclause_args</a>(expr-&gt;args, &amp;clause_expr, &amp;cst, &amp;expronleft))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;incompatible clause&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We expect Var on left */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!expronleft)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;incompatible clause&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Deconstruct the array constant, unless it's NULL (we'll cover<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that case below)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!cst-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arrayval = DatumGetArrayTypeP(cst-&gt;constvalue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L2271" title="utils/cache/lsyscache.c:2271">get_typlenbyvalalign</a>(ARR_ELEMTYPE(arrayval),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;elmlen, &amp;elmbyval, &amp;elmalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/arrayfuncs.c.html#L3612" title="utils/adt/arrayfuncs.c:3612">deconstruct_array</a>(arrayval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ARR_ELEMTYPE(arrayval),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen, elmbyval, elmalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;elem_values, &amp;elem_nulls, &amp;num_elems);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* match the attribute/expression to a dimension of the statistic */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx = <a href="#L1535" title="statistics/mcv.c:1535">mcv_match_expression</a>(clause_expr, keys, exprs, &amp;collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Walk through the MCV items and evaluate the current clause. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> items that were already ruled out, and terminate if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there are no remaining MCV items that might possibly match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; mcvlist-&gt;nitems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; match = !expr-&gt;useOr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MCVItem&nbsp; &nbsp; *item = &amp;mcvlist-&gt;items[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When the MCV item or the Const value is NULL we can treat<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this as a mismatch. We must not call the operator because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of strictness.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item-&gt;isnull[idx] || cst-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches[i] = <a href="#L88" title="statistics/mcv.c:88">RESULT_MERGE</a>(matches[i], is_or, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Skip MCV items that can't change result in the bitmap. Once<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the value gets false for AND-lists, or true for OR-lists,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we don't need to look at more clauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L100" title="statistics/mcv.c:100">RESULT_IS_FINAL</a>(matches[i], is_or))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; num_elems; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; elem_value = elem_values[j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; elem_isnull = elem_nulls[j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; elem_match;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NULL <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> always evaluate as not matching. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (elem_isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match = <a href="#L88" title="statistics/mcv.c:88">RESULT_MERGE</a>(match, expr-&gt;useOr, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Stop evaluating the array elements once we reach a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matching value that can't change - ALL() is the same as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * AND-list, ANY() is the same as OR-list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L100" title="statistics/mcv.c:100">RESULT_IS_FINAL</a>(match, expr-&gt;useOr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elem_match = DatumGetBool(<a href="../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;opproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[idx],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elem_value));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match = <a href="#L88" title="statistics/mcv.c:88">RESULT_MERGE</a>(match, expr-&gt;useOr, elem_match);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* update the match bitmap with the result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches[i] = <a href="#L88" title="statistics/mcv.c:88">RESULT_MERGE</a>(matches[i], is_or, match);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(clause, NullTest))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NullTest&nbsp;&nbsp; *expr = (NullTest *) clause;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *clause_expr = (Node *) (expr-&gt;arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* match the attribute/expression to a dimension of the statistic */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx = <a href="#L1535" title="statistics/mcv.c:1535">mcv_match_expression</a>(clause_expr, keys, exprs, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Walk through the MCV items and evaluate the current clause. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> items that were already ruled out, and terminate if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there are no remaining MCV items that might possibly match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; mcvlist-&gt;nitems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; match = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* assume mismatch */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MCVItem&nbsp; &nbsp; *item = &amp;mcvlist-&gt;items[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if the clause mismatches the MCV item, update the bitmap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (expr-&gt;nulltesttype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_NULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match = (item-&gt;isnull[idx]) ? <span class="Constant">true</span> : match;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_NOT_NULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match = (!item-&gt;isnull[idx]) ? <span class="Constant">true</span> : match;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, update the match bitmap, depending on OR/AND type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches[i] = <a href="#L88" title="statistics/mcv.c:88">RESULT_MERGE</a>(matches[i], is_or, match);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (is_orclause(clause) || is_andclause(clause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* AND/OR clause, with all subclauses being compatible */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BoolExpr&nbsp;&nbsp; *bool_clause = ((BoolExpr *) clause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *bool_clauses = bool_clause-&gt;args;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* match/mismatch bitmap for each MCV item */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *bool_matches = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(bool_clauses != NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(bool_clauses) &gt;= <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* build the match bitmap for the OR-clauses */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool_matches = <a href="#L1599" title="statistics/mcv.c:1599">mcv_get_match_bitmap</a>(root, bool_clauses, keys, exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mcvlist, is_orclause(clause));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Merge the bitmap produced by <a href="#L1599" title="statistics/mcv.c:1599">mcv_get_match_bitmap</a> into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current one. We need to consider if we're evaluating AND or OR<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * condition when merging the results.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; mcvlist-&gt;nitems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches[i] = <a href="#L88" title="statistics/mcv.c:88">RESULT_MERGE</a>(matches[i], is_or, bool_matches[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(bool_matches);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (is_notclause(clause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NOT clause, with all subclauses compatible */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BoolExpr&nbsp;&nbsp; *not_clause = ((BoolExpr *) clause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *not_args = not_clause-&gt;args;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* match/mismatch bitmap for each MCV item */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *not_matches = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(not_args != NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(not_args) == <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* build the match bitmap for the NOT-clause */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; not_matches = <a href="#L1599" title="statistics/mcv.c:1599">mcv_get_match_bitmap</a>(root, not_args, keys, exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mcvlist, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Merge the bitmap produced by <a href="#L1599" title="statistics/mcv.c:1599">mcv_get_match_bitmap</a> into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current one. We're handling a NOT clause, so invert the result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> merging it into the global bitmap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; mcvlist-&gt;nitems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches[i] = <a href="#L88" title="statistics/mcv.c:88">RESULT_MERGE</a>(matches[i], is_or, !not_matches[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(not_matches);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(clause, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Var (has to be a boolean Var, possibly from below NOT) */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) (clause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* match the attribute to a dimension of the statistic */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx = <a href="../nodes/bitmapset.c.html#L539" title="nodes/bitmapset.c:539">bms_member_index</a>(keys, var-&gt;varattno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(var-&gt;vartype == BOOLOID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Walk through the MCV items and evaluate the current clause. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> items that were already ruled out, and terminate if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there are no remaining MCV items that might possibly match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; mcvlist-&gt;nitems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MCVItem&nbsp; &nbsp; *item = &amp;mcvlist-&gt;items[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; match = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if the item is NULL, it's a mismatch */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!item-&gt;isnull[idx] &amp;&amp; DatumGetBool(item-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[idx]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* update the result bitmap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches[i] = <a href="#L88" title="statistics/mcv.c:88">RESULT_MERGE</a>(matches[i], is_or, match);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise, it must be a bare boolean-returning expression */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* match the expression to a dimension of the statistic */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx = <a href="#L1535" title="statistics/mcv.c:1535">mcv_match_expression</a>(clause, keys, exprs, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Walk through the MCV items and evaluate the current clause. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> items that were already ruled out, and terminate if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there are no remaining MCV items that might possibly match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; mcvlist-&gt;nitems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; match;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MCVItem&nbsp; &nbsp; *item = &amp;mcvlist-&gt;items[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* &quot;match&quot; just means it's <a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> TRUE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match = !item-&gt;isnull[idx] &amp;&amp; DatumGetBool(item-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[idx]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, update the match bitmap, depending on OR/AND type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches[i] = <a href="#L88" title="statistics/mcv.c:88">RESULT_MERGE</a>(matches[i], is_or, match);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> matches;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2006" title="statistics/mcv.c:2006">mcv_combine_selectivities</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Combine per-column and multi-column MCV selectivity estimates.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * simple_sel is a &quot;simple&quot; selectivity estimate (produced without using <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * extended statistics, essentially assuming independence of columns/clauses).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * mcv_sel and mcv_basesel are sums of the frequencies and base frequencies of<br/></li>
<li></span><span class="Comment"> * all matching MCV items.&nbsp; The difference (mcv_sel - mcv_basesel) is then<br/></li>
<li></span><span class="Comment"> * essentially interpreted as a correction to be added to simple_sel, as<br/></li>
<li></span><span class="Comment"> * described below.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * mcv_totalsel is the sum of the frequencies of all MCV items (not just the<br/></li>
<li></span><span class="Comment"> * matching ones).&nbsp; This is used as an <a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound on the portion of the<br/></li>
<li></span><span class="Comment"> * selectivity estimates not covered by the MCV statistics.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: While simple and base selectivities are defined in a quite similar<br/></li>
<li></span><span class="Comment"> * way, the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are computed differently and are not therefore <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>. The<br/></li>
<li></span><span class="Comment"> * simple selectivity is computed as a product of per-clause estimates, while<br/></li>
<li></span><span class="Comment"> * the base selectivity is computed by adding up base frequencies of matching<br/></li>
<li></span><span class="Comment"> * items of the multi-column MCV list. So the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> may differ for two <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a><br/></li>
<li></span><span class="Comment"> * reasons - (a) the MCV list may not cover 100% of the data and (b) some of<br/></li>
<li></span><span class="Comment"> * the MCV items did not match the estimated clauses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As both (a) and (b) reduce the base selectivity value, it generally holds<br/></li>
<li></span><span class="Comment"> * that (simple_sel &gt;= mcv_basesel). If the MCV list covers all the data, the<br/></li>
<li></span><span class="Comment"> * <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> may be <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * So, other_sel = (simple_sel - mcv_basesel) is an estimate for the part not<br/></li>
<li></span><span class="Comment"> * covered by the MCV list, and (mcv_sel - mcv_basesel) may be seen as a<br/></li>
<li></span><span class="Comment"> * correction for the part covered by the MCV list. Those two statements are<br/></li>
<li></span><span class="Comment"> * actually equivalent.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Selectivity<br/></li>
<li><a id="L2006">&#x200c;</a><span class="linkable">mcv_combine_selectivities</span>(Selectivity simple_sel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Selectivity mcv_sel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Selectivity mcv_basesel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Selectivity mcv_totalsel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Selectivity other_sel;<br/></li>
<li>&nbsp; &nbsp; Selectivity sel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* estimated selectivity of <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> not covered by MCV matches */<br/></li>
<li></span>&nbsp; &nbsp; other_sel = simple_sel - mcv_basesel;<br/></li>
<li>&nbsp; &nbsp; CLAMP_PROBABILITY(other_sel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* this non-MCV selectivity cannot exceed 1 - mcv_totalsel */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (other_sel &gt; <span class="Constant">1.0</span> - mcv_totalsel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; other_sel = <span class="Constant">1.0</span> - mcv_totalsel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* overall selectivity is the sum of the MCV and non-MCV parts */<br/></li>
<li></span>&nbsp; &nbsp; sel = mcv_sel + other_sel;<br/></li>
<li>&nbsp; &nbsp; CLAMP_PROBABILITY(sel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> sel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2048" title="statistics/mcv.c:2048">mcv_clauselist_selectivity</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Use MCV statistics to estimate the selectivity of an implicitly-ANDed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; list of clauses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This determines which MCV items match every clause in the list and returns<br/></li>
<li></span><span class="Comment"> * the sum of the frequencies of those items.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In addition, it returns the sum of the base frequencies of each of those<br/></li>
<li></span><span class="Comment"> * items (that is the sum of the selectivities that each item would have if<br/></li>
<li></span><span class="Comment"> * the columns were independent of one another), and the total selectivity of<br/></li>
<li></span><span class="Comment"> * all the MCV items (not just the matching ones).&nbsp; These are expected to be<br/></li>
<li></span><span class="Comment"> * used together with a &quot;simple&quot; selectivity estimate (one based only on<br/></li>
<li></span><span class="Comment"> * per-column statistics) to produce an overall selectivity estimate that<br/></li>
<li></span><span class="Comment"> * makes use of both per-column and multi-column statistics --- see<br/></li>
<li></span><span class="Comment"> * <a href="#L2006" title="statistics/mcv.c:2006">mcv_combine_selectivities</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Selectivity<br/></li>
<li><a id="L2048">&#x200c;</a><span class="linkable">mcv_clauselist_selectivity</span>(PlannerInfo *root, StatisticExtInfo *stat,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *clauses, <span class="Type">int</span> varRelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JoinType jointype, SpecialJoinInfo *sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Selectivity *basesel, Selectivity *totalsel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; MCVList&nbsp; &nbsp; *mcv;<br/></li>
<li>&nbsp; &nbsp; Selectivity s = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte = root-&gt;simple_rte_array[rel-&gt;relid];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* match/mismatch bitmap for each MCV item */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *matches = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* load the MCV list stored in the statistics object */<br/></li>
<li></span>&nbsp; &nbsp; mcv = <a href="#L558" title="statistics/mcv.c:558">statext_mcv_load</a>(stat-&gt;statOid, rte-&gt;inh);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build a match bitmap for the clauses */<br/></li>
<li></span>&nbsp; &nbsp; matches = <a href="#L1599" title="statistics/mcv.c:1599">mcv_get_match_bitmap</a>(root, clauses, stat-&gt;keys, stat-&gt;exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mcv, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sum frequencies for all the matching MCV items */<br/></li>
<li></span>&nbsp; &nbsp; *basesel = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; *totalsel = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; mcv-&gt;nitems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *totalsel += mcv-&gt;items[i].frequency;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (matches[i] != <span class="Constant">false</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *basesel += mcv-&gt;items[i].base_frequency;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s += mcv-&gt;items[i].frequency;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> s;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2126" title="statistics/mcv.c:2126">mcv_clause_selectivity_or</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Use MCV statistics to estimate the selectivity of a clause that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; appears in an ORed list of clauses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As with <a href="#L2048" title="statistics/mcv.c:2048">mcv_clauselist_selectivity</a>() this determines which MCV items match<br/></li>
<li></span><span class="Comment"> * the clause and returns both the sum of the frequencies and the sum of the<br/></li>
<li></span><span class="Comment"> * base frequencies of those items, as well as the sum of the frequencies of<br/></li>
<li></span><span class="Comment"> * all MCV items (not just the matching ones) so that this information can be<br/></li>
<li></span><span class="Comment"> * used by <a href="#L2006" title="statistics/mcv.c:2006">mcv_combine_selectivities</a>() to produce a selectivity estimate that<br/></li>
<li></span><span class="Comment"> * makes use of both per-column and multi-column statistics.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Additionally, we return information to <a href="../main/main.c.html#L320" title="main/main.c:320">help</a> compute the overall selectivity<br/></li>
<li></span><span class="Comment"> * of the ORed list of clauses assumed to contain this clause.&nbsp; This function<br/></li>
<li></span><span class="Comment"> * is intended to be called for each clause in the ORed list of clauses,<br/></li>
<li></span><span class="Comment"> * allowing the overall selectivity to be computed using the following<br/></li>
<li></span><span class="Comment"> * algorithm:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Suppose P[n] = P(C[1] OR C[2] OR ... OR C[n]) is the combined selectivity<br/></li>
<li></span><span class="Comment"> * of the first n clauses in the list.&nbsp; Then the combined selectivity taking<br/></li>
<li></span><span class="Comment"> * into account the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> clause C[n+1] can be written as<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; P[n+1] = P[n] + P(C[n+1]) - P((C[1] OR ... OR C[n]) AND C[n+1])<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The final term above represents the overlap between the clauses examined so<br/></li>
<li></span><span class="Comment"> * far and the (n+1)'th clause.&nbsp; To estimate its selectivity, we track the<br/></li>
<li></span><span class="Comment"> * match bitmap for the ORed list of clauses examined so far and examine its<br/></li>
<li></span><span class="Comment"> * intersection with the match bitmap for the (n+1)'th clause.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We then also return the sums of the MCV item frequencies and base<br/></li>
<li></span><span class="Comment"> * frequencies for the match bitmap intersection corresponding to the overlap<br/></li>
<li></span><span class="Comment"> * term above, so that they can be combined with a simple selectivity estimate<br/></li>
<li></span><span class="Comment"> * for that term.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The parameter &quot;or_matches&quot; is an in/out parameter tracking the match bitmap<br/></li>
<li></span><span class="Comment"> * for the clauses examined so far.&nbsp; The caller is expected to set it to NULL<br/></li>
<li></span><span class="Comment"> * the first time it calls this function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Selectivity<br/></li>
<li><a id="L2126">&#x200c;</a><span class="linkable">mcv_clause_selectivity_or</span>(PlannerInfo *root, StatisticExtInfo *stat,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MCVList *mcv, Node *clause, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> **or_matches,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Selectivity *basesel, Selectivity *overlap_mcvsel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Selectivity *overlap_basesel, Selectivity *totalsel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Selectivity s = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *new_matches;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build the OR-matches bitmap, if not built already */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*or_matches == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *or_matches = <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * mcv-&gt;nitems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build the match bitmap for the new clause */<br/></li>
<li></span>&nbsp; &nbsp; new_matches = <a href="#L1599" title="statistics/mcv.c:1599">mcv_get_match_bitmap</a>(root, list_make1(clause), stat-&gt;keys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stat-&gt;exprs, mcv, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sum the frequencies for all the MCV items matching this clause and also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those matching the overlap between this clause and <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the preceding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clauses as described above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *basesel = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; *overlap_mcvsel = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; *overlap_basesel = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; *totalsel = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; mcv-&gt;nitems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *totalsel += mcv-&gt;items[i].frequency;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (new_matches[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s += mcv-&gt;items[i].frequency;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *basesel += mcv-&gt;items[i].base_frequency;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((*or_matches)[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *overlap_mcvsel += mcv-&gt;items[i].frequency;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *overlap_basesel += mcv-&gt;items[i].base_frequency;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* update the OR-matches bitmap for the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> clause */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (*or_matches)[i] = (*or_matches)[i] || new_matches[i];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(new_matches);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> s;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
