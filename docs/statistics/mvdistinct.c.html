<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>statistics/mvdistinct.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>statistics/mvdistinct.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L61">CombinationGenerator</a></li>
<li><a href="#L68">CombinationGenerator</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L521">estimate_ndistinct</a></li>
<li><a href="#L692">generate_combinations</a></li>
<li><a href="#L657">generate_combinations_recurse</a></li>
<li><a href="#L642">generator_free</a></li>
<li><a href="#L589">generator_init</a></li>
<li><a href="#L627">generator_next</a></li>
<li><a href="#L550">n_choose_k</a></li>
<li><a href="#L425">ndistinct_for_combination</a></li>
<li><a href="#L575">num_combinations</a></li>
<li><a href="#L339">pg_ndistinct_in</a></li>
<li><a href="#L355">pg_ndistinct_out</a></li>
<li><a href="#L392">pg_ndistinct_recv</a></li>
<li><a href="#L408">pg_ndistinct_send</a></li>
<li><a href="#L88">statext_ndistinct_build</a></li>
<li><a href="#L250">statext_ndistinct_deserialize</a></li>
<li><a href="#L148">statext_ndistinct_load</a></li>
<li><a href="#L179">statext_ndistinct_serialize</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L52">MinSizeOfItem</a></li>
<li><a href="#L55">MinSizeOfItems</a></li>
<li><a href="#L45">SizeOfHeader</a></li>
<li><a href="#L48">SizeOfItem</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * mvdistinct.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; POSTGRES multivariate ndistinct coefficients<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Estimating number of groups in a combination of columns (e.g. for GROUP BY)<br/></li>
<li></span><span class="Comment"> * is tricky, and the estimation error is often significant.<br/></li>
<li></span><br/></li>
<li><span class="Comment"> * The multivariate ndistinct coefficients address this by storing ndistinct<br/></li>
<li></span><span class="Comment"> * estimates for combinations of the user-specified columns.&nbsp; So for example<br/></li>
<li></span><span class="Comment"> * given a statistics object on three columns (a,b,c), this module estimates<br/></li>
<li></span><span class="Comment"> * and stores n-distinct for (a,b), (a,c), (b,c) and (a,b,c).&nbsp; The per-column<br/></li>
<li></span><span class="Comment"> * estimates are already available in pg_statistic.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/statistics/mvdistinct.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_statistic_ext.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_statistic_ext_data.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/stringinfo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;statistics/extended_stats_internal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;statistics/statistics.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/typcache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;varatt.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L425" title="statistics/mvdistinct.c:425">ndistinct_for_combination</a>(<span class="Type">double</span> totalrows, StatsBuildData *data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> k, <span class="Type">int</span> *combination);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L521" title="statistics/mvdistinct.c:521">estimate_ndistinct</a>(<span class="Type">double</span> totalrows, <span class="Type">int</span> numrows, <span class="Type">int</span> d, <span class="Type">int</span> f1);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L550" title="statistics/mvdistinct.c:550">n_choose_k</a>(<span class="Type">int</span> n, <span class="Type">int</span> k);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L575" title="statistics/mvdistinct.c:575">num_combinations</a>(<span class="Type">int</span> n);<br/></li>
<li><br/></li>
<li><span class="Comment">/* size of the struct header fields (magic, type, nitems) */<br/></li>
<li><a id="L45">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SizeOfHeader</span>&nbsp; &nbsp; &nbsp; &nbsp; (</span><span class="Constant">3</span><span class="PreProc"> * </span><span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(uint32))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* size of a serialized ndistinct item (coefficient, natts, atts) */<br/></li>
<li><a id="L48">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SizeOfItem</span>(natts) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (</span><span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(</span><span class="Type">double</span><span class="PreProc">) + </span><span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(</span><span class="Type">int</span><span class="PreProc">) + (natts) * </span><span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(AttrNumber))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* minimal size of a ndistinct item (with two attributes) */<br/></li>
<li><a id="L52">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MinSizeOfItem</span>&nbsp; &nbsp; <a href="dependencies.c.html#L41" title="statistics/dependencies.c:41">SizeOfItem</a>(</span><span class="Constant">2</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* minimal size of mvndistinct, when all items are minimal */<br/></li>
<li><a id="L55">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MinSizeOfItems</span>(nitems)&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (<a href="dependencies.c.html#L38" title="statistics/dependencies.c:38">SizeOfHeader</a> + (nitems) * <a href="dependencies.c.html#L45" title="statistics/dependencies.c:45">MinSizeOfItem</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Combination generator API */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> state for generator of k-combinations of n elements */<br/></li>
<li><a id="L61">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">CombinationGenerator</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* size of the combination */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* total number of elements */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* index of the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> combination to return */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncombinations;&nbsp; &nbsp; <span class="Comment">/* number of combinations (size of array) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *combinations;&nbsp; &nbsp; <span class="Comment">/* array of pre-built combinations */<br/></li>
<li><a id="L68">&#x200c;</a></span>} <span class="linkable">CombinationGenerator</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L61" title="statistics/mvdistinct.c:61">CombinationGenerator</a> *<a href="#L589" title="statistics/mvdistinct.c:589">generator_init</a>(<span class="Type">int</span> n, <span class="Type">int</span> k);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L642" title="statistics/mvdistinct.c:642">generator_free</a>(<a href="#L61" title="statistics/mvdistinct.c:61">CombinationGenerator</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span> *<a href="#L627" title="statistics/mvdistinct.c:627">generator_next</a>(<a href="#L61" title="statistics/mvdistinct.c:61">CombinationGenerator</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L692" title="statistics/mvdistinct.c:692">generate_combinations</a>(<a href="#L61" title="statistics/mvdistinct.c:61">CombinationGenerator</a> *state);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L88" title="statistics/mvdistinct.c:88">statext_ndistinct_build</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Compute ndistinct coefficient for the combination of attributes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This computes the ndistinct estimate using the same estimator used<br/></li>
<li></span><span class="Comment"> * in <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>.c and then computes the coefficient.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To handle expressions easily, we treat them as system attributes with<br/></li>
<li></span><span class="Comment"> * negative attnums, and offset everything by number of expressions to<br/></li>
<li></span><span class="Comment"> * allow using Bitmapsets.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MVNDistinct *<br/></li>
<li><a id="L88">&#x200c;</a><span class="linkable">statext_ndistinct_build</span>(<span class="Type">double</span> totalrows, StatsBuildData *data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MVNDistinct *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemcnt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numattrs = data-&gt;nattnums;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numcombs = <a href="#L575" title="statistics/mvdistinct.c:575">num_combinations</a>(numattrs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(offsetof(MVNDistinct, items) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numcombs * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MVNDistinctItem));<br/></li>
<li>&nbsp; &nbsp; result-&gt;magic = STATS_NDISTINCT_MAGIC;<br/></li>
<li>&nbsp; &nbsp; result-&gt;type = STATS_NDISTINCT_TYPE_BASIC;<br/></li>
<li>&nbsp; &nbsp; result-&gt;nitems = numcombs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; itemcnt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (k = <span class="Constant">2</span>; k &lt;= numattrs; k++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *combination;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L61" title="statistics/mvdistinct.c:61">CombinationGenerator</a> *generator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* generate combinations of K out of N elements */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; generator = <a href="#L589" title="statistics/mvdistinct.c:589">generator_init</a>(numattrs, k);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((combination = <a href="#L627" title="statistics/mvdistinct.c:627">generator_next</a>(generator)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MVNDistinctItem *item = &amp;result-&gt;items[itemcnt];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;attributes = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber) * k);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;nattributes = k;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> the indexes to attnums */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; k; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;attributes[j] = data-&gt;attnums[combination[j]];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(AttributeNumberIsValid(item-&gt;attributes[j]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;ndistinct =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L425" title="statistics/mvdistinct.c:425">ndistinct_for_combination</a>(totalrows, data, k, combination);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemcnt++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(itemcnt &lt;= result-&gt;nitems);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L642" title="statistics/mvdistinct.c:642">generator_free</a>(generator);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* must consume exactly the whole output array */<br/></li>
<li></span>&nbsp; &nbsp; Assert(itemcnt == result-&gt;nitems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L148" title="statistics/mvdistinct.c:148">statext_ndistinct_load</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Load the ndistinct value for the indicated pg_statistic_ext tuple<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MVNDistinct *<br/></li>
<li><a id="L148">&#x200c;</a><span class="linkable">statext_ndistinct_load</span>(Oid mvoid, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> inh)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MVNDistinct *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; ndist;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; htup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; htup = <a href="../utils/cache/syscache.c.html#L229" title="utils/cache/syscache.c:229">SearchSysCache2</a>(STATEXTDATASTXOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(mvoid), BoolGetDatum(inh));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(htup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for statistics object </span><span class="Special">%u</span><span class="Constant">&quot;</span>, mvoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ndist = <a href="../utils/cache/syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(STATEXTDATASTXOID, htup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_statistic_ext_data_stxdndistinct, &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;requested statistics kind </span><span class="Special">\&quot;%c\&quot;</span><span class="Constant"> is not yet built for statistics object </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; STATS_EXT_NDISTINCT, mvoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L250" title="statistics/mvdistinct.c:250">statext_ndistinct_deserialize</a>(DatumGetByteaPP(ndist));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(htup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L179" title="statistics/mvdistinct.c:179">statext_ndistinct_serialize</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; serialize ndistinct to the on-disk bytea format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>bytea *<br/></li>
<li><a id="L179">&#x200c;</a><span class="linkable">statext_ndistinct_serialize</span>(MVNDistinct *ndistinct)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *output;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tmp;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(ndistinct-&gt;magic == STATS_NDISTINCT_MAGIC);<br/></li>
<li>&nbsp; &nbsp; Assert(ndistinct-&gt;type == STATS_NDISTINCT_TYPE_BASIC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Base size is size of scalar fields in the struct, plus one base struct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for each item, including number of items for each.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; len = VARHDRSZ + <a href="dependencies.c.html#L38" title="statistics/dependencies.c:38">SizeOfHeader</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and also include space for the actual attribute numbers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ndistinct-&gt;nitems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmembers;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nmembers = ndistinct-&gt;items[i].nattributes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(nmembers &gt;= <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len += <a href="dependencies.c.html#L41" title="statistics/dependencies.c:41">SizeOfItem</a>(nmembers);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; output = (bytea *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(output, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tmp = VARDATA(output);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Store the base struct <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (magic, type, nitems) */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(tmp, &amp;ndistinct-&gt;magic, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; tmp += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32);<br/></li>
<li>&nbsp; &nbsp; memcpy(tmp, &amp;ndistinct-&gt;type, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; tmp += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32);<br/></li>
<li>&nbsp; &nbsp; memcpy(tmp, &amp;ndistinct-&gt;nitems, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; tmp += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * store number of attributes and attribute numbers for each entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ndistinct-&gt;nitems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MVNDistinctItem item = ndistinct-&gt;items[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmembers = item.nattributes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(tmp, &amp;item.ndistinct, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">double</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmp += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">double</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(tmp, &amp;nmembers, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmp += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(tmp, item.attributes, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber) * nmembers);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmp += nmembers * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* protect against overflows */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(tmp &lt;= ((<span class="Type">char</span> *) output + len));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check we used exactly the expected space */<br/></li>
<li></span>&nbsp; &nbsp; Assert(tmp == ((<span class="Type">char</span> *) output + len));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> output;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L250" title="statistics/mvdistinct.c:250">statext_ndistinct_deserialize</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Read an on-disk bytea format MVNDistinct to in-memory format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MVNDistinct *<br/></li>
<li><a id="L250">&#x200c;</a><span class="linkable">statext_ndistinct_deserialize</span>(bytea *data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; minimum_size;<br/></li>
<li>&nbsp; &nbsp; MVNDistinct ndist;<br/></li>
<li>&nbsp; &nbsp; MVNDistinct *ndistinct;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (data == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we expect at least the basic fields of MVNDistinct struct */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (VARSIZE_ANY_EXHDR(data) &lt; <a href="dependencies.c.html#L38" title="statistics/dependencies.c:38">SizeOfHeader</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid MVNDistinct size </span><span class="Special">%zu</span><span class="Constant"> (expected at least </span><span class="Special">%zu</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY_EXHDR(data), <a href="dependencies.c.html#L38" title="statistics/dependencies.c:38">SizeOfHeader</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> pointer to the data part (<a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the varlena header) */<br/></li>
<li></span>&nbsp; &nbsp; tmp = VARDATA_ANY(data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read the header fields and perform basic sanity checks */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(&amp;ndist.magic, tmp, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; tmp += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32);<br/></li>
<li>&nbsp; &nbsp; memcpy(&amp;ndist.type, tmp, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; tmp += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32);<br/></li>
<li>&nbsp; &nbsp; memcpy(&amp;ndist.nitems, tmp, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; tmp += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndist.magic != STATS_NDISTINCT_MAGIC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid ndistinct magic </span><span class="Special">%08x</span><span class="Constant"> (expected </span><span class="Special">%08x</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ndist.magic, STATS_NDISTINCT_MAGIC);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndist.type != STATS_NDISTINCT_TYPE_BASIC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid ndistinct type </span><span class="Special">%d</span><span class="Constant"> (expected </span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ndist.type, STATS_NDISTINCT_TYPE_BASIC);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndist.nitems == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid zero-length item array in MVNDistinct&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* what minimum bytea size do we expect for those parameters */<br/></li>
<li></span>&nbsp; &nbsp; minimum_size = <a href="dependencies.c.html#L48" title="statistics/dependencies.c:48">MinSizeOfItems</a>(ndist.nitems);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (VARSIZE_ANY_EXHDR(data) &lt; minimum_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid MVNDistinct size </span><span class="Special">%zu</span><span class="Constant"> (expected at least </span><span class="Special">%zu</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY_EXHDR(data), minimum_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate space for the ndistinct items (no space for each item's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attnos: those live in bitmapsets allocated separately)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ndistinct = <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(MAXALIGN(offsetof(MVNDistinct, items)) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ndist.nitems * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MVNDistinctItem)));<br/></li>
<li>&nbsp; &nbsp; ndistinct-&gt;magic = ndist.magic;<br/></li>
<li>&nbsp; &nbsp; ndistinct-&gt;type = ndist.type;<br/></li>
<li>&nbsp; &nbsp; ndistinct-&gt;nitems = ndist.nitems;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ndistinct-&gt;nitems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MVNDistinctItem *item = &amp;ndistinct-&gt;items[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ndistinct value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;item-&gt;ndistinct, tmp, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">double</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmp += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">double</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of attributes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;item-&gt;nattributes, tmp, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmp += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert((item-&gt;nattributes &gt;= <span class="Constant">2</span>) &amp;&amp; (item-&gt;nattributes &lt;= STATS_MAX_DIMENSIONS));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; item-&gt;attributes<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = (AttrNumber *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(item-&gt;nattributes * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(item-&gt;attributes, tmp, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber) * item-&gt;nattributes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmp += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber) * item-&gt;nattributes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* still within the bytea */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(tmp &lt;= ((<span class="Type">char</span> *) data + VARSIZE_ANY(data)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we should have consumed the whole bytea exactly */<br/></li>
<li></span>&nbsp; &nbsp; Assert(tmp == ((<span class="Type">char</span> *) data + VARSIZE_ANY(data)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ndistinct;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L339" title="statistics/mvdistinct.c:339">pg_ndistinct_in</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; input routine for type pg_ndistinct<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * pg_ndistinct is real enough to be a table column, but it has no<br/></li>
<li></span><span class="Comment"> * operations of its own, and disallows input (just like <a href="../utils/adt/pseudotypes.c.html#L334" title="utils/adt/pseudotypes.c:334">pg_node_tree</a>).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L339">&#x200c;</a><span class="linkable">pg_ndistinct_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> a value of type </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;pg_ndistinct&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * pg_ndistinct<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; output routine for type pg_ndistinct<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Produces a human-readable representation of the value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L355">&#x200c;</a><span class="linkable">pg_ndistinct_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *data = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; MVNDistinct *ndist = <a href="#L250" title="statistics/mvdistinct.c:250">statext_ndistinct_deserialize</a>(data);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; StringInfoData str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;str);<br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;str, <span class="Constant">'{'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ndist-&gt;nitems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MVNDistinctItem item = ndist-&gt;items[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;str, <span class="Constant">&quot;, &quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; item.nattributes; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum = item.attributes[j];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;str, <span class="Constant">&quot;</span><span class="Special">%s%d</span><span class="Constant">&quot;</span>, (j == <span class="Constant">0</span>) ? <span class="Constant">&quot;</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span> : <span class="Constant">&quot;, &quot;</span>, attnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;str, <span class="Constant">&quot;</span><span class="Special">\&quot;</span><span class="Constant">: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) item.ndistinct);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;str, <span class="Constant">'}'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(str.data);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L392" title="statistics/mvdistinct.c:392">pg_ndistinct_recv</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; binary input routine for type pg_ndistinct<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L392">&#x200c;</a><span class="linkable">pg_ndistinct_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> a value of type </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;pg_ndistinct&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L408" title="statistics/mvdistinct.c:408">pg_ndistinct_send</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; binary output routine for type pg_ndistinct<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * n-distinct is serialized into a bytea value, so let's <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L408">&#x200c;</a><span class="linkable">pg_ndistinct_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../utils/adt/varlena.c.html#L490" title="utils/adt/varlena.c:490">byteasend</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L425" title="statistics/mvdistinct.c:425">ndistinct_for_combination</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Estimates number of distinct <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in a combination of columns.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This uses the same ndistinct estimator as <a href="../commands/analyze.c.html#L2351" title="commands/analyze.c:2351">compute_scalar_stats</a>() in<br/></li>
<li></span><span class="Comment"> * ANALYZE, i.e.,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; n*d / (n - f1 + f1*n/N)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * except that instead of <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in a single column we are dealing with<br/></li>
<li></span><span class="Comment"> * combination of multiple columns.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L425">&#x200c;</a></span><span class="linkable">ndistinct_for_combination</span>(<span class="Type">double</span> totalrows, StatsBuildData *data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> k, <span class="Type">int</span> *combination)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *isnull;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>;<br/></li>
<li>&nbsp; &nbsp; SortItem&nbsp;&nbsp; *items;<br/></li>
<li>&nbsp; &nbsp; MultiSortSupport mss;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numrows = data-&gt;numrows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mss = <a href="extended_stats.c.html#L832" title="statistics/extended_stats.c:832">multi_sort_init</a>(k);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In order to determine the number of distinct elements, create separate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[]/isnull[] arrays with all the data we have, then sort them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * using the specified column combination as dimensions.&nbsp; We could try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sort in place, but it'd probably be more complex and bug-prone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; items = (SortItem *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numrows * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortItem));<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = (Datum *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * numrows * k);<br/></li>
<li>&nbsp; &nbsp; isnull = (<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * numrows * k);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numrows; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; items[i].<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = &amp;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i * k];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; items[i].isnull = &amp;isnull[i * k];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For each dimension, set up sort-support and fill in the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sample data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use the column data types' default sort operators and collations;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * perhaps at some point it'd be worth using column-specific collations?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; k; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VacAttrStats *colstat = data-&gt;stats[combination[i]];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typid = colstat-&gt;attrtypid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; collid = colstat-&gt;attrcollid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; type = <a href="../utils/cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(typid, TYPECACHE_LT_OPR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (type-&gt;lt_opr == InvalidOid) <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for ordering operator for type </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* prepare the sort function for this dimension */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="extended_stats.c.html#L851" title="statistics/extended_stats.c:851">multi_sort_add_dimension</a>(mss, i, type-&gt;lt_opr, collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* accumulate all the data for this dimension into the arrays */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; numrows; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; items[j].<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] = data-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[combination[i]][j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; items[j].isnull[i] = data-&gt;nulls[combination[i]][j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can sort the array <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> ... */<br/></li>
<li></span>&nbsp; &nbsp; qsort_interruptible(items, numrows, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortItem),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="extended_stats.c.html#L865" title="statistics/extended_stats.c:865">multi_sort_compare</a>, mss);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... and count the number of distinct combinations */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; f1 = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; cnt = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; d = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; numrows; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="extended_stats.c.html#L865" title="statistics/extended_stats.c:865">multi_sort_compare</a>(&amp;items[i], &amp;items[i - <span class="Constant">1</span>], mss) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cnt == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f1 += <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cnt += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cnt == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; f1 += <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L521" title="statistics/mvdistinct.c:521">estimate_ndistinct</a>(totalrows, numrows, d, f1);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* The Duj1 estimator (already used in <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>.c). */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L521">&#x200c;</a></span><span class="linkable">estimate_ndistinct</span>(<span class="Type">double</span> totalrows, <span class="Type">int</span> numrows, <span class="Type">int</span> d, <span class="Type">int</span> f1)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; numer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; denom,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndistinct;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; numer = (<span class="Type">double</span>) numrows * (<span class="Type">double</span>) d;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; denom = (<span class="Type">double</span>) (numrows - f1) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">double</span>) f1 * (<span class="Type">double</span>) numrows / totalrows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ndistinct = numer / denom;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clamp to sane <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> in case of roundoff error */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ndistinct &lt; (<span class="Type">double</span>) d)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ndistinct = (<span class="Type">double</span>) d;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndistinct &gt; totalrows)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ndistinct = totalrows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> floor(ndistinct + <span class="Constant">0.5</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L550" title="statistics/mvdistinct.c:550">n_choose_k</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; computes binomial coefficients using an algorithm that is both<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; efficient and prevents overflows<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L550">&#x200c;</a></span><span class="linkable">n_choose_k</span>(<span class="Type">int</span> n, <span class="Type">int</span> k)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert((k &gt; <span class="Constant">0</span>) &amp;&amp; (n &gt;= k));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* use symmetry of the binomial coefficients */<br/></li>
<li></span>&nbsp; &nbsp; k = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(k, n - k);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; r = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (d = <span class="Constant">1</span>; d &lt;= k; ++d)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r *= n--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r /= d;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> r;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L575" title="statistics/mvdistinct.c:575">num_combinations</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; number of combinations, excluding single-value combinations<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L575">&#x200c;</a></span><span class="linkable">num_combinations</span>(<span class="Type">int</span> n)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<span class="Constant">1</span> &lt;&lt; n) - (n + <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L589" title="statistics/mvdistinct.c:589">generator_init</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the generator of combinations<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The generator produces combinations of K elements in the interval (0..N).<br/></li>
<li></span><span class="Comment"> * We prebuild all the combinations in this method, which is simpler than<br/></li>
<li></span><span class="Comment"> * generating them on the fly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L61" title="statistics/mvdistinct.c:61">CombinationGenerator</a> *<br/></li>
<li><a id="L589">&#x200c;</a><span class="linkable">generator_init</span>(<span class="Type">int</span> n, <span class="Type">int</span> k)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L61" title="statistics/mvdistinct.c:61">CombinationGenerator</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert((n &gt;= k) &amp;&amp; (k &gt; <span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* allocate the generator state as a single chunk of memory */<br/></li>
<li></span>&nbsp; &nbsp; state = (<a href="#L61" title="statistics/mvdistinct.c:61">CombinationGenerator</a> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L61" title="statistics/mvdistinct.c:61">CombinationGenerator</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;ncombinations = <a href="#L550" title="statistics/mvdistinct.c:550">n_choose_k</a>(n, k);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pre-allocate space for all combinations */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;combinations = (<span class="Type">int</span> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * k * state-&gt;ncombinations);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;current = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;k = k;<br/></li>
<li>&nbsp; &nbsp; state-&gt;n = n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> actually pre-generate all the combinations of K elements */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L692" title="statistics/mvdistinct.c:692">generate_combinations</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure we got the expected number of combinations */<br/></li>
<li></span>&nbsp; &nbsp; Assert(state-&gt;current == state-&gt;ncombinations);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* reset the number, so we start with the first one */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;current = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L627" title="statistics/mvdistinct.c:627">generator_next</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; returns the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> combination from the prebuilt list<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a combination of K array indexes (0 .. N), as specified to<br/></li>
<li></span><span class="Comment"> * <a href="#L589" title="statistics/mvdistinct.c:589">generator_init</a>), or NULL when there are no more combination.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int</span> *<br/></li>
<li><a id="L627">&#x200c;</a><span class="linkable">generator_next</span>(<a href="#L61" title="statistics/mvdistinct.c:61">CombinationGenerator</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;current == state-&gt;ncombinations)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> &amp;state-&gt;combinations[state-&gt;k * state-&gt;current++];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L642" title="statistics/mvdistinct.c:642">generator_free</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; free the <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> state of the generator<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Releases the generator <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> state (pre-built combinations).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L642">&#x200c;</a></span><span class="linkable">generator_free</span>(<a href="#L61" title="statistics/mvdistinct.c:61">CombinationGenerator</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state-&gt;combinations);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L657" title="statistics/mvdistinct.c:657">generate_combinations_recurse</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; given a prefix, generate all possible combinations<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given a prefix (first few elements of the combination), generate following<br/></li>
<li></span><span class="Comment"> * elements recursively. We generate the combinations in lexicographic order,<br/></li>
<li></span><span class="Comment"> * which eliminates permutations of the same combination.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L657">&#x200c;</a></span><span class="linkable">generate_combinations_recurse</span>(<a href="#L61" title="statistics/mvdistinct.c:61">CombinationGenerator</a> *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> index, <span class="Type">int</span> start, <span class="Type">int</span> *current)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we haven't filled all the elements, simply recurse. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (index &lt; state-&gt;k)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> have to be in ascending order, so make sure we start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with the value passed by parameter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = start; i &lt; state-&gt;n; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current[index] = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L657" title="statistics/mvdistinct.c:657">generate_combinations_recurse</a>(state, (index + <span class="Constant">1</span>), (i + <span class="Constant">1</span>), current);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we got a valid combination, add it to the array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;state-&gt;combinations[(state-&gt;k * state-&gt;current)],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; current, state-&gt;k * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;current++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L692" title="statistics/mvdistinct.c:692">generate_combinations</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; generate all k-combinations of N elements<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L692">&#x200c;</a></span><span class="linkable">generate_combinations</span>(<a href="#L61" title="statistics/mvdistinct.c:61">CombinationGenerator</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *current = (<span class="Type">int</span> *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * state-&gt;k);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L657" title="statistics/mvdistinct.c:657">generate_combinations_recurse</a>(state, <span class="Constant">0</span>, <span class="Constant">0</span>, current);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(current);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
