<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>optimizer/plan/planmain.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>optimizer/plan/planmain.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L54">query_planner</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * planmain.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Routines to plan a single query<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * What's in a name, anyway?&nbsp; The top-level entry point of the <a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>/<br/></li>
<li></span><span class="Comment"> * optimizer is over in <a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>.c, not here as you might think from the<br/></li>
<li></span><span class="Comment"> * file name.&nbsp; But this is the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> code for planning a basic join operation,<br/></li>
<li></span><span class="Comment"> * shorn of features like subselects, inheritance, aggregates, grouping,<br/></li>
<li></span><span class="Comment"> * and so on.&nbsp; (Those are the things <a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>.c deals with.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/optimizer/plan/planmain.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/appendinfo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/clauses.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/orclauses.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/pathnode.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/paths.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/placeholder.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/planmain.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L54" title="optimizer/plan/planmain.c:54">query_planner</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Generate a path (that is, a simplified plan) for a basic query,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; which may involve joins but not <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fancier features.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since <a href="#L54" title="optimizer/plan/planmain.c:54">query_planner</a> does not handle the toplevel processing (grouping,<br/></li>
<li></span><span class="Comment"> * sorting, etc) it cannot <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> the best path by itself.&nbsp; Instead, it<br/></li>
<li></span><span class="Comment"> * returns the RelOptInfo for the top level of joining, and the caller<br/></li>
<li></span><span class="Comment"> * (<a href="planner.c.html#L1305" title="optimizer/plan/planner.c:1305">grouping_planner</a>) can choose among the surviving paths for the rel.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * root describes the query to plan<br/></li>
<li></span><span class="Comment"> * qp_callback is a function to compute query_pathkeys once it's safe to do so<br/></li>
<li></span><span class="Comment"> * qp_extra is optional extra data to pass to qp_callback<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the PlannerInfo node also includes a query_pathkeys field, which<br/></li>
<li></span><span class="Comment"> * tells <a href="#L54" title="optimizer/plan/planmain.c:54">query_planner</a> the sort order that is desired in the final output<br/></li>
<li></span><span class="Comment"> * plan.&nbsp; This value is *not* available at call time, but is computed by<br/></li>
<li></span><span class="Comment"> * qp_callback once we have completed merging the query's equivalence classes.<br/></li>
<li></span><span class="Comment"> * (We cannot construct canonical pathkeys until that's done.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RelOptInfo *<br/></li>
<li><a id="L54">&#x200c;</a><span class="linkable">query_planner</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; query_pathkeys_callback qp_callback, <span class="Type">void</span> *qp_extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *joinlist;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *final_rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Init <a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> lists to empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: append_rel_list was set up by <a href="planner.c.html#L628" title="optimizer/plan/planner.c:628">subquery_planner</a>, so do not touch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;join_rel_list = NIL;<br/></li>
<li>&nbsp; &nbsp; root-&gt;join_rel_hash = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;join_rel_level = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;join_cur_level = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;canon_pathkeys = NIL;<br/></li>
<li>&nbsp; &nbsp; root-&gt;left_join_clauses = NIL;<br/></li>
<li>&nbsp; &nbsp; root-&gt;right_join_clauses = NIL;<br/></li>
<li>&nbsp; &nbsp; root-&gt;full_join_clauses = NIL;<br/></li>
<li>&nbsp; &nbsp; root-&gt;join_info_list = NIL;<br/></li>
<li>&nbsp; &nbsp; root-&gt;placeholder_list = NIL;<br/></li>
<li>&nbsp; &nbsp; root-&gt;placeholder_array = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;placeholder_array_size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;fkey_list = NIL;<br/></li>
<li>&nbsp; &nbsp; root-&gt;initial_rels = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up arrays for accessing base relations and AppendRelInfos.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/relnode.c.html#L94" title="optimizer/util/relnode.c:94">setup_simple_rel_arrays</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In the trivial case where the jointree is a single RTE_RESULT relation,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bypass all the rest of this function and just make a RelOptInfo and its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one access path.&nbsp; This is worth optimizing because it applies for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * common cases like &quot;SELECT expression&quot; and &quot;INSERT ... VALUES()&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;jointree-&gt;fromlist != NIL);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;jointree-&gt;fromlist) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *jtnode = (Node *) linitial(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;jointree-&gt;fromlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(jtnode, RangeTblRef))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varno = ((RangeTblRef *) jtnode)-&gt;rtindex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = root-&gt;simple_rte_array[varno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rte != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind == RTE_RESULT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make the RelOptInfo for it directly */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final_rel = <a href="../util/relnode.c.html#L192" title="optimizer/util/relnode.c:192">build_simple_rel</a>(root, varno, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If query allows parallelism in general, check whether the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * quals are parallel-restricted.&nbsp; (We need not check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * final_rel-&gt;reltarget because it's empty at this point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Anything parallel-restricted in the query tlist will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dealt with later.)&nbsp; We should always do this in a subquery,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since it might be useful to use the subquery in parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * paths in the parent level.&nbsp; At top level this is normally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not worth the cycles, because a Result-only plan would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * never be interesting to parallelize.&nbsp; However, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="planner.c.html#L67" title="optimizer/plan/planner.c:67">debug_parallel_query</a> is on, then we want to execute the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Result in a parallel worker if possible, so we must check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;glob-&gt;parallelModeOK &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (root-&gt;query_level &gt; <span class="Constant">1</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="planner.c.html#L67" title="optimizer/plan/planner.c:67">debug_parallel_query</a> != DEBUG_PARALLEL_OFF))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final_rel-&gt;consider_parallel =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/clauses.c.html#L753" title="optimizer/util/clauses.c:753">is_parallel_safe</a>(root, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;jointree-&gt;quals);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The only path for it is a trivial Result path.&nbsp; We cheat a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> here by using a GroupResultPath, because that way we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can just jam the quals into it without preprocessing them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (But, if you hold your head at the right angle, a FROM-less<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * SELECT is a kind of degenerate-grouping case, so it's not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that much of a cheat.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(final_rel, (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/pathnode.c.html#L1518" title="optimizer/util/pathnode.c:1518">create_group_result_path</a>(root, final_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final_rel-&gt;reltarget,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (List *) <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;jointree-&gt;quals));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Select cheapest path (pretty easy in this case...) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L242" title="optimizer/util/pathnode.c:242">set_cheapest</a>(final_rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't need to run <a href="../path/equivclass.c.html#L1044" title="optimizer/path/equivclass.c:1044">generate_base_implied_equalities</a>, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we do need to pretend that EC merging is complete.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;ec_merging_done = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We still are required to call qp_callback, in case it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * something like &quot;SELECT 2+2 ORDER BY 1&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*qp_callback) (root, qp_extra);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> final_rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Construct RelOptInfo nodes for all base relations used in the query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Appendrel member relations (&quot;other rels&quot;) will be added later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: the reason we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the baserels by searching the jointree, rather<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than scanning the rangetable, is that the rangetable may contain RTEs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for rels not actively part of the query, for example views.&nbsp; We don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * want to make RelOptInfos for them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="initsplan.c.html#L157" title="optimizer/plan/initsplan.c:157">add_base_rels_to_query</a>(root, (Node *) <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;jointree);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Examine the targetlist and join tree, adding entries to baserel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * targetlists for all referenced Vars, and generating PlaceHolderInfo<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entries for all referenced PlaceHolderVars.&nbsp; Restrict and join clauses<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are added to appropriate lists belonging to the mentioned relations. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * also build EquivalenceClasses for provably equivalent expressions. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SpecialJoinInfo list is also built to hold information about join order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restrictions.&nbsp; Finally, we form a target joinlist for <a href="../path/allpaths.c.html#L171" title="optimizer/path/allpaths.c:171">make_one_rel</a>() to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * work from.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="initsplan.c.html#L234" title="optimizer/plan/initsplan.c:234">build_base_rel_tlists</a>(root, root-&gt;processed_tlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../util/placeholder.c.html#L185" title="optimizer/util/placeholder.c:185">find_placeholders_in_jointree</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="initsplan.c.html#L358" title="optimizer/plan/initsplan.c:358">find_lateral_references</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; joinlist = <a href="initsplan.c.html#L740" title="optimizer/plan/initsplan.c:740">deconstruct_jointree</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reconsider <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> postponed outer-join quals <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that we have built up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * equivalence classes.&nbsp; (This could result in further additions or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mergings of classes.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../path/equivclass.c.html#L2008" title="optimizer/path/equivclass.c:2008">reconsider_outer_join_clauses</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we formed <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> equivalence classes, generate additional restriction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clauses as appropriate.&nbsp; (Implied join clauses are formed on-the-fly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * later.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../path/equivclass.c.html#L1044" title="optimizer/path/equivclass.c:1044">generate_base_implied_equalities</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have completed merging equivalence sets, so it's <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> possible to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * generate pathkeys in canonical form; so compute query_pathkeys and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other pathkeys fields in PlannerInfo.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; (*qp_callback) (root, qp_extra);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Examine <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> &quot;placeholder&quot; expressions generated during subquery pullup.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure that the Vars they need are marked as needed at the relevant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * join level.&nbsp; This must be done <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> join removal because it might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cause Vars or placeholders to be needed above a join when they weren't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so marked <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/placeholder.c.html#L300" title="optimizer/util/placeholder.c:300">fix_placeholder_input_needed_levels</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> useless outer joins.&nbsp; Ideally this would be done during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * jointree preprocessing, but the necessary information isn't available<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * until we've built baserel data structures and classified qual clauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; joinlist = <a href="analyzejoins.c.html#L81" title="optimizer/plan/analyzejoins.c:81">remove_useless_joins</a>(root, joinlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, reduce <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> semijoins with unique inner rels to plain inner joins.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Likewise, this can't be done until <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> for lack of needed info.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="analyzejoins.c.html#L764" title="optimizer/plan/analyzejoins.c:764">reduce_unique_semijoins</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remove self joins on a unique column.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; joinlist = <a href="analyzejoins.c.html#L2453" title="optimizer/plan/analyzejoins.c:2453">remove_useless_self_joins</a>(root, joinlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now distribute &quot;placeholders&quot; to base rels as needed.&nbsp; This has to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * done after join removal because removal could change whether a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * placeholder is evaluable at a base rel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/placeholder.c.html#L329" title="optimizer/util/placeholder.c:329">add_placeholders_to_base_rels</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Construct the lateral reference sets <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that we have finalized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PlaceHolderVar eval levels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="initsplan.c.html#L501" title="optimizer/plan/initsplan.c:501">create_lateral_join_info</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Match foreign keys to equivalence classes and join quals.&nbsp; This must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * done after finalizing equivalence classes, and it's useful to wait till<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after join removal so that we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> processing foreign keys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * involving removed relations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="initsplan.c.html#L3169" title="optimizer/plan/initsplan.c:3169">match_foreign_keys_to_quals</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look for join OR clauses that we can extract single-relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restriction OR clauses from.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/orclauses.c.html#L75" title="optimizer/util/orclauses.c:75">extract_restriction_or_clauses</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now expand appendrels by adding &quot;otherrels&quot; for their children.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * delay this to the end so that we have as much information as possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * available for each baserel, including all restriction clauses.&nbsp; That<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * let us prune away partitions that don't satisfy a restriction clause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also note that some information such as lateral_relids is propagated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from baserels to otherrels here, so we must have computed it already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="initsplan.c.html#L195" title="optimizer/plan/initsplan.c:195">add_other_rels_to_query</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Distribute <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> UPDATE/DELETE/MERGE row identity variables to the target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relations.&nbsp; This can't be done till we've finished expansion of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * appendrels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/appendinfo.c.html#L965" title="optimizer/util/appendinfo.c:965">distribute_row_identity_vars</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ready to do the primary planning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; final_rel = <a href="../path/allpaths.c.html#L171" title="optimizer/path/allpaths.c:171">make_one_rel</a>(root, joinlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that we got at least one usable path */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!final_rel || !final_rel-&gt;cheapest_total_path ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; final_rel-&gt;cheapest_total_path-&gt;param_info != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to construct the join relation&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> final_rel;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
