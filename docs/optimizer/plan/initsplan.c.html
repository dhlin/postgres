<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>optimizer/plan/initsplan.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>optimizer/plan/initsplan.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L38">from_collapse_limit</a></li>
<li><a href="#L39">join_collapse_limit</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L59">JoinTreeItem</a></li>
<li><a href="#L80">JoinTreeItem</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L2629">add_base_clause_to_rel</a></li>
<li><a href="#L157">add_base_rels_to_query</a></li>
<li><a href="#L195">add_other_rels_to_query</a></li>
<li><a href="#L279">add_vars_to_targetlist</a></li>
<li><a href="#L234">build_base_rel_tlists</a></li>
<li><a href="#L3060">build_implied_join_equality</a></li>
<li><a href="#L3371">check_hashjoinable</a></li>
<li><a href="#L3399">check_memoizable</a></li>
<li><a href="#L3334">check_mergejoinable</a></li>
<li><a href="#L2584">check_redundant_nullability_qual</a></li>
<li><a href="#L1700">compute_semijoin_info</a></li>
<li><a href="#L501">create_lateral_join_info</a></li>
<li><a href="#L1120">deconstruct_distribute</a></li>
<li><a href="#L1878">deconstruct_distribute_oj_quals</a></li>
<li><a href="#L740">deconstruct_jointree</a></li>
<li><a href="#L822">deconstruct_recurse</a></li>
<li><a href="#L2197">distribute_qual_to_rels</a></li>
<li><a href="#L2119">distribute_quals_to_rels</a></li>
<li><a href="#L2836">distribute_restrictinfo_to_rels</a></li>
<li><a href="#L2696">expr_is_nonnullable</a></li>
<li><a href="#L406">extract_lateral_references</a></li>
<li><a href="#L358">find_lateral_references</a></li>
<li><a href="#L3129">get_join_domain_min_rels</a></li>
<li><a href="#L1360">make_outerjoininfo</a></li>
<li><a href="#L1322">mark_rels_nulled_by_join</a></li>
<li><a href="#L3169">match_foreign_keys_to_quals</a></li>
<li><a href="#L2921">process_implied_equality</a></li>
<li><a href="#L1272">process_security_barrier_quals</a></li>
<li><a href="#L2781">restriction_is_always_false</a></li>
<li><a href="#L2732">restriction_is_always_true</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * initsplan.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Target list, qualification, joininfo initialization routines<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/optimizer/plan/initsplan.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/clauses.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/cost.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/inherit.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/joininfo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/pathnode.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/paths.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/placeholder.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/planmain.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/<a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/restrictinfo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/<a href="../../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;rewrite/rewriteManip.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/typcache.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* These parameters are set by GUC */<br/></li>
<li><a id="L38">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">from_collapse_limit</span>;<br/></li>
<li><a id="L39">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">join_collapse_limit</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L740" title="optimizer/plan/initsplan.c:740">deconstruct_jointree</a> requires multiple passes over the join tree, because we<br/></li>
<li></span><span class="Comment"> * need to finish computing JoinDomains <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we start distributing quals.<br/></li>
<li></span><span class="Comment"> * As long as we have to do that, other information such as the relevant<br/></li>
<li></span><span class="Comment"> * qualscopes might as well be computed in the first pass too.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L822" title="optimizer/plan/initsplan.c:822">deconstruct_recurse</a> recursively examines the join tree and builds a List<br/></li>
<li></span><span class="Comment"> * (in depth-first traversal order) of <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> structs, which are then<br/></li>
<li></span><span class="Comment"> * processed iteratively by <a href="#L1120" title="optimizer/plan/initsplan.c:1120">deconstruct_distribute</a>.&nbsp; If there are outer<br/></li>
<li></span><span class="Comment"> * joins, non-degenerate outer join clauses are processed in a third pass<br/></li>
<li></span><span class="Comment"> * <a href="#L1878" title="optimizer/plan/initsplan.c:1878">deconstruct_distribute_oj_quals</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> structs themselves can be freed at the end of<br/></li>
<li></span><span class="Comment"> * <a href="#L740" title="optimizer/plan/initsplan.c:740">deconstruct_jointree</a>, but do not modify or free their substructure,<br/></li>
<li></span><span class="Comment"> * as the relid sets may also be pointed to by RestrictInfo and<br/></li>
<li></span><span class="Comment"> * SpecialJoinInfo nodes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L59">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">JoinTreeItem</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fields filled during <a href="#L822" title="optimizer/plan/initsplan.c:822">deconstruct_recurse</a>: */<br/></li>
<li></span>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *jtnode;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* jointree node to examine */<br/></li>
<li></span>&nbsp; &nbsp; JoinDomain *jdomain;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* join domain for its ON/WHERE clauses */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *jti_parent;&nbsp; &nbsp; <span class="Comment">/* <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> for this node's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parent, or NULL if it's the top */<br/></li>
<li></span>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; qualscope;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* base+OJ Relids syntactically included in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this jointree node */<br/></li>
<li></span>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; inner_join_rels;&nbsp; &nbsp; <span class="Comment">/* base+OJ Relids syntactically included<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in inner joins appearing at or below<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this jointree node */<br/></li>
<li></span>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; left_rels;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if join node, Relids of the left side */<br/></li>
<li></span>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; right_rels;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if join node, Relids of the right side */<br/></li>
<li></span>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; nonnullable_rels;&nbsp; &nbsp; <span class="Comment">/* if outer join, Relids of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-nullable side */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Fields filled during <a href="#L1120" title="optimizer/plan/initsplan.c:1120">deconstruct_distribute</a>: */<br/></li>
<li></span>&nbsp; &nbsp; SpecialJoinInfo *sjinfo;&nbsp; &nbsp; <span class="Comment">/* if outer join, its SpecialJoinInfo */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *oj_joinclauses; <span class="Comment">/* outer join quals not yet distributed */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *lateral_clauses;&nbsp; &nbsp; <span class="Comment">/* quals postponed from children due to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lateral references */<br/></li>
<li><a id="L80">&#x200c;</a></span>} <span class="linkable">JoinTreeItem</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L406" title="optimizer/plan/initsplan.c:406">extract_lateral_references</a>(PlannerInfo *root, RelOptInfo *brel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index rtindex);<br/></li>
<li><span class="Type">static</span> List *<a href="#L822" title="optimizer/plan/initsplan.c:822">deconstruct_recurse</a>(PlannerInfo *root, Node *jtnode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JoinDomain *parent_domain,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *parent_jtitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **item_list);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1120" title="optimizer/plan/initsplan.c:1120">deconstruct_distribute</a>(PlannerInfo *root, <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *jtitem);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1272" title="optimizer/plan/initsplan.c:1272">process_security_barrier_quals</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> rti, <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *jtitem);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1322" title="optimizer/plan/initsplan.c:1322">mark_rels_nulled_by_join</a>(PlannerInfo *root, Index ojrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids lower_rels);<br/></li>
<li><span class="Type">static</span> SpecialJoinInfo *<a href="#L1360" title="optimizer/plan/initsplan.c:1360">make_outerjoininfo</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids left_rels, Relids right_rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids inner_join_rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JoinType jointype, Index ojrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *clause);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1700" title="optimizer/plan/initsplan.c:1700">compute_semijoin_info</a>(PlannerInfo *root, SpecialJoinInfo *sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *clause);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1878" title="optimizer/plan/initsplan.c:1878">deconstruct_distribute_oj_quals</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *jtitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *jtitem);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2119" title="optimizer/plan/initsplan.c:2119">distribute_quals_to_rels</a>(PlannerInfo *root, List *clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *jtitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SpecialJoinInfo *sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index security_level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids qualscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids ojscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids outerjoin_nonnullable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids incompatible_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> allow_equivalence,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> has_clone,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_clone,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **postponed_oj_qual_list);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2197" title="optimizer/plan/initsplan.c:2197">distribute_qual_to_rels</a>(PlannerInfo *root, Node *clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *jtitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpecialJoinInfo *sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index security_level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids qualscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids ojscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids outerjoin_nonnullable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids incompatible_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> allow_equivalence,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> has_clone,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_clone,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **postponed_oj_qual_list);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2584" title="optimizer/plan/initsplan.c:2584">check_redundant_nullability_qual</a>(PlannerInfo *root, Node *clause);<br/></li>
<li><span class="Type">static</span> Relids <a href="#L3129" title="optimizer/plan/initsplan.c:3129">get_join_domain_min_rels</a>(PlannerInfo *root, Relids domain_relids);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3334" title="optimizer/plan/initsplan.c:3334">check_mergejoinable</a>(RestrictInfo *restrictinfo);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3371" title="optimizer/plan/initsplan.c:3371">check_hashjoinable</a>(RestrictInfo *restrictinfo);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3399" title="optimizer/plan/initsplan.c:3399">check_memoizable</a>(RestrictInfo *restrictinfo);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; JOIN TREES<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L157" title="optimizer/plan/initsplan.c:157">add_base_rels_to_query</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Scan the query's jointree and create baserel RelOptInfos for all<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the base relations (e.g., table, subquery, and function RTEs)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; appearing in the jointree.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The initial invocation must pass root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;jointree as the value of<br/></li>
<li></span><span class="Comment"> * jtnode.&nbsp; Internally, the function recurses through the jointree.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At the end of this process, there should be one baserel RelOptInfo for<br/></li>
<li></span><span class="Comment"> * every non-join RTE that is used in the query.&nbsp; Some of the baserels<br/></li>
<li></span><span class="Comment"> * may be appendrel parents, which will require additional &quot;otherrel&quot;<br/></li>
<li></span><span class="Comment"> * RelOptInfos for their member rels, but those are added later.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L157">&#x200c;</a></span><span class="linkable">add_base_rels_to_query</span>(PlannerInfo *root, Node *jtnode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (jtnode == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(jtnode, RangeTblRef))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varno = ((RangeTblRef *) jtnode)-&gt;rtindex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../util/relnode.c.html#L192" title="optimizer/util/relnode.c:192">build_simple_rel</a>(root, varno, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(jtnode, FromExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FromExpr&nbsp;&nbsp; *f = (FromExpr *) jtnode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, f-&gt;fromlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L157" title="optimizer/plan/initsplan.c:157">add_base_rels_to_query</a>(root, lfirst(l));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(jtnode, JoinExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JoinExpr&nbsp;&nbsp; *j = (JoinExpr *) jtnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L157" title="optimizer/plan/initsplan.c:157">add_base_rels_to_query</a>(root, j-&gt;larg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L157" title="optimizer/plan/initsplan.c:157">add_base_rels_to_query</a>(root, j-&gt;rarg);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) nodeTag(jtnode));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L195" title="optimizer/plan/initsplan.c:195">add_other_rels_to_query</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; create &quot;otherrel&quot; RelOptInfos for the children of appendrel baserels<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At the end of this process, there should be RelOptInfos for all relations<br/></li>
<li></span><span class="Comment"> * that will be scanned by the query.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L195">&#x200c;</a></span><span class="linkable">add_other_rels_to_query</span>(PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rti;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (rti = <span class="Constant">1</span>; rti &lt; root-&gt;simple_rel_array_size; rti++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel = root-&gt;simple_rel_array[rti];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = root-&gt;simple_rte_array[rti];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there may be empty slots corresponding to non-baserel RTEs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> &quot;otherrels&quot; that were already added. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;reloptkind != RELOPT_BASEREL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's marked as inheritable, look for children. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;inh)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/inherit.c.html#L86" title="optimizer/util/inherit.c:86">expand_inherited_rtentry</a>(root, rel, rte, rti);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; TARGET LISTS<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L234" title="optimizer/plan/initsplan.c:234">build_base_rel_tlists</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Add targetlist entries for each var needed in the query's final tlist<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; (and HAVING clause, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) to the appropriate base relations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We mark such <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> as needed by &quot;relation 0&quot; to ensure that they will<br/></li>
<li></span><span class="Comment"> * propagate up through all join plan steps.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L234">&#x200c;</a></span><span class="linkable">build_base_rel_tlists</span>(PlannerInfo *root, List *final_tlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist_vars = <a href="../util/var.c.html#L607" title="optimizer/util/var.c:607">pull_var_clause</a>((Node *) final_tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PVC_RECURSE_AGGREGATES |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PVC_RECURSE_WINDOWFUNCS |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PVC_INCLUDE_PLACEHOLDERS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tlist_vars != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L279" title="optimizer/plan/initsplan.c:279">add_vars_to_targetlist</a>(root, tlist_vars, <a href="../../nodes/bitmapset.c.html#L216" title="nodes/bitmapset.c:216">bms_make_singleton</a>(<span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(tlist_vars);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there's a HAVING clause, we'll need the Vars it uses, too.&nbsp; Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that HAVING can contain Aggrefs but not WindowFuncs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;havingQual)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *having_vars = <a href="../util/var.c.html#L607" title="optimizer/util/var.c:607">pull_var_clause</a>(root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;havingQual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PVC_RECURSE_AGGREGATES |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PVC_INCLUDE_PLACEHOLDERS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (having_vars != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L279" title="optimizer/plan/initsplan.c:279">add_vars_to_targetlist</a>(root, having_vars,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/bitmapset.c.html#L216" title="nodes/bitmapset.c:216">bms_make_singleton</a>(<span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(having_vars);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L279" title="optimizer/plan/initsplan.c:279">add_vars_to_targetlist</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; For each variable appearing in the list, add it to the owning<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; relation's targetlist if not already present, and mark the variable<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; as being needed for the indicated join (or for final output if<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; where_needed includes &quot;relation 0&quot;).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; The list may also contain PlaceHolderVars.&nbsp; These don't necessarily<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; have a single owning relation; we keep their attr_needed info in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; root-&gt;placeholder_list instead.&nbsp; Find or create the associated<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; PlaceHolderInfo entry, and update its ph_needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L279">&#x200c;</a></span><span class="linkable">add_vars_to_targetlist</span>(PlannerInfo *root, List *<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids where_needed)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *temp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!bms_is_empty(where_needed));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(temp, <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *node = (Node *) lfirst(temp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel = <a href="../util/relnode.c.html#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(root, var-&gt;varno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attno = var-&gt;varattno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(where_needed, rel-&gt;relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(attno &gt;= rel-&gt;min_attr &amp;&amp; attno &lt;= rel-&gt;max_attr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attno -= rel-&gt;min_attr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;attr_needed[attno] == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Variable not yet requested, so add to rel's targetlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The value available at the rel's scan level has not been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nulled by <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer join, so drop its varnullingrels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (We'll put those back as we climb up the join tree.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var = copyObject(var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varnullingrels = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;reltarget-&gt;exprs = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rel-&gt;reltarget-&gt;exprs, var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reltarget cost and width will be computed later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;attr_needed[attno] = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(rel-&gt;attr_needed[attno],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; where_needed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *phv = (PlaceHolderVar *) node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderInfo *phinfo = <a href="../util/placeholder.c.html#L83" title="optimizer/util/placeholder.c:83">find_placeholder_info</a>(root, phv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phinfo-&gt;ph_needed = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(phinfo-&gt;ph_needed,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; where_needed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) nodeTag(node));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; LATERAL REFERENCES<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L358" title="optimizer/plan/initsplan.c:358">find_lateral_references</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; For each LATERAL subquery, extract all its references to Vars and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; PlaceHolderVars of the current query level, and make sure those <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; will be available for evaluation of the subquery.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * While later planning steps ensure that the Var/PHV source rels are on the<br/></li>
<li></span><span class="Comment"> * outside of nestloops relative to the LATERAL subquery, we also need to<br/></li>
<li></span><span class="Comment"> * ensure that the Vars/PHVs propagate up to the nestloop join level; this<br/></li>
<li></span><span class="Comment"> * means setting suitable where_needed <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for them.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this only deals with lateral references in unflattened LATERAL<br/></li>
<li></span><span class="Comment"> * subqueries.&nbsp; When we flatten a LATERAL subquery, its lateral references<br/></li>
<li></span><span class="Comment"> * become plain Vars in the parent query, but they may have to be wrapped in<br/></li>
<li></span><span class="Comment"> * PlaceHolderVars if they need to be forced NULL by outer joins that don't<br/></li>
<li></span><span class="Comment"> * also null the LATERAL subquery.&nbsp; That's all handled elsewhere.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This has to run <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="#L740" title="optimizer/plan/initsplan.c:740">deconstruct_jointree</a>, since it might result in<br/></li>
<li></span><span class="Comment"> * creation of PlaceHolderInfos.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L358">&#x200c;</a></span><span class="linkable">find_lateral_references</span>(PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; rti;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We need do nothing if the query contains no LATERAL RTEs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!root-&gt;hasLateralRTEs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Examine all baserels (the rel array has been set up by <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (rti = <span class="Constant">1</span>; rti &lt; root-&gt;simple_rel_array_size; rti++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *brel = root-&gt;simple_rel_array[rti];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there may be empty slots corresponding to non-baserel RTEs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (brel == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(brel-&gt;relid == rti); <span class="Comment">/* sanity check on array */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is less obvious than it might look.&nbsp; We ignore appendrel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherrels and consider only their parent baserels.&nbsp; In a case where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a LATERAL-containing UNION ALL subquery was pulled up, it is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherrel that is actually going to be in the plan.&nbsp; However, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * want to mark all its lateral references as needed by the parent,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because it is the parent's relid that will be used for join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * planning purposes.&nbsp; And the parent's RTE will contain all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lateral references we need to know, since the pulled-up member is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nothing but a copy of parts of the original RTE's subquery.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could visit the parent's children instead and transform their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * references back to the parent's relid, but it would be much more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * complicated for no real gain.&nbsp; (Important here is that the child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * members have not yet received <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> processing beyond being pulled<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * up.)&nbsp; Similarly, in appendrels created by inheritance expansion,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's sufficient to look at the parent relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore RTEs that are &quot;other rels&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (brel-&gt;reloptkind != RELOPT_BASEREL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L406" title="optimizer/plan/initsplan.c:406">extract_lateral_references</a>(root, brel, rti);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L406">&#x200c;</a></span><span class="linkable">extract_lateral_references</span>(PlannerInfo *root, RelOptInfo *brel, Index rtindex)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte = root-&gt;simple_rte_array[rtindex];<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newvars;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; where_needed;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No cross-references are possible if it's not LATERAL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!rte-&gt;lateral)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch the appropriate variables */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind == RTE_RELATION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> = <a href="../util/var.c.html#L335" title="optimizer/util/var.c:335">pull_vars_of_level</a>((Node *) rte-&gt;tablesample, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rte-&gt;rtekind == RTE_SUBQUERY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> = <a href="../util/var.c.html#L335" title="optimizer/util/var.c:335">pull_vars_of_level</a>((Node *) rte-&gt;subquery, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rte-&gt;rtekind == RTE_FUNCTION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> = <a href="../util/var.c.html#L335" title="optimizer/util/var.c:335">pull_vars_of_level</a>((Node *) rte-&gt;<a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rte-&gt;rtekind == RTE_TABLEFUNC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> = <a href="../util/var.c.html#L335" title="optimizer/util/var.c:335">pull_vars_of_level</a>((Node *) rte-&gt;tablefunc, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rte-&gt;rtekind == RTE_VALUES)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> = <a href="../util/var.c.html#L335" title="optimizer/util/var.c:335">pull_vars_of_level</a>((Node *) rte-&gt;values_lists, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy each Var (or PlaceHolderVar) and adjust it to match our level */<br/></li>
<li></span>&nbsp; &nbsp; newvars = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *node = (Node *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node = copyObject(node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Adjustment is easy since it's just one node */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varlevelsup = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *phv = (PlaceHolderVar *) node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; levelsup = phv-&gt;phlevelsup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Have to work harder to adjust the contained expression too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (levelsup != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../rewrite/rewriteManip.c.html#L849" title="rewrite/rewriteManip.c:849">IncrementVarSublevelsUp</a>(node, -levelsup, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we pulled the PHV out of a subquery RTE, its expression<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * needs to be preprocessed.&nbsp; <a href="planner.c.html#L628" title="optimizer/plan/planner.c:628">subquery_planner</a>() already did this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for level-zero PHVs in function and <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> RTEs, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (levelsup &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phv-&gt;phexpr = <a href="planner.c.html#L1272" title="optimizer/plan/planner.c:1272">preprocess_phv_expression</a>(root, phv-&gt;phexpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newvars = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newvars, node);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We mark the Vars as being &quot;needed&quot; at the LATERAL RTE.&nbsp; This is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of a cheat: a more formal approach would be to mark each one as needed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * at the join of the LATERAL RTE with its source RTE.&nbsp; But it will work,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and it's much less tedious than computing a separate where_needed for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * each Var.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; where_needed = <a href="../../nodes/bitmapset.c.html#L216" title="nodes/bitmapset.c:216">bms_make_singleton</a>(rtindex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Push Vars into their source relations' targetlists, and PHVs into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * root-&gt;placeholder_list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L279" title="optimizer/plan/initsplan.c:279">add_vars_to_targetlist</a>(root, newvars, where_needed);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remember the lateral references for <a href="#L501" title="optimizer/plan/initsplan.c:501">create_lateral_join_info</a> */<br/></li>
<li></span>&nbsp; &nbsp; brel-&gt;lateral_vars = newvars;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L501" title="optimizer/plan/initsplan.c:501">create_lateral_join_info</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Fill in the per-base-relation direct_lateral_relids, lateral_relids<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; and lateral_referencers sets.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L501">&#x200c;</a></span><span class="linkable">create_lateral_join_info</span>(PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found_laterals = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; rti;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We need do nothing if the query contains no LATERAL RTEs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!root-&gt;hasLateralRTEs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We'll need to have the ph_eval_at <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for PlaceHolderVars */<br/></li>
<li></span>&nbsp; &nbsp; Assert(root-&gt;placeholdersFrozen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Examine all baserels (the rel array has been set up by <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (rti = <span class="Constant">1</span>; rti &lt; root-&gt;simple_rel_array_size; rti++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *brel = root-&gt;simple_rel_array[rti];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; lateral_relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there may be empty slots corresponding to non-baserel RTEs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (brel == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(brel-&gt;relid == rti); <span class="Comment">/* sanity check on array */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore RTEs that are &quot;other rels&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (brel-&gt;reloptkind != RELOPT_BASEREL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lateral_relids = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* consider each laterally-referenced Var or PHV */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, brel-&gt;lateral_vars)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *node = (Node *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found_laterals = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lateral_relids = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(lateral_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *phv = (PlaceHolderVar *) node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderInfo *phinfo = <a href="../util/placeholder.c.html#L83" title="optimizer/util/placeholder.c:83">find_placeholder_info</a>(root, phv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found_laterals = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lateral_relids = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(lateral_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; phinfo-&gt;ph_eval_at);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> have all the simple lateral refs from this rel */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; brel-&gt;direct_lateral_relids = lateral_relids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; brel-&gt;lateral_relids = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(lateral_relids);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now check for lateral references within PlaceHolderVars, and mark their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * eval_at rels as having lateral references to the source rels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For a PHV that is due to be evaluated at a baserel, mark its source(s)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as direct lateral dependencies of the baserel (adding onto the ones<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recorded above).&nbsp; If it's due to be evaluated at a join, mark its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * source(s) as indirect lateral dependencies of each baserel in the join,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ie put them into lateral_relids but not direct_lateral_relids.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * appropriate because we can't put <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such baserel on the outside of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * join to one of the PHV's lateral dependencies, but on the other hand we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * also can't yet join it directly to the dependency.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, root-&gt;placeholder_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderInfo *phinfo = (PlaceHolderInfo *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; eval_at = phinfo-&gt;ph_eval_at;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; lateral_refs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (phinfo-&gt;ph_lateral == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* PHV is uninteresting if no lateral refs */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; found_laterals = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Include only baserels not outer joins in the evaluation sites'<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lateral relids.&nbsp; This avoids problems when outer join order gets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rearranged, and it should still ensure that the lateral <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * available when needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lateral_refs = <a href="../../nodes/bitmapset.c.html#L292" title="nodes/bitmapset.c:292">bms_intersect</a>(phinfo-&gt;ph_lateral, root-&gt;all_baserels);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!bms_is_empty(lateral_refs));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L715" title="nodes/bitmapset.c:715">bms_get_singleton_member</a>(eval_at, &amp;varno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Evaluation site is a baserel */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *brel = <a href="../util/relnode.c.html#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(root, varno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; brel-&gt;direct_lateral_relids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(brel-&gt;direct_lateral_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lateral_refs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; brel-&gt;lateral_relids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(brel-&gt;lateral_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lateral_refs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Evaluation site is a join */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varno = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((varno = <a href="../../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(eval_at, varno)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *brel = <a href="../util/relnode.c.html#L454" title="optimizer/util/relnode.c:454">find_base_rel_ignore_join</a>(root, varno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (brel == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; <span class="Comment">/* ignore outer joins in eval_at */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; brel-&gt;lateral_relids = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(brel-&gt;lateral_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lateral_refs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we found no actual lateral references, we're done; but reset the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hasLateralRTEs flag to avoid useless work later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!found_laterals)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;hasLateralRTEs = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate the transitive closure of the lateral_relids sets, so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they describe both direct and indirect lateral references.&nbsp; If relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * X references Y laterally, and Y references Z laterally, then we will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have to scan X on the inside of a nestloop with Z, so for all intents<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and purposes X is laterally dependent on Z too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This code is essentially Warshall's algorithm for transitive closure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The outer loop considers each baserel, and propagates its lateral<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dependencies to those baserels that have a lateral dependency on it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (rti = <span class="Constant">1</span>; rti &lt; root-&gt;simple_rel_array_size; rti++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *brel = root-&gt;simple_rel_array[rti];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; outer_lateral_relids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; rti2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (brel == <span class="Constant">NULL</span> || brel-&gt;reloptkind != RELOPT_BASEREL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* need not consider baserel further if it has no lateral refs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; outer_lateral_relids = brel-&gt;lateral_relids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (outer_lateral_relids == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else scan all baserels */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (rti2 = <span class="Constant">1</span>; rti2 &lt; root-&gt;simple_rel_array_size; rti2++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *brel2 = root-&gt;simple_rel_array[rti2];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (brel2 == <span class="Constant">NULL</span> || brel2-&gt;reloptkind != RELOPT_BASEREL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if brel2 has lateral ref to brel, propagate brel's refs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(rti, brel2-&gt;lateral_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; brel2-&gt;lateral_relids = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(brel2-&gt;lateral_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_lateral_relids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we've identified all lateral references, mark each baserel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with the set of relids of rels that reference it laterally (possibly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indirectly) --- that is, the inverse mapping of lateral_relids.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (rti = <span class="Constant">1</span>; rti &lt; root-&gt;simple_rel_array_size; rti++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *brel = root-&gt;simple_rel_array[rti];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; lateral_relids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rti2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (brel == <span class="Constant">NULL</span> || brel-&gt;reloptkind != RELOPT_BASEREL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Nothing to do at rels with no lateral refs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lateral_relids = brel-&gt;lateral_relids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bms_is_empty(lateral_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No rel should have a lateral dependency on itself */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(rti, lateral_relids));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark this rel's referencees */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rti2 = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((rti2 = <a href="../../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(lateral_relids, rti2)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *brel2 = root-&gt;simple_rel_array[rti2];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (brel2 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must be an OJ */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(brel2-&gt;reloptkind == RELOPT_BASEREL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; brel2-&gt;lateral_referencers =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(brel2-&gt;lateral_referencers, rti);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; JOIN TREE PROCESSING<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L740" title="optimizer/plan/initsplan.c:740">deconstruct_jointree</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Recursively scan the query's join tree for WHERE and JOIN/ON qual<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; clauses, and add these to the appropriate restrictinfo and joininfo<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; lists belonging to base RelOptInfos.&nbsp; Also, add SpecialJoinInfo nodes<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; to root-&gt;join_info_list for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer joins appearing in the query tree.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Return a &quot;joinlist&quot; data structure showing the join order decisions<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; that need to be made by <a href="../path/allpaths.c.html#L171" title="optimizer/path/allpaths.c:171">make_one_rel</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The &quot;joinlist&quot; result is a list of items that are either RangeTblRef<br/></li>
<li></span><span class="Comment"> * jointree nodes or sub-joinlists.&nbsp; All the items at the same level of<br/></li>
<li></span><span class="Comment"> * joinlist must be joined in an order to be determined by <a href="../path/allpaths.c.html#L171" title="optimizer/path/allpaths.c:171">make_one_rel</a>()<br/></li>
<li></span><span class="Comment"> * (note that legal orders may be constrained by SpecialJoinInfo nodes).<br/></li>
<li></span><span class="Comment"> * A sub-joinlist represents a subproblem to be planned separately. Currently<br/></li>
<li></span><span class="Comment"> * sub-joinlists arise only from FULL OUTER JOIN or when collapsing of<br/></li>
<li></span><span class="Comment"> * subproblems is stopped by <a href="#L39" title="optimizer/plan/initsplan.c:39">join_collapse_limit</a> or <a href="#L38" title="optimizer/plan/initsplan.c:38">from_collapse_limit</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L740">&#x200c;</a><span class="linkable">deconstruct_jointree</span>(PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; JoinDomain *top_jdomain;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *item_list = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * After this point, no more PlaceHolderInfos may be made, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1360" title="optimizer/plan/initsplan.c:1360">make_outerjoininfo</a> requires all active placeholders to be present in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * root-&gt;placeholder_list while we crawl up the join tree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;placeholdersFrozen = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch the already-created top-level join domain for the query */<br/></li>
<li></span>&nbsp; &nbsp; top_jdomain = linitial_node(JoinDomain, root-&gt;join_domains);<br/></li>
<li>&nbsp; &nbsp; top_jdomain-&gt;jd_relids = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* filled during <a href="#L822" title="optimizer/plan/initsplan.c:822">deconstruct_recurse</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Start recursion at top of jointree */<br/></li>
<li></span>&nbsp; &nbsp; Assert(root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;jointree != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IsA(root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;jointree, FromExpr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* These are filled as we scan the jointree */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;all_baserels = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;outer_join_rels = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Perform the initial scan of the jointree */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="#L822" title="optimizer/plan/initsplan.c:822">deconstruct_recurse</a>(root, (Node *) root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;jointree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; top_jdomain, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;item_list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we can form the value of all_query_rels, too */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;all_query_rels = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(root-&gt;all_baserels, root-&gt;outer_join_rels);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... which should match what we computed for the top join domain */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(root-&gt;all_query_rels, top_jdomain-&gt;jd_relids));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now scan all the jointree nodes again, and distribute quals */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, item_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *jtitem = (<a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1120" title="optimizer/plan/initsplan.c:1120">deconstruct_distribute</a>(root, jtitem);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there were <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> special joins then we may have some postponed LEFT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * JOIN clauses to deal with.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;join_info_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, item_list)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *jtitem = (<a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (jtitem-&gt;oj_joinclauses != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1878" title="optimizer/plan/initsplan.c:1878">deconstruct_distribute_oj_quals</a>(root, item_list, jtitem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't need the JoinTreeItems <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1560" title="nodes/list.c:1560">list_free_deep</a>(item_list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L822" title="optimizer/plan/initsplan.c:822">deconstruct_recurse</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; One recursion level of <a href="#L740" title="optimizer/plan/initsplan.c:740">deconstruct_jointree</a>'s initial jointree scan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * jtnode is the jointree node to examine, and parent_domain is the<br/></li>
<li></span><span class="Comment"> * enclosing join domain.&nbsp; (We must add all base+OJ relids appearing<br/></li>
<li></span><span class="Comment"> * here or below to parent_domain.)&nbsp; parent_jtitem is the <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a><br/></li>
<li></span><span class="Comment"> * for the parent jointree node, or NULL at the top of the recursion.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * item_list is an in/out parameter: we add a <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> struct to<br/></li>
<li></span><span class="Comment"> * that list for each jointree node, in depth-first traversal order.<br/></li>
<li></span><span class="Comment"> * (Hence, after each call, the last list item corresponds to its jtnode.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return value is the appropriate joinlist for this jointree node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L822">&#x200c;</a><span class="linkable">deconstruct_recurse</span>(PlannerInfo *root, Node *jtnode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JoinDomain *parent_domain,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *parent_jtitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **item_list)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *joinlist;<br/></li>
<li>&nbsp; &nbsp; <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *jtitem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(jtnode != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make the new <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a>, but don't add it to item_list yet */<br/></li>
<li></span>&nbsp; &nbsp; jtitem = palloc0_object(<a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a>);<br/></li>
<li>&nbsp; &nbsp; jtitem-&gt;jtnode = jtnode;<br/></li>
<li>&nbsp; &nbsp; jtitem-&gt;jti_parent = parent_jtitem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(jtnode, RangeTblRef))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varno = ((RangeTblRef *) jtnode)-&gt;rtindex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fill all_baserels as we encounter baserel jointree nodes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;all_baserels = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(root-&gt;all_baserels, varno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This node belongs to parent_domain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;jdomain = parent_domain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent_domain-&gt;jd_relids = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(parent_domain-&gt;jd_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* qualscope is just the one RTE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;qualscope = <a href="../../nodes/bitmapset.c.html#L216" title="nodes/bitmapset.c:216">bms_make_singleton</a>(varno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* A single baserel does not create an inner join */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;inner_join_rels = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; joinlist = list_make1(jtnode);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(jtnode, FromExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FromExpr&nbsp;&nbsp; *f = (FromExpr *) jtnode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remaining;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This node belongs to parent_domain, as do its children */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;jdomain = parent_domain;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Recurse to handle child nodes, and compute output joinlist.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * collapse subproblems into a single joinlist whenever the resulting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * joinlist wouldn't exceed <a href="#L38" title="optimizer/plan/initsplan.c:38">from_collapse_limit</a> members.&nbsp; Also, always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * collapse one-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> subproblems, since that won't lengthen the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * joinlist anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;qualscope = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;inner_join_rels = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; joinlist = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; remaining = list_length(f-&gt;fromlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, f-&gt;fromlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *sub_item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sub_joinlist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_members;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_joinlist = <a href="#L822" title="optimizer/plan/initsplan.c:822">deconstruct_recurse</a>(root, lfirst(l),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parent_domain,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jtitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; item_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_item = (<a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *) llast(*item_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;qualscope = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(jtitem-&gt;qualscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_item-&gt;qualscope);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;inner_join_rels = sub_item-&gt;inner_join_rels;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_members = list_length(sub_joinlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remaining--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sub_members &lt;= <span class="Constant">1</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(joinlist) + sub_members + remaining &lt;= <a href="#L38" title="optimizer/plan/initsplan.c:38">from_collapse_limit</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinlist = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(joinlist, sub_joinlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(joinlist, sub_joinlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A FROM with more than one list <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is an inner join subsuming<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all below it, so we should report inner_join_rels = qualscope. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there was exactly one <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, we should (and already did) report<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whatever its inner_join_rels were.&nbsp; If there were no elements (is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that still possible?) the initialization <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the loop fixed it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(f-&gt;fromlist) &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;inner_join_rels = jtitem-&gt;qualscope;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(jtnode, JoinExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JoinExpr&nbsp;&nbsp; *j = (JoinExpr *) jtnode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JoinDomain *child_domain,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *fj_domain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *left_item,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *right_item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *leftjoinlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *rightjoinlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (j-&gt;jointype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JOIN_INNER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This node belongs to parent_domain, as do its children */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;jdomain = parent_domain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftjoinlist = <a href="#L822" title="optimizer/plan/initsplan.c:822">deconstruct_recurse</a>(root, j-&gt;larg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parent_domain,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jtitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; item_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left_item = (<a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *) llast(*item_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightjoinlist = <a href="#L822" title="optimizer/plan/initsplan.c:822">deconstruct_recurse</a>(root, j-&gt;rarg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent_domain,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right_item = (<a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *) llast(*item_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute qualscope etc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;qualscope = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(left_item-&gt;qualscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right_item-&gt;qualscope);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;inner_join_rels = jtitem-&gt;qualscope;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;left_rels = left_item-&gt;qualscope;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;right_rels = right_item-&gt;qualscope;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Inner join adds no restrictions for quals */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;nonnullable_rels = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JOIN_LEFT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JOIN_ANTI:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make new join domain for my quals and the RHS */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_domain = makeNode(JoinDomain);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_domain-&gt;jd_relids = <span class="Constant">NULL</span>; <span class="Comment">/* filled by recursion */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;join_domains = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;join_domains, child_domain);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;jdomain = child_domain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftjoinlist = <a href="#L822" title="optimizer/plan/initsplan.c:822">deconstruct_recurse</a>(root, j-&gt;larg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parent_domain,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jtitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; item_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left_item = (<a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *) llast(*item_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightjoinlist = <a href="#L822" title="optimizer/plan/initsplan.c:822">deconstruct_recurse</a>(root, j-&gt;rarg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_domain,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right_item = (<a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *) llast(*item_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute join domain contents, qualscope etc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent_domain-&gt;jd_relids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(parent_domain-&gt;jd_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_domain-&gt;jd_relids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;qualscope = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(left_item-&gt;qualscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right_item-&gt;qualscope);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* caution: ANTI join derived from SEMI will lack rtindex */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j-&gt;rtindex != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent_domain-&gt;jd_relids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(parent_domain-&gt;jd_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; j-&gt;rtindex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;qualscope = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(jtitem-&gt;qualscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; j-&gt;rtindex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;outer_join_rels = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(root-&gt;outer_join_rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; j-&gt;rtindex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1322" title="optimizer/plan/initsplan.c:1322">mark_rels_nulled_by_join</a>(root, j-&gt;rtindex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; right_item-&gt;qualscope);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;inner_join_rels = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(left_item-&gt;inner_join_rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right_item-&gt;inner_join_rels);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;left_rels = left_item-&gt;qualscope;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;right_rels = right_item-&gt;qualscope;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;nonnullable_rels = left_item-&gt;qualscope;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JOIN_SEMI:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This node belongs to parent_domain, as do its children */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;jdomain = parent_domain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftjoinlist = <a href="#L822" title="optimizer/plan/initsplan.c:822">deconstruct_recurse</a>(root, j-&gt;larg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parent_domain,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jtitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; item_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left_item = (<a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *) llast(*item_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightjoinlist = <a href="#L822" title="optimizer/plan/initsplan.c:822">deconstruct_recurse</a>(root, j-&gt;rarg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent_domain,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right_item = (<a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *) llast(*item_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute qualscope etc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;qualscope = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(left_item-&gt;qualscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right_item-&gt;qualscope);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* SEMI join never has rtindex, so don't add to anything */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(j-&gt;rtindex == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;inner_join_rels = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(left_item-&gt;inner_join_rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right_item-&gt;inner_join_rels);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;left_rels = left_item-&gt;qualscope;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;right_rels = right_item-&gt;qualscope;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Semi join adds no restrictions for quals */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;nonnullable_rels = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JOIN_FULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The FULL JOIN's quals need their very own domain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fj_domain = makeNode(JoinDomain);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;join_domains = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;join_domains, fj_domain);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;jdomain = fj_domain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse, giving each side its own join domain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_domain = makeNode(JoinDomain);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_domain-&gt;jd_relids = <span class="Constant">NULL</span>; <span class="Comment">/* filled by recursion */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;join_domains = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;join_domains, child_domain);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftjoinlist = <a href="#L822" title="optimizer/plan/initsplan.c:822">deconstruct_recurse</a>(root, j-&gt;larg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; child_domain,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jtitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; item_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left_item = (<a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *) llast(*item_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fj_domain-&gt;jd_relids = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(child_domain-&gt;jd_relids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_domain = makeNode(JoinDomain);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_domain-&gt;jd_relids = <span class="Constant">NULL</span>; <span class="Comment">/* filled by recursion */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;join_domains = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;join_domains, child_domain);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightjoinlist = <a href="#L822" title="optimizer/plan/initsplan.c:822">deconstruct_recurse</a>(root, j-&gt;rarg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_domain,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right_item = (<a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *) llast(*item_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute qualscope etc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fj_domain-&gt;jd_relids = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(fj_domain-&gt;jd_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; child_domain-&gt;jd_relids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent_domain-&gt;jd_relids = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(parent_domain-&gt;jd_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fj_domain-&gt;jd_relids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;qualscope = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(left_item-&gt;qualscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right_item-&gt;qualscope);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(j-&gt;rtindex != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent_domain-&gt;jd_relids = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(parent_domain-&gt;jd_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j-&gt;rtindex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;qualscope = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(jtitem-&gt;qualscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; j-&gt;rtindex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;outer_join_rels = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(root-&gt;outer_join_rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; j-&gt;rtindex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1322" title="optimizer/plan/initsplan.c:1322">mark_rels_nulled_by_join</a>(root, j-&gt;rtindex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; left_item-&gt;qualscope);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1322" title="optimizer/plan/initsplan.c:1322">mark_rels_nulled_by_join</a>(root, j-&gt;rtindex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; right_item-&gt;qualscope);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;inner_join_rels = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(left_item-&gt;inner_join_rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right_item-&gt;inner_join_rels);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;left_rels = left_item-&gt;qualscope;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;right_rels = right_item-&gt;qualscope;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* each side is both outer and inner */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;nonnullable_rels = jtitem-&gt;qualscope;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* JOIN_RIGHT was eliminated during <a href="../prep/prepjointree.c.html#L2713" title="optimizer/prep/prepjointree.c:2713">reduce_outer_joins</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized join type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) j-&gt;jointype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftjoinlist = rightjoinlist = NIL; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compute the output joinlist.&nbsp; We fold subproblems together except<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * at a FULL JOIN or where <a href="#L39" title="optimizer/plan/initsplan.c:39">join_collapse_limit</a> would be exceeded.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j-&gt;jointype == JOIN_FULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* force the join order exactly at this node */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinlist = list_make1(list_make2(leftjoinlist, rightjoinlist));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (list_length(leftjoinlist) + list_length(rightjoinlist) &lt;=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L39" title="optimizer/plan/initsplan.c:39">join_collapse_limit</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK to <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> subproblems */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinlist = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(leftjoinlist, rightjoinlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can't <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a>, but needn't force join order above here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *leftpart,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *rightpart;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* avoid creating useless 1-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> sublists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(leftjoinlist) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftpart = (Node *) linitial(leftjoinlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftpart = (Node *) leftjoinlist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(rightjoinlist) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightpart = (Node *) linitial(rightjoinlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightpart = (Node *) rightjoinlist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinlist = list_make2(leftpart, rightpart);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) nodeTag(jtnode));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; joinlist = NIL;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finally, we can add the new <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> to item_list */<br/></li>
<li></span>&nbsp; &nbsp; *item_list = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(*item_list, jtitem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> joinlist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1120" title="optimizer/plan/initsplan.c:1120">deconstruct_distribute</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Process one jointree node in phase 2 of <a href="#L740" title="optimizer/plan/initsplan.c:740">deconstruct_jointree</a> processing.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Distribute quals of the node to appropriate restriction and join lists.<br/></li>
<li></span><span class="Comment"> * In addition, entries will be added to root-&gt;join_info_list for outer joins.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1120">&#x200c;</a></span><span class="linkable">deconstruct_distribute</span>(PlannerInfo *root, <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *jtitem)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *jtnode = jtitem-&gt;jtnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(jtnode, RangeTblRef))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varno = ((RangeTblRef *) jtnode)-&gt;rtindex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Deal with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> securityQuals attached to the RTE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;qual_security_level &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1272" title="optimizer/plan/initsplan.c:1272">process_security_barrier_quals</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; varno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jtitem);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(jtnode, FromExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FromExpr&nbsp;&nbsp; *f = (FromExpr *) jtnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Process <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> lateral-referencing quals that were postponed to this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * level by children.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2119" title="optimizer/plan/initsplan.c:2119">distribute_quals_to_rels</a>(root, jtitem-&gt;lateral_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jtitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;qual_security_level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jtitem-&gt;qualscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">false</span>, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now process the top-level quals.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2119" title="optimizer/plan/initsplan.c:2119">distribute_quals_to_rels</a>(root, (List *) f-&gt;quals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jtitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;qual_security_level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jtitem-&gt;qualscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">false</span>, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(jtnode, JoinExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JoinExpr&nbsp;&nbsp; *j = (JoinExpr *) jtnode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; ojscope;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *my_quals;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpecialJoinInfo *sjinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp; **postponed_oj_qual_list;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Include lateral-referencing quals postponed from children in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * my_quals, so that they'll be handled properly in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1360" title="optimizer/plan/initsplan.c:1360">make_outerjoininfo</a>.&nbsp; (This is destructive to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * jtitem-&gt;lateral_clauses, but we won't use that again.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; my_quals = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(jtitem-&gt;lateral_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (List *) j-&gt;quals);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For an OJ, form the SpecialJoinInfo <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, so that we can pass it to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L2197" title="optimizer/plan/initsplan.c:2197">distribute_qual_to_rels</a>.&nbsp; We must compute its ojscope too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Semijoins are a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of a hybrid: we build a SpecialJoinInfo, but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * want ojscope = NULL for <a href="#L2197" title="optimizer/plan/initsplan.c:2197">distribute_qual_to_rels</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j-&gt;jointype != JOIN_INNER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sjinfo = <a href="#L1360" title="optimizer/plan/initsplan.c:1360">make_outerjoininfo</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;left_rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;right_rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;inner_join_rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j-&gt;jointype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j-&gt;rtindex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; my_quals);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem-&gt;sjinfo = sjinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j-&gt;jointype == JOIN_SEMI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ojscope = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ojscope = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(sjinfo-&gt;min_lefthand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sjinfo-&gt;min_righthand);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sjinfo = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ojscope = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's a left join with a join clause that is strict for the LHS,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then we need to postpone handling of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-degenerate join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clauses, in case the join is able to commute with another left join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * per identity 3.&nbsp; (Degenerate clauses need not be postponed, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * they will drop down below this join anyway.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j-&gt;jointype == JOIN_LEFT &amp;&amp; sjinfo-&gt;lhs_strict)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; postponed_oj_qual_list = &amp;jtitem-&gt;oj_joinclauses;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add back <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> commutable <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> OJ relids that were removed from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * min_lefthand or min_righthand, else the ojscope cross-check in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L2197" title="optimizer/plan/initsplan.c:2197">distribute_qual_to_rels</a> will complain.&nbsp; Since we are postponing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * processing of non-degenerate clauses, this addition doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * affect anything except that cross-check.&nbsp; Real clause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * positioning decisions will be made later, when we revisit the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * postponed clauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ojscope = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(ojscope, sjinfo-&gt;commute_below_l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ojscope = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(ojscope, sjinfo-&gt;commute_below_r);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; postponed_oj_qual_list = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Process the JOIN's qual clauses */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2119" title="optimizer/plan/initsplan.c:2119">distribute_quals_to_rels</a>(root, my_quals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jtitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;qual_security_level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jtitem-&gt;qualscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ojscope, jtitem-&gt;nonnullable_rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,&nbsp; &nbsp; <span class="Comment">/* incompatible_relids */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,&nbsp; &nbsp; <span class="Comment">/* allow_equivalence */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>,&nbsp; &nbsp; <span class="Comment">/* not clones */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; postponed_oj_qual_list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And add the SpecialJoinInfo to join_info_list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sjinfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;join_info_list = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;join_info_list, sjinfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) nodeTag(jtnode));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1272" title="optimizer/plan/initsplan.c:1272">process_security_barrier_quals</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Transfer security-barrier quals into relation's baserestrictinfo list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The rewriter put <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> relevant security-barrier conditions into the RTE's<br/></li>
<li></span><span class="Comment"> * securityQuals field, but it's <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> time to copy them into the rel's<br/></li>
<li></span><span class="Comment"> * baserestrictinfo.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In inheritance cases, we only consider quals attached to the parent rel<br/></li>
<li></span><span class="Comment"> * here; they will be valid for all children too, so it's okay to consider<br/></li>
<li></span><span class="Comment"> * them for purposes like equivalence class creation.&nbsp; Quals attached to<br/></li>
<li></span><span class="Comment"> * individual child rels will be dealt with during path creation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1272">&#x200c;</a></span><span class="linkable">process_security_barrier_quals</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> rti, <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *jtitem)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte = root-&gt;simple_rte_array[rti];<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; security_level = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Each <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of the securityQuals list has been preprocessed into an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * implicitly-ANDed list of clauses.&nbsp; All the clauses in a given sublist<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should get the same security level, but successive sublists get higher<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * levels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, rte-&gt;securityQuals)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *qualset = (List *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We cheat to the extent of passing ojscope = qualscope rather than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * its more logical value of NULL.&nbsp; The only effect this has is to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * force a Var-free qual to be evaluated at the rel rather than being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pushed up to top of tree, which we don't want.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2119" title="optimizer/plan/initsplan.c:2119">distribute_quals_to_rels</a>(root, qualset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jtitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; security_level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jtitem-&gt;qualscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jtitem-&gt;qualscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>,&nbsp; &nbsp; <span class="Comment">/* not clones */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; security_level++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assert that qual_security_level is higher than anything we just used */<br/></li>
<li></span>&nbsp; &nbsp; Assert(security_level &lt;= root-&gt;qual_security_level);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1322" title="optimizer/plan/initsplan.c:1322">mark_rels_nulled_by_join</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Fill RelOptInfo.nulling_relids of baserels nulled by this outer join<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Inputs:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; ojrelid: RT index of the join RTE (must not be 0)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; lower_rels: the base+OJ Relids syntactically below nullable side of join<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1322">&#x200c;</a></span><span class="linkable">mark_rels_nulled_by_join</span>(PlannerInfo *root, Index ojrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids lower_rels)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((relid = <a href="../../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(lower_rels, relid)) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel = root-&gt;simple_rel_array[relid];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel == <span class="Constant">NULL</span>)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must be an outer join */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(relid, root-&gt;outer_join_rels));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;nulling_relids = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(rel-&gt;nulling_relids, ojrelid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1360" title="optimizer/plan/initsplan.c:1360">make_outerjoininfo</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Build a SpecialJoinInfo for the current outer join<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Inputs:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; left_rels: the base+OJ Relids syntactically on outer side of join<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; right_rels: the base+OJ Relids syntactically on inner side of join<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; inner_join_rels: base+OJ Relids participating in inner joins below this one<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; jointype: what it says (must always be LEFT, FULL, SEMI, or ANTI)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; ojrelid: RT index of the join RTE (0 for SEMI, which isn't in the RT list)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; clause: the outer join's join condition (in implicit-AND format)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The node should eventually be appended to root-&gt;join_info_list, but we<br/></li>
<li></span><span class="Comment"> * do not do that here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we assume that this function is invoked bottom-up, so that<br/></li>
<li></span><span class="Comment"> * root-&gt;join_info_list already contains entries for all outer joins that are<br/></li>
<li></span><span class="Comment"> * syntactically below this one.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> SpecialJoinInfo *<br/></li>
<li><a id="L1360">&#x200c;</a><span class="linkable">make_outerjoininfo</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids left_rels, Relids right_rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids inner_join_rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JoinType jointype, Index ojrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *clause)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpecialJoinInfo *sjinfo = makeNode(SpecialJoinInfo);<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; clause_relids;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; strict_relids;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; min_lefthand;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; min_righthand;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; commute_below_l;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; commute_below_r;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We should not see RIGHT JOIN here because left/right were switched<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * earlier<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(jointype != JOIN_INNER);<br/></li>
<li>&nbsp; &nbsp; Assert(jointype != JOIN_RIGHT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Presently the executor cannot support FOR [<a href="../../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>] UPDATE/SHARE marking of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rels appearing on the nullable side of an outer join. (It's somewhat<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unclear what that would mean, anyway: what should we mark when a result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * row is generated from no <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of the nullable relation?)&nbsp; &nbsp; So,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * complain if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> nullable rel is FOR [<a href="../../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>] UPDATE/SHARE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * You might be wondering why this test isn't made far upstream in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parser.&nbsp; It's because the parser hasn't got enough info --- consider<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * FOR UPDATE applied to a view.&nbsp; Only after rewriting and flattening do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we know whether the view contains an outer join.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use the original RowMarkClause list here; the PlanRowMark list would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list everything.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rowMarks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RowMarkClause *rc = (RowMarkClause *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(rc-&gt;rti, right_rels) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jointype == JOIN_FULL &amp;&amp; <a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(rc-&gt;rti, left_rels)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; translator: %s is a SQL row locking clause such as FOR UPDATE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> cannot be applied to the nullable side of an outer join&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../parser/analyze.c.html#L3213" title="parser/analyze.c:3213">LCS_asString</a>(rc-&gt;strength))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sjinfo-&gt;syn_lefthand = left_rels;<br/></li>
<li>&nbsp; &nbsp; sjinfo-&gt;syn_righthand = right_rels;<br/></li>
<li>&nbsp; &nbsp; sjinfo-&gt;jointype = jointype;<br/></li>
<li>&nbsp; &nbsp; sjinfo-&gt;ojrelid = ojrelid;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* these fields may get added to later: */<br/></li>
<li></span>&nbsp; &nbsp; sjinfo-&gt;commute_above_l = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; sjinfo-&gt;commute_above_r = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; sjinfo-&gt;commute_below_l = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; sjinfo-&gt;commute_below_r = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1700" title="optimizer/plan/initsplan.c:1700">compute_semijoin_info</a>(root, sjinfo, clause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If it's a full join, no need to be very smart */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (jointype == JOIN_FULL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sjinfo-&gt;min_lefthand = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(left_rels);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sjinfo-&gt;min_righthand = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(right_rels);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sjinfo-&gt;lhs_strict = <span class="Constant">false</span>; <span class="Comment">/* don't care about this */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> sjinfo;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Retrieve all relids mentioned within the join clause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; clause_relids = <a href="../util/var.c.html#L108" title="optimizer/util/var.c:108">pull_varnos</a>(root, (Node *) clause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For which relids is the clause strict, ie, it cannot succeed if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rel's columns are all NULL?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; strict_relids = <a href="../util/clauses.c.html#L1456" title="optimizer/util/clauses.c:1456">find_nonnullable_rels</a>((Node *) clause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remember whether the clause is strict for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> LHS relations */<br/></li>
<li></span>&nbsp; &nbsp; sjinfo-&gt;lhs_strict = <a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(strict_relids, left_rels);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Required LHS always includes the LHS rels mentioned in the clause. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * may have to add more rels based on <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> outer joins; see below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; min_lefthand = <a href="../../nodes/bitmapset.c.html#L292" title="nodes/bitmapset.c:292">bms_intersect</a>(clause_relids, left_rels);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Similarly for required RHS.&nbsp; But here, we must also include <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inner joins, to ensure we don't try to commute with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; min_righthand = <a href="../../nodes/bitmapset.c.html#L1109" title="nodes/bitmapset.c:1109">bms_int_members</a>(<a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(clause_relids, inner_join_rels),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right_rels);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now check previous outer joins for ordering restrictions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commute_below_l and commute_below_r accumulate the relids of <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * outer joins that we think this one can commute with.&nbsp; These decisions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are just tentative within this loop, since we might <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * intermediate outer join that prevents commutation.&nbsp; Surviving relids<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will get merged into the SpecialJoinInfo structs afterwards.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; commute_below_l = commute_below_r = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(l, root-&gt;join_info_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpecialJoinInfo *otherinfo = (SpecialJoinInfo *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_unsafe_phvs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A full join is an optimization barrier: we can't associate into or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * out of it.&nbsp; Hence, if it overlaps either LHS or RHS of the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rel, expand that side's min relset to cover the whole full join.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (otherinfo-&gt;jointype == JOIN_FULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(otherinfo-&gt;ojrelid != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(left_rels, otherinfo-&gt;syn_lefthand) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(left_rels, otherinfo-&gt;syn_righthand))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_lefthand = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(min_lefthand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; otherinfo-&gt;syn_lefthand);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_lefthand = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(min_lefthand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; otherinfo-&gt;syn_righthand);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_lefthand = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(min_lefthand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherinfo-&gt;ojrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(right_rels, otherinfo-&gt;syn_lefthand) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(right_rels, otherinfo-&gt;syn_righthand))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_righthand = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(min_righthand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherinfo-&gt;syn_lefthand);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_righthand = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(min_righthand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherinfo-&gt;syn_righthand);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_righthand = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(min_righthand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; otherinfo-&gt;ojrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Needn't do anything else with the full join */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If our join condition contains <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> PlaceHolderVars that need to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * evaluated above the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> OJ, then we can't commute with it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (otherinfo-&gt;ojrelid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_unsafe_phvs =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/placeholder.c.html#L464" title="optimizer/util/placeholder.c:464">contain_placeholder_references_to</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Node *) clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherinfo-&gt;ojrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_unsafe_phvs = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For a <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> OJ in our LHS, if our join condition uses the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * join's RHS and is not strict for that rel, we must preserve the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ordering of the two OJs, so add <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> OJ's full syntactic relset to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * min_lefthand.&nbsp; (We must use its full syntactic relset, not just its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * min_lefthand + min_righthand.&nbsp; This is because there might be other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OJs below this one that this one can commute with, but we cannot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * commute with them if we don't with this one.)&nbsp; Also, if we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unsafe PHVs or the current join is a semijoin or antijoin, we must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * preserve ordering regardless of strictness.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: I believe we have to insist on being strict for at least one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rel in the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> OJ's min_righthand, not its whole syn_righthand.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When we don't need to preserve ordering, check to see if outer join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * identity 3 applies, and if so, remove the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> OJ's ojrelid from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * our min_lefthand so that commutation is allowed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(left_rels, otherinfo-&gt;syn_righthand))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(clause_relids, otherinfo-&gt;syn_righthand) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (have_unsafe_phvs ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jointype == JOIN_SEMI || jointype == JOIN_ANTI ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(strict_relids, otherinfo-&gt;min_righthand)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Preserve ordering */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_lefthand = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(min_lefthand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; otherinfo-&gt;syn_lefthand);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_lefthand = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(min_lefthand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; otherinfo-&gt;syn_righthand);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (otherinfo-&gt;ojrelid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_lefthand = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(min_lefthand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherinfo-&gt;ojrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (jointype == JOIN_LEFT &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; otherinfo-&gt;jointype == JOIN_LEFT &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(strict_relids, otherinfo-&gt;min_righthand) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(clause_relids, otherinfo-&gt;syn_lefthand))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Identity 3 applies, so remove the ordering restriction */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_lefthand = <a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(min_lefthand, otherinfo-&gt;ojrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Record the (still tentative) commutability relationship */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commute_below_l =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(commute_below_l, otherinfo-&gt;ojrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For a <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> OJ in our RHS, if our join condition does not use the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> join's RHS and the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> OJ's join condition is strict, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can interchange the ordering of the two OJs; otherwise we must add<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> OJ's full syntactic relset to min_righthand.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also, if our join condition does not use the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> join's LHS<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * either, force the ordering to be preserved.&nbsp; Otherwise we can end<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * up with SpecialJoinInfos with identical min_righthands, which can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * confuse <a href="../path/joinrels.c.html#L349" title="optimizer/path/joinrels.c:349">join_is_legal</a> (see discussion in backend/optimizer/README).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also, we must preserve ordering anyway if we have unsafe PHVs, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if either this join or the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> OJ is a semijoin or antijoin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When we don't need to preserve ordering, check to see if outer join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * identity 3 applies, and if so, remove the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> OJ's ojrelid from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * our min_righthand so that commutation is allowed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(right_rels, otherinfo-&gt;syn_righthand))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(clause_relids, otherinfo-&gt;syn_righthand) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(clause_relids, otherinfo-&gt;min_lefthand) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_unsafe_phvs ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jointype == JOIN_SEMI ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jointype == JOIN_ANTI ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherinfo-&gt;jointype == JOIN_SEMI ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherinfo-&gt;jointype == JOIN_ANTI ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !otherinfo-&gt;lhs_strict)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Preserve ordering */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_righthand = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(min_righthand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherinfo-&gt;syn_lefthand);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_righthand = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(min_righthand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherinfo-&gt;syn_righthand);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (otherinfo-&gt;ojrelid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_righthand = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(min_righthand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; otherinfo-&gt;ojrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (jointype == JOIN_LEFT &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; otherinfo-&gt;jointype == JOIN_LEFT &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; otherinfo-&gt;lhs_strict)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Identity 3 applies, so remove the ordering restriction */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_righthand = <a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(min_righthand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; otherinfo-&gt;ojrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Record the (still tentative) commutability relationship */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commute_below_r =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(commute_below_r, otherinfo-&gt;ojrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Examine PlaceHolderVars.&nbsp; If a PHV is supposed to be evaluated within<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this join's nullable side, then ensure that min_righthand contains the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * full eval_at set of the PHV.&nbsp; This ensures that the PHV actually can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * evaluated within the RHS.&nbsp; Note that this works only because we should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already have determined the final eval_at level for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> PHV<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * syntactically within this join.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, root-&gt;placeholder_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderInfo *phinfo = (PlaceHolderInfo *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; ph_syn_level = phinfo-&gt;ph_var-&gt;phrels;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore placeholder if it didn't syntactically come from RHS */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(ph_syn_level, right_rels))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Else, prevent join from being formed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we eval the PHV */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; min_righthand = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(min_righthand, phinfo-&gt;ph_eval_at);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we found nothing to put in min_lefthand, punt and make it the full<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LHS, to avoid having an empty min_lefthand which will confuse later<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processing. (We don't try to be smart about such cases, just correct.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Likewise for min_righthand.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bms_is_empty(min_lefthand))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; min_lefthand = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(left_rels);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bms_is_empty(min_righthand))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; min_righthand = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(right_rels);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now they'd better be nonempty */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!bms_is_empty(min_lefthand));<br/></li>
<li>&nbsp; &nbsp; Assert(!bms_is_empty(min_righthand));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shouldn't overlap either */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(min_lefthand, min_righthand));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sjinfo-&gt;min_lefthand = min_lefthand;<br/></li>
<li>&nbsp; &nbsp; sjinfo-&gt;min_righthand = min_righthand;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we've identified the correct min_lefthand and min_righthand,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> commute_below_l or commute_below_r relids that have not gotten<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * added back into those sets (due to intervening outer joins) are indeed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commutable with this one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, delete <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subsequently-added-back relids (this is easier than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * maintaining commute_below_l/r precisely through all the above).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; commute_below_l = <a href="../../nodes/bitmapset.c.html#L1161" title="nodes/bitmapset.c:1161">bms_del_members</a>(commute_below_l, min_lefthand);<br/></li>
<li>&nbsp; &nbsp; commute_below_r = <a href="../../nodes/bitmapset.c.html#L1161" title="nodes/bitmapset.c:1161">bms_del_members</a>(commute_below_r, min_righthand);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Anything left? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (commute_below_l || commute_below_r)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Yup, so we must update the derived data in the SpecialJoinInfos */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sjinfo-&gt;commute_below_l = commute_below_l;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sjinfo-&gt;commute_below_r = commute_below_r;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, root-&gt;join_info_list)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpecialJoinInfo *otherinfo = (SpecialJoinInfo *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(otherinfo-&gt;ojrelid, commute_below_l))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherinfo-&gt;commute_above_l =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(otherinfo-&gt;commute_above_l, ojrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(otherinfo-&gt;ojrelid, commute_below_r))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherinfo-&gt;commute_above_r =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(otherinfo-&gt;commute_above_r, ojrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> sjinfo;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1700" title="optimizer/plan/initsplan.c:1700">compute_semijoin_info</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Fill semijoin-related fields of a new SpecialJoinInfo<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this relies on only the jointype and syn_righthand fields of the<br/></li>
<li></span><span class="Comment"> * SpecialJoinInfo; the rest may not be set yet.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1700">&#x200c;</a></span><span class="linkable">compute_semijoin_info</span>(PlannerInfo *root, SpecialJoinInfo *sjinfo, List *clause)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *semi_operators;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *semi_rhs_exprs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; all_btree;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; all_hash;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize semijoin-related fields in case we can't unique-ify */<br/></li>
<li></span>&nbsp; &nbsp; sjinfo-&gt;semi_can_btree = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; sjinfo-&gt;semi_can_hash = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; sjinfo-&gt;semi_operators = NIL;<br/></li>
<li>&nbsp; &nbsp; sjinfo-&gt;semi_rhs_exprs = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing more to do if it's not a semijoin */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sjinfo-&gt;jointype != JOIN_SEMI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look to see whether the semijoin's join quals consist of AND'ed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * equality operators, with (only) RHS variables on only one side of each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one.&nbsp; If so, we can figure out how to enforce uniqueness for the RHS.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that the input clause list is the list of quals that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * *syntactically* associated with the semijoin, which in practice means<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the synthesized comparison list for an IN or the WHERE of an EXISTS.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Particularly in the latter case, it might contain clauses that aren't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * *semantically* associated with the join, but refer to just one side or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the other.&nbsp; We can ignore such clauses here, as they will just drop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * down to be processed within one side or the other.&nbsp; (It is okay to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consider only the syntactically-associated clauses here because for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * semijoin, no higher-level quals could refer to the RHS, and so there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can be no other quals that are semantically associated with this join.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do things this way because it is useful to have the set of potential<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unique-ification expressions <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we can extract the list of quals<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that are actually semantically associated with the particular join.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that the semi_operators list consists of the joinqual operators<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * themselves (but commuted if needed to put the RHS value on the right).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * These could be cross-type operators, in which case the operator<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * actually needed for uniqueness is a related single-type operator. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assume here that that operator will be available from the btree or <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * opclass when the time comes ... if not, <a href="createplan.c.html#L1720" title="optimizer/plan/createplan.c:1720">create_unique_plan</a>() will fail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; semi_operators = NIL;<br/></li>
<li>&nbsp; &nbsp; semi_rhs_exprs = NIL;<br/></li>
<li>&nbsp; &nbsp; all_btree = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; all_hash = <a href="../path/costsize.c.html#L141" title="optimizer/path/costsize.c:141">enable_hashagg</a>;&nbsp; &nbsp; <span class="Comment">/* don't consider <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> if not enabled */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, clause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OpExpr&nbsp; &nbsp; &nbsp;&nbsp; *op = (OpExpr *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *left_expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *right_expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; left_varnos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; right_varnos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; all_varnos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opinputtype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Is it a binary opclause? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsA(op, OpExpr) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(op-&gt;args) != <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No, but does it reference both sides? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all_varnos = <a href="../util/var.c.html#L108" title="optimizer/util/var.c:108">pull_varnos</a>(root, (Node *) op);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(all_varnos, sjinfo-&gt;syn_righthand) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(all_varnos, sjinfo-&gt;syn_righthand))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Clause refers to only one rel, so ignore it --- unless it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contains volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, in which case we'd better<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * punt.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>((Node *) op))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Non-operator clause referencing both sides, must punt */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Extract data from binary opclause */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; opno = op-&gt;opno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; left_expr = linitial(op-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; right_expr = lsecond(op-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; left_varnos = <a href="../util/var.c.html#L108" title="optimizer/util/var.c:108">pull_varnos</a>(root, left_expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; right_varnos = <a href="../util/var.c.html#L108" title="optimizer/util/var.c:108">pull_varnos</a>(root, right_expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; all_varnos = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(left_varnos, right_varnos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opinputtype = <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(left_expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Does it reference both sides? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(all_varnos, sjinfo-&gt;syn_righthand) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(all_varnos, sjinfo-&gt;syn_righthand))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Clause refers to only one rel, so ignore it --- unless it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contains volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, in which case we'd better punt.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>((Node *) op))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check rel membership of arguments */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!bms_is_empty(right_varnos) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(right_varnos, sjinfo-&gt;syn_righthand) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(left_varnos, sjinfo-&gt;syn_righthand))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* typical case, right_expr is RHS variable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!bms_is_empty(left_varnos) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(left_varnos, sjinfo-&gt;syn_righthand) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(right_varnos, sjinfo-&gt;syn_righthand))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* flipped case, left_expr is RHS variable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opno = <a href="../../utils/cache/lsyscache.c.html#L1509" title="utils/cache/lsyscache.c:1509">get_commutator</a>(opno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(opno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right_expr = left_expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mixed membership of args, punt */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* all operators must be btree equality or <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> equality */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (all_btree)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* oprcanmerge is considered a hint... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/cache/lsyscache.c.html#L1386" title="utils/cache/lsyscache.c:1386">op_mergejoinable</a>(opno, opinputtype) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/lsyscache.c.html#L366" title="utils/cache/lsyscache.c:366">get_mergejoin_opfamilies</a>(opno) == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all_btree = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (all_hash)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... but oprcanhash had better be correct */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/cache/lsyscache.c.html#L1437" title="utils/cache/lsyscache.c:1437">op_hashjoinable</a>(opno, opinputtype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all_hash = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(all_btree || all_hash))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* so far so good, keep building lists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; semi_operators = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(semi_operators, opno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; semi_rhs_exprs = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(semi_rhs_exprs, copyObject(right_expr));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Punt if we didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> at least one column to unique-ify */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (semi_rhs_exprs == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The expressions we'd need to unique-ify mustn't be volatile.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>((Node *) semi_rhs_exprs))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we get here, we can unique-ify the semijoin's RHS using at least one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of sorting and hashing.&nbsp; Save the information about how to do that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sjinfo-&gt;semi_can_btree = all_btree;<br/></li>
<li>&nbsp; &nbsp; sjinfo-&gt;semi_can_hash = all_hash;<br/></li>
<li>&nbsp; &nbsp; sjinfo-&gt;semi_operators = semi_operators;<br/></li>
<li>&nbsp; &nbsp; sjinfo-&gt;semi_rhs_exprs = semi_rhs_exprs;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1878" title="optimizer/plan/initsplan.c:1878">deconstruct_distribute_oj_quals</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Adjust LEFT JOIN quals to be suitable for commuted-left-join cases,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; then <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> them into the joinqual lists and EquivalenceClass structures.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This runs immediately after we've completed the <a href="#L1120" title="optimizer/plan/initsplan.c:1120">deconstruct_distribute</a> scan.<br/></li>
<li></span><span class="Comment"> * jtitems contains all the JoinTreeItems (in depth-first order), and jtitem<br/></li>
<li></span><span class="Comment"> * is one that has postponed oj_joinclauses to deal with.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1878">&#x200c;</a></span><span class="linkable">deconstruct_distribute_oj_quals</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *jtitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *jtitem)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpecialJoinInfo *sjinfo = jtitem-&gt;sjinfo;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; qualscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ojscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nonnullable_rels;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Recompute syntactic and semantic scopes of this left join */<br/></li>
<li></span>&nbsp; &nbsp; qualscope = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(sjinfo-&gt;syn_lefthand, sjinfo-&gt;syn_righthand);<br/></li>
<li>&nbsp; &nbsp; qualscope = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(qualscope, sjinfo-&gt;ojrelid);<br/></li>
<li>&nbsp; &nbsp; ojscope = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(sjinfo-&gt;min_lefthand, sjinfo-&gt;min_righthand);<br/></li>
<li>&nbsp; &nbsp; nonnullable_rels = sjinfo-&gt;syn_lefthand;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this join can commute with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other ones per outer-join identity 3,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and it is the one providing the join clause with flexible semantics,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then we have to generate variants of the join clause with different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nullingrels labeling.&nbsp; Otherwise, just <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> out the postponed clause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as-is.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(sjinfo-&gt;lhs_strict); <span class="Comment">/* else we shouldn't be here */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sjinfo-&gt;commute_above_r || sjinfo-&gt;commute_below_l)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; joins_above;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; joins_below;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; incompatible_joins;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; joins_so_far;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *quals;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_last_rinfo_serial;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Identify the outer joins this one commutes with */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; joins_above = sjinfo-&gt;commute_above_r;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; joins_below = sjinfo-&gt;commute_below_l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Generate qual variants with different sets of nullingrels bits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We only need <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>-sets that correspond to the successively less<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deeply syntactically-nested subsets of this join and its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * commutators.&nbsp; That's true first because obviously only those forms<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the Vars and PHVs could appear elsewhere in the query, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * second because the outer join identities do not provide a way to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * re-order such joins in a way that would require different marking.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (That is, while the current join may commute with several others,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of those others can commute with each other.)&nbsp; To visit the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interesting joins in syntactic nesting order, we rely on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * jtitems list to be ordered that way.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We first strip out all the nullingrels bits corresponding to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * commuting joins below this one, and then successively put them back<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as we crawl up the join stack.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; quals = jtitem-&gt;oj_joinclauses;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!bms_is_empty(joins_below))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; quals = (List *) <a href="../../rewrite/rewriteManip.c.html#L1234" title="rewrite/rewriteManip.c:1234">remove_nulling_relids</a>((Node *) quals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; joins_below,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We'll need to mark the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> versions of the quals as not safe to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * apply above not-yet-processed joins of the stack.&nbsp; This prevents<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possibly applying a cloned qual at the wrong join level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; incompatible_joins = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(joins_below, joins_above);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; incompatible_joins = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(incompatible_joins,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sjinfo-&gt;ojrelid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Each time we produce RestrictInfo(s) from these quals, reset the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * last_rinfo_serial counter, so that the RestrictInfos for the &quot;same&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * qual condition get identical serial numbers.&nbsp; (This relies on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fact that we're not changing the qual list in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> way that'd affect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the number of RestrictInfos built from it.) This'll allow us to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * detect duplicative qual usage later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; save_last_rinfo_serial = root-&gt;last_rinfo_serial;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; joins_so_far = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, jtitems)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *otherjtitem = (<a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpecialJoinInfo *othersj = otherjtitem-&gt;sjinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; below_sjinfo = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; above_sjinfo = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; this_qualscope;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; this_ojscope;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; allow_equivalence,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has_clone,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_clone;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (othersj == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not an outer-join item, ignore */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(othersj-&gt;ojrelid, joins_below))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* othersj commutes with sjinfo from below left */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; below_sjinfo = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (othersj == sjinfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* found our join in syntactic order */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(joins_so_far, joins_below));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(othersj-&gt;ojrelid, joins_above))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* othersj commutes with sjinfo from above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; above_sjinfo = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* othersj is not relevant, ignore */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset serial counter for this version of the quals */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;last_rinfo_serial = save_last_rinfo_serial;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When we are looking at joins above sjinfo, we are envisioning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pushing sjinfo to above othersj, so add othersj's nulling <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> distributing the quals.&nbsp; We should add it to Vars coming<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from the current join's LHS: we want to transform the second<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * form of OJ identity 3 to the first form, in which Vars of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation B will appear nulled by the syntactically-<a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> OJ<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * within the Pbc clause, but those of relation C will not.&nbsp; (In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the notation used by optimizer/README, we're converting a qual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the form Pbc to Pb*c.)&nbsp; Of course, we must also remove that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> from the incompatible_joins value, else we'll make a qual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that can't be placed anywhere.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (above_sjinfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; quals = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../rewrite/rewriteManip.c.html#L1147" title="rewrite/rewriteManip.c:1147">add_nulling_relids</a>((Node *) quals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sjinfo-&gt;syn_lefthand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/bitmapset.c.html#L216" title="nodes/bitmapset.c:216">bms_make_singleton</a>(othersj-&gt;ojrelid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; incompatible_joins = <a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(incompatible_joins,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; othersj-&gt;ojrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute qualscope and ojscope for this join level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_qualscope = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(qualscope, joins_so_far);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_ojscope = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(ojscope, joins_so_far);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (above_sjinfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* othersj is not yet in joins_so_far, but we need it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_qualscope = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(this_qualscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; othersj-&gt;ojrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_ojscope = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(this_ojscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; othersj-&gt;ojrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* sjinfo is in joins_so_far, and we don't want it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_ojscope = <a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(this_ojscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sjinfo-&gt;ojrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We generate EquivalenceClasses only from the first form of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * quals, with the fewest nullingrels bits set.&nbsp; An EC made from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this version of the quals can be useful below the outer-join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nest, whereas versions with some nullingrels bits set would not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be.&nbsp; We cannot generate ECs from more than one version, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll make nonsensical conclusions that Vars with nullingrels<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bits set are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to their versions without.&nbsp; Fortunately,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * such ECs wouldn't be very useful anyway, because they'd equate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> not observable outside the join nest.&nbsp; (See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * optimizer/README.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The first form of the quals is also the only one marked as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * has_clone rather than is_clone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allow_equivalence = (joins_so_far == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has_clone = allow_equivalence;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_clone = !has_clone;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2119" title="optimizer/plan/initsplan.c:2119">distribute_quals_to_rels</a>(root, quals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; otherjtitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;qual_security_level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; this_qualscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; this_ojscope, nonnullable_rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(incompatible_joins),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; allow_equivalence,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; has_clone,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; is_clone,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>); <span class="Comment">/* no more postponement */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Adjust qual nulling bits for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> level up, if needed.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't want to put sjinfo's own <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> in at all, and if we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * above sjinfo then we did it already.&nbsp; Here, we should mark all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Vars coming from the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> join's RHS.&nbsp; (Again, we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * converting a qual of the form Pbc to Pb*c, but <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * putting back bits that were there in the parser output and were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * temporarily stripped above.)&nbsp; Update incompatible_joins too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (below_sjinfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; quals = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../rewrite/rewriteManip.c.html#L1147" title="rewrite/rewriteManip.c:1147">add_nulling_relids</a>((Node *) quals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; othersj-&gt;syn_righthand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/bitmapset.c.html#L216" title="nodes/bitmapset.c:216">bms_make_singleton</a>(othersj-&gt;ojrelid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; incompatible_joins = <a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(incompatible_joins,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; othersj-&gt;ojrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and track joins processed so far */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joins_so_far = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(joins_so_far, othersj-&gt;ojrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No commutation possible, just process the postponed clauses */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2119" title="optimizer/plan/initsplan.c:2119">distribute_quals_to_rels</a>(root, jtitem-&gt;oj_joinclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jtitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;qual_security_level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; qualscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ojscope, nonnullable_rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,&nbsp; &nbsp; <span class="Comment">/* incompatible_relids */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,&nbsp; &nbsp; <span class="Comment">/* allow_equivalence */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>,&nbsp; &nbsp; <span class="Comment">/* not clones */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>); <span class="Comment">/* no more postponement */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; QUALIFICATIONS<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2119" title="optimizer/plan/initsplan.c:2119">distribute_quals_to_rels</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Convenience routine to apply <a href="#L2197" title="optimizer/plan/initsplan.c:2197">distribute_qual_to_rels</a> to each <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; of an AND'ed list of clauses.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2119">&#x200c;</a></span><span class="linkable">distribute_quals_to_rels</span>(PlannerInfo *root, List *clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *jtitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SpecialJoinInfo *sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index security_level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids qualscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids ojscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids outerjoin_nonnullable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids incompatible_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> allow_equivalence,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> has_clone,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_clone,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **postponed_oj_qual_list)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, clauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *clause = (Node *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2197" title="optimizer/plan/initsplan.c:2197">distribute_qual_to_rels</a>(root, clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jtitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; security_level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qualscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ojscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outerjoin_nonnullable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; incompatible_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allow_equivalence,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has_clone,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_clone,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; postponed_oj_qual_list);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2197" title="optimizer/plan/initsplan.c:2197">distribute_qual_to_rels</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Add clause information to either the baserestrictinfo or joininfo list<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; (depending on whether the clause is a join) of each base relation<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; mentioned in the clause.&nbsp; A RestrictInfo node is created and added to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the appropriate list for each rel.&nbsp; Alternatively, if the clause uses a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; mergejoinable operator, enter its left- and right-side expressions into<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the query's EquivalenceClasses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In some cases, quals will be added to parent jtitems' lateral_clauses<br/></li>
<li></span><span class="Comment"> * or to postponed_oj_qual_list instead of being processed right away.<br/></li>
<li></span><span class="Comment"> * These will be dealt with in later calls of <a href="#L1120" title="optimizer/plan/initsplan.c:1120">deconstruct_distribute</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'clause': the qual clause to be distributed<br/></li>
<li></span><span class="Comment"> * 'jtitem': the <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> for the containing jointree node<br/></li>
<li></span><span class="Comment"> * 'sjinfo': join's SpecialJoinInfo (NULL for an inner join or WHERE clause)<br/></li>
<li></span><span class="Comment"> * 'security_level': security_level to assign to the qual<br/></li>
<li></span><span class="Comment"> * 'qualscope': set of base+OJ rels the qual's syntactic scope covers<br/></li>
<li></span><span class="Comment"> * 'ojscope': NULL if not an outer-join qual, else the minimum set of base+OJ<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; rels needed to form this join<br/></li>
<li></span><span class="Comment"> * 'outerjoin_nonnullable': NULL if not an outer-join qual, else the set of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; base+OJ rels appearing on the outer (nonnullable) side of the join<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (for FULL JOIN this includes both sides of the join, and must in fact<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> qualscope)<br/></li>
<li></span><span class="Comment"> * 'incompatible_relids': the set of outer-join relid(s) that must not be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; computed below this qual.&nbsp; We only bother to compute this for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &quot;clone&quot; quals, otherwise it can be left NULL.<br/></li>
<li></span><span class="Comment"> * 'allow_equivalence': true if it's okay to convert clause into an<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; EquivalenceClass<br/></li>
<li></span><span class="Comment"> * 'has_clone': has_clone property to assign to the qual<br/></li>
<li></span><span class="Comment"> * 'is_clone': is_clone property to assign to the qual<br/></li>
<li></span><span class="Comment"> * 'postponed_oj_qual_list': if not NULL, non-degenerate outer join clauses<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; should be added to this list instead of being processed (list entries<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; are just the bare clauses)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'qualscope' identifies what level of JOIN the qual came from syntactically.<br/></li>
<li></span><span class="Comment"> * 'ojscope' is needed if we decide to force the qual up to the outer-join<br/></li>
<li></span><span class="Comment"> * level, which will be ojscope not necessarily qualscope.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At the time this is called, root-&gt;join_info_list must contain entries for<br/></li>
<li></span><span class="Comment"> * at least those special joins that are syntactically below this qual.<br/></li>
<li></span><span class="Comment"> * (We <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> need that only for detection of redundant IS NULL quals.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2197">&#x200c;</a></span><span class="linkable">distribute_qual_to_rels</span>(PlannerInfo *root, Node *clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *jtitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpecialJoinInfo *sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index security_level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids qualscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids ojscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids outerjoin_nonnullable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids incompatible_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> allow_equivalence,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> has_clone,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_clone,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **postponed_oj_qual_list)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; relids;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_pushed_down;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; pseudoconstant = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; maybe_equivalence;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; maybe_outer_join;<br/></li>
<li>&nbsp; &nbsp; RestrictInfo *restrictinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Retrieve all relids mentioned within the clause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relids = <a href="../util/var.c.html#L108" title="optimizer/util/var.c:108">pull_varnos</a>(root, clause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In ordinary SQL, a WHERE or JOIN/ON clause can't reference <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> rels<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that aren't within its syntactic scope; however, if we pulled up a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LATERAL subquery then we might <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> such references in quals that have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * been pulled up.&nbsp; We need to treat such quals as belonging to the join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * level that includes every rel they reference.&nbsp; Although we could make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../prep/prepjointree.c.html#L817" title="optimizer/prep/prepjointree.c:817">pull_up_subqueries</a>() place such quals correctly to begin with, it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * easier to handle it here.&nbsp; When we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a clause that contains Vars<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * outside its syntactic scope, locate the nearest parent join level that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * includes all the required rels and add the clause to that level's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lateral_clauses list.&nbsp; We'll process it when we reach that join level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(relids, qualscope))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L59" title="optimizer/plan/initsplan.c:59">JoinTreeItem</a> *pitem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(root-&gt;hasLateralRTEs);&nbsp; &nbsp; <span class="Comment">/* shouldn't happen otherwise */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(sjinfo == <span class="Constant">NULL</span>); <span class="Comment">/* mustn't postpone past outer join */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (pitem = jtitem-&gt;jti_parent; pitem; pitem = pitem-&gt;jti_parent)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(relids, pitem-&gt;qualscope))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pitem-&gt;lateral_clauses = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(pitem-&gt;lateral_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; clause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We should not be postponing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> quals past an outer join.&nbsp; If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this Assert fires, <a href="../prep/prepjointree.c.html#L817" title="optimizer/prep/prepjointree.c:817">pull_up_subqueries</a>() messed up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(pitem-&gt;sjinfo == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to postpone qual containing lateral reference&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's an outer-join clause, also check that relids is a <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ojscope.&nbsp; (This should not fail if the syntactic scope check passed.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ojscope &amp;&amp; !<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(relids, ojscope))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;JOIN qualification cannot refer to other relations&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the clause is variable-free, our normal heuristic for pushing it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * down to just the mentioned rels doesn't work, because there are <a href="../util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the clause is an outer-join clause, we must force it to the OJ's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * semantic level to preserve semantics.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, when the clause contains volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, we force it to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be evaluated at its original syntactic level.&nbsp; This preserves the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expected semantics.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When the clause contains no volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> either, it is actually a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pseudoconstant clause that will not change value during <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * execution of the plan, and hence can be used as a one-time qual in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * gating Result plan node.&nbsp; We put such a clause into the regular<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * RestrictInfo lists for the moment, but eventually createplan.c will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a> it out and make a gating Result node immediately above whatever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plan node the pseudoconstant clause is assigned to.&nbsp; It's usually best<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to put a gating node as high in the plan tree as possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bms_is_empty(relids))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ojscope)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* clause is attached to outer join, eval it there */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relids = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(ojscope);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mustn't use as gating qual, so don't mark pseudoconstant */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>(clause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* eval at original syntactic level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relids = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(qualscope);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* again, can't mark pseudoconstant */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are in the top-level join domain, we can <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> the qual to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the top of the plan tree.&nbsp; Otherwise, be conservative and eval<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it at original syntactic level.&nbsp; (Ideally we'd <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> it to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * top of the current join domain in all cases, but that causes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * problems if we later rearrange outer-join evaluation order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pseudoconstant quals below the top level are a pretty odd case,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so it's not clear that it's worth working hard on.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (jtitem-&gt;jdomain == (JoinDomain *) linitial(root-&gt;join_domains))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relids = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(jtitem-&gt;jdomain-&gt;jd_relids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relids = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(qualscope);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mark as gating qual */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pseudoconstant = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tell createplan.c to check for gating quals */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;hasPseudoConstantQuals = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check to see if clause application must be delayed by outer-join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * considerations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> about is_pushed_down: we mark the qual as &quot;pushed down&quot; if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it is (potentially) applicable at a level different from its original<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * syntactic level.&nbsp; This flag is used to distinguish OUTER JOIN ON quals<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from other quals pushed down to the same joinrel.&nbsp; The rules are:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; WHERE quals and INNER JOIN quals: is_pushed_down = true.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; Non-degenerate OUTER JOIN quals: is_pushed_down = false.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; Degenerate OUTER JOIN quals: is_pushed_down = true.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A &quot;degenerate&quot; OUTER JOIN qual is one that doesn't mention the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-nullable side, and hence can be pushed down into the nullable side<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * without changing the join result.&nbsp; It is correct to treat it as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * regular filter condition at the level where it is evaluated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: it is not immediately obvious that a simple boolean is enough<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for this: if for some reason we were to attach a degenerate qual to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its original join level, it would need to be treated as an outer join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * qual there.&nbsp; However, this cannot happen, because all the rels the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clause mentions must be in the outer join's min_righthand, therefore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the join it needs must be formed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the outer join; and we always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attach quals to the lowest level where they can be evaluated.&nbsp; But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we were ever to re-introduce a mechanism for delaying evaluation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of &quot;expensive&quot; quals, this area would need work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: generally, use of is_pushed_down has to go through the macro<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * RINFO_IS_PUSHED_DOWN, because that flag alone is not always sufficient<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to tell whether a clause must be treated as pushed-down in context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This seems like another reason why it should perhaps be rethought.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(relids, outerjoin_nonnullable))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The qual is attached to an outer join and mentions (some of the)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rels on the nonnullable side, so it's not degenerate.&nbsp; If the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caller wants to postpone handling such clauses, just add it to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * postponed_oj_qual_list and return.&nbsp; (The work we've done up to here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will have to be redone later, but there's not much of it.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (postponed_oj_qual_list != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *postponed_oj_qual_list = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(*postponed_oj_qual_list, clause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can't use such a clause to deduce equivalence (the left and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * right sides might be unequal above the join because one of them has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * gone to NULL) ... but we might be able to use it for more limited<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deductions, if it is mergejoinable.&nbsp; So consider adding it to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lists of set-aside outer-join clauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; is_pushed_down = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maybe_equivalence = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maybe_outer_join = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now force the qual to be evaluated exactly at the level of joining<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * corresponding to the outer join.&nbsp; We cannot let it get pushed down<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * into the nonnullable side, since then we'd produce no output rows,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rather than the intended single null-extended row, for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nonnullable-side rows failing the qual.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ojscope);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relids = ojscope;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!pseudoconstant);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Normal qual clause or degenerate outer-join clause.&nbsp; Either way, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can mark it as pushed-down.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; is_pushed_down = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's possible that this is an IS NULL clause that's redundant with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> antijoin; if so we can just discard it.&nbsp; We need not test<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the other cases, because this will only be possible for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pushed-down clauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2584" title="optimizer/plan/initsplan.c:2584">check_redundant_nullability_qual</a>(root, clause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Feed qual to the equivalence machinery, if allowed by caller */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; maybe_equivalence = allow_equivalence;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since it doesn't mention the LHS, it's certainly not useful as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set-aside OJ clause, even if it's in an OJ.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; maybe_outer_join = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build the RestrictInfo node itself.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; restrictinfo = <a href="../util/restrictinfo.c.html#L63" title="optimizer/util/restrictinfo.c:63">make_restrictinfo</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Expr *) clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; is_pushed_down,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; has_clone,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; is_clone,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pseudoconstant,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; security_level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; incompatible_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outerjoin_nonnullable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's a join clause, add <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> used in the clause to targetlists of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * their relations, so that they will be emitted by the plan nodes that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan those relations (else they won't be available at the join node!).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Normally we mark the <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> as needed at the join identified by &quot;relids&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, if this is a clone clause then ignore the outer-join relids in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that set.&nbsp; Otherwise, <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> appearing in a cloned clause would end up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * marked as having to propagate to the highest one of the commuting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * joins, which would often be an overestimate.&nbsp; For such clauses, correct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * var propagation is ensured by making ojscope include input rels from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * both sides of the join.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: if the clause gets absorbed into an EquivalenceClass then this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * may be unnecessary, but for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we have to do it to cover the case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * where the EC becomes ec_broken and we end up reinserting the original<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clauses into the plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L781" title="nodes/bitmapset.c:781">bms_membership</a>(relids) == BMS_MULTIPLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> = <a href="../util/var.c.html#L607" title="optimizer/util/var.c:607">pull_var_clause</a>(clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PVC_RECURSE_AGGREGATES |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PVC_RECURSE_WINDOWFUNCS |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PVC_INCLUDE_PLACEHOLDERS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; where_needed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_clone)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; where_needed = <a href="../../nodes/bitmapset.c.html#L292" title="nodes/bitmapset.c:292">bms_intersect</a>(relids, root-&gt;all_baserels);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; where_needed = relids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L279" title="optimizer/plan/initsplan.c:279">add_vars_to_targetlist</a>(root, <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>, where_needed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We check &quot;mergejoinability&quot; of every clause, not only join clauses,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because we want to know about equivalences between <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> of the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation, or between <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> and consts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3334" title="optimizer/plan/initsplan.c:3334">check_mergejoinable</a>(restrictinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it is a true equivalence clause, <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> it to the EquivalenceClass<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * machinery.&nbsp; We do *not* attach it directly to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> restriction or join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lists.&nbsp; The EC code will propagate it to the appropriate places later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the clause has a mergejoinable operator, yet isn't an equivalence<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because it is an outer-join clause, the EC code may still be able to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * something with it.&nbsp; We add it to appropriate lists for further<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consideration later.&nbsp; Specifically:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it is a left or right outer-join qualification that relates the two<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sides of the outer join (no funny business like leftvar1 = leftvar2 +<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rightvar), we add it to root-&gt;left_join_clauses or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * root-&gt;right_join_clauses according to which side the nonnullable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * variable appears on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it is a full outer-join qualification, we add it to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * root-&gt;full_join_clauses.&nbsp; (Ideally we'd discard cases that aren't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leftvar = rightvar, as we do for left/right joins, but this routine<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't have the info needed to do that; and the current usage of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * full_join_clauses list doesn't require that, so it's not currently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worth complicating this routine's API to make it possible.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="../util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of the above hold, pass it off to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L2836" title="optimizer/plan/initsplan.c:2836">distribute_restrictinfo_to_rels</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In all cases, it's important to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the left_ec and right_ec<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fields of a mergejoinable clause, so that all possibly mergejoinable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expressions have representations in EquivalenceClasses.&nbsp; If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../path/equivclass.c.html#L118" title="optimizer/path/equivclass.c:118">process_equivalence</a> is successful, it will take care of that;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otherwise, we have to call <a href="../path/pathkeys.c.html#L1446" title="optimizer/path/pathkeys.c:1446">initialize_mergeclause_eclasses</a> to do it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (restrictinfo-&gt;mergeopfamilies)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (maybe_equivalence)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../path/equivclass.c.html#L118" title="optimizer/path/equivclass.c:118">process_equivalence</a>(root, &amp;restrictinfo, jtitem-&gt;jdomain))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* EC rejected it, so set left_ec/right_ec the hard way ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (restrictinfo-&gt;mergeopfamilies)&nbsp; &nbsp; <span class="Comment">/* EC might have changed this */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/pathkeys.c.html#L1446" title="optimizer/path/pathkeys.c:1446">initialize_mergeclause_eclasses</a>(root, restrictinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and fall through to <a href="#L2836" title="optimizer/plan/initsplan.c:2836">distribute_restrictinfo_to_rels</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (maybe_outer_join &amp;&amp; restrictinfo-&gt;can_join)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we need to set up left_ec/right_ec the hard way */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/pathkeys.c.html#L1446" title="optimizer/path/pathkeys.c:1446">initialize_mergeclause_eclasses</a>(root, restrictinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> see if it should go to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer-join lists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(sjinfo != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(restrictinfo-&gt;left_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outerjoin_nonnullable) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(restrictinfo-&gt;right_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outerjoin_nonnullable))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we have outervar = innervar */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OuterJoinClauseInfo *ojcinfo = makeNode(OuterJoinClauseInfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ojcinfo-&gt;rinfo = restrictinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ojcinfo-&gt;sjinfo = sjinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;left_join_clauses = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;left_join_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ojcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(restrictinfo-&gt;right_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outerjoin_nonnullable) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(restrictinfo-&gt;left_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outerjoin_nonnullable))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we have innervar = outervar */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OuterJoinClauseInfo *ojcinfo = makeNode(OuterJoinClauseInfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ojcinfo-&gt;rinfo = restrictinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ojcinfo-&gt;sjinfo = sjinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;right_join_clauses = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;right_join_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ojcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sjinfo-&gt;jointype == JOIN_FULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FULL JOIN (above tests cannot match in this case) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OuterJoinClauseInfo *ojcinfo = makeNode(OuterJoinClauseInfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ojcinfo-&gt;rinfo = restrictinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ojcinfo-&gt;sjinfo = sjinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;full_join_clauses = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;full_join_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ojcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nope, so fall through to <a href="#L2836" title="optimizer/plan/initsplan.c:2836">distribute_restrictinfo_to_rels</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we still need to set up left_ec/right_ec */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/pathkeys.c.html#L1446" title="optimizer/path/pathkeys.c:1446">initialize_mergeclause_eclasses</a>(root, restrictinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No EC special case applies, so <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> it into the clause lists */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2836" title="optimizer/plan/initsplan.c:2836">distribute_restrictinfo_to_rels</a>(root, restrictinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2584" title="optimizer/plan/initsplan.c:2584">check_redundant_nullability_qual</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Check to see if the qual is an IS NULL qual that is redundant with<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; a <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> JOIN_ANTI join.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We want to suppress redundant IS NULL quals, not so much to save cycles<br/></li>
<li></span><span class="Comment"> * as to avoid generating bogus selectivity estimates for them.&nbsp; So if<br/></li>
<li></span><span class="Comment"> * redundancy is detected here, <a href="#L2197" title="optimizer/plan/initsplan.c:2197">distribute_qual_to_rels</a>() just throws away<br/></li>
<li></span><span class="Comment"> * the qual.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2584">&#x200c;</a></span><span class="linkable">check_redundant_nullability_qual</span>(PlannerInfo *root, Node *clause)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *forced_null_var;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for IS NULL, and identify the Var forced to NULL */<br/></li>
<li></span>&nbsp; &nbsp; forced_null_var = <a href="../util/clauses.c.html#L1977" title="optimizer/util/clauses.c:1977">find_forced_null_var</a>(clause);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (forced_null_var == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the Var comes from the nullable side of a <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> antijoin, the IS<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NULL condition is necessarily true.&nbsp; If it's not nulled by anything,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there is no point in searching the join_info_list.&nbsp; Otherwise, we need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out whether the nulling rel is an antijoin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (forced_null_var-&gt;varnullingrels == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, root-&gt;join_info_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpecialJoinInfo *sjinfo = (SpecialJoinInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This test will not succeed if sjinfo-&gt;ojrelid is zero, which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible for an antijoin that was converted from a semijoin; but in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * such a case the Var couldn't have come from its nullable side.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sjinfo-&gt;jointype == JOIN_ANTI &amp;&amp; sjinfo-&gt;ojrelid != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(sjinfo-&gt;ojrelid, forced_null_var-&gt;varnullingrels))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2629" title="optimizer/plan/initsplan.c:2629">add_base_clause_to_rel</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Add 'restrictinfo' as a baserestrictinfo to the base relation denoted<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; by 'relid'.&nbsp; We offer some simple prechecks to try to determine if the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; qual is always true, in which case we ignore it rather than add it.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If we detect the qual is always false, we replace it with<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; constant-FALSE.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2629">&#x200c;</a></span><span class="linkable">add_base_clause_to_rel</span>(PlannerInfo *root, Index relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RestrictInfo *restrictinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *rel = <a href="../util/relnode.c.html#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(root, relid);<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte = root-&gt;simple_rte_array[relid];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../nodes/bitmapset.c.html#L781" title="nodes/bitmapset.c:781">bms_membership</a>(restrictinfo-&gt;required_relids) == BMS_SINGLETON);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For inheritance parent tables, we must always record the RestrictInfo<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in baserestrictinfo as is.&nbsp; If we were to transform or <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> adding it,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then the original wouldn't be available in <a href="../util/inherit.c.html#L834" title="optimizer/util/inherit.c:834">apply_child_basequals</a>. Since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there are two RangeTblEntries for inheritance parents, one with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inh==true and the other with inh==false, we're still able to apply this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * optimization to the inh==false one.&nbsp; The inh==true one is what<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../util/inherit.c.html#L834" title="optimizer/util/inherit.c:834">apply_child_basequals</a>() sees, whereas the inh==false one is what's used<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the scan node in the final plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We make an exception to this for partitioned tables.&nbsp; For these, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * always apply the constant-TRUE and constant-FALSE transformations.&nbsp; A<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * qual which is either of these for a partitioned table must also be that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for all of its child partitions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!rte-&gt;inh || rte-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't add the clause if it is always true */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2732" title="optimizer/plan/initsplan.c:2732">restriction_is_always_true</a>(root, restrictinfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Substitute the origin qual with constant-FALSE if it is provably<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * always false.&nbsp; Note that we keep the same rinfo_serial.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2781" title="optimizer/plan/initsplan.c:2781">restriction_is_always_false</a>(root, restrictinfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_rinfo_serial = restrictinfo-&gt;rinfo_serial;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restrictinfo = <a href="../util/restrictinfo.c.html#L63" title="optimizer/util/restrictinfo.c:63">make_restrictinfo</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Expr *) <a href="../../nodes/makefuncs.c.html#L359" title="nodes/makefuncs.c:359">makeBoolConst</a>(<span class="Constant">false</span>, <span class="Constant">false</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; restrictinfo-&gt;is_pushed_down,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; restrictinfo-&gt;has_clone,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; restrictinfo-&gt;is_clone,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; restrictinfo-&gt;pseudoconstant,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>, <span class="Comment">/* security_level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; restrictinfo-&gt;required_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; restrictinfo-&gt;incompatible_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; restrictinfo-&gt;outer_relids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restrictinfo-&gt;rinfo_serial = save_rinfo_serial;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add clause to rel's restriction list */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;baserestrictinfo = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rel-&gt;baserestrictinfo, restrictinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update security level info */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;baserestrict_min_security = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(rel-&gt;baserestrict_min_security,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; restrictinfo-&gt;security_level);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2696" title="optimizer/plan/initsplan.c:2696">expr_is_nonnullable</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Check to see if the Expr cannot be NULL<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the Expr is a simple Var that is defined NOT NULL and meanwhile is not<br/></li>
<li></span><span class="Comment"> * nulled by <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer joins, then we can know that it cannot be NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2696">&#x200c;</a></span><span class="linkable">expr_is_nonnullable</span>(PlannerInfo *root, Expr *expr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *rel;<br/></li>
<li>&nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> only check simple Vars */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IsA(expr, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; var = (Var *) expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* could the Var be nulled by <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer joins? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!bms_is_empty(var-&gt;varnullingrels))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* system columns cannot be NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varattno &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* is the column defined NOT NULL? */<br/></li>
<li></span>&nbsp; &nbsp; rel = <a href="../util/relnode.c.html#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(root, var-&gt;varno);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varattno &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(var-&gt;varattno, rel-&gt;notnullattnums))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2732" title="optimizer/plan/initsplan.c:2732">restriction_is_always_true</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Check to see if the RestrictInfo is always true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently we only check for NullTest quals and OR clauses that include<br/></li>
<li></span><span class="Comment"> * NullTest quals.&nbsp; We may extend it in the future.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2732">&#x200c;</a></span><span class="linkable">restriction_is_always_true</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RestrictInfo *restrictinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for NullTest qual */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(restrictinfo-&gt;clause, NullTest))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; NullTest&nbsp;&nbsp; *nulltest = (NullTest *) restrictinfo-&gt;clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* is this NullTest an IS_NOT_NULL qual? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nulltest-&gt;nulltesttype != IS_NOT_NULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2696" title="optimizer/plan/initsplan.c:2696">expr_is_nonnullable</a>(root, nulltest-&gt;arg);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If it's an OR, check its sub-clauses */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/restrictinfo.c.html#L416" title="optimizer/util/restrictinfo.c:416">restriction_is_or_clause</a>(restrictinfo))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(is_orclause(restrictinfo-&gt;orclause));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the given OR branches is provably always true then the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entire condition is true.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, ((BoolExpr *) restrictinfo-&gt;orclause)-&gt;args)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *orarg = (Node *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsA(orarg, RestrictInfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2732" title="optimizer/plan/initsplan.c:2732">restriction_is_always_true</a>(root, (RestrictInfo *) orarg))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2781" title="optimizer/plan/initsplan.c:2781">restriction_is_always_false</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Check to see if the RestrictInfo is always false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently we only check for NullTest quals and OR clauses that include<br/></li>
<li></span><span class="Comment"> * NullTest quals.&nbsp; We may extend it in the future.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2781">&#x200c;</a></span><span class="linkable">restriction_is_always_false</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *restrictinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for NullTest qual */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(restrictinfo-&gt;clause, NullTest))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; NullTest&nbsp;&nbsp; *nulltest = (NullTest *) restrictinfo-&gt;clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* is this NullTest an IS_NULL qual? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nulltest-&gt;nulltesttype != IS_NULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2696" title="optimizer/plan/initsplan.c:2696">expr_is_nonnullable</a>(root, nulltest-&gt;arg);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If it's an OR, check its sub-clauses */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/restrictinfo.c.html#L416" title="optimizer/util/restrictinfo.c:416">restriction_is_or_clause</a>(restrictinfo))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(is_orclause(restrictinfo-&gt;orclause));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Currently, when processing OR expressions, we only return true when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all of the OR branches are always false.&nbsp; This could perhaps be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expanded to remove OR branches that are provably false.&nbsp; This may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be a useful thing to do as it could result in the OR being left<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with a single arg.&nbsp; That's useful as it would allow the OR<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * condition to be replaced with its single argument which may allow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * use of an index for faster filtering on the remaining condition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, ((BoolExpr *) restrictinfo-&gt;orclause)-&gt;args)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *orarg = (Node *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsA(orarg, RestrictInfo) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L2781" title="optimizer/plan/initsplan.c:2781">restriction_is_always_false</a>(root, (RestrictInfo *) orarg))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2836" title="optimizer/plan/initsplan.c:2836">distribute_restrictinfo_to_rels</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Push a completed RestrictInfo into the proper restriction or join<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; clause list(s).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is the last step of <a href="#L2197" title="optimizer/plan/initsplan.c:2197">distribute_qual_to_rels</a>() for ordinary qual<br/></li>
<li></span><span class="Comment"> * clauses.&nbsp; Clauses that are interesting for equivalence-class processing<br/></li>
<li></span><span class="Comment"> * are diverted to the EC machinery, but may ultimately get fed back here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2836">&#x200c;</a></span><span class="linkable">distribute_restrictinfo_to_rels</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *restrictinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; relids = restrictinfo-&gt;required_relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!bms_is_empty(relids))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L715" title="nodes/bitmapset.c:715">bms_get_singleton_member</a>(relids, &amp;relid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There is only one relation participating in the clause, so it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is a restriction clause for that relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2629" title="optimizer/plan/initsplan.c:2629">add_base_clause_to_rel</a>(root, relid, restrictinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The clause is a join clause, since there is more than one rel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in its relid set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for hashjoinable operators.&nbsp; (We don't bother setting the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hashjoin info except in true join clauses.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3371" title="optimizer/plan/initsplan.c:3371">check_hashjoinable</a>(restrictinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Likewise, check if the clause is suitable to be used with a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Memoize node to cache inner tuples during a parameterized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nested loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3399" title="optimizer/plan/initsplan.c:3399">check_memoizable</a>(restrictinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add clause to the join lists of all the relevant relations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/joininfo.c.html#L98" title="optimizer/util/joininfo.c:98">add_join_clause_to_rels</a>(root, restrictinfo, relids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clause references no rels, and therefore we have no place to attach<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it.&nbsp; Shouldn't get here if callers are working properly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot cope with variable-free clause&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2921" title="optimizer/plan/initsplan.c:2921">process_implied_equality</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create a restrictinfo item that says &quot;item1 op item2&quot;, and <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> it<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; into the appropriate lists.&nbsp; (In practice opno is always a btree<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; equality operator.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;qualscope&quot; is the nominal syntactic level to impute to the restrictinfo.<br/></li>
<li></span><span class="Comment"> * This must contain at least all the rels used in the expressions, but it<br/></li>
<li></span><span class="Comment"> * is used only to set the qual application level when both exprs are<br/></li>
<li></span><span class="Comment"> * variable-free.&nbsp; (Hence, it should usually match the join domain in which<br/></li>
<li></span><span class="Comment"> * the clause applies.)&nbsp; Otherwise the qual is applied at the lowest join<br/></li>
<li></span><span class="Comment"> * level that provides all its variables.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;security_level&quot; is the security level to assign to the new restrictinfo.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;both_const&quot; indicates whether both items are known pseudo-constant;<br/></li>
<li></span><span class="Comment"> * in this case it is worth applying <a href="../util/clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a>() in case we<br/></li>
<li></span><span class="Comment"> * can produce constant TRUE or constant FALSE.&nbsp; (Otherwise it's not,<br/></li>
<li></span><span class="Comment"> * because the expressions went through <a href="../util/clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a> already.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the generated RestrictInfo, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.&nbsp; The result will be NULL<br/></li>
<li></span><span class="Comment"> * if both_const is true and we successfully reduced the clause to<br/></li>
<li></span><span class="Comment"> * constant TRUE.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this function will copy item1 and item2, but it is caller's<br/></li>
<li></span><span class="Comment"> * responsibility to make sure that the Relids parameters are fresh copies<br/></li>
<li></span><span class="Comment"> * not shared with other uses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we do not do <a href="../path/pathkeys.c.html#L1446" title="optimizer/path/pathkeys.c:1446">initialize_mergeclause_eclasses</a>() here.&nbsp; It is<br/></li>
<li></span><span class="Comment"> * caller's responsibility that left_ec/right_ec be set as necessary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RestrictInfo *<br/></li>
<li><a id="L2921">&#x200c;</a><span class="linkable">process_implied_equality</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid opno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Expr *item1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Expr *item2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids qualscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index security_level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> both_const)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RestrictInfo *restrictinfo;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *clause;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; relids;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; pseudoconstant = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build the new clause.&nbsp; Copy to ensure it shares no substructure with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * original (this is necessary in case there are subselects in there...)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; clause = (Node *) <a href="../../nodes/makefuncs.c.html#L628" title="nodes/makefuncs.c:628">make_opclause</a>(opno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BOOLOID,&nbsp; &nbsp; <span class="Comment">/* opresulttype */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,&nbsp; &nbsp; <span class="Comment">/* opretset */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; copyObject(item1),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; copyObject(item2),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If both constant, try to reduce to a boolean constant. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (both_const)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; clause = <a href="../util/clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a>(root, clause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we produced const TRUE, just drop the clause */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (clause &amp;&amp; IsA(clause, Const))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Const&nbsp; &nbsp; &nbsp;&nbsp; *cclause = (Const *) clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(cclause-&gt;consttype == BOOLOID);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!cclause-&gt;constisnull &amp;&amp; DatumGetBool(cclause-&gt;constvalue))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The rest of this is a very cut-down version of <a href="#L2197" title="optimizer/plan/initsplan.c:2197">distribute_qual_to_rels</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> most of the work therein, but there are a couple of special<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases we still have to handle.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Retrieve all relids mentioned within the possibly-simplified clause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relids = <a href="../util/var.c.html#L108" title="optimizer/util/var.c:108">pull_varnos</a>(root, clause);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(relids, qualscope));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the clause is variable-free, our normal heuristic for pushing it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * down to just the mentioned rels doesn't work, because there are <a href="../util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Apply it as a gating qual at the appropriate level (see comments for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L3129" title="optimizer/plan/initsplan.c:3129">get_join_domain_min_rels</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bms_is_empty(relids))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* eval at join domain's safe level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relids = <a href="#L3129" title="optimizer/plan/initsplan.c:3129">get_join_domain_min_rels</a>(root, qualscope);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mark as gating qual */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pseudoconstant = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tell createplan.c to check for gating quals */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;hasPseudoConstantQuals = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build the RestrictInfo node itself.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; restrictinfo = <a href="../util/restrictinfo.c.html#L63" title="optimizer/util/restrictinfo.c:63">make_restrictinfo</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Expr *) clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,&nbsp; &nbsp; <span class="Comment">/* is_pushed_down */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Comment">/* !has_clone */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Comment">/* !is_clone */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pseudoconstant,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; security_level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,&nbsp; &nbsp; <span class="Comment">/* incompatible_relids */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>); <span class="Comment">/* outer_relids */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's a join clause, add <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> used in the clause to targetlists of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * their relations, so that they will be emitted by the plan nodes that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan those relations (else they won't be available at the join node!).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Typically, we'd have already done this when the component expressions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * were first seen by <a href="#L2197" title="optimizer/plan/initsplan.c:2197">distribute_qual_to_rels</a>; but it is possible that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some of the Vars could have missed having that done because they only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * appeared in single-relation clauses originally.&nbsp; So do it here for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * safety.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L781" title="nodes/bitmapset.c:781">bms_membership</a>(relids) == BMS_MULTIPLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> = <a href="../util/var.c.html#L607" title="optimizer/util/var.c:607">pull_var_clause</a>(clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PVC_RECURSE_AGGREGATES |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PVC_RECURSE_WINDOWFUNCS |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PVC_INCLUDE_PLACEHOLDERS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L279" title="optimizer/plan/initsplan.c:279">add_vars_to_targetlist</a>(root, <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>, relids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check mergejoinability.&nbsp; This will usually succeed, since the op came<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from an EquivalenceClass; but we could have reduced the original clause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to a constant.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3334" title="optimizer/plan/initsplan.c:3334">check_mergejoinable</a>(restrictinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note we don't do <a href="../path/pathkeys.c.html#L1446" title="optimizer/path/pathkeys.c:1446">initialize_mergeclause_eclasses</a>(); the caller can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handle that much more cheaply than we can.&nbsp; It's okay to call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L2836" title="optimizer/plan/initsplan.c:2836">distribute_restrictinfo_to_rels</a>() <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> that happens.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Push the new clause into all the appropriate restrictinfo lists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2836" title="optimizer/plan/initsplan.c:2836">distribute_restrictinfo_to_rels</a>(root, restrictinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> restrictinfo;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3060" title="optimizer/plan/initsplan.c:3060">build_implied_join_equality</a> --- build a RestrictInfo for a derived equality<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This overlaps the functionality of <a href="#L2921" title="optimizer/plan/initsplan.c:2921">process_implied_equality</a>(), but we<br/></li>
<li></span><span class="Comment"> * must not <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> the RestrictInfo into the joininfo tree.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this function will copy item1 and item2, but it is caller's<br/></li>
<li></span><span class="Comment"> * responsibility to make sure that the Relids parameters are fresh copies<br/></li>
<li></span><span class="Comment"> * not shared with other uses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we do not do <a href="../path/pathkeys.c.html#L1446" title="optimizer/path/pathkeys.c:1446">initialize_mergeclause_eclasses</a>() here.&nbsp; It is<br/></li>
<li></span><span class="Comment"> * caller's responsibility that left_ec/right_ec be set as necessary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RestrictInfo *<br/></li>
<li><a id="L3060">&#x200c;</a><span class="linkable">build_implied_join_equality</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid opno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Expr *item1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Expr *item2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids qualscope,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index security_level)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RestrictInfo *restrictinfo;<br/></li>
<li>&nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build the new clause.&nbsp; Copy to ensure it shares no substructure with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * original (this is necessary in case there are subselects in there...)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; clause = <a href="../../nodes/makefuncs.c.html#L628" title="nodes/makefuncs.c:628">make_opclause</a>(opno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BOOLOID, <span class="Comment">/* opresulttype */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,&nbsp; &nbsp; <span class="Comment">/* opretset */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copyObject(item1),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copyObject(item2),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build the RestrictInfo node itself.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; restrictinfo = <a href="../util/restrictinfo.c.html#L63" title="optimizer/util/restrictinfo.c:63">make_restrictinfo</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,&nbsp; &nbsp; <span class="Comment">/* is_pushed_down */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Comment">/* !has_clone */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Comment">/* !is_clone */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Comment">/* pseudoconstant */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; security_level,&nbsp; &nbsp; <span class="Comment">/* security_level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; qualscope, <span class="Comment">/* required_relids */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,&nbsp; &nbsp; <span class="Comment">/* incompatible_relids */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>); <span class="Comment">/* outer_relids */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set mergejoinability/hashjoinability flags */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3334" title="optimizer/plan/initsplan.c:3334">check_mergejoinable</a>(restrictinfo);<br/></li>
<li>&nbsp; &nbsp; <a href="#L3371" title="optimizer/plan/initsplan.c:3371">check_hashjoinable</a>(restrictinfo);<br/></li>
<li>&nbsp; &nbsp; <a href="#L3399" title="optimizer/plan/initsplan.c:3399">check_memoizable</a>(restrictinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> restrictinfo;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3129" title="optimizer/plan/initsplan.c:3129">get_join_domain_min_rels</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Identify the appropriate join level for derived quals belonging<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; to the join domain with the given relids.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When we derive a pseudoconstant (Var-free) clause from an EquivalenceClass,<br/></li>
<li></span><span class="Comment"> * we'd ideally apply the clause at the top level of the EC's join domain.<br/></li>
<li></span><span class="Comment"> * However, if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer joins inside that domain that get commuted<br/></li>
<li></span><span class="Comment"> * with joins outside it, that leads to not finding a correct place to apply<br/></li>
<li></span><span class="Comment"> * the clause.&nbsp; Instead, remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> outer joins from the relid set,<br/></li>
<li></span><span class="Comment"> * and apply the clause to just the remaining rels.&nbsp; This still results in a<br/></li>
<li></span><span class="Comment"> * correct answer, since if the clause produces FALSE then the LHS of these<br/></li>
<li></span><span class="Comment"> * joins will be empty leading to an empty join result.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * However, there's no need to remove outer joins if this is the top-level<br/></li>
<li></span><span class="Comment"> * join domain of the query, since then there's nothing else to commute with.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: it's tempting to use this in <a href="#L2197" title="optimizer/plan/initsplan.c:2197">distribute_qual_to_rels</a> where it's<br/></li>
<li></span><span class="Comment"> * dealing with pseudoconstant quals; but we can't because the necessary<br/></li>
<li></span><span class="Comment"> * SpecialJoinInfos aren't all formed at that point.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is always freshly <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d; we do not modify domain_relids.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Relids<br/></li>
<li><a id="L3129">&#x200c;</a><span class="linkable">get_join_domain_min_rels</span>(PlannerInfo *root, Relids domain_relids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(domain_relids);<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Top-level join domain? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(result, root-&gt;all_query_rels))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nope, look for <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> outer joins that could potentially commute out */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, root-&gt;join_info_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpecialJoinInfo *sjinfo = (SpecialJoinInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sjinfo-&gt;jointype == JOIN_LEFT &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(sjinfo-&gt;ojrelid, result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(result, sjinfo-&gt;ojrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/bitmapset.c.html#L1161" title="nodes/bitmapset.c:1161">bms_del_members</a>(result, sjinfo-&gt;syn_righthand);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3169" title="optimizer/plan/initsplan.c:3169">match_foreign_keys_to_quals</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Match foreign-key constraints to equivalence classes and join quals<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The idea here is to see which query join conditions match equality<br/></li>
<li></span><span class="Comment"> * constraints of a foreign-key relationship.&nbsp; For such join conditions,<br/></li>
<li></span><span class="Comment"> * we can use the FK semantics to make selectivity estimates that are more<br/></li>
<li></span><span class="Comment"> * reliable than estimating from statistics, especially for multiple-column<br/></li>
<li></span><span class="Comment"> * FKs, where the normal assumption of independent conditions tends to fail.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In this function we annotate the ForeignKeyOptInfos in root-&gt;fkey_list<br/></li>
<li></span><span class="Comment"> * with info about which eclasses and join qual clauses they match, and<br/></li>
<li></span><span class="Comment"> * discard <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> ForeignKeyOptInfos that are irrelevant for the query.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3169">&#x200c;</a></span><span class="linkable">match_foreign_keys_to_quals</span>(PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newlist = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, root-&gt;fkey_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ForeignKeyOptInfo *fkinfo = (ForeignKeyOptInfo *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *con_rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *ref_rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Either relid might identify a rel that is in the query's rtable but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * isn't referenced by the jointree, or has been removed by join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * removal, so that it won't have a RelOptInfo.&nbsp; Hence don't use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../util/relnode.c.html#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>() here.&nbsp; We can ignore such FKs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fkinfo-&gt;con_relid &gt;= root-&gt;simple_rel_array_size ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkinfo-&gt;ref_relid &gt;= root-&gt;simple_rel_array_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just paranoia */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; con_rel = root-&gt;simple_rel_array[fkinfo-&gt;con_relid];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (con_rel == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ref_rel = root-&gt;simple_rel_array[fkinfo-&gt;ref_relid];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ref_rel == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore FK unless both rels are baserels.&nbsp; This gets rid of FKs that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * link to inheritance child rels (otherrels).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (con_rel-&gt;reloptkind != RELOPT_BASEREL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ref_rel-&gt;reloptkind != RELOPT_BASEREL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Scan the columns and try to match them to eclasses and quals.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: for simple inner joins, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> match should be in an <a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;Loose&quot; quals that syntactically match an FK equality must have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * been rejected for EC status because they are outer-join quals or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * similar.&nbsp; We can still consider them to match the FK.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (colno = <span class="Constant">0</span>; colno &lt; fkinfo-&gt;nkeys; colno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EquivalenceClass *ec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; con_attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ref_attno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fpeqop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ec = <a href="../path/equivclass.c.html#L2516" title="optimizer/path/equivclass.c:2516">match_eclasses_to_foreign_key_col</a>(root, fkinfo, colno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't bother looking for loose quals if we got an EC match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ec != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkinfo-&gt;nmatched_ec++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ec-&gt;ec_has_const)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkinfo-&gt;nconst_ec++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Scan joininfo list for relevant clauses.&nbsp; Either rel's joininfo<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list would do equally well; we use con_rel's.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; con_attno = fkinfo-&gt;conkey[colno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ref_attno = fkinfo-&gt;confkey[colno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fpeqop = InvalidOid;&nbsp; &nbsp; <span class="Comment">/* we'll look this up only if needed */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, con_rel-&gt;joininfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OpExpr&nbsp; &nbsp; &nbsp;&nbsp; *clause = (OpExpr *) rinfo-&gt;clause;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *leftvar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *rightvar;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Only binary OpExprs are useful for consideration */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsA(clause, OpExpr) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(clause-&gt;args) != <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftvar = (Var *) get_leftop((Expr *) clause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightvar = (Var *) get_rightop((Expr *) clause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Operands must be Vars, possibly with RelabelType */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (leftvar &amp;&amp; IsA(leftvar, RelabelType))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftvar = (Var *) ((RelabelType *) leftvar)-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(leftvar &amp;&amp; IsA(leftvar, Var)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (rightvar &amp;&amp; IsA(rightvar, RelabelType))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightvar = (Var *) ((RelabelType *) rightvar)-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(rightvar &amp;&amp; IsA(rightvar, Var)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now try to match the <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> to the current foreign key cols */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fkinfo-&gt;ref_relid == leftvar-&gt;varno &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ref_attno == leftvar-&gt;varattno &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkinfo-&gt;con_relid == rightvar-&gt;varno &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; con_attno == rightvar-&gt;varattno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Vars match, but is it the right operator? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (clause-&gt;opno == fkinfo-&gt;conpfeqop[colno])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkinfo-&gt;rinfos[colno] = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(fkinfo-&gt;rinfos[colno],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkinfo-&gt;nmatched_ri++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (fkinfo-&gt;ref_relid == rightvar-&gt;varno &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ref_attno == rightvar-&gt;varattno &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fkinfo-&gt;con_relid == leftvar-&gt;varno &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; con_attno == leftvar-&gt;varattno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reverse match, must check commutator operator.&nbsp; Look it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * up if we didn't already.&nbsp; (In the worst case we might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do multiple lookups here, but that would require an FK<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * equality operator without commutator, which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unlikely.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(fpeqop))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fpeqop = <a href="../../utils/cache/lsyscache.c.html#L1509" title="utils/cache/lsyscache.c:1509">get_commutator</a>(fkinfo-&gt;conpfeqop[colno]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (clause-&gt;opno == fpeqop)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkinfo-&gt;rinfos[colno] = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(fkinfo-&gt;rinfos[colno],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkinfo-&gt;nmatched_ri++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we found <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> matching loose quals, count col as matched */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fkinfo-&gt;rinfos[colno])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkinfo-&gt;nmatched_rcols++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Currently, we drop multicolumn FKs that aren't fully matched to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * query.&nbsp; Later we might figure out how to derive some sort of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * estimate from them, in which case this test should be weakened to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;if ((fkinfo-&gt;nmatched_ec + fkinfo-&gt;nmatched_rcols) &gt; 0)&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((fkinfo-&gt;nmatched_ec + fkinfo-&gt;nmatched_rcols) == fkinfo-&gt;nkeys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newlist, fkinfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Replace fkey_list, thereby discarding <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> useless entries */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;fkey_list = newlist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; CHECKS FOR MERGEJOINABLE AND HASHJOINABLE CLAUSES<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3334" title="optimizer/plan/initsplan.c:3334">check_mergejoinable</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; If the restrictinfo's clause is mergejoinable, set the mergejoin<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; info fields in the restrictinfo.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Currently, we support mergejoin for binary opclauses where<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the operator is a mergejoinable operator.&nbsp; The arguments can be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; anything --- as long as there are no volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in them.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3334">&#x200c;</a></span><span class="linkable">check_mergejoinable</span>(RestrictInfo *restrictinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *clause = restrictinfo-&gt;clause;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opno;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *leftarg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (restrictinfo-&gt;pseudoconstant)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!is_opclause(clause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(((OpExpr *) clause)-&gt;args) != <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opno = ((OpExpr *) clause)-&gt;opno;<br/></li>
<li>&nbsp; &nbsp; leftarg = linitial(((OpExpr *) clause)-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/cache/lsyscache.c.html#L1386" title="utils/cache/lsyscache.c:1386">op_mergejoinable</a>(opno, <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(leftarg)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>((Node *) restrictinfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; restrictinfo-&gt;mergeopfamilies = <a href="../../utils/cache/lsyscache.c.html#L366" title="utils/cache/lsyscache.c:366">get_mergejoin_opfamilies</a>(opno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: <a href="../../utils/cache/lsyscache.c.html#L1386" title="utils/cache/lsyscache.c:1386">op_mergejoinable</a> is just a hint; if we fail to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the operator<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> btree opfamilies, mergeopfamilies remains NIL and so the clause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is not treated as mergejoinable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3371" title="optimizer/plan/initsplan.c:3371">check_hashjoinable</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; If the restrictinfo's clause is hashjoinable, set the hashjoin<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; info fields in the restrictinfo.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Currently, we support hashjoin for binary opclauses where<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the operator is a hashjoinable operator.&nbsp; The arguments can be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; anything --- as long as there are no volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in them.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3371">&#x200c;</a></span><span class="linkable">check_hashjoinable</span>(RestrictInfo *restrictinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *clause = restrictinfo-&gt;clause;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opno;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *leftarg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (restrictinfo-&gt;pseudoconstant)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!is_opclause(clause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(((OpExpr *) clause)-&gt;args) != <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opno = ((OpExpr *) clause)-&gt;opno;<br/></li>
<li>&nbsp; &nbsp; leftarg = linitial(((OpExpr *) clause)-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/cache/lsyscache.c.html#L1437" title="utils/cache/lsyscache.c:1437">op_hashjoinable</a>(opno, <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(leftarg)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>((Node *) restrictinfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; restrictinfo-&gt;hashjoinoperator = opno;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3399" title="optimizer/plan/initsplan.c:3399">check_memoizable</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; If the restrictinfo's clause is suitable to be used for a Memoize node,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; set the left_hasheqoperator and right_hasheqoperator to the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> equality<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; operator that will be needed during caching.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3399">&#x200c;</a></span><span class="linkable">check_memoizable</span>(RestrictInfo *restrictinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li>&nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *clause = restrictinfo-&gt;clause;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lefttype;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; righttype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (restrictinfo-&gt;pseudoconstant)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!is_opclause(clause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(((OpExpr *) clause)-&gt;args) != <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lefttype = <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(linitial(((OpExpr *) clause)-&gt;args));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typentry = <a href="../../utils/cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(lefttype, TYPECACHE_HASH_PROC |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_EQ_OPR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(typentry-&gt;hash_proc) &amp;&amp; OidIsValid(typentry-&gt;eq_opr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; restrictinfo-&gt;left_hasheqoperator = typentry-&gt;eq_opr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; righttype = <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(lsecond(((OpExpr *) clause)-&gt;args));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lookup the right type, unless it's the same as the left type, in which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case typentry is already pointing to the required TypeCacheEntry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lefttype != righttype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry = <a href="../../utils/cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(righttype, TYPECACHE_HASH_PROC |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_EQ_OPR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(typentry-&gt;hash_proc) &amp;&amp; OidIsValid(typentry-&gt;eq_opr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; restrictinfo-&gt;right_hasheqoperator = typentry-&gt;eq_opr;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
