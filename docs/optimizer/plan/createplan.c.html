<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>optimizer/plan/createplan.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>optimizer/plan/createplan.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L5478">bitmap_subplan_mark_shared</a></li>
<li><a href="#L825">build_path_tlist</a></li>
<li><a href="#L2152">change_plan_targetlist</a></li>
<li><a href="#L5409">copy_generic_path_info</a></li>
<li><a href="#L5424">copy_plan_costsize</a></li>
<li><a href="#L2308">create_agg_plan</a></li>
<li><a href="#L1216">create_append_plan</a></li>
<li><a href="#L3201">create_bitmap_scan_plan</a></li>
<li><a href="#L3331">create_bitmap_subplan</a></li>
<li><a href="#L3890">create_ctescan_plan</a></li>
<li><a href="#L4276">create_customscan_plan</a></li>
<li><a href="#L4121">create_foreignscan_plan</a></li>
<li><a href="#L3760">create_functionscan_plan</a></li>
<li><a href="#L1957">create_gather_merge_plan</a></li>
<li><a href="#L1919">create_gather_plan</a></li>
<li><a href="#L1022">create_gating_plan</a></li>
<li><a href="#L2241">create_group_plan</a></li>
<li><a href="#L1587">create_group_result_plan</a></li>
<li><a href="#L2392">create_groupingsets_plan</a></li>
<li><a href="#L4746">create_hashjoin_plan</a></li>
<li><a href="#L2214">create_incrementalsort_plan</a></li>
<li><a href="#L3005">create_indexscan_plan</a></li>
<li><a href="#L1081">create_join_plan</a></li>
<li><a href="#L2855">create_limit_plan</a></li>
<li><a href="#L2791">create_lockrows_plan</a></li>
<li><a href="#L1638">create_material_plan</a></li>
<li><a href="#L1666">create_memoize_plan</a></li>
<li><a href="#L1437">create_merge_append_plan</a></li>
<li><a href="#L4439">create_mergejoin_plan</a></li>
<li><a href="#L2550">create_minmaxagg_plan</a></li>
<li><a href="#L2814">create_modifytable_plan</a></li>
<li><a href="#L3985">create_namedtuplestorescan_plan</a></li>
<li><a href="#L4347">create_nestloop_plan</a></li>
<li><a href="#L337">create_plan</a></li>
<li><a href="#L388">create_plan_recurse</a></li>
<li><a href="#L1612">create_project_set_plan</a></li>
<li><a href="#L2018">create_projection_plan</a></li>
<li><a href="#L2755">create_recursiveunion_plan</a></li>
<li><a href="#L4024">create_resultscan_plan</a></li>
<li><a href="#L2954">create_samplescan_plan</a></li>
<li><a href="#L559">create_scan_plan</a></li>
<li><a href="#L2916">create_seqscan_plan</a></li>
<li><a href="#L2719">create_setop_plan</a></li>
<li><a href="#L2180">create_sort_plan</a></li>
<li><a href="#L3701">create_subqueryscan_plan</a></li>
<li><a href="#L3803">create_tablefuncscan_plan</a></li>
<li><a href="#L3636">create_tidrangescan_plan</a></li>
<li><a href="#L3539">create_tidscan_plan</a></li>
<li><a href="#L1720">create_unique_plan</a></li>
<li><a href="#L2280">create_upper_unique_plan</a></li>
<li><a href="#L3846">create_valuesscan_plan</a></li>
<li><a href="#L2616">create_windowagg_plan</a></li>
<li><a href="#L4061">create_worktablescan_plan</a></li>
<li><a href="#L5063">fix_indexorderby_references</a></li>
<li><a href="#L5092">fix_indexqual_clause</a></li>
<li><a href="#L5163">fix_indexqual_operand</a></li>
<li><a href="#L5022">fix_indexqual_references</a></li>
<li><a href="#L1002">get_gating_quals</a></li>
<li><a href="#L5238">get_switched_clauses</a></li>
<li><a href="#L2120">inject_projection_plan</a></li>
<li><a href="#L7207">is_projection_capable_path</a></li>
<li><a href="#L7257">is_projection_capable_plan</a></li>
<li><a href="#L5446">label_sort_with_costsize</a></li>
<li><a href="#L6593">make_agg</a></li>
<li><a href="#L5918">make_bitmap_and</a></li>
<li><a href="#L5625">make_bitmap_heapscan</a></li>
<li><a href="#L5604">make_bitmap_indexscan</a></li>
<li><a href="#L5933">make_bitmap_or</a></li>
<li><a href="#L5762">make_ctescan</a></li>
<li><a href="#L5822">make_foreignscan</a></li>
<li><a href="#L5703">make_functionscan</a></li>
<li><a href="#L6854">make_gather</a></li>
<li><a href="#L6669">make_group</a></li>
<li><a href="#L6004">make_hash</a></li>
<li><a href="#L5973">make_hashjoin</a></li>
<li><a href="#L6098">make_incrementalsort</a></li>
<li><a href="#L6381">make_incrementalsort_from_pathkeys</a></li>
<li><a href="#L5575">make_indexonlyscan</a></li>
<li><a href="#L5544">make_indexscan</a></li>
<li><a href="#L6960">make_limit</a></li>
<li><a href="#L6939">make_lockrows</a></li>
<li><a href="#L6505">make_material</a></li>
<li><a href="#L6568">make_memoize</a></li>
<li><a href="#L6027">make_mergejoin</a></li>
<li><a href="#L7028">make_modifytable</a></li>
<li><a href="#L5783">make_namedtuplestorescan</a></li>
<li><a href="#L5948">make_nestloop</a></li>
<li><a href="#L7009">make_project_set</a></li>
<li><a href="#L5862">make_recursive_union</a></li>
<li><a href="#L6988">make_result</a></li>
<li><a href="#L5525">make_samplescan</a></li>
<li><a href="#L5508">make_seqscan</a></li>
<li><a href="#L6883">make_setop</a></li>
<li><a href="#L6068">make_sort</a></li>
<li><a href="#L6464">make_sort_from_groupcols</a></li>
<li><a href="#L6346">make_sort_from_pathkeys</a></li>
<li><a href="#L6415">make_sort_from_sortclauses</a></li>
<li><a href="#L5683">make_subqueryscan</a></li>
<li><a href="#L5724">make_tablefuncscan</a></li>
<li><a href="#L5664">make_tidrangescan</a></li>
<li><a href="#L5645">make_tidscan</a></li>
<li><a href="#L6748">make_unique_from_pathkeys</a></li>
<li><a href="#L6699">make_unique_from_sortclauses</a></li>
<li><a href="#L5743">make_valuesscan</a></li>
<li><a href="#L6627">make_windowagg</a></li>
<li><a href="#L5803">make_worktablescan</a></li>
<li><a href="#L1140">mark_async_capable_plan</a></li>
<li><a href="#L6527">materialize_finished_plan</a></li>
<li><a href="#L5315">order_qual_clauses</a></li>
<li><a href="#L6164">prepare_sort_from_pathkeys</a></li>
<li><a href="#L2354">remap_groupColIdx</a></li>
<li><a href="#L4935">replace_nestloop_params</a></li>
<li><a href="#L4942">replace_nestloop_params_mutator</a></li>
<li><a href="#L865">use_physical_tlist</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L69">CP_EXACT_TLIST</a></li>
<li><a href="#L72">CP_IGNORE_TLIST</a></li>
<li><a href="#L71">CP_LABEL_TLIST</a></li>
<li><a href="#L70">CP_SMALL_TLIST</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * createplan.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Routines to create the desired plan for processing a query.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Planning is complete, we just need to convert the selected<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Path into a Plan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/optimizer/plan/createplan.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/sysattr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_class.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;foreign/fdwapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/extensible.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/clauses.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/cost.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/paramassign.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/pathnode.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/paths.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/placeholder.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/plancat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/planmain.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/prep.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/restrictinfo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/subselect.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/tlist.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_clause.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parsetree.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;partitioning/partprune.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Flag bits that can appear in the flags argument of <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>().<br/></li>
<li></span><span class="Comment"> * These can be OR-ed together.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L69" title="optimizer/plan/createplan.c:69">CP_EXACT_TLIST</a> specifies that the generated plan node must return exactly<br/></li>
<li></span><span class="Comment"> * the tlist specified by the path's pathtarget (this overrides both<br/></li>
<li></span><span class="Comment"> * <a href="#L70" title="optimizer/plan/createplan.c:70">CP_SMALL_TLIST</a> and <a href="#L71" title="optimizer/plan/createplan.c:71">CP_LABEL_TLIST</a>, if those are set).&nbsp; Otherwise, the<br/></li>
<li></span><span class="Comment"> * plan node is allowed to return just the Vars and PlaceHolderVars needed<br/></li>
<li></span><span class="Comment"> * to evaluate the pathtarget.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L70" title="optimizer/plan/createplan.c:70">CP_SMALL_TLIST</a> specifies that a narrower tlist is preferred.&nbsp; This is<br/></li>
<li></span><span class="Comment"> * passed down by parent nodes such as Sort and Hash, which will have to<br/></li>
<li></span><span class="Comment"> * store the returned tuples.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L71" title="optimizer/plan/createplan.c:71">CP_LABEL_TLIST</a> specifies that the plan node must return columns matching<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> sortgrouprefs specified in its pathtarget, with appropriate<br/></li>
<li></span><span class="Comment"> * ressortgroupref labels.&nbsp; This is passed down by parent nodes such as Sort<br/></li>
<li></span><span class="Comment"> * and Group, which need these <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to be available in their inputs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L72" title="optimizer/plan/createplan.c:72">CP_IGNORE_TLIST</a> specifies that the caller plans to replace the targetlist,<br/></li>
<li></span><span class="Comment"> * and therefore it doesn't matter a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> what target list gets generated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L69">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CP_EXACT_TLIST</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x0001</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* Plan must return specified tlist */<br/></li>
<li><a id="L70">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CP_SMALL_TLIST</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x0002</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* Prefer narrower tlists */<br/></li>
<li><a id="L71">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CP_LABEL_TLIST</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x0004</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* tlist must contain sortgrouprefs */<br/></li>
<li><a id="L72">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CP_IGNORE_TLIST</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x0008</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* caller will replace tlist */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> Plan *<a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(PlannerInfo *root, Path *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> flags);<br/></li>
<li><span class="Type">static</span> Plan *<a href="#L559" title="optimizer/plan/createplan.c:559">create_scan_plan</a>(PlannerInfo *root, Path *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> flags);<br/></li>
<li><span class="Type">static</span> List *<a href="#L825" title="optimizer/plan/createplan.c:825">build_path_tlist</a>(PlannerInfo *root, Path *path);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L865" title="optimizer/plan/createplan.c:865">use_physical_tlist</a>(PlannerInfo *root, Path *path, <span class="Type">int</span> flags);<br/></li>
<li><span class="Type">static</span> List *<a href="#L1002" title="optimizer/plan/createplan.c:1002">get_gating_quals</a>(PlannerInfo *root, List *quals);<br/></li>
<li><span class="Type">static</span> Plan *<a href="#L1022" title="optimizer/plan/createplan.c:1022">create_gating_plan</a>(PlannerInfo *root, Path *path, Plan *plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *gating_quals);<br/></li>
<li><span class="Type">static</span> Plan *<a href="#L1081" title="optimizer/plan/createplan.c:1081">create_join_plan</a>(PlannerInfo *root, JoinPath *best_path);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1140" title="optimizer/plan/createplan.c:1140">mark_async_capable_plan</a>(Plan *plan, Path *path);<br/></li>
<li><span class="Type">static</span> Plan *<a href="#L1216" title="optimizer/plan/createplan.c:1216">create_append_plan</a>(PlannerInfo *root, AppendPath *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> flags);<br/></li>
<li><span class="Type">static</span> Plan *<a href="#L1437" title="optimizer/plan/createplan.c:1437">create_merge_append_plan</a>(PlannerInfo *root, MergeAppendPath *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> flags);<br/></li>
<li><span class="Type">static</span> Result *<a href="#L1587" title="optimizer/plan/createplan.c:1587">create_group_result_plan</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GroupResultPath *best_path);<br/></li>
<li><span class="Type">static</span> ProjectSet *<a href="#L1612" title="optimizer/plan/createplan.c:1612">create_project_set_plan</a>(PlannerInfo *root, ProjectSetPath *best_path);<br/></li>
<li><span class="Type">static</span> Material *<a href="#L1638" title="optimizer/plan/createplan.c:1638">create_material_plan</a>(PlannerInfo *root, MaterialPath *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> flags);<br/></li>
<li><span class="Type">static</span> Memoize *<a href="#L1666" title="optimizer/plan/createplan.c:1666">create_memoize_plan</a>(PlannerInfo *root, MemoizePath *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> flags);<br/></li>
<li><span class="Type">static</span> Plan *<a href="#L1720" title="optimizer/plan/createplan.c:1720">create_unique_plan</a>(PlannerInfo *root, UniquePath *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> flags);<br/></li>
<li><span class="Type">static</span> Gather *<a href="#L1919" title="optimizer/plan/createplan.c:1919">create_gather_plan</a>(PlannerInfo *root, GatherPath *best_path);<br/></li>
<li><span class="Type">static</span> Plan *<a href="#L2018" title="optimizer/plan/createplan.c:2018">create_projection_plan</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ProjectionPath *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> flags);<br/></li>
<li><span class="Type">static</span> Plan *<a href="#L2120" title="optimizer/plan/createplan.c:2120">inject_projection_plan</a>(Plan *subplan, List *tlist, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> parallel_safe);<br/></li>
<li><span class="Type">static</span> Sort *<a href="#L2180" title="optimizer/plan/createplan.c:2180">create_sort_plan</a>(PlannerInfo *root, SortPath *best_path, <span class="Type">int</span> flags);<br/></li>
<li><span class="Type">static</span> IncrementalSort *<a href="#L2214" title="optimizer/plan/createplan.c:2214">create_incrementalsort_plan</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IncrementalSortPath *best_path, <span class="Type">int</span> flags);<br/></li>
<li><span class="Type">static</span> Group *<a href="#L2241" title="optimizer/plan/createplan.c:2241">create_group_plan</a>(PlannerInfo *root, GroupPath *best_path);<br/></li>
<li><span class="Type">static</span> Unique *<a href="#L2280" title="optimizer/plan/createplan.c:2280">create_upper_unique_plan</a>(PlannerInfo *root, UpperUniquePath *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> flags);<br/></li>
<li><span class="Type">static</span> Agg *<a href="#L2308" title="optimizer/plan/createplan.c:2308">create_agg_plan</a>(PlannerInfo *root, AggPath *best_path);<br/></li>
<li><span class="Type">static</span> Plan *<a href="#L2392" title="optimizer/plan/createplan.c:2392">create_groupingsets_plan</a>(PlannerInfo *root, GroupingSetsPath *best_path);<br/></li>
<li><span class="Type">static</span> Result *<a href="#L2550" title="optimizer/plan/createplan.c:2550">create_minmaxagg_plan</a>(PlannerInfo *root, MinMaxAggPath *best_path);<br/></li>
<li><span class="Type">static</span> WindowAgg *<a href="#L2616" title="optimizer/plan/createplan.c:2616">create_windowagg_plan</a>(PlannerInfo *root, WindowAggPath *best_path);<br/></li>
<li><span class="Type">static</span> SetOp *<a href="#L2719" title="optimizer/plan/createplan.c:2719">create_setop_plan</a>(PlannerInfo *root, SetOpPath *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> flags);<br/></li>
<li><span class="Type">static</span> RecursiveUnion *<a href="#L2755" title="optimizer/plan/createplan.c:2755">create_recursiveunion_plan</a>(PlannerInfo *root, RecursiveUnionPath *best_path);<br/></li>
<li><span class="Type">static</span> LockRows *<a href="#L2791" title="optimizer/plan/createplan.c:2791">create_lockrows_plan</a>(PlannerInfo *root, LockRowsPath *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> flags);<br/></li>
<li><span class="Type">static</span> ModifyTable *<a href="#L2814" title="optimizer/plan/createplan.c:2814">create_modifytable_plan</a>(PlannerInfo *root, ModifyTablePath *best_path);<br/></li>
<li><span class="Type">static</span> Limit *<a href="#L2855" title="optimizer/plan/createplan.c:2855">create_limit_plan</a>(PlannerInfo *root, LimitPath *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> flags);<br/></li>
<li><span class="Type">static</span> SeqScan *<a href="#L2916" title="optimizer/plan/createplan.c:2916">create_seqscan_plan</a>(PlannerInfo *root, Path *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *tlist, List *scan_clauses);<br/></li>
<li><span class="Type">static</span> SampleScan *<a href="#L2954" title="optimizer/plan/createplan.c:2954">create_samplescan_plan</a>(PlannerInfo *root, Path *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *tlist, List *scan_clauses);<br/></li>
<li><span class="Type">static</span> Scan *<a href="#L3005" title="optimizer/plan/createplan.c:3005">create_indexscan_plan</a>(PlannerInfo *root, IndexPath *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *tlist, List *scan_clauses, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> indexonly);<br/></li>
<li><span class="Type">static</span> BitmapHeapScan *<a href="#L3201" title="optimizer/plan/createplan.c:3201">create_bitmap_scan_plan</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BitmapHeapPath *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *tlist, List *scan_clauses);<br/></li>
<li><span class="Type">static</span> Plan *<a href="#L3331" title="optimizer/plan/createplan.c:3331">create_bitmap_subplan</a>(PlannerInfo *root, Path *bitmapqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **qual, List **indexqual, List **indexECs);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5478" title="optimizer/plan/createplan.c:5478">bitmap_subplan_mark_shared</a>(Plan *plan);<br/></li>
<li><span class="Type">static</span> TidScan *<a href="#L3539" title="optimizer/plan/createplan.c:3539">create_tidscan_plan</a>(PlannerInfo *root, TidPath *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *tlist, List *scan_clauses);<br/></li>
<li><span class="Type">static</span> TidRangeScan *<a href="#L3636" title="optimizer/plan/createplan.c:3636">create_tidrangescan_plan</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TidRangePath *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *scan_clauses);<br/></li>
<li><span class="Type">static</span> SubqueryScan *<a href="#L3701" title="optimizer/plan/createplan.c:3701">create_subqueryscan_plan</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SubqueryScanPath *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *tlist, List *scan_clauses);<br/></li>
<li><span class="Type">static</span> FunctionScan *<a href="#L3760" title="optimizer/plan/createplan.c:3760">create_functionscan_plan</a>(PlannerInfo *root, Path *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *tlist, List *scan_clauses);<br/></li>
<li><span class="Type">static</span> ValuesScan *<a href="#L3846" title="optimizer/plan/createplan.c:3846">create_valuesscan_plan</a>(PlannerInfo *root, Path *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *tlist, List *scan_clauses);<br/></li>
<li><span class="Type">static</span> TableFuncScan *<a href="#L3803" title="optimizer/plan/createplan.c:3803">create_tablefuncscan_plan</a>(PlannerInfo *root, Path *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *tlist, List *scan_clauses);<br/></li>
<li><span class="Type">static</span> CteScan *<a href="#L3890" title="optimizer/plan/createplan.c:3890">create_ctescan_plan</a>(PlannerInfo *root, Path *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *tlist, List *scan_clauses);<br/></li>
<li><span class="Type">static</span> NamedTuplestoreScan *<a href="#L3985" title="optimizer/plan/createplan.c:3985">create_namedtuplestorescan_plan</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path *best_path, List *tlist, List *scan_clauses);<br/></li>
<li><span class="Type">static</span> Result *<a href="#L4024" title="optimizer/plan/createplan.c:4024">create_resultscan_plan</a>(PlannerInfo *root, Path *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *tlist, List *scan_clauses);<br/></li>
<li><span class="Type">static</span> WorkTableScan *<a href="#L4061" title="optimizer/plan/createplan.c:4061">create_worktablescan_plan</a>(PlannerInfo *root, Path *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *tlist, List *scan_clauses);<br/></li>
<li><span class="Type">static</span> ForeignScan *<a href="#L4121" title="optimizer/plan/createplan.c:4121">create_foreignscan_plan</a>(PlannerInfo *root, ForeignPath *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *tlist, List *scan_clauses);<br/></li>
<li><span class="Type">static</span> CustomScan *<a href="#L4276" title="optimizer/plan/createplan.c:4276">create_customscan_plan</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CustomPath *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *tlist, List *scan_clauses);<br/></li>
<li><span class="Type">static</span> NestLoop *<a href="#L4347" title="optimizer/plan/createplan.c:4347">create_nestloop_plan</a>(PlannerInfo *root, NestPath *best_path);<br/></li>
<li><span class="Type">static</span> MergeJoin *<a href="#L4439" title="optimizer/plan/createplan.c:4439">create_mergejoin_plan</a>(PlannerInfo *root, MergePath *best_path);<br/></li>
<li><span class="Type">static</span> HashJoin *<a href="#L4746" title="optimizer/plan/createplan.c:4746">create_hashjoin_plan</a>(PlannerInfo *root, HashPath *best_path);<br/></li>
<li><span class="Type">static</span> Node *<a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(PlannerInfo *root, Node *expr);<br/></li>
<li><span class="Type">static</span> Node *<a href="#L4942" title="optimizer/plan/createplan.c:4942">replace_nestloop_params_mutator</a>(Node *node, PlannerInfo *root);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5022" title="optimizer/plan/createplan.c:5022">fix_indexqual_references</a>(PlannerInfo *root, IndexPath *index_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **stripped_indexquals_p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **fixed_indexquals_p);<br/></li>
<li><span class="Type">static</span> List *<a href="#L5063" title="optimizer/plan/createplan.c:5063">fix_indexorderby_references</a>(PlannerInfo *root, IndexPath *index_path);<br/></li>
<li><span class="Type">static</span> Node *<a href="#L5092" title="optimizer/plan/createplan.c:5092">fix_indexqual_clause</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexOptInfo *index, <span class="Type">int</span> indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *clause, List *indexcolnos);<br/></li>
<li><span class="Type">static</span> Node *<a href="#L5163" title="optimizer/plan/createplan.c:5163">fix_indexqual_operand</a>(Node *node, IndexOptInfo *index, <span class="Type">int</span> indexcol);<br/></li>
<li><span class="Type">static</span> List *<a href="#L5238" title="optimizer/plan/createplan.c:5238">get_switched_clauses</a>(List *clauses, Relids outerrelids);<br/></li>
<li><span class="Type">static</span> List *<a href="#L5315" title="optimizer/plan/createplan.c:5315">order_qual_clauses</a>(PlannerInfo *root, List *clauses);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(Plan *dest, Path *src);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5424" title="optimizer/plan/createplan.c:5424">copy_plan_costsize</a>(Plan *dest, Plan *src);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5446" title="optimizer/plan/createplan.c:5446">label_sort_with_costsize</a>(PlannerInfo *root, Sort *plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> limit_tuples);<br/></li>
<li><span class="Type">static</span> SeqScan *<a href="#L5508" title="optimizer/plan/createplan.c:5508">make_seqscan</a>(List *qptlist, List *qpqual, Index scanrelid);<br/></li>
<li><span class="Type">static</span> SampleScan *<a href="#L5525" title="optimizer/plan/createplan.c:5525">make_samplescan</a>(List *qptlist, List *qpqual, Index scanrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TableSampleClause *tsc);<br/></li>
<li><span class="Type">static</span> IndexScan *<a href="#L5544" title="optimizer/plan/createplan.c:5544">make_indexscan</a>(List *qptlist, List *qpqual, Index scanrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid indexid, List *indexqual, List *indexqualorig,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *indexorderby, List *indexorderbyorig,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *indexorderbyops,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanDirection indexscandir);<br/></li>
<li><span class="Type">static</span> IndexOnlyScan *<a href="#L5575" title="optimizer/plan/createplan.c:5575">make_indexonlyscan</a>(List *qptlist, List *qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index scanrelid, Oid indexid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *indexqual, List *recheckqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *indexorderby,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *indextlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanDirection indexscandir);<br/></li>
<li><span class="Type">static</span> BitmapIndexScan *<a href="#L5604" title="optimizer/plan/createplan.c:5604">make_bitmap_indexscan</a>(Index scanrelid, Oid indexid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *indexqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *indexqualorig);<br/></li>
<li><span class="Type">static</span> BitmapHeapScan *<a href="#L5625" title="optimizer/plan/createplan.c:5625">make_bitmap_heapscan</a>(List *qptlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Plan *lefttree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *bitmapqualorig,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index scanrelid);<br/></li>
<li><span class="Type">static</span> TidScan *<a href="#L5645" title="optimizer/plan/createplan.c:5645">make_tidscan</a>(List *qptlist, List *qpqual, Index scanrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *tidquals);<br/></li>
<li><span class="Type">static</span> TidRangeScan *<a href="#L5664" title="optimizer/plan/createplan.c:5664">make_tidrangescan</a>(List *qptlist, List *qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index scanrelid, List *tidrangequals);<br/></li>
<li><span class="Type">static</span> SubqueryScan *<a href="#L5683" title="optimizer/plan/createplan.c:5683">make_subqueryscan</a>(List *qptlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index scanrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Plan *subplan);<br/></li>
<li><span class="Type">static</span> FunctionScan *<a href="#L5703" title="optimizer/plan/createplan.c:5703">make_functionscan</a>(List *qptlist, List *qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index scanrelid, List *<a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> funcordinality);<br/></li>
<li><span class="Type">static</span> ValuesScan *<a href="#L5743" title="optimizer/plan/createplan.c:5743">make_valuesscan</a>(List *qptlist, List *qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index scanrelid, List *values_lists);<br/></li>
<li><span class="Type">static</span> TableFuncScan *<a href="#L5724" title="optimizer/plan/createplan.c:5724">make_tablefuncscan</a>(List *qptlist, List *qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index scanrelid, TableFunc *tablefunc);<br/></li>
<li><span class="Type">static</span> CteScan *<a href="#L5762" title="optimizer/plan/createplan.c:5762">make_ctescan</a>(List *qptlist, List *qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index scanrelid, <span class="Type">int</span> ctePlanId, <span class="Type">int</span> cteParam);<br/></li>
<li><span class="Type">static</span> NamedTuplestoreScan *<a href="#L5783" title="optimizer/plan/createplan.c:5783">make_namedtuplestorescan</a>(List *qptlist, List *qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index scanrelid, <span class="Type">char</span> *enrname);<br/></li>
<li><span class="Type">static</span> WorkTableScan *<a href="#L5803" title="optimizer/plan/createplan.c:5803">make_worktablescan</a>(List *qptlist, List *qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index scanrelid, <span class="Type">int</span> wtParam);<br/></li>
<li><span class="Type">static</span> RecursiveUnion *<a href="#L5862" title="optimizer/plan/createplan.c:5862">make_recursive_union</a>(List *tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Plan *lefttree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Plan *righttree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> wtParam,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *distinctList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span> numGroups);<br/></li>
<li><span class="Type">static</span> BitmapAnd *<a href="#L5918" title="optimizer/plan/createplan.c:5918">make_bitmap_and</a>(List *bitmapplans);<br/></li>
<li><span class="Type">static</span> BitmapOr *<a href="#L5933" title="optimizer/plan/createplan.c:5933">make_bitmap_or</a>(List *bitmapplans);<br/></li>
<li><span class="Type">static</span> NestLoop *<a href="#L5948" title="optimizer/plan/createplan.c:5948">make_nestloop</a>(List *tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *joinclauses, List *otherclauses, List *nestParams,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Plan *lefttree, Plan *righttree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JoinType jointype, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> inner_unique);<br/></li>
<li><span class="Type">static</span> HashJoin *<a href="#L5973" title="optimizer/plan/createplan.c:5973">make_hashjoin</a>(List *tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *joinclauses, List *otherclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *hashclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *hashoperators, List *hashcollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *hashkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Plan *lefttree, Plan *righttree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JoinType jointype, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> inner_unique);<br/></li>
<li><span class="Type">static</span> Hash *<a href="#L6004" title="optimizer/plan/createplan.c:6004">make_hash</a>(Plan *lefttree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *hashkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid skewTable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AttrNumber skewColumn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skewInherit);<br/></li>
<li><span class="Type">static</span> MergeJoin *<a href="#L6027" title="optimizer/plan/createplan.c:6027">make_mergejoin</a>(List *tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *joinclauses, List *otherclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *mergeclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *mergefamilies,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *mergecollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *mergestrategies,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *mergenullsfirst,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Plan *lefttree, Plan *righttree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JoinType jointype, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> inner_unique,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skip_mark_restore);<br/></li>
<li><span class="Type">static</span> Sort *<a href="#L6068" title="optimizer/plan/createplan.c:6068">make_sort</a>(Plan *lefttree, <span class="Type">int</span> numCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AttrNumber *sortColIdx, Oid *sortOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *collations, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *nullsFirst);<br/></li>
<li><span class="Type">static</span> IncrementalSort *<a href="#L6098" title="optimizer/plan/createplan.c:6098">make_incrementalsort</a>(Plan *lefttree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> numCols, <span class="Type">int</span> nPresortedCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AttrNumber *sortColIdx, Oid *sortOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *collations, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *nullsFirst);<br/></li>
<li><span class="Type">static</span> Plan *<a href="#L6164" title="optimizer/plan/createplan.c:6164">prepare_sort_from_pathkeys</a>(Plan *lefttree, List *pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> AttrNumber *reqColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> adjust_tlist_in_place,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *p_numsortkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber **p_sortColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid **p_sortOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid **p_collations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> **p_nullsFirst);<br/></li>
<li><span class="Type">static</span> Sort *<a href="#L6346" title="optimizer/plan/createplan.c:6346">make_sort_from_pathkeys</a>(Plan *lefttree, List *pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids relids);<br/></li>
<li><span class="Type">static</span> IncrementalSort *<a href="#L6381" title="optimizer/plan/createplan.c:6381">make_incrementalsort_from_pathkeys</a>(Plan *lefttree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *pathkeys, Relids relids, <span class="Type">int</span> nPresortedCols);<br/></li>
<li><span class="Type">static</span> Sort *<a href="#L6464" title="optimizer/plan/createplan.c:6464">make_sort_from_groupcols</a>(List *groupcls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber *grpColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Plan *lefttree);<br/></li>
<li><span class="Type">static</span> Material *<a href="#L6505" title="optimizer/plan/createplan.c:6505">make_material</a>(Plan *lefttree);<br/></li>
<li><span class="Type">static</span> Memoize *<a href="#L6568" title="optimizer/plan/createplan.c:6568">make_memoize</a>(Plan *lefttree, Oid *hashoperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *collations, List *param_exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> singlerow, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> binary_mode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint32 est_entries, Bitmapset *keyparamids);<br/></li>
<li><span class="Type">static</span> WindowAgg *<a href="#L6627" title="optimizer/plan/createplan.c:6627">make_windowagg</a>(List *tlist, Index winref,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> partNumCols, AttrNumber *partColIdx, Oid *partOperators, Oid *partCollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> ordNumCols, AttrNumber *ordColIdx, Oid *ordOperators, Oid *ordCollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> frameOptions, Node *startOffset, Node *endOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid startInRangeFunc, Oid endInRangeFunc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid inRangeColl, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> inRangeAsc, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> inRangeNullsFirst,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *runCondition, List *qual, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> topWindow,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Plan *lefttree);<br/></li>
<li><span class="Type">static</span> Group *<a href="#L6669" title="optimizer/plan/createplan.c:6669">make_group</a>(List *tlist, List *qual, <span class="Type">int</span> numGroupCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AttrNumber *grpColIdx, Oid *grpOperators, Oid *grpCollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Plan *lefttree);<br/></li>
<li><span class="Type">static</span> Unique *<a href="#L6699" title="optimizer/plan/createplan.c:6699">make_unique_from_sortclauses</a>(Plan *lefttree, List *distinctList);<br/></li>
<li><span class="Type">static</span> Unique *<a href="#L6748" title="optimizer/plan/createplan.c:6748">make_unique_from_pathkeys</a>(Plan *lefttree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *pathkeys, <span class="Type">int</span> numCols);<br/></li>
<li><span class="Type">static</span> Gather *<a href="#L6854" title="optimizer/plan/createplan.c:6854">make_gather</a>(List *qptlist, List *qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nworkers, <span class="Type">int</span> rescan_param, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> single_copy, Plan *subplan);<br/></li>
<li><span class="Type">static</span> SetOp *<a href="#L6883" title="optimizer/plan/createplan.c:6883">make_setop</a>(SetOpCmd cmd, SetOpStrategy strategy, Plan *lefttree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *distinctList, AttrNumber flagColIdx, <span class="Type">int</span> firstFlag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">long</span> numGroups);<br/></li>
<li><span class="Type">static</span> LockRows *<a href="#L6939" title="optimizer/plan/createplan.c:6939">make_lockrows</a>(Plan *lefttree, List *rowMarks, <span class="Type">int</span> epqParam);<br/></li>
<li><span class="Type">static</span> Result *<a href="#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(List *tlist, Node *resconstantqual, Plan *subplan);<br/></li>
<li><span class="Type">static</span> ProjectSet *<a href="#L7009" title="optimizer/plan/createplan.c:7009">make_project_set</a>(List *tlist, Plan *subplan);<br/></li>
<li><span class="Type">static</span> ModifyTable *<a href="#L7028" title="optimizer/plan/createplan.c:7028">make_modifytable</a>(PlannerInfo *root, Plan *subplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CmdType operation, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> canSetTag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index nominalRelation, Index rootRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> partColsUpdated,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *resultRelations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *updateColnosLists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *withCheckOptionLists, List *returningLists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *rowMarks, OnConflictExpr *onconflict,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *mergeActionLists, List *mergeJoinConditions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> epqParam);<br/></li>
<li><span class="Type">static</span> GatherMerge *<a href="#L1957" title="optimizer/plan/createplan.c:1957">create_gather_merge_plan</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GatherMergePath *best_path);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L337" title="optimizer/plan/createplan.c:337">create_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates the access plan for a query by recursively processing the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; desired tree of pathnodes, starting at the node 'best_path'.&nbsp; For<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; every pathnode found, we create a corresponding plan node containing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; appropriate id, target list, and qualification information.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; The tlists and quals in the plan tree are still in <a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> format,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; ie, Vars still correspond to the parser's numbering.&nbsp; This will be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; fixed later by setrefs.c.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; best_path is the best access path<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Returns a Plan tree.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Plan *<br/></li>
<li><a id="L337">&#x200c;</a><span class="linkable">create_plan</span>(PlannerInfo *root, Path *best_path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* plan_params should not be in use in current query level */<br/></li>
<li></span>&nbsp; &nbsp; Assert(root-&gt;plan_params == NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize this module's workspace in PlannerInfo */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;curOuterRels = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;curOuterParams = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Recursively process the path tree, demanding the correct tlist result */<br/></li>
<li></span>&nbsp; &nbsp; plan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path, <a href="#L69" title="optimizer/plan/createplan.c:69">CP_EXACT_TLIST</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure the topmost plan node's targetlist exposes the original<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * column names and other decorative info.&nbsp; Targetlists generated within<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> don't bother with that stuff, but we must have it on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * top-level tlist seen at execution time.&nbsp; However, ModifyTable plan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nodes don't have a tlist matching the querytree targetlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IsA(plan, ModifyTable))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/tlist.c.html#L318" title="optimizer/util/tlist.c:318">apply_tlist_labeling</a>(plan-&gt;targetlist, root-&gt;processed_tlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Attach <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> initPlans created in this query level to the topmost plan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * node.&nbsp; (In principle the initplans could go in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> plan node at or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * above where they're referenced, but there seems no reason to put them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> than the topmost node for the query level.&nbsp; Also, see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comments for <a href="subselect.c.html#L2254" title="optimizer/plan/subselect.c:2254">SS_finalize_plan</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> you try to change this.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="subselect.c.html#L2239" title="optimizer/plan/subselect.c:2239">SS_attach_initplans</a>(root, plan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check we successfully assigned all NestLoopParams to plan nodes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;curOuterParams != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to assign all NestLoopParams to plan nodes&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset plan_params to ensure param IDs used for nestloop params are not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * re-used later<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;plan_params = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Recursive guts of <a href="#L337" title="optimizer/plan/createplan.c:337">create_plan</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Plan *<br/></li>
<li><a id="L388">&#x200c;</a><span class="linkable">create_plan_recurse</span>(PlannerInfo *root, Path *best_path, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Guard against stack overflow due to overly complex plans */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (best_path-&gt;pathtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SeqScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SampleScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IndexScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IndexOnlyScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_BitmapHeapScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_TidScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_TidRangeScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SubqueryScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_FunctionScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_TableFuncScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ValuesScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_CteScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_WorkTableScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_NamedTuplestoreScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ForeignScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_CustomScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = <a href="#L559" title="optimizer/plan/createplan.c:559">create_scan_plan</a>(root, best_path, flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_HashJoin:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_MergeJoin:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_NestLoop:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = <a href="#L1081" title="optimizer/plan/createplan.c:1081">create_join_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (JoinPath *) best_path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Append:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = <a href="#L1216" title="optimizer/plan/createplan.c:1216">create_append_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (AppendPath *) best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_MergeAppend:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = <a href="#L1437" title="optimizer/plan/createplan.c:1437">create_merge_append_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (MergeAppendPath *) best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Result:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(best_path, ProjectionPath))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = <a href="#L2018" title="optimizer/plan/createplan.c:2018">create_projection_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ProjectionPath *) best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(best_path, MinMaxAggPath))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L2550" title="optimizer/plan/createplan.c:2550">create_minmaxagg_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (MinMaxAggPath *) best_path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(best_path, GroupResultPath))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L1587" title="optimizer/plan/createplan.c:1587">create_group_result_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (GroupResultPath *) best_path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Simple RTE_RESULT base relation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(IsA(best_path, Path));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = <a href="#L559" title="optimizer/plan/createplan.c:559">create_scan_plan</a>(root, best_path, flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ProjectSet:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L1612" title="optimizer/plan/createplan.c:1612">create_project_set_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ProjectSetPath *) best_path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Material:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L1638" title="optimizer/plan/createplan.c:1638">create_material_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (MaterialPath *) best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Memoize:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L1666" title="optimizer/plan/createplan.c:1666">create_memoize_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (MemoizePath *) best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Unique:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(best_path, UpperUniquePath))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L2280" title="optimizer/plan/createplan.c:2280">create_upper_unique_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (UpperUniquePath *) best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(IsA(best_path, UniquePath));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = <a href="#L1720" title="optimizer/plan/createplan.c:1720">create_unique_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (UniquePath *) best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Gather:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L1919" title="optimizer/plan/createplan.c:1919">create_gather_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (GatherPath *) best_path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Sort:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L2180" title="optimizer/plan/createplan.c:2180">create_sort_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (SortPath *) best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IncrementalSort:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L2214" title="optimizer/plan/createplan.c:2214">create_incrementalsort_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (IncrementalSortPath *) best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Group:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L2241" title="optimizer/plan/createplan.c:2241">create_group_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (GroupPath *) best_path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Agg:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(best_path, GroupingSetsPath))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = <a href="#L2392" title="optimizer/plan/createplan.c:2392">create_groupingsets_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (GroupingSetsPath *) best_path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(IsA(best_path, AggPath));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L2308" title="optimizer/plan/createplan.c:2308">create_agg_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (AggPath *) best_path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_WindowAgg:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L2616" title="optimizer/plan/createplan.c:2616">create_windowagg_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (WindowAggPath *) best_path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SetOp:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L2719" title="optimizer/plan/createplan.c:2719">create_setop_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (SetOpPath *) best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_RecursiveUnion:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L2755" title="optimizer/plan/createplan.c:2755">create_recursiveunion_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (RecursiveUnionPath *) best_path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_LockRows:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L2791" title="optimizer/plan/createplan.c:2791">create_lockrows_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (LockRowsPath *) best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ModifyTable:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L2814" title="optimizer/plan/createplan.c:2814">create_modifytable_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ModifyTablePath *) best_path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Limit:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L2855" title="optimizer/plan/createplan.c:2855">create_limit_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (LimitPath *) best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_GatherMerge:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L1957" title="optimizer/plan/createplan.c:1957">create_gather_merge_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (GatherMergePath *) best_path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) best_path-&gt;pathtype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L559" title="optimizer/plan/createplan.c:559">create_scan_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Create a scan plan for the parent relation of 'best_path'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Plan *<br/></li>
<li><a id="L559">&#x200c;</a><span class="linkable">create_scan_plan</span>(PlannerInfo *root, Path *best_path, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *rel = best_path-&gt;parent;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *scan_clauses;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *gating_clauses;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Extract the relevant restriction clauses from the parent relation. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * executor must apply all these restrictions during the scan, except for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pseudoconstants which we'll take care of below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is a plain indexscan or index-only scan, we need not consider<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restriction clauses that are implied by the index's predicate, so use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indrestrictinfo not baserestrictinfo.&nbsp; Note that we can't do that for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bitmap indexscans, since there's not necessarily a single index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * involved; but it doesn't matter since <a href="#L3201" title="optimizer/plan/createplan.c:3201">create_bitmap_scan_plan</a>() will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * able to get rid of such clauses anyway via predicate proof.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (best_path-&gt;pathtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IndexScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IndexOnlyScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan_clauses = castNode(IndexPath, best_path)-&gt;indexinfo-&gt;indrestrictinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan_clauses = rel-&gt;baserestrictinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is a parameterized scan, we also need to enforce all the join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clauses available from the outer relation(s).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For paranoia's sake, don't modify the stored baserestrictinfo list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;param_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan_clauses = <a href="../../nodes/list.c.html#L598" title="nodes/list.c:598">list_concat_copy</a>(scan_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;param_info-&gt;ppi_clauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Detect whether we have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pseudoconstant quals to deal with.&nbsp; Then, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we'll need a gating Result node, it will be able to project, so there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are no requirements on the child's tlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this replaces a join, it must be a foreign scan or a custom scan,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and the FDW or the custom scan <a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> would have stored in the best<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * path the list of RestrictInfo nodes to apply to the join; check against<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that list in that case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IS_JOIN_REL(rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *join_clauses;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(best_path-&gt;pathtype == T_ForeignScan ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_path-&gt;pathtype == T_CustomScan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;pathtype == T_ForeignScan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; join_clauses = ((ForeignPath *) best_path)-&gt;fdw_restrictinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; join_clauses = ((CustomPath *) best_path)-&gt;custom_restrictinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gating_clauses = <a href="#L1002" title="optimizer/plan/createplan.c:1002">get_gating_quals</a>(root, join_clauses);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; gating_clauses = <a href="#L1002" title="optimizer/plan/createplan.c:1002">get_gating_quals</a>(root, scan_clauses);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (gating_clauses)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For table scans, rather than using the relation targetlist (which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only those Vars actually needed by the query), we prefer to generate a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tlist containing all Vars in order.&nbsp; This will allow the executor to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> away projection of the table tuples, if possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * But if the caller is going to ignore our tlist anyway, then don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bother generating one at all.&nbsp; We use an exact equality test here, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that this only applies when <a href="#L72" title="optimizer/plan/createplan.c:72">CP_IGNORE_TLIST</a> is the only flag set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flags == <a href="#L72" title="optimizer/plan/createplan.c:72">CP_IGNORE_TLIST</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tlist = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L865" title="optimizer/plan/createplan.c:865">use_physical_tlist</a>(root, best_path, flags))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;pathtype == T_IndexOnlyScan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* For index-only scan, the preferred tlist is the index's */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tlist = copyObject(((IndexPath *) best_path)-&gt;indexinfo-&gt;indextlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Transfer sortgroupref data to the replacement tlist, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * requested (<a href="#L865" title="optimizer/plan/createplan.c:865">use_physical_tlist</a> checked that this will work).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; <a href="#L71" title="optimizer/plan/createplan.c:71">CP_LABEL_TLIST</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/tlist.c.html#L774" title="optimizer/util/tlist.c:774">apply_pathtarget_labeling_to_tlist</a>(tlist, best_path-&gt;pathtarget);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tlist = <a href="../util/plancat.c.html#L1747" title="optimizer/util/plancat.c:1747">build_physical_tlist</a>(root, rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tlist == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Failed because of dropped cols, so use regular method */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tlist = <a href="#L825" title="optimizer/plan/createplan.c:825">build_path_tlist</a>(root, best_path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* As above, transfer sortgroupref data to replacement tlist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; <a href="#L71" title="optimizer/plan/createplan.c:71">CP_LABEL_TLIST</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/tlist.c.html#L774" title="optimizer/util/tlist.c:774">apply_pathtarget_labeling_to_tlist</a>(tlist, best_path-&gt;pathtarget);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tlist = <a href="#L825" title="optimizer/plan/createplan.c:825">build_path_tlist</a>(root, best_path);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (best_path-&gt;pathtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SeqScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L2916" title="optimizer/plan/createplan.c:2916">create_seqscan_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan_clauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SampleScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L2954" title="optimizer/plan/createplan.c:2954">create_samplescan_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scan_clauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IndexScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L3005" title="optimizer/plan/createplan.c:3005">create_indexscan_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (IndexPath *) best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IndexOnlyScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L3005" title="optimizer/plan/createplan.c:3005">create_indexscan_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (IndexPath *) best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_BitmapHeapScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L3201" title="optimizer/plan/createplan.c:3201">create_bitmap_scan_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (BitmapHeapPath *) best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan_clauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_TidScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L3539" title="optimizer/plan/createplan.c:3539">create_tidscan_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (TidPath *) best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan_clauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_TidRangeScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L3636" title="optimizer/plan/createplan.c:3636">create_tidrangescan_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (TidRangePath *) best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scan_clauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SubqueryScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L3701" title="optimizer/plan/createplan.c:3701">create_subqueryscan_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (SubqueryScanPath *) best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scan_clauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_FunctionScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L3760" title="optimizer/plan/createplan.c:3760">create_functionscan_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scan_clauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_TableFuncScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L3803" title="optimizer/plan/createplan.c:3803">create_tablefuncscan_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan_clauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ValuesScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L3846" title="optimizer/plan/createplan.c:3846">create_valuesscan_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scan_clauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_CteScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L3890" title="optimizer/plan/createplan.c:3890">create_ctescan_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan_clauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_NamedTuplestoreScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L3985" title="optimizer/plan/createplan.c:3985">create_namedtuplestorescan_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan_clauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Result:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L4024" title="optimizer/plan/createplan.c:4024">create_resultscan_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scan_clauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_WorkTableScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L4061" title="optimizer/plan/createplan.c:4061">create_worktablescan_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan_clauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ForeignScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L4121" title="optimizer/plan/createplan.c:4121">create_foreignscan_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ForeignPath *) best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan_clauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_CustomScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L4276" title="optimizer/plan/createplan.c:4276">create_customscan_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (CustomPath *) best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scan_clauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) best_path-&gt;pathtype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pseudoconstant clauses attached to this node, insert a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * gating Result node that evaluates the pseudoconstants as one-time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * quals.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (gating_clauses)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan = <a href="#L1022" title="optimizer/plan/createplan.c:1022">create_gating_plan</a>(root, best_path, plan, gating_clauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Build a target list (ie, a list of TargetEntry) for the Path's output.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is almost just <a href="../util/tlist.c.html#L624" title="optimizer/util/tlist.c:624">make_tlist_from_pathtarget</a>(), but we also have to<br/></li>
<li></span><span class="Comment"> * deal with replacing nestloop params.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L825">&#x200c;</a><span class="linkable">build_path_tlist</span>(PlannerInfo *root, Path *path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist = NIL;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp;&nbsp; *sortgrouprefs = path-&gt;pathtarget-&gt;sortgrouprefs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resno = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *v;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(v, path-&gt;pathtarget-&gt;exprs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *node = (Node *) lfirst(v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's a parameterized path, there might be lateral references in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the tlist, which need to be replaced with Params.&nbsp; There's no need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to remake the TargetEntry nodes, so apply this to each list item<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * separately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path-&gt;param_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node = <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>((Expr *) node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sortgrouprefs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle-&gt;ressortgroupref = sortgrouprefs[resno - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tlist, tle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; resno++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tlist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L865" title="optimizer/plan/createplan.c:865">use_physical_tlist</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Decide whether to use a tlist matching relation structure,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; rather than only those Vars actually referenced.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L865">&#x200c;</a></span><span class="linkable">use_physical_tlist</span>(PlannerInfo *root, Path *path, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *rel = path-&gt;parent;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Forget it if either exact tlist or small tlist is demanded.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; (<a href="#L69" title="optimizer/plan/createplan.c:69">CP_EXACT_TLIST</a> | <a href="#L70" title="optimizer/plan/createplan.c:70">CP_SMALL_TLIST</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can do this for real relation scans, subquery scans, function scans,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tablefunc scans, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> scans, and CTE scans (but not for, eg, joins).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rtekind != RTE_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rtekind != RTE_SUBQUERY &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rtekind != RTE_FUNCTION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rtekind != RTE_TABLEFUNC &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rtekind != RTE_VALUES &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rtekind != RTE_CTE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Can't do it with inheritance cases either (mainly because Append<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't project; this test may be unnecessary <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1216" title="optimizer/plan/createplan.c:1216">create_append_plan</a> instructs its children to return an exact tlist).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;reloptkind != RELOPT_BASEREL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, don't do it to a CustomPath; the premise that we're extracting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * columns from a simple physical tuple is unlikely to hold for those.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (When it does make sense, the custom path creator can set up the path's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pathtarget that way.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(path, CustomPath))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If a bitmap scan's tlist is empty, keep it as-is.&nbsp; This may allow the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * executor to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> heap page fetches, and in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, the benefit of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * using a physical tlist instead would be minimal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(path, BitmapHeapPath) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;pathtarget-&gt;exprs == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Can't do it if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> system columns or whole-row Vars are requested.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (This could possibly be fixed but would take some fragile assumptions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in setrefs.c, I think.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = rel-&gt;min_attr; i &lt;= <span class="Constant">0</span>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!bms_is_empty(rel-&gt;attr_needed[i - rel-&gt;min_attr]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Can't do it if the rel is required to emit <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> placeholder expressions,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, root-&gt;placeholder_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderInfo *phinfo = (PlaceHolderInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L641" title="nodes/bitmapset.c:641">bms_nonempty_difference</a>(phinfo-&gt;ph_needed, rel-&gt;relids) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(phinfo-&gt;ph_eval_at, rel-&gt;relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For an index-only scan, the &quot;physical tlist&quot; is the index's indextlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can only return that without a projection if all the index's columns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are returnable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (path-&gt;pathtype == T_IndexOnlyScan)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexOptInfo *indexinfo = ((IndexPath *) path)-&gt;indexinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; indexinfo-&gt;ncolumns; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!indexinfo-&gt;canreturn[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, can't do it if <a href="#L71" title="optimizer/plan/createplan.c:71">CP_LABEL_TLIST</a> is specified and path is requested<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to emit <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> sort/group columns that are not simple Vars.&nbsp; (If they are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * simple Vars, they should appear in the physical tlist, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../util/tlist.c.html#L774" title="optimizer/util/tlist.c:774">apply_pathtarget_labeling_to_tlist</a> will take care of getting them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * labeled again.)&nbsp; &nbsp; We also have to check that no two sort/group columns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are the same Var, else that <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of the physical tlist would need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conflicting ressortgroupref labels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; <a href="#L71" title="optimizer/plan/createplan.c:71">CP_LABEL_TLIST</a>) &amp;&amp; path-&gt;pathtarget-&gt;sortgrouprefs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *sortgroupatts = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, path-&gt;pathtarget-&gt;exprs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *expr = (Expr *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path-&gt;pathtarget-&gt;sortgrouprefs[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (expr &amp;&amp; IsA(expr, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attno = ((Var *) expr)-&gt;varattno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attno -= FirstLowInvalidHeapAttributeNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(attno, sortgroupatts))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortgroupatts = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(sortgroupatts, attno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1002" title="optimizer/plan/createplan.c:1002">get_gating_quals</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; See if there are pseudoconstant quals in a node's quals list<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the node's quals list includes <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pseudoconstant quals,<br/></li>
<li></span><span class="Comment"> * return just those quals.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L1002">&#x200c;</a><span class="linkable">get_gating_quals</span>(PlannerInfo *root, List *quals)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No need to look if we know there are no pseudoconstants */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!root-&gt;hasPseudoConstantQuals)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort into desirable execution order while still in RestrictInfo form */<br/></li>
<li></span>&nbsp; &nbsp; quals = <a href="#L5315" title="optimizer/plan/createplan.c:5315">order_qual_clauses</a>(root, quals);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pull out <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pseudoconstant quals from the RestrictInfo list */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../util/restrictinfo.c.html#L494" title="optimizer/util/restrictinfo.c:494">extract_actual_clauses</a>(quals, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1022" title="optimizer/plan/createplan.c:1022">create_gating_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Deal with pseudoconstant qual clauses<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Add a gating Result node atop the already-built plan.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Plan *<br/></li>
<li><a id="L1022">&#x200c;</a><span class="linkable">create_gating_plan</span>(PlannerInfo *root, Path *path, Plan *plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *gating_quals)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *gplan;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *splan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(gating_quals);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We might have a trivial Result plan already.&nbsp; Stacking one Result atop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * another is silly, so if that applies, just discard the input plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (We're assuming its targetlist is uninteresting; it should be either<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the same as the result of <a href="#L825" title="optimizer/plan/createplan.c:825">build_path_tlist</a>, or a simplified version.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; splan = plan;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(plan, Result))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Result&nbsp; &nbsp; &nbsp;&nbsp; *rplan = (Result *) plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rplan-&gt;plan.lefttree == <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rplan-&gt;resconstantqual == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we need a Result node anyway, always return the path's requested<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tlist; that's never a wrong choice, even if the parent node didn't ask<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for <a href="#L69" title="optimizer/plan/createplan.c:69">CP_EXACT_TLIST</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; gplan = (Plan *) <a href="#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(<a href="#L825" title="optimizer/plan/createplan.c:825">build_path_tlist</a>(root, path),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) gating_quals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; splan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Notice that we don't change cost or size estimates when doing gating.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The costs of qual eval were already included in the subplan's cost.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Leaving the size alone amounts to assuming that the gating qual will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * succeed, which is the conservative estimate for planning <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> queries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We certainly don't want to assume the output size is zero (unless the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * gating qual is actually constant FALSE, and that case is dealt with in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clausesel.c).&nbsp; Interpolating between the two cases is silly, because it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't reflect what will really happen at runtime, and besides which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in most cases we have only a very bad idea of the probability of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * gating qual being true.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5424" title="optimizer/plan/createplan.c:5424">copy_plan_costsize</a>(gplan, plan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Gating quals could be unsafe, so better use the Path's safety flag */<br/></li>
<li></span>&nbsp; &nbsp; gplan-&gt;parallel_safe = path-&gt;parallel_safe;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> gplan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1081" title="optimizer/plan/createplan.c:1081">create_join_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create a join plan for 'best_path' and (recursively) plans for its<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; inner and outer paths.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Plan *<br/></li>
<li><a id="L1081">&#x200c;</a><span class="linkable">create_join_plan</span>(PlannerInfo *root, JoinPath *best_path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *gating_clauses;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (best_path-&gt;path.pathtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_MergeJoin:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L4439" title="optimizer/plan/createplan.c:4439">create_mergejoin_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (MergePath *) best_path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_HashJoin:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L4746" title="optimizer/plan/createplan.c:4746">create_hashjoin_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (HashPath *) best_path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_NestLoop:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L4347" title="optimizer/plan/createplan.c:4347">create_nestloop_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (NestPath *) best_path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) best_path-&gt;path.pathtype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pseudoconstant clauses attached to this node, insert a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * gating Result node that evaluates the pseudoconstants as one-time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * quals.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; gating_clauses = <a href="#L1002" title="optimizer/plan/createplan.c:1002">get_gating_quals</a>(root, best_path-&gt;joinrestrictinfo);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (gating_clauses)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan = <a href="#L1022" title="optimizer/plan/createplan.c:1022">create_gating_plan</a>(root, (Path *) best_path, plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gating_clauses);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * * Expensive function pullups may have pulled local predicates * into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this path node.&nbsp; Put them in the qpqual of the plan node. * JMH,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 6/15/92<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (get_loc_restrictinfo(best_path) != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set_qpqual((Plan) plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(get_qpqual((Plan) plan),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/restrictinfo.c.html#L469" title="optimizer/util/restrictinfo.c:469">get_actual_clauses</a>(get_loc_restrictinfo(best_path))));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1140" title="optimizer/plan/createplan.c:1140">mark_async_capable_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Check whether the Plan node created from a Path node is async-capable,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and if so, mark the Plan node as such and return true, otherwise<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; return false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1140">&#x200c;</a></span><span class="linkable">mark_async_capable_plan</span>(Plan *plan, Path *path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (nodeTag(path))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SubqueryScanPath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SubqueryScan *scan_plan = (SubqueryScan *) plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the generated plan node includes a gating Result node,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we can't execute it asynchronously.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(plan, Result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If a SubqueryScan node atop of an async-capable plan node<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is deletable, consider it as async-capable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="setrefs.c.html#L1464" title="optimizer/plan/setrefs.c:1464">trivial_subqueryscan</a>(scan_plan) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1140" title="optimizer/plan/createplan.c:1140">mark_async_capable_plan</a>(scan_plan-&gt;subplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((SubqueryScanPath *) path)-&gt;subpath))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ForeignPath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FdwRoutine *fdwroutine = path-&gt;parent-&gt;fdwroutine;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the generated plan node includes a gating Result node,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we can't execute it asynchronously.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(plan, Result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(fdwroutine != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fdwroutine-&gt;IsForeignPathAsyncCapable != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdwroutine-&gt;IsForeignPathAsyncCapable((ForeignPath *) path))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ProjectionPath:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the generated plan node includes a Result node for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * projection, we can't execute it asynchronously.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(plan, Result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L2018" title="optimizer/plan/createplan.c:2018">create_projection_plan</a>() would have pulled up the subplan, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check the capability using the subpath.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1140" title="optimizer/plan/createplan.c:1140">mark_async_capable_plan</a>(plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((ProjectionPath *) path)-&gt;subpath))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;async_capable = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1216" title="optimizer/plan/createplan.c:1216">create_append_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create an Append plan for 'best_path' and (recursively) plans<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; for its subpaths.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Returns a Plan node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Plan *<br/></li>
<li><a id="L1216">&#x200c;</a><span class="linkable">create_append_plan</span>(PlannerInfo *root, AppendPath *best_path, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Append&nbsp; &nbsp; &nbsp;&nbsp; *plan;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist = <a href="#L825" title="optimizer/plan/createplan.c:825">build_path_tlist</a>(root, &amp;best_path-&gt;path);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orig_tlist_length = list_length(tlist);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; tlist_was_changed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pathkeys = best_path-&gt;path.pathkeys;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *subplans = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *subpaths;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nasyncplans = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *rel = best_path-&gt;path.parent;<br/></li>
<li>&nbsp; &nbsp; PartitionPruneInfo *partpruneinfo = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nodenumsortkeys = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; AttrNumber *nodeSortColIdx = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *nodeSortOperators = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *nodeCollations = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nodeNullsFirst = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; consider_async = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The subpaths list could be empty, if every child was proven empty by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constraint exclusion.&nbsp; In that case generate a dummy plan that returns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no rows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that an AppendPath with no members is also generated in certain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases where there was no appending construct at all, but we know the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation is empty (see <a href="../path/allpaths.c.html#L2166" title="optimizer/path/allpaths.c:2166">set_dummy_rel_pathlist</a> and <a href="../path/joinrels.c.html#L1381" title="optimizer/path/joinrels.c:1381">mark_dummy_rel</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;subpaths == NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Generate a Result plan with constant-FALSE gating qual */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Node *) list_make1(<a href="../../nodes/makefuncs.c.html#L359" title="nodes/makefuncs.c:359">makeBoolConst</a>(<span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(plan, (Path *) best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise build an Append plan.&nbsp; Note that if there's just one child,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the Append is pretty useless; but we wait till setrefs.c to get rid of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it.&nbsp; Doing so here doesn't work because the varno of the child scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plan won't match the parent-rel Vars it'll be asked to emit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't have the actual creation of the Append node split out into a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * separate make_xxx function.&nbsp; This is because we want to run<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L6164" title="optimizer/plan/createplan.c:6164">prepare_sort_from_pathkeys</a> on it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we do so on the individual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * child plans, to make cross-checking the sort info easier.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; plan = makeNode(Append);<br/></li>
<li>&nbsp; &nbsp; plan-&gt;plan.targetlist = tlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;plan.qual = NIL;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;plan.lefttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;plan.righttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;apprelids = rel-&gt;relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pathkeys != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compute sort column info, and adjust the Append's tlist as needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Because we pass adjust_tlist_in_place = true, we may ignore the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function result; it must be the same plan node.&nbsp; However, we then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to detect whether <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tlist entries were added.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L6164" title="optimizer/plan/createplan.c:6164">prepare_sort_from_pathkeys</a>((Plan *) plan, pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;path.parent-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;nodenumsortkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;nodeSortColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;nodeSortOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;nodeCollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;nodeNullsFirst);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tlist_was_changed = (orig_tlist_length != list_length(plan-&gt;plan.targetlist));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If appropriate, consider async append */<br/></li>
<li></span>&nbsp; &nbsp; consider_async = (<a href="../path/costsize.c.html#L154" title="optimizer/path/costsize.c:154">enable_async_append</a> &amp;&amp; pathkeys == NIL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !best_path-&gt;path.parallel_safe &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(best_path-&gt;subpaths) &gt; <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build the plan for each child */<br/></li>
<li></span>&nbsp; &nbsp; foreach(subpaths, best_path-&gt;subpaths)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *subpath = (Path *) lfirst(subpaths);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must insist that all children return the same tlist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; subplan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, subpath, <a href="#L69" title="optimizer/plan/createplan.c:69">CP_EXACT_TLIST</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For ordered Appends, we must insert a Sort node if subplan isn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sufficiently ordered.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pathkeys != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numsortkeys;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber *sortColIdx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *sortOperators;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *collations;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nullsFirst;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compute sort column info, and adjust subplan's tlist as needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must apply <a href="#L6164" title="optimizer/plan/createplan.c:6164">prepare_sort_from_pathkeys</a> even to subplans that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't need an explicit sort, to make sure they are returning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the same sort key columns the Append expects.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subplan = <a href="#L6164" title="optimizer/plan/createplan.c:6164">prepare_sort_from_pathkeys</a>(subplan, pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subpath-&gt;parent-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nodeSortColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;numsortkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;sortColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;sortOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;collations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;nullsFirst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check that we got the same sort key information.&nbsp; We just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Assert that the sortops match, since those depend only on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pathkeys; but it seems like a good idea to check the sort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column numbers explicitly, to ensure the tlists match up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(numsortkeys == nodenumsortkeys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (memcmp(sortColIdx, nodeSortColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numsortkeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber)) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;Append child's targetlist doesn't match Append&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(memcmp(sortOperators, nodeSortOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numsortkeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid)) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(memcmp(collations, nodeCollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numsortkeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid)) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(memcmp(nullsFirst, nodeNullsFirst,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numsortkeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>)) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now, insert a Sort node if subplan isn't sufficiently ordered */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../path/pathkeys.c.html#L341" title="optimizer/path/pathkeys.c:341">pathkeys_contained_in</a>(pathkeys, subpath-&gt;pathkeys))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sort&nbsp; &nbsp; &nbsp;&nbsp; *sort = <a href="#L6068" title="optimizer/plan/createplan.c:6068">make_sort</a>(subplan, numsortkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sortColIdx, sortOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collations, nullsFirst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5446" title="optimizer/plan/createplan.c:5446">label_sort_with_costsize</a>(root, sort, best_path-&gt;limit_tuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subplan = (Plan *) sort;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If needed, check to see if subplan can be executed asynchronously */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (consider_async &amp;&amp; <a href="#L1140" title="optimizer/plan/createplan.c:1140">mark_async_capable_plan</a>(subplan, subpath))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(subplan-&gt;async_capable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++nasyncplans;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subplans = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(subplans, subplan);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> quals exist, they may be useful to perform further partition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pruning during execution.&nbsp; Gather information needed by the executor to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do partition pruning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../path/costsize.c.html#L152" title="optimizer/path/costsize.c:152">enable_partition_pruning</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *prunequal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prunequal = <a href="../util/restrictinfo.c.html#L494" title="optimizer/util/restrictinfo.c:494">extract_actual_clauses</a>(rel-&gt;baserestrictinfo, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;path.param_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *prmquals = best_path-&gt;path.param_info-&gt;ppi_clauses;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prmquals = <a href="../util/restrictinfo.c.html#L494" title="optimizer/util/restrictinfo.c:494">extract_actual_clauses</a>(prmquals, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prmquals = (List *) <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Node *) prmquals);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prunequal = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(prunequal, prmquals);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prunequal != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partpruneinfo =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../partitioning/partprune.c.html#L220" title="partitioning/partprune.c:220">make_partition_pruneinfo</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_path-&gt;subpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prunequal);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;appendplans = subplans;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;nasyncplans = nasyncplans;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;first_partial_plan = best_path-&gt;first_partial_path;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;part_prune_info = partpruneinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;plan-&gt;plan, (Path *) best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="#L6164" title="optimizer/plan/createplan.c:6164">prepare_sort_from_pathkeys</a> added sort columns, but we were told to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * produce either the exact tlist or a narrow tlist, we should get rid of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the sort columns again.&nbsp; We must inject a projection node to do so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tlist_was_changed &amp;&amp; (flags &amp; (<a href="#L69" title="optimizer/plan/createplan.c:69">CP_EXACT_TLIST</a> | <a href="#L70" title="optimizer/plan/createplan.c:70">CP_SMALL_TLIST</a>)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tlist = <a href="../../nodes/list.c.html#L1593" title="nodes/list.c:1593">list_copy_head</a>(plan-&gt;plan.targetlist, orig_tlist_length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2120" title="optimizer/plan/createplan.c:2120">inject_projection_plan</a>((Plan *) plan, tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;plan.parallel_safe);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Plan *) plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1437" title="optimizer/plan/createplan.c:1437">create_merge_append_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create a MergeAppend plan for 'best_path' and (recursively) plans<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; for its subpaths.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Returns a Plan node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Plan *<br/></li>
<li><a id="L1437">&#x200c;</a><span class="linkable">create_merge_append_plan</span>(PlannerInfo *root, MergeAppendPath *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MergeAppend *node = makeNode(MergeAppend);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;plan;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist = <a href="#L825" title="optimizer/plan/createplan.c:825">build_path_tlist</a>(root, &amp;best_path-&gt;path);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orig_tlist_length = list_length(tlist);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; tlist_was_changed;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pathkeys = best_path-&gt;path.pathkeys;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *subplans = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *subpaths;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *rel = best_path-&gt;path.parent;<br/></li>
<li>&nbsp; &nbsp; PartitionPruneInfo *partpruneinfo = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't have the actual creation of the MergeAppend node split out<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into a separate make_xxx function.&nbsp; This is because we want to run<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L6164" title="optimizer/plan/createplan.c:6164">prepare_sort_from_pathkeys</a> on it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we do so on the individual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * child plans, to make cross-checking the sort info easier.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(plan, (Path *) best_path);<br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = tlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = NIL;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;apprelids = rel-&gt;relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute sort column info, and adjust MergeAppend's tlist as needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Because we pass adjust_tlist_in_place = true, we may ignore the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function result; it must be the same plan node.&nbsp; However, we then need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to detect whether <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tlist entries were added.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L6164" title="optimizer/plan/createplan.c:6164">prepare_sort_from_pathkeys</a>(plan, pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;path.parent-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;node-&gt;numCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;node-&gt;sortColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;node-&gt;sortOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;node-&gt;collations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;node-&gt;nullsFirst);<br/></li>
<li>&nbsp; &nbsp; tlist_was_changed = (orig_tlist_length != list_length(plan-&gt;targetlist));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now prepare the child plans.&nbsp; We must apply <a href="#L6164" title="optimizer/plan/createplan.c:6164">prepare_sort_from_pathkeys</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * even to subplans that don't need an explicit sort, to make sure they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are returning the same sort key columns the MergeAppend expects.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(subpaths, best_path-&gt;subpaths)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *subpath = (Path *) lfirst(subpaths);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numsortkeys;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber *sortColIdx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *sortOperators;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *collations;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nullsFirst;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Build the child plan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must insist that all children return the same tlist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; subplan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, subpath, <a href="#L69" title="optimizer/plan/createplan.c:69">CP_EXACT_TLIST</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute sort column info, and adjust subplan's tlist as needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; subplan = <a href="#L6164" title="optimizer/plan/createplan.c:6164">prepare_sort_from_pathkeys</a>(subplan, pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subpath-&gt;parent-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;sortColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;numsortkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;sortColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;sortOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;collations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;nullsFirst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check that we got the same sort key information.&nbsp; We just Assert<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that the sortops match, since those depend only on the pathkeys;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but it seems like a good idea to check the sort column numbers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * explicitly, to ensure the tlists really do match up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(numsortkeys == node-&gt;numCols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (memcmp(sortColIdx, node-&gt;sortColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numsortkeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber)) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;MergeAppend child's targetlist doesn't match MergeAppend&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(memcmp(sortOperators, node-&gt;sortOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numsortkeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid)) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(memcmp(collations, node-&gt;collations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numsortkeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid)) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(memcmp(nullsFirst, node-&gt;nullsFirst,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numsortkeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>)) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now, insert a Sort node if subplan isn't sufficiently ordered */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../path/pathkeys.c.html#L341" title="optimizer/path/pathkeys.c:341">pathkeys_contained_in</a>(pathkeys, subpath-&gt;pathkeys))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sort&nbsp; &nbsp; &nbsp;&nbsp; *sort = <a href="#L6068" title="optimizer/plan/createplan.c:6068">make_sort</a>(subplan, numsortkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sortColIdx, sortOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collations, nullsFirst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5446" title="optimizer/plan/createplan.c:5446">label_sort_with_costsize</a>(root, sort, best_path-&gt;limit_tuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subplan = (Plan *) sort;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subplans = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(subplans, subplan);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> quals exist, they may be useful to perform further partition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pruning during execution.&nbsp; Gather information needed by the executor to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do partition pruning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../path/costsize.c.html#L152" title="optimizer/path/costsize.c:152">enable_partition_pruning</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *prunequal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prunequal = <a href="../util/restrictinfo.c.html#L494" title="optimizer/util/restrictinfo.c:494">extract_actual_clauses</a>(rel-&gt;baserestrictinfo, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't currently generate <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> parameterized MergeAppend paths */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(best_path-&gt;path.param_info == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prunequal != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partpruneinfo = <a href="../../partitioning/partprune.c.html#L220" title="partitioning/partprune.c:220">make_partition_pruneinfo</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_path-&gt;subpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prunequal);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node-&gt;mergeplans = subplans;<br/></li>
<li>&nbsp; &nbsp; node-&gt;part_prune_info = partpruneinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="#L6164" title="optimizer/plan/createplan.c:6164">prepare_sort_from_pathkeys</a> added sort columns, but we were told to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * produce either the exact tlist or a narrow tlist, we should get rid of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the sort columns again.&nbsp; We must inject a projection node to do so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tlist_was_changed &amp;&amp; (flags &amp; (<a href="#L69" title="optimizer/plan/createplan.c:69">CP_EXACT_TLIST</a> | <a href="#L70" title="optimizer/plan/createplan.c:70">CP_SMALL_TLIST</a>)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tlist = <a href="../../nodes/list.c.html#L1593" title="nodes/list.c:1593">list_copy_head</a>(plan-&gt;targetlist, orig_tlist_length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2120" title="optimizer/plan/createplan.c:2120">inject_projection_plan</a>(plan, tlist, plan-&gt;parallel_safe);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1587" title="optimizer/plan/createplan.c:1587">create_group_result_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create a Result plan for 'best_path'.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; This is only used for degenerate grouping cases.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Returns a Plan node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Result *<br/></li>
<li><a id="L1587">&#x200c;</a><span class="linkable">create_group_result_plan</span>(PlannerInfo *root, GroupResultPath *best_path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Result&nbsp; &nbsp; &nbsp;&nbsp; *plan;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *quals;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tlist = <a href="#L825" title="optimizer/plan/createplan.c:825">build_path_tlist</a>(root, &amp;best_path-&gt;path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* best_path-&gt;quals is just bare clauses */<br/></li>
<li></span>&nbsp; &nbsp; quals = <a href="#L5315" title="optimizer/plan/createplan.c:5315">order_qual_clauses</a>(root, best_path-&gt;quals);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan = <a href="#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(tlist, (Node *) quals, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;plan-&gt;plan, (Path *) best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1612" title="optimizer/plan/createplan.c:1612">create_project_set_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create a ProjectSet plan for 'best_path'.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Returns a Plan node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ProjectSet *<br/></li>
<li><a id="L1612">&#x200c;</a><span class="linkable">create_project_set_plan</span>(PlannerInfo *root, ProjectSetPath *best_path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ProjectSet *plan;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Since we intend to project, we don't need to constrain child tlist */<br/></li>
<li></span>&nbsp; &nbsp; subplan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;subpath, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tlist = <a href="#L825" title="optimizer/plan/createplan.c:825">build_path_tlist</a>(root, &amp;best_path-&gt;path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan = <a href="#L7009" title="optimizer/plan/createplan.c:7009">make_project_set</a>(tlist, subplan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;plan-&gt;plan, (Path *) best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1638" title="optimizer/plan/createplan.c:1638">create_material_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create a Material plan for 'best_path' and (recursively) plans<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; for its subpaths.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Returns a Plan node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Material *<br/></li>
<li><a id="L1638">&#x200c;</a><span class="linkable">create_material_plan</span>(PlannerInfo *root, MaterialPath *best_path, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Material&nbsp;&nbsp; *plan;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't want <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> excess columns in the materialized tuples, so request<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a smaller tlist.&nbsp; Otherwise, since Material doesn't project, tlist<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * requirements pass through.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; subplan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags | <a href="#L70" title="optimizer/plan/createplan.c:70">CP_SMALL_TLIST</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan = <a href="#L6505" title="optimizer/plan/createplan.c:6505">make_material</a>(subplan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;plan-&gt;plan, (Path *) best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1666" title="optimizer/plan/createplan.c:1666">create_memoize_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create a Memoize plan for 'best_path' and (recursively) plans for its<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; subpaths.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Returns a Plan node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Memoize *<br/></li>
<li><a id="L1666">&#x200c;</a><span class="linkable">create_memoize_plan</span>(PlannerInfo *root, MemoizePath *best_path, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Memoize&nbsp; &nbsp; *plan;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *keyparamids;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *operators;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *collations;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *param_exprs = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nkeys;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; subplan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags | <a href="#L70" title="optimizer/plan/createplan.c:70">CP_SMALL_TLIST</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; param_exprs = (List *) <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_path-&gt;param_exprs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nkeys = list_length(param_exprs);<br/></li>
<li>&nbsp; &nbsp; Assert(nkeys &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; operators = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nkeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; collations = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nkeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; forboth(lc, param_exprs, lc2, best_path-&gt;hash_operators)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *param_expr = (Expr *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opno = lfirst_oid(lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; operators[i] = opno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; collations[i] = <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) param_expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; keyparamids = <a href="../util/clauses.c.html#L5405" title="optimizer/util/clauses.c:5405">pull_paramids</a>((Expr *) param_exprs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan = <a href="#L6568" title="optimizer/plan/createplan.c:6568">make_memoize</a>(subplan, operators, collations, param_exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;singlerow, best_path-&gt;binary_mode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;est_entries, keyparamids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;plan-&gt;plan, (Path *) best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1720" title="optimizer/plan/createplan.c:1720">create_unique_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create a Unique plan for 'best_path' and (recursively) plans<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; for its subpaths.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Returns a Plan node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Plan *<br/></li>
<li><a id="L1720">&#x200c;</a><span class="linkable">create_unique_plan</span>(PlannerInfo *root, UniquePath *best_path, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *in_operators;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *uniq_exprs;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newtlist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextresno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; newitems;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numGroupCols;<br/></li>
<li>&nbsp; &nbsp; AttrNumber *groupColIdx;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *groupCollations;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; groupColPos;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Unique doesn't project, so tlist requirements pass through */<br/></li>
<li></span>&nbsp; &nbsp; subplan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;subpath, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Done if we don't need to do <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> actual unique-ifying */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;umethod == UNIQUE_PATH_NOOP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> subplan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As constructed, the subplan has a &quot;flat&quot; tlist containing just the Vars<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needed here and at <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> levels.&nbsp; The <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> we are supposed to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unique-ify may be expressions in these variables.&nbsp; We have to add <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * such expressions to the subplan's tlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The subplan may have a &quot;physical&quot; tlist if it is a simple scan plan. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're going to sort, this should be reduced to the regular tlist, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that we don't sort more data than we need to.&nbsp; For hashing, the tlist<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should be left as-is if we don't need to add <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> expressions; but if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do have to add expressions, then a projection step will be needed at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * runtime anyway, so we may as well remove unneeded items. Therefore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * newtlist starts from <a href="#L825" title="optimizer/plan/createplan.c:825">build_path_tlist</a>() not just a copy of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subplan's tlist; and we don't install it into the subplan unless we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sorting or stuff has to be added.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; in_operators = best_path-&gt;in_operators;<br/></li>
<li>&nbsp; &nbsp; uniq_exprs = best_path-&gt;uniq_exprs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> modified subplan tlist as just the &quot;required&quot; <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> */<br/></li>
<li></span>&nbsp; &nbsp; newtlist = <a href="#L825" title="optimizer/plan/createplan.c:825">build_path_tlist</a>(root, &amp;best_path-&gt;path);<br/></li>
<li>&nbsp; &nbsp; nextresno = list_length(newtlist) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; newitems = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, uniq_exprs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *uniqexpr = lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../util/tlist.c.html#L79" title="optimizer/util/tlist.c:79">tlist_member</a>(uniqexpr, newtlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tle)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>((Expr *) uniqexpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextresno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newtlist, tle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextresno++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newitems = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use <a href="#L2152" title="optimizer/plan/createplan.c:2152">change_plan_targetlist</a> in case we need to insert a Result node */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newitems || best_path-&gt;umethod == UNIQUE_PATH_SORT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subplan = <a href="#L2152" title="optimizer/plan/createplan.c:2152">change_plan_targetlist</a>(subplan, newtlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_path-&gt;path.parallel_safe);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build control information showing which subplan output columns are to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be examined by the grouping step.&nbsp; Unfortunately we can't <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with the previous loop, since we didn't then know which version of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subplan tlist we'd end up using.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newtlist = subplan-&gt;targetlist;<br/></li>
<li>&nbsp; &nbsp; numGroupCols = list_length(uniq_exprs);<br/></li>
<li>&nbsp; &nbsp; groupColIdx = (AttrNumber *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numGroupCols * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber));<br/></li>
<li>&nbsp; &nbsp; groupCollations = (Oid *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numGroupCols * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; groupColPos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(l, uniq_exprs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *uniqexpr = lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../util/tlist.c.html#L79" title="optimizer/util/tlist.c:79">tlist_member</a>(uniqexpr, newtlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tle)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> unique expression in subplan tlist&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; groupColIdx[groupColPos] = tle-&gt;resno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; groupCollations[groupColPos] = <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) tle-&gt;expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; groupColPos++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;umethod == UNIQUE_PATH_HASH)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *groupOperators;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get the hashable equality operators for the Agg node to use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Normally these are the same as the IN clause operators, but if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * those are cross-type operators then the equality operators are the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ones for the IN clause operators' RHS datatype.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; groupOperators = (Oid *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numGroupCols * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; groupColPos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, in_operators)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in_oper = lfirst_oid(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eq_oper;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/cache/lsyscache.c.html#L410" title="utils/cache/lsyscache.c:410">get_compatible_hash_operators</a>(in_oper, <span class="Constant">NULL</span>, &amp;eq_oper))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> compatible <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> operator for operator </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; in_oper);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; groupOperators[groupColPos++] = eq_oper;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since the Agg node is going to project anyway, we can give it the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * minimum output tlist, without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> stuff we might have added to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subplan tlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L6593" title="optimizer/plan/createplan.c:6593">make_agg</a>(<a href="#L825" title="optimizer/plan/createplan.c:825">build_path_tlist</a>(root, &amp;best_path-&gt;path),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AGG_HASHED,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AGGSPLIT_SIMPLE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numGroupCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; groupColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; groupOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; groupCollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_path-&gt;path.rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subplan);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sortList = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Sort&nbsp; &nbsp; &nbsp;&nbsp; *sort;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create an ORDER BY list to sort the input compatibly */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; groupColPos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, in_operators)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in_oper = lfirst_oid(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eqop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *sortcl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortop = <a href="../../utils/cache/lsyscache.c.html#L305" title="utils/cache/lsyscache.c:305">get_ordering_op_for_equality_op</a>(in_oper, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(sortop))&nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> ordering operator for equality operator </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; in_oper);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The Unique node will need equality operators.&nbsp; Normally these<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are the same as the IN clause operators, but if those are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cross-type operators then the equality operators are the ones<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for the IN clause operators' RHS datatype.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eqop = <a href="../../utils/cache/lsyscache.c.html#L267" title="utils/cache/lsyscache.c:267">get_equality_op_for_ordering_op</a>(sortop, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(eqop))&nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> equality operator for ordering operator </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sortop);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../../parser/parse_relation.c.html#L3439" title="parser/parse_relation.c:3439">get_tle_by_resno</a>(subplan-&gt;targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; groupColIdx[groupColPos]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(tle != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortcl = makeNode(SortGroupClause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortcl-&gt;tleSortGroupRef = <a href="../../parser/parse_clause.c.html#L3592" title="parser/parse_clause.c:3592">assignSortGroupRef</a>(tle,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subplan-&gt;targetlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortcl-&gt;eqop = eqop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortcl-&gt;sortop = sortop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortcl-&gt;nulls_first = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortcl-&gt;hashable = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* no need to make this accurate */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortList = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(sortList, sortcl);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; groupColPos++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sort = <a href="#L6415" title="optimizer/plan/createplan.c:6415">make_sort_from_sortclauses</a>(sortList, subplan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5446" title="optimizer/plan/createplan.c:5446">label_sort_with_costsize</a>(root, sort, -<span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L6699" title="optimizer/plan/createplan.c:6699">make_unique_from_sortclauses</a>((Plan *) sort, sortList);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy cost data from Path to Plan */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(plan, &amp;best_path-&gt;path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1919" title="optimizer/plan/createplan.c:1919">create_gather_plan</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create a Gather plan for 'best_path' and (recursively) plans<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; for its subpaths.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Gather *<br/></li>
<li><a id="L1919">&#x200c;</a><span class="linkable">create_gather_plan</span>(PlannerInfo *root, GatherPath *best_path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Gather&nbsp; &nbsp; &nbsp;&nbsp; *gather_plan;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Push projection down to the child node.&nbsp; That way, the projection work<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is parallelized, and there can be no system columns in the result (they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't travel through a tuple queue because it uses MinimalTuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * representation).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; subplan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;subpath, <a href="#L69" title="optimizer/plan/createplan.c:69">CP_EXACT_TLIST</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tlist = <a href="#L825" title="optimizer/plan/createplan.c:825">build_path_tlist</a>(root, &amp;best_path-&gt;path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; gather_plan = <a href="#L6854" title="optimizer/plan/createplan.c:6854">make_gather</a>(tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;num_workers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/paramassign.c.html#L664" title="optimizer/util/paramassign.c:664">assign_special_exec_param</a>(root),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;single_copy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subplan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;gather_plan-&gt;plan, &amp;best_path-&gt;path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* use parallel mode for parallel plans. */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;glob-&gt;parallelModeNeeded = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> gather_plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1957" title="optimizer/plan/createplan.c:1957">create_gather_merge_plan</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create a Gather Merge plan for 'best_path' and (recursively)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; plans for its subpaths.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> GatherMerge *<br/></li>
<li><a id="L1957">&#x200c;</a><span class="linkable">create_gather_merge_plan</span>(PlannerInfo *root, GatherMergePath *best_path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GatherMerge *gm_plan;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pathkeys = best_path-&gt;path.pathkeys;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist = <a href="#L825" title="optimizer/plan/createplan.c:825">build_path_tlist</a>(root, &amp;best_path-&gt;path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* As with Gather, project away columns in the workers. */<br/></li>
<li></span>&nbsp; &nbsp; subplan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;subpath, <a href="#L69" title="optimizer/plan/createplan.c:69">CP_EXACT_TLIST</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create a shell for a GatherMerge plan. */<br/></li>
<li></span>&nbsp; &nbsp; gm_plan = makeNode(GatherMerge);<br/></li>
<li>&nbsp; &nbsp; gm_plan-&gt;plan.targetlist = tlist;<br/></li>
<li>&nbsp; &nbsp; gm_plan-&gt;num_workers = best_path-&gt;num_workers;<br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;gm_plan-&gt;plan, &amp;best_path-&gt;path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assign the rescan Param. */<br/></li>
<li></span>&nbsp; &nbsp; gm_plan-&gt;rescan_param = <a href="../util/paramassign.c.html#L664" title="optimizer/util/paramassign.c:664">assign_special_exec_param</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Gather Merge is pointless with no pathkeys; use Gather instead. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(pathkeys != NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute sort column info, and adjust subplan's tlist as needed */<br/></li>
<li></span>&nbsp; &nbsp; subplan = <a href="#L6164" title="optimizer/plan/createplan.c:6164">prepare_sort_from_pathkeys</a>(subplan, pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_path-&gt;subpath-&gt;parent-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gm_plan-&gt;sortColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;gm_plan-&gt;numCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;gm_plan-&gt;sortColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;gm_plan-&gt;sortOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;gm_plan-&gt;collations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;gm_plan-&gt;nullsFirst);<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * All gather <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> paths should have already guaranteed the necessary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sort order either by adding an explicit sort node or by using presorted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * input. We can't simply add a sort here on additional pathkeys, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we can't guarantee the sort would be safe. For example, expressions may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be volatile or otherwise parallel unsafe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../path/pathkeys.c.html#L341" title="optimizer/path/pathkeys.c:341">pathkeys_contained_in</a>(pathkeys, best_path-&gt;subpath-&gt;pathkeys))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;gather <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> input not sufficiently sorted&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now insert the subplan under GatherMerge. */<br/></li>
<li></span>&nbsp; &nbsp; gm_plan-&gt;plan.lefttree = subplan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* use parallel mode for parallel plans. */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;glob-&gt;parallelModeNeeded = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> gm_plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2018" title="optimizer/plan/createplan.c:2018">create_projection_plan</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create a plan tree to do a projection step and (recursively) plans<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; for its subpaths.&nbsp; We may need a Result node for the projection,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; but sometimes we can just let the subplan do the work.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Plan *<br/></li>
<li><a id="L2018">&#x200c;</a><span class="linkable">create_projection_plan</span>(PlannerInfo *root, ProjectionPath *best_path, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needs_result_node = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Convert our subpath to a Plan and determine whether we need a Result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In most cases where we don't need to project, creation_projection_path<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will have set dummypp, but not always.&nbsp; First, some createplan.c<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * routines change the tlists of their nodes.&nbsp; (An example is that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1437" title="optimizer/plan/createplan.c:1437">create_merge_append_plan</a> might add resjunk sort columns to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * MergeAppend.)&nbsp; Second, <a href="../util/pathnode.c.html#L2685" title="optimizer/util/pathnode.c:2685">create_projection_path</a> has no way of knowing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * what path node will be placed on top of the projection path and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * therefore can't predict whether it will require an exact tlist. For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * both of these reasons, we have to recheck here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L865" title="optimizer/plan/createplan.c:865">use_physical_tlist</a>(root, &amp;best_path-&gt;path, flags))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Our caller doesn't really care what tlist we return, so we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * actually need to project.&nbsp; However, we may still need to ensure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * proper sortgroupref labels, if the caller cares about those.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; subplan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;subpath, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tlist = subplan-&gt;targetlist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; <a href="#L71" title="optimizer/plan/createplan.c:71">CP_LABEL_TLIST</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/tlist.c.html#L774" title="optimizer/util/tlist.c:774">apply_pathtarget_labeling_to_tlist</a>(tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_path-&gt;path.pathtarget);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L7207" title="optimizer/plan/createplan.c:7207">is_projection_capable_path</a>(best_path-&gt;subpath))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Our caller requires that we return the exact tlist, but no separate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result node is needed because the subpath is projection-capable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Tell <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a> that we're going to ignore the tlist it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * produces.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; subplan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L72" title="optimizer/plan/createplan.c:72">CP_IGNORE_TLIST</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L7257" title="optimizer/plan/createplan.c:7257">is_projection_capable_plan</a>(subplan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tlist = <a href="#L825" title="optimizer/plan/createplan.c:825">build_path_tlist</a>(root, &amp;best_path-&gt;path);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It looks like we need a result node, unless by good fortune the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * requested tlist is exactly the one the child wants to produce.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; subplan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;subpath, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tlist = <a href="#L825" title="optimizer/plan/createplan.c:825">build_path_tlist</a>(root, &amp;best_path-&gt;path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; needs_result_node = !<a href="../util/tlist.c.html#L218" title="optimizer/util/tlist.c:218">tlist_same_exprs</a>(tlist, subplan-&gt;targetlist);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we make a different decision about whether to include a Result node<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than <a href="../util/pathnode.c.html#L2685" title="optimizer/util/pathnode.c:2685">create_projection_path</a> did, we'll have made slightly wrong cost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimates; but label the plan with the cost estimates we actually used,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not &quot;corrected&quot; ones.&nbsp; (</span><span class="Todo">XXX</span><span class="Comment"> this could be cleaned up if we moved more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the sortcolumn setup logic into Path creation, but that would add<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expense to creating Paths we might end up not using.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!needs_result_node)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't need a separate Result, just assign tlist to subplan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; plan = subplan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;targetlist = tlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Label plan with the estimated costs we actually used */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;startup_cost = best_path-&gt;path.startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;total_cost = best_path-&gt;path.total_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;plan_rows = best_path-&gt;path.rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;plan_width = best_path-&gt;path.pathtarget-&gt;width;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;parallel_safe = best_path-&gt;path.parallel_safe;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... but don't change subplan's parallel_aware flag */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We need a Result node */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(tlist, <span class="Constant">NULL</span>, subplan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(plan, (Path *) best_path);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2120" title="optimizer/plan/createplan.c:2120">inject_projection_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> a Result node to do a projection step.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used in a few places where we decide on-the-fly that we need a<br/></li>
<li></span><span class="Comment"> * projection step as part of the tree generated for some Path node.<br/></li>
<li></span><span class="Comment"> * We should try to get rid of this in favor of doing it more honestly.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * One reason it's ugly is we have to be told the right parallel_safe marking<br/></li>
<li></span><span class="Comment"> * to apply (since the tlist might be unsafe even if the child plan is safe).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Plan *<br/></li>
<li><a id="L2120">&#x200c;</a><span class="linkable">inject_projection_plan</span>(Plan *subplan, List *tlist, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> parallel_safe)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan = (Plan *) <a href="#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(tlist, <span class="Constant">NULL</span>, subplan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In principle, we should <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> tlist eval cost plus cpu_per_tuple per<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * row for the Result node.&nbsp; But the former has probably been factored in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already and the latter was not accounted for during Path construction,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so being formally correct might just make the EXPLAIN output look less<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consistent not more so.&nbsp; Hence, just copy the subplan's cost.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5424" title="optimizer/plan/createplan.c:5424">copy_plan_costsize</a>(plan, subplan);<br/></li>
<li>&nbsp; &nbsp; plan-&gt;parallel_safe = parallel_safe;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2152" title="optimizer/plan/createplan.c:2152">change_plan_targetlist</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Externally available wrapper for <a href="#L2120" title="optimizer/plan/createplan.c:2120">inject_projection_plan</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is meant for use by FDW plan-generation <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, which might<br/></li>
<li></span><span class="Comment"> * want to adjust the tlist computed by some subplan tree.&nbsp; In general,<br/></li>
<li></span><span class="Comment"> * a Result node is needed to compute the new tlist, but we can <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a><br/></li>
<li></span><span class="Comment"> * some cases.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In most cases, tlist_parallel_safe can just be passed as the parallel_safe<br/></li>
<li></span><span class="Comment"> * flag of the FDW's own Path node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Plan *<br/></li>
<li><a id="L2152">&#x200c;</a><span class="linkable">change_plan_targetlist</span>(Plan *subplan, List *tlist, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tlist_parallel_safe)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the top plan node can't do projections and its existing target list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * isn't already what we need, we need to add a Result node to <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * along.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L7257" title="optimizer/plan/createplan.c:7257">is_projection_capable_plan</a>(subplan) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../util/tlist.c.html#L218" title="optimizer/util/tlist.c:218">tlist_same_exprs</a>(tlist, subplan-&gt;targetlist))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subplan = <a href="#L2120" title="optimizer/plan/createplan.c:2120">inject_projection_plan</a>(subplan, tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subplan-&gt;parallel_safe &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tlist_parallel_safe);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Else we can just replace the plan node's tlist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; subplan-&gt;targetlist = tlist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subplan-&gt;parallel_safe &amp;= tlist_parallel_safe;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> subplan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2180" title="optimizer/plan/createplan.c:2180">create_sort_plan</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create a Sort plan for 'best_path' and (recursively) plans<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; for its subpaths.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Sort *<br/></li>
<li><a id="L2180">&#x200c;</a><span class="linkable">create_sort_plan</span>(PlannerInfo *root, SortPath *best_path, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Sort&nbsp; &nbsp; &nbsp;&nbsp; *plan;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't want <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> excess columns in the sorted tuples, so request a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * smaller tlist.&nbsp; Otherwise, since Sort doesn't project, tlist<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * requirements pass through.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; subplan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags | <a href="#L70" title="optimizer/plan/createplan.c:70">CP_SMALL_TLIST</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L6346" title="optimizer/plan/createplan.c:6346">make_sort_from_pathkeys</a> indirectly calls <a href="../path/equivclass.c.html#L771" title="optimizer/path/equivclass.c:771">find_ec_member_matching_expr</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which will ignore <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> child EC members that don't belong to the given<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relids. Thus, if this sort path is based on a child relation, we must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pass its relids.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; plan = <a href="#L6346" title="optimizer/plan/createplan.c:6346">make_sort_from_pathkeys</a>(subplan, best_path-&gt;path.pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IS_OTHER_REL(best_path-&gt;subpath-&gt;parent) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_path-&gt;path.parent-&gt;relids : <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;plan-&gt;plan, (Path *) best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2214" title="optimizer/plan/createplan.c:2214">create_incrementalsort_plan</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Do the same as <a href="#L2180" title="optimizer/plan/createplan.c:2180">create_sort_plan</a>, but create IncrementalSort plan.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> IncrementalSort *<br/></li>
<li><a id="L2214">&#x200c;</a><span class="linkable">create_incrementalsort_plan</span>(PlannerInfo *root, IncrementalSortPath *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IncrementalSort *plan;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* See comments in <a href="#L2180" title="optimizer/plan/createplan.c:2180">create_sort_plan</a>() above */<br/></li>
<li></span>&nbsp; &nbsp; subplan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;spath.subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags | <a href="#L70" title="optimizer/plan/createplan.c:70">CP_SMALL_TLIST</a>);<br/></li>
<li>&nbsp; &nbsp; plan = <a href="#L6381" title="optimizer/plan/createplan.c:6381">make_incrementalsort_from_pathkeys</a>(subplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;spath.path.pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IS_OTHER_REL(best_path-&gt;spath.subpath-&gt;parent) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;spath.path.parent-&gt;relids : <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;nPresortedCols);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;plan-&gt;sort.plan, (Path *) best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2241" title="optimizer/plan/createplan.c:2241">create_group_plan</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create a Group plan for 'best_path' and (recursively) plans<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; for its subpaths.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Group *<br/></li>
<li><a id="L2241">&#x200c;</a><span class="linkable">create_group_plan</span>(PlannerInfo *root, GroupPath *best_path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Group&nbsp; &nbsp; &nbsp;&nbsp; *plan;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *quals;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Group can project, so no need to be terribly picky about child tlist,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but we do need grouping columns to be available<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; subplan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;subpath, <a href="#L71" title="optimizer/plan/createplan.c:71">CP_LABEL_TLIST</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tlist = <a href="#L825" title="optimizer/plan/createplan.c:825">build_path_tlist</a>(root, &amp;best_path-&gt;path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; quals = <a href="#L5315" title="optimizer/plan/createplan.c:5315">order_qual_clauses</a>(root, best_path-&gt;qual);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan = <a href="#L6669" title="optimizer/plan/createplan.c:6669">make_group</a>(tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; quals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(best_path-&gt;groupClause),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/tlist.c.html#L514" title="optimizer/util/tlist.c:514">extract_grouping_cols</a>(best_path-&gt;groupClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subplan-&gt;targetlist),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/tlist.c.html#L463" title="optimizer/util/tlist.c:463">extract_grouping_ops</a>(best_path-&gt;groupClause),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/tlist.c.html#L489" title="optimizer/util/tlist.c:489">extract_grouping_collations</a>(best_path-&gt;groupClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subplan-&gt;targetlist),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subplan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;plan-&gt;plan, (Path *) best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2280" title="optimizer/plan/createplan.c:2280">create_upper_unique_plan</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create a Unique plan for 'best_path' and (recursively) plans<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; for its subpaths.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Unique *<br/></li>
<li><a id="L2280">&#x200c;</a><span class="linkable">create_upper_unique_plan</span>(PlannerInfo *root, UpperUniquePath *best_path, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Unique&nbsp; &nbsp; &nbsp;&nbsp; *plan;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unique doesn't project, so tlist requirements pass through; moreover we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need grouping columns to be labeled.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; subplan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags | <a href="#L71" title="optimizer/plan/createplan.c:71">CP_LABEL_TLIST</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan = <a href="#L6748" title="optimizer/plan/createplan.c:6748">make_unique_from_pathkeys</a>(subplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_path-&gt;path.pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_path-&gt;numkeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;plan-&gt;plan, (Path *) best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2308" title="optimizer/plan/createplan.c:2308">create_agg_plan</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create an Agg plan for 'best_path' and (recursively) plans<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; for its subpaths.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Agg *<br/></li>
<li><a id="L2308">&#x200c;</a><span class="linkable">create_agg_plan</span>(PlannerInfo *root, AggPath *best_path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Agg&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *plan;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *quals;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Agg can project, so no need to be terribly picky about child tlist, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we do need grouping columns to be available<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; subplan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;subpath, <a href="#L71" title="optimizer/plan/createplan.c:71">CP_LABEL_TLIST</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tlist = <a href="#L825" title="optimizer/plan/createplan.c:825">build_path_tlist</a>(root, &amp;best_path-&gt;path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; quals = <a href="#L5315" title="optimizer/plan/createplan.c:5315">order_qual_clauses</a>(root, best_path-&gt;qual);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan = <a href="#L6593" title="optimizer/plan/createplan.c:6593">make_agg</a>(tlist, quals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;aggstrategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;aggsplit,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(best_path-&gt;groupClause),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/tlist.c.html#L514" title="optimizer/util/tlist.c:514">extract_grouping_cols</a>(best_path-&gt;groupClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subplan-&gt;targetlist),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/tlist.c.html#L463" title="optimizer/util/tlist.c:463">extract_grouping_ops</a>(best_path-&gt;groupClause),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/tlist.c.html#L489" title="optimizer/util/tlist.c:489">extract_grouping_collations</a>(best_path-&gt;groupClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subplan-&gt;targetlist),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;numGroups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;transitionSpace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subplan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;plan-&gt;plan, (Path *) best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a groupclause for a collection of grouping sets, produce the<br/></li>
<li></span><span class="Comment"> * corresponding groupColIdx.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * root-&gt;grouping_map <a href="../../utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a> the tleSortGroupRef to the actual column position in<br/></li>
<li></span><span class="Comment"> * the input tuple. So we get the ref from the entries in the groupclause and<br/></li>
<li></span><span class="Comment"> * look them up there.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> AttrNumber *<br/></li>
<li><a id="L2354">&#x200c;</a><span class="linkable">remap_groupColIdx</span>(PlannerInfo *root, List *groupClause)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AttrNumber *grouping_map = root-&gt;grouping_map;<br/></li>
<li>&nbsp; &nbsp; AttrNumber *new_grpColIdx;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(grouping_map);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; new_grpColIdx = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber) * list_length(groupClause));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, groupClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *clause = lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_grpColIdx[i++] = grouping_map[clause-&gt;tleSortGroupRef];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> new_grpColIdx;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2392" title="optimizer/plan/createplan.c:2392">create_groupingsets_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create a plan for 'best_path' and (recursively) plans<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; for its subpaths.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; What we emit is an Agg plan with some vestigial Agg and Sort nodes<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; hanging off the side.&nbsp; The top Agg implements the last grouping set<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; specified in the GroupingSetsPath, and <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> additional grouping sets<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; each give rise to a subsidiary Agg and Sort node in the top Agg's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &quot;chain&quot; list.&nbsp; These nodes don't participate in the plan directly,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; but they are a convenient way to represent the required data for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the extra steps.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Returns a Plan node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Plan *<br/></li>
<li><a id="L2392">&#x200c;</a><span class="linkable">create_groupingsets_plan</span>(PlannerInfo *root, GroupingSetsPath *best_path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Agg&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *plan;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *rollups = best_path-&gt;rollups;<br/></li>
<li>&nbsp; &nbsp; AttrNumber *grouping_map;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxref;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *chain;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shouldn't get here without grouping sets */<br/></li>
<li></span>&nbsp; &nbsp; Assert(root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupingSets);<br/></li>
<li>&nbsp; &nbsp; Assert(rollups != NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Agg can project, so no need to be terribly picky about child tlist, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we do need grouping columns to be available<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; subplan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;subpath, <a href="#L71" title="optimizer/plan/createplan.c:71">CP_LABEL_TLIST</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute the mapping from tleSortGroupRef to column index in the child's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tlist.&nbsp; First, identify max SortGroupRef in groupClause, for array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sizing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; maxref = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, root-&gt;processed_groupClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *gc = (SortGroupClause *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (gc-&gt;tleSortGroupRef &gt; maxref)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxref = gc-&gt;tleSortGroupRef;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; grouping_map = (AttrNumber *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>((maxref + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now look up the column numbers in the child's tlist */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, root-&gt;processed_groupClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *gc = (SortGroupClause *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = <a href="../util/tlist.c.html#L367" title="optimizer/util/tlist.c:367">get_sortgroupclause_tle</a>(gc, subplan-&gt;targetlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; grouping_map[gc-&gt;tleSortGroupRef] = tle-&gt;resno;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During setrefs.c, we'll need the grouping_map to fix up the cols lists<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in GroupingFunc nodes.&nbsp; Save it for setrefs.c to use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(root-&gt;grouping_map == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; root-&gt;grouping_map = grouping_map;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate the side nodes that describe the other sort and group<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operations besides the top one.&nbsp; Note that we don't worry about putting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * accurate cost estimates in the side nodes; only the topmost Agg node's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * costs will be shown by EXPLAIN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; chain = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(rollups) &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_first_sort = ((RollupData *) linitial(rollups))-&gt;is_hashed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; for_each_from(lc, rollups, <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RollupData *rollup = lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber *new_grpColIdx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *sort_plan = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *agg_plan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStrategy strat;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_grpColIdx = <a href="#L2354" title="optimizer/plan/createplan.c:2354">remap_groupColIdx</a>(root, rollup-&gt;groupClause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rollup-&gt;is_hashed &amp;&amp; !is_first_sort)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sort_plan = (Plan *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6464" title="optimizer/plan/createplan.c:6464">make_sort_from_groupcols</a>(rollup-&gt;groupClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new_grpColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subplan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rollup-&gt;is_hashed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_first_sort = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rollup-&gt;is_hashed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strat = AGG_HASHED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (linitial(rollup-&gt;gsets) == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strat = AGG_PLAIN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strat = AGG_SORTED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; agg_plan = (Plan *) <a href="#L6593" title="optimizer/plan/createplan.c:6593">make_agg</a>(NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strat,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AGGSPLIT_SIMPLE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_length((List *) linitial(rollup-&gt;gsets)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new_grpColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/tlist.c.html#L463" title="optimizer/util/tlist.c:463">extract_grouping_ops</a>(rollup-&gt;groupClause),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/tlist.c.html#L489" title="optimizer/util/tlist.c:489">extract_grouping_collations</a>(rollup-&gt;groupClause, subplan-&gt;targetlist),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rollup-&gt;gsets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rollup-&gt;numGroups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_path-&gt;transitionSpace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sort_plan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remove stuff we don't need to avoid bloating debug output.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sort_plan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sort_plan-&gt;targetlist = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sort_plan-&gt;lefttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chain = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(chain, agg_plan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now make the real Agg node<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RollupData *rollup = linitial(rollups);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber *top_grpColIdx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numGroupCols;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; top_grpColIdx = <a href="#L2354" title="optimizer/plan/createplan.c:2354">remap_groupColIdx</a>(root, rollup-&gt;groupClause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numGroupCols = list_length((List *) linitial(rollup-&gt;gsets));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan = <a href="#L6593" title="optimizer/plan/createplan.c:6593">make_agg</a>(<a href="#L825" title="optimizer/plan/createplan.c:825">build_path_tlist</a>(root, &amp;best_path-&gt;path),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;aggstrategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AGGSPLIT_SIMPLE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numGroupCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; top_grpColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/tlist.c.html#L463" title="optimizer/util/tlist.c:463">extract_grouping_ops</a>(rollup-&gt;groupClause),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/tlist.c.html#L489" title="optimizer/util/tlist.c:489">extract_grouping_collations</a>(rollup-&gt;groupClause, subplan-&gt;targetlist),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;gsets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chain,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;numGroups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;transitionSpace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subplan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy cost data from Path to Plan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;plan-&gt;plan, &amp;best_path-&gt;path);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Plan *) plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2550" title="optimizer/plan/createplan.c:2550">create_minmaxagg_plan</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create a Result plan for 'best_path' and (recursively) plans<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; for its subpaths.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Result *<br/></li>
<li><a id="L2550">&#x200c;</a><span class="linkable">create_minmaxagg_plan</span>(PlannerInfo *root, MinMaxAggPath *best_path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Result&nbsp; &nbsp; &nbsp;&nbsp; *plan;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare an <a href="../../executor/execMain.c.html#L833" title="executor/execMain.c:833">InitPlan</a> for each aggregate's subquery. */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, best_path-&gt;mmaggregates)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MinMaxAggInfo *mminfo = (MinMaxAggInfo *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlannerInfo *subroot = mminfo-&gt;subroot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *subparse = subroot-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Generate the plan for the subquery. We already have a Path, but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have to convert it to a Plan and attach a LIMIT node above it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since we are entering a different <a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> context (subroot),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recurse to <a href="#L337" title="optimizer/plan/createplan.c:337">create_plan</a> not <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; plan = <a href="#L337" title="optimizer/plan/createplan.c:337">create_plan</a>(subroot, mminfo-&gt;path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L6960" title="optimizer/plan/createplan.c:6960">make_limit</a>(plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subparse-&gt;limitOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subparse-&gt;limitCount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subparse-&gt;limitOption,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must apply correct cost/width data to Limit node */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;startup_cost = mminfo-&gt;path-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;total_cost = mminfo-&gt;pathcost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;plan_rows = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;plan_width = mminfo-&gt;path-&gt;pathtarget-&gt;width;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;parallel_safe = mminfo-&gt;path-&gt;parallel_safe;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Convert the plan into an <a href="../../executor/execMain.c.html#L833" title="executor/execMain.c:833">InitPlan</a> in the outer query. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="subselect.c.html#L3017" title="optimizer/plan/subselect.c:3017">SS_make_initplan_from_plan</a>(root, subroot, plan, mminfo-&gt;param);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Generate the output plan --- basically just a Result */<br/></li>
<li></span>&nbsp; &nbsp; tlist = <a href="#L825" title="optimizer/plan/createplan.c:825">build_path_tlist</a>(root, &amp;best_path-&gt;path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan = <a href="#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(tlist, (Node *) best_path-&gt;quals, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;plan-&gt;plan, (Path *) best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During setrefs.c, we'll need to replace references to the Agg nodes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with <a href="../../executor/execMain.c.html#L833" title="executor/execMain.c:833">InitPlan</a> output params.&nbsp; (We can't just do that locally in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * MinMaxAgg node, because path nodes above here may have Agg references<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as well.)&nbsp; Save the mmaggregates list to tell setrefs.c to do that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(root-&gt;minmax_aggs == NIL);<br/></li>
<li>&nbsp; &nbsp; root-&gt;minmax_aggs = best_path-&gt;mmaggregates;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2616" title="optimizer/plan/createplan.c:2616">create_windowagg_plan</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create a WindowAgg plan for 'best_path' and (recursively) plans<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; for its subpaths.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> WindowAgg *<br/></li>
<li><a id="L2616">&#x200c;</a><span class="linkable">create_windowagg_plan</span>(PlannerInfo *root, WindowAggPath *best_path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WindowAgg&nbsp; *plan;<br/></li>
<li>&nbsp; &nbsp; WindowClause *wc = best_path-&gt;winclause;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numPart = list_length(wc-&gt;partitionClause);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numOrder = list_length(wc-&gt;orderClause);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partNumCols;<br/></li>
<li>&nbsp; &nbsp; AttrNumber *partColIdx;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *partOperators;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *partCollations;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ordNumCols;<br/></li>
<li>&nbsp; &nbsp; AttrNumber *ordColIdx;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *ordOperators;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *ordCollations;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Choice of tlist here is motivated by the fact that WindowAgg will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * storing the input rows of window frames in a tuplestore; it therefore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * behooves us to request a small tlist to avoid wasting space. We do of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * course need grouping columns to be available.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; subplan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="optimizer/plan/createplan.c:71">CP_LABEL_TLIST</a> | <a href="#L70" title="optimizer/plan/createplan.c:70">CP_SMALL_TLIST</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tlist = <a href="#L825" title="optimizer/plan/createplan.c:825">build_path_tlist</a>(root, &amp;best_path-&gt;path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Convert SortGroupClause lists into arrays of attr indexes and equality<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operators, as wanted by executor.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; partColIdx = (AttrNumber *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber) * numPart);<br/></li>
<li>&nbsp; &nbsp; partOperators = (Oid *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * numPart);<br/></li>
<li>&nbsp; &nbsp; partCollations = (Oid *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * numPart);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; partNumCols = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, wc-&gt;partitionClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *sgc = (SortGroupClause *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = <a href="../util/tlist.c.html#L367" title="optimizer/util/tlist.c:367">get_sortgroupclause_tle</a>(sgc, subplan-&gt;targetlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(OidIsValid(sgc-&gt;eqop));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partColIdx[partNumCols] = tle-&gt;resno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partOperators[partNumCols] = sgc-&gt;eqop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partCollations[partNumCols] = <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) tle-&gt;expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partNumCols++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ordColIdx = (AttrNumber *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber) * numOrder);<br/></li>
<li>&nbsp; &nbsp; ordOperators = (Oid *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * numOrder);<br/></li>
<li>&nbsp; &nbsp; ordCollations = (Oid *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * numOrder);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ordNumCols = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, wc-&gt;orderClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *sgc = (SortGroupClause *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = <a href="../util/tlist.c.html#L367" title="optimizer/util/tlist.c:367">get_sortgroupclause_tle</a>(sgc, subplan-&gt;targetlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(OidIsValid(sgc-&gt;eqop));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ordColIdx[ordNumCols] = tle-&gt;resno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ordOperators[ordNumCols] = sgc-&gt;eqop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ordCollations[ordNumCols] = <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) tle-&gt;expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ordNumCols++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And finally we can make the WindowAgg node */<br/></li>
<li></span>&nbsp; &nbsp; plan = <a href="#L6627" title="optimizer/plan/createplan.c:6627">make_windowagg</a>(tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wc-&gt;winref,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partNumCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partCollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ordNumCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ordColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ordOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ordCollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wc-&gt;frameOptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wc-&gt;startOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wc-&gt;endOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wc-&gt;startInRangeFunc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wc-&gt;endInRangeFunc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wc-&gt;inRangeColl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wc-&gt;inRangeAsc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wc-&gt;inRangeNullsFirst,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wc-&gt;runCondition,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;topwindow,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subplan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;plan-&gt;plan, (Path *) best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2719" title="optimizer/plan/createplan.c:2719">create_setop_plan</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create a SetOp plan for 'best_path' and (recursively) plans<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; for its subpaths.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> SetOp *<br/></li>
<li><a id="L2719">&#x200c;</a><span class="linkable">create_setop_plan</span>(PlannerInfo *root, SetOpPath *best_path, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SetOp&nbsp; &nbsp; &nbsp;&nbsp; *plan;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; numGroups;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SetOp doesn't project, so tlist requirements pass through; moreover we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need grouping columns to be labeled.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; subplan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags | <a href="#L71" title="optimizer/plan/createplan.c:71">CP_LABEL_TLIST</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert numGroups to long int --- but 'ware overflow! */<br/></li>
<li></span>&nbsp; &nbsp; numGroups = <a href="../path/costsize.c.html#L254" title="optimizer/path/costsize.c:254">clamp_cardinality_to_long</a>(best_path-&gt;numGroups);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan = <a href="#L6883" title="optimizer/plan/createplan.c:6883">make_setop</a>(best_path-&gt;cmd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;distinctList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;flagColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;firstFlag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numGroups);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;plan-&gt;plan, (Path *) best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2755" title="optimizer/plan/createplan.c:2755">create_recursiveunion_plan</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create a RecursiveUnion plan for 'best_path' and (recursively) plans<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; for its subpaths.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> RecursiveUnion *<br/></li>
<li><a id="L2755">&#x200c;</a><span class="linkable">create_recursiveunion_plan</span>(PlannerInfo *root, RecursiveUnionPath *best_path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RecursiveUnion *plan;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *leftplan;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *rightplan;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; numGroups;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Need both children to produce same tlist, so force it */<br/></li>
<li></span>&nbsp; &nbsp; leftplan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;leftpath, <a href="#L69" title="optimizer/plan/createplan.c:69">CP_EXACT_TLIST</a>);<br/></li>
<li>&nbsp; &nbsp; rightplan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;rightpath, <a href="#L69" title="optimizer/plan/createplan.c:69">CP_EXACT_TLIST</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tlist = <a href="#L825" title="optimizer/plan/createplan.c:825">build_path_tlist</a>(root, &amp;best_path-&gt;path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert numGroups to long int --- but 'ware overflow! */<br/></li>
<li></span>&nbsp; &nbsp; numGroups = <a href="../path/costsize.c.html#L254" title="optimizer/path/costsize.c:254">clamp_cardinality_to_long</a>(best_path-&gt;numGroups);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan = <a href="#L5862" title="optimizer/plan/createplan.c:5862">make_recursive_union</a>(tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;wtParam,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;distinctList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numGroups);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;plan-&gt;plan, (Path *) best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2791" title="optimizer/plan/createplan.c:2791">create_lockrows_plan</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create a LockRows plan for 'best_path' and (recursively) plans<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; for its subpaths.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> LockRows *<br/></li>
<li><a id="L2791">&#x200c;</a><span class="linkable">create_lockrows_plan</span>(PlannerInfo *root, LockRowsPath *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LockRows&nbsp;&nbsp; *plan;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* LockRows doesn't project, so tlist requirements pass through */<br/></li>
<li></span>&nbsp; &nbsp; subplan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;subpath, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan = <a href="#L6939" title="optimizer/plan/createplan.c:6939">make_lockrows</a>(subplan, best_path-&gt;rowMarks, best_path-&gt;epqParam);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;plan-&gt;plan, (Path *) best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2814" title="optimizer/plan/createplan.c:2814">create_modifytable_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create a ModifyTable plan for 'best_path'.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Returns a Plan node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ModifyTable *<br/></li>
<li><a id="L2814">&#x200c;</a><span class="linkable">create_modifytable_plan</span>(PlannerInfo *root, ModifyTablePath *best_path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ModifyTable *plan;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *subpath = best_path-&gt;subpath;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Subplan must produce exactly the specified tlist */<br/></li>
<li></span>&nbsp; &nbsp; subplan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, subpath, <a href="#L69" title="optimizer/plan/createplan.c:69">CP_EXACT_TLIST</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Transfer resname/resjunk labeling, too, to keep executor happy */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/tlist.c.html#L318" title="optimizer/util/tlist.c:318">apply_tlist_labeling</a>(subplan-&gt;targetlist, root-&gt;processed_tlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan = <a href="#L7028" title="optimizer/plan/createplan.c:7028">make_modifytable</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;operation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;canSetTag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;nominalRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;rootRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;partColsUpdated,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;resultRelations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;updateColnosLists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;withCheckOptionLists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;returningLists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;rowMarks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;onconflict,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;mergeActionLists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;mergeJoinConditions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;epqParam);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;plan-&gt;plan, &amp;best_path-&gt;path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2855" title="optimizer/plan/createplan.c:2855">create_limit_plan</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create a Limit plan for 'best_path' and (recursively) plans<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; for its subpaths.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Limit *<br/></li>
<li><a id="L2855">&#x200c;</a><span class="linkable">create_limit_plan</span>(PlannerInfo *root, LimitPath *best_path, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Limit&nbsp; &nbsp; &nbsp;&nbsp; *plan;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numUniqkeys = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; AttrNumber *uniqColIdx = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *uniqOperators = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *uniqCollations = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Limit doesn't project, so tlist requirements pass through */<br/></li>
<li></span>&nbsp; &nbsp; subplan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;subpath, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Extract information necessary for comparing rows for WITH TIES. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;limitOption == LIMIT_OPTION_WITH_TIES)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numUniqkeys = list_length(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;sortClause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uniqColIdx = (AttrNumber *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numUniqkeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uniqOperators = (Oid *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numUniqkeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uniqCollations = (Oid *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numUniqkeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numUniqkeys = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;sortClause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *sortcl = (SortGroupClause *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = <a href="../util/tlist.c.html#L367" title="optimizer/util/tlist.c:367">get_sortgroupclause_tle</a>(sortcl, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;targetList);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uniqColIdx[numUniqkeys] = tle-&gt;resno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uniqOperators[numUniqkeys] = sortcl-&gt;eqop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uniqCollations[numUniqkeys] = <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) tle-&gt;expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numUniqkeys++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan = <a href="#L6960" title="optimizer/plan/createplan.c:6960">make_limit</a>(subplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;limitOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;limitCount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;limitOption,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numUniqkeys, uniqColIdx, uniqOperators, uniqCollations);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;plan-&gt;plan, (Path *) best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; BASE-RELATION SCAN METHODS<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2916" title="optimizer/plan/createplan.c:2916">create_seqscan_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Returns a seqscan plan for the base relation scanned by 'best_path'<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; with restriction clauses 'scan_clauses' and targetlist 'tlist'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> SeqScan *<br/></li>
<li><a id="L2916">&#x200c;</a><span class="linkable">create_seqscan_plan</span>(PlannerInfo *root, Path *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *tlist, List *scan_clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SeqScan&nbsp; &nbsp; *scan_plan;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; scan_relid = best_path-&gt;parent-&gt;relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* it should be a base rel... */<br/></li>
<li></span>&nbsp; &nbsp; Assert(scan_relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(best_path-&gt;parent-&gt;rtekind == RTE_RELATION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort clauses into best execution order */<br/></li>
<li></span>&nbsp; &nbsp; scan_clauses = <a href="#L5315" title="optimizer/plan/createplan.c:5315">order_qual_clauses</a>(root, scan_clauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */<br/></li>
<li></span>&nbsp; &nbsp; scan_clauses = <a href="../util/restrictinfo.c.html#L494" title="optimizer/util/restrictinfo.c:494">extract_actual_clauses</a>(scan_clauses, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Replace <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer-relation variables with nestloop params */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;param_info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan_clauses = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) scan_clauses);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan_plan = <a href="#L5508" title="optimizer/plan/createplan.c:5508">make_seqscan</a>(tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scan_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scan_relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;scan_plan-&gt;scan.plan, best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> scan_plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2954" title="optimizer/plan/createplan.c:2954">create_samplescan_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Returns a samplescan plan for the base relation scanned by 'best_path'<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; with restriction clauses 'scan_clauses' and targetlist 'tlist'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> SampleScan *<br/></li>
<li><a id="L2954">&#x200c;</a><span class="linkable">create_samplescan_plan</span>(PlannerInfo *root, Path *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *tlist, List *scan_clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SampleScan *scan_plan;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; scan_relid = best_path-&gt;parent-&gt;relid;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li>&nbsp; &nbsp; TableSampleClause *tsc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* it should be a base rel with a tablesample clause... */<br/></li>
<li></span>&nbsp; &nbsp; Assert(scan_relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; rte = planner_rt_fetch(scan_relid, root);<br/></li>
<li>&nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_RELATION);<br/></li>
<li>&nbsp; &nbsp; tsc = rte-&gt;tablesample;<br/></li>
<li>&nbsp; &nbsp; Assert(tsc != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort clauses into best execution order */<br/></li>
<li></span>&nbsp; &nbsp; scan_clauses = <a href="#L5315" title="optimizer/plan/createplan.c:5315">order_qual_clauses</a>(root, scan_clauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */<br/></li>
<li></span>&nbsp; &nbsp; scan_clauses = <a href="../util/restrictinfo.c.html#L494" title="optimizer/util/restrictinfo.c:494">extract_actual_clauses</a>(scan_clauses, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Replace <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer-relation variables with nestloop params */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;param_info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan_clauses = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) scan_clauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tsc = (TableSampleClause *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) tsc);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan_plan = <a href="#L5525" title="optimizer/plan/createplan.c:5525">make_samplescan</a>(tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan_relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tsc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;scan_plan-&gt;scan.plan, best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> scan_plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3005" title="optimizer/plan/createplan.c:3005">create_indexscan_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Returns an indexscan plan for the base relation scanned by 'best_path'<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; with restriction clauses 'scan_clauses' and targetlist 'tlist'.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use this for both plain IndexScans and IndexOnlyScans, because the<br/></li>
<li></span><span class="Comment"> * qual preprocessing work is the same for both.&nbsp; Note that the caller tells<br/></li>
<li></span><span class="Comment"> * us which to build --- we don't look at best_path-&gt;path.pathtype, because<br/></li>
<li></span><span class="Comment"> * <a href="#L3331" title="optimizer/plan/createplan.c:3331">create_bitmap_subplan</a> needs to be able to override the prior decision.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Scan *<br/></li>
<li><a id="L3005">&#x200c;</a><span class="linkable">create_indexscan_plan</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexPath *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *scan_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> indexonly)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Scan&nbsp; &nbsp; &nbsp;&nbsp; *scan_plan;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexclauses = best_path-&gt;indexclauses;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexorderbys = best_path-&gt;indexorderbys;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; baserelid = best_path-&gt;path.parent-&gt;relid;<br/></li>
<li>&nbsp; &nbsp; IndexOptInfo *indexinfo = best_path-&gt;indexinfo;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexoid = indexinfo-&gt;indexoid;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *qpqual;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *stripped_indexquals;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *fixed_indexquals;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *fixed_indexorderbys;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexorderbyops = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* it should be a base rel... */<br/></li>
<li></span>&nbsp; &nbsp; Assert(baserelid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(best_path-&gt;path.parent-&gt;rtekind == RTE_RELATION);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check the scan direction is valid */<br/></li>
<li></span>&nbsp; &nbsp; Assert(best_path-&gt;indexscandir == ForwardScanDirection ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_path-&gt;indexscandir == BackwardScanDirection);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Extract the index qual expressions (stripped of RestrictInfos) from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * IndexClauses list, and prepare a copy with index Vars substituted for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table Vars.&nbsp; (This step also does <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a> on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fixed_indexquals.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5022" title="optimizer/plan/createplan.c:5022">fix_indexqual_references</a>(root, best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;stripped_indexquals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;fixed_indexquals);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Likewise fix up index attr references in the ORDER BY expressions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fixed_indexorderbys = <a href="#L5063" title="optimizer/plan/createplan.c:5063">fix_indexorderby_references</a>(root, best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The qpqual list must contain all restrictions not automatically handled<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by the index, other than pseudoconstant clauses which will be handled<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by a separate gating plan node.&nbsp; All the predicates in the indexquals<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will be checked (either by the index itself, or by nodeIndexscan.c),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> &quot;special&quot; operators involved then they must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * included in qpqual.&nbsp; The upshot is that qpqual must contain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan_clauses minus whatever appears in indexquals.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../path/equivclass.c.html#L3308" title="optimizer/path/equivclass.c:3308">is_redundant_with_indexclauses</a>() detects cases where a scan clause is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * present in the indexclauses list or is generated from the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * EquivalenceClass as some indexclause, and is therefore redundant with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it, though not <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>.&nbsp; (The latter happens when indxpath.c prefers a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * different derived equality than what <a href="../path/equivclass.c.html#L1392" title="optimizer/path/equivclass.c:1392">generate_join_implied_equalities</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * picked for a parameterized scan's ppi_clauses.)&nbsp; Note that it will not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * match to lossy index clauses, which is critical because we have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * include the original clause in qpqual in that case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In some situations (particularly with OR'd index conditions) we may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have scan_clauses that are not <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to, but are logically implied by,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the index quals; so we also try a <a href="../util/predtest.c.html#L152" title="optimizer/util/predtest.c:152">predicate_implied_by</a>() check to see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we can discard quals that way.&nbsp; (<a href="../util/predtest.c.html#L152" title="optimizer/util/predtest.c:152">predicate_implied_by</a> assumes its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first input contains only immutable <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, so we have to check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: if you change this <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of code you should also look at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../path/costsize.c.html#L840" title="optimizer/path/costsize.c:840">extract_nonindex_conditions</a>() in costsize.c.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; qpqual = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(l, scan_clauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rinfo-&gt;pseudoconstant)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we may drop pseudoconstants here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../path/equivclass.c.html#L3308" title="optimizer/path/equivclass.c:3308">is_redundant_with_indexclauses</a>(rinfo, indexclauses))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dup or derived from same EquivalenceClass */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../util/clauses.c.html#L370" title="optimizer/util/clauses.c:370">contain_mutable_functions</a>((Node *) rinfo-&gt;clause) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/predtest.c.html#L152" title="optimizer/util/predtest.c:152">predicate_implied_by</a>(list_make1(rinfo-&gt;clause), stripped_indexquals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* provably implied by indexquals */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qpqual = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(qpqual, rinfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort clauses into best execution order */<br/></li>
<li></span>&nbsp; &nbsp; qpqual = <a href="#L5315" title="optimizer/plan/createplan.c:5315">order_qual_clauses</a>(root, qpqual);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */<br/></li>
<li></span>&nbsp; &nbsp; qpqual = <a href="../util/restrictinfo.c.html#L494" title="optimizer/util/restrictinfo.c:494">extract_actual_clauses</a>(qpqual, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have to replace <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer-relation variables with nestloop params in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the indexqualorig, qpqual, and indexorderbyorig expressions.&nbsp; A <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * annoying to have to do this separately from the processing in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L5022" title="optimizer/plan/createplan.c:5022">fix_indexqual_references</a> --- rethink this when generalizing the inner<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indexscan support.&nbsp; But note we can't really do this earlier because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it'd break the comparisons to predicates above ... (or would it?&nbsp; Those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wouldn't have outer refs)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;path.param_info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stripped_indexquals = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) stripped_indexquals);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qpqual = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) qpqual);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexorderbys = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) indexorderbys);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are ORDER BY expressions, look up the sort operators for their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * result datatypes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexorderbys)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *pathkeyCell,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *exprCell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PathKey contains OID of the btree opfamily we're sorting by, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that's not quite enough because we need the expression's datatype<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to look up the sort operator in the operator family.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(best_path-&gt;path.pathkeys) == list_length(indexorderbys));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; forboth(pathkeyCell, best_path-&gt;path.pathkeys, exprCell, indexorderbys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *pathkey = (PathKey *) lfirst(pathkeyCell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *expr = (Node *) lfirst(exprCell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exprtype = <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortop;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get sort operator from opfamily */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortop = <a href="../../utils/cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(pathkey-&gt;pk_opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; exprtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; exprtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pathkey-&gt;pk_strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(sortop))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing operator </span><span class="Special">%d</span><span class="Constant">(</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) in opfamily </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pathkey-&gt;pk_strategy, exprtype, exprtype, pathkey-&gt;pk_opfamily);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexorderbyops = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(indexorderbyops, sortop);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For an index-only scan, we must mark indextlist entries as resjunk if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they are columns that the index AM can't return; this cues setrefs.c to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not generate references to those columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexonly)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, indexinfo-&gt;indextlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *indextle = (TargetEntry *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indextle-&gt;resjunk = !indexinfo-&gt;canreturn[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finally ready to build the plan node */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexonly)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan_plan = (Scan *) <a href="#L5575" title="optimizer/plan/createplan.c:5575">make_indexonlyscan</a>(tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; baserelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fixed_indexquals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stripped_indexquals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fixed_indexorderbys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexinfo-&gt;indextlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;indexscandir);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; scan_plan = (Scan *) <a href="#L5544" title="optimizer/plan/createplan.c:5544">make_indexscan</a>(tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; baserelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fixed_indexquals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stripped_indexquals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fixed_indexorderbys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexorderbys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexorderbyops,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;indexscandir);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;scan_plan-&gt;plan, &amp;best_path-&gt;path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> scan_plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3201" title="optimizer/plan/createplan.c:3201">create_bitmap_scan_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Returns a bitmap scan plan for the base relation scanned by 'best_path'<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; with restriction clauses 'scan_clauses' and targetlist 'tlist'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> BitmapHeapScan *<br/></li>
<li><a id="L3201">&#x200c;</a><span class="linkable">create_bitmap_scan_plan</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BitmapHeapPath *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *scan_clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; baserelid = best_path-&gt;path.parent-&gt;relid;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *bitmapqualplan;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *bitmapqualorig;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexquals;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexECs;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *qpqual;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; BitmapHeapScan *scan_plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* it should be a base rel... */<br/></li>
<li></span>&nbsp; &nbsp; Assert(baserelid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(best_path-&gt;path.parent-&gt;rtekind == RTE_RELATION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process the bitmapqual tree into a Plan tree and qual lists */<br/></li>
<li></span>&nbsp; &nbsp; bitmapqualplan = <a href="#L3331" title="optimizer/plan/createplan.c:3331">create_bitmap_subplan</a>(root, best_path-&gt;bitmapqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;bitmapqualorig, &amp;indexquals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;indexECs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;path.parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5478" title="optimizer/plan/createplan.c:5478">bitmap_subplan_mark_shared</a>(bitmapqualplan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The qpqual list must contain all restrictions not automatically handled<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by the index, other than pseudoconstant clauses which will be handled<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by a separate gating plan node.&nbsp; All the predicates in the indexquals<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will be checked (either by the index itself, or by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nodeBitmapHeapscan.c), but if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> &quot;special&quot; operators<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * involved then they must be added to qpqual.&nbsp; The upshot is that qpqual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must contain scan_clauses minus whatever appears in indexquals.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This loop is similar to the comparable code in <a href="#L3005" title="optimizer/plan/createplan.c:3005">create_indexscan_plan</a>(),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but with some differences because it has to <a href="../geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the scan clauses to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stripped (no RestrictInfos) indexquals.&nbsp; See comments there for more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * info.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In normal cases simple <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>() checks will be enough to spot duplicate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clauses, so we try that first.&nbsp; We <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> see if the scan clause is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * redundant with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> top-level indexqual by virtue of being generated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the same EC.&nbsp; After that, try <a href="../util/predtest.c.html#L152" title="optimizer/util/predtest.c:152">predicate_implied_by</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unlike <a href="#L3005" title="optimizer/plan/createplan.c:3005">create_indexscan_plan</a>(), the <a href="../util/predtest.c.html#L152" title="optimizer/util/predtest.c:152">predicate_implied_by</a>() test here is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * useful for getting rid of qpquals that are implied by index predicates,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because the predicate conditions are included in the &quot;indexquals&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * returned by <a href="#L3331" title="optimizer/plan/createplan.c:3331">create_bitmap_subplan</a>().&nbsp; Bitmap scans have to do it that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * way because predicate conditions need to be rechecked if the scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * becomes lossy, so they have to be included in bitmapqualorig.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; qpqual = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(l, scan_clauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *clause = (Node *) rinfo-&gt;clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rinfo-&gt;pseudoconstant)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we may drop pseudoconstants here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/list.c.html#L661" title="nodes/list.c:661">list_member</a>(indexquals, clause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* simple duplicate */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rinfo-&gt;parent_ec &amp;&amp; <a href="../../nodes/list.c.html#L682" title="nodes/list.c:682">list_member_ptr</a>(indexECs, rinfo-&gt;parent_ec))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* derived from same EquivalenceClass */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../util/clauses.c.html#L370" title="optimizer/util/clauses.c:370">contain_mutable_functions</a>(clause) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/predtest.c.html#L152" title="optimizer/util/predtest.c:152">predicate_implied_by</a>(list_make1(clause), indexquals, <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* provably implied by indexquals */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qpqual = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(qpqual, rinfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort clauses into best execution order */<br/></li>
<li></span>&nbsp; &nbsp; qpqual = <a href="#L5315" title="optimizer/plan/createplan.c:5315">order_qual_clauses</a>(root, qpqual);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */<br/></li>
<li></span>&nbsp; &nbsp; qpqual = <a href="../util/restrictinfo.c.html#L494" title="optimizer/util/restrictinfo.c:494">extract_actual_clauses</a>(qpqual, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When dealing with special operators, we will at this point have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * duplicate clauses in qpqual and bitmapqualorig.&nbsp; We may as well drop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'em from bitmapqualorig, since there's no point in making the tests<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * twice.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bitmapqualorig = <a href="../../nodes/list.c.html#L1263" title="nodes/list.c:1263">list_difference_ptr</a>(bitmapqualorig, qpqual);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have to replace <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer-relation variables with nestloop params in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the qpqual and bitmapqualorig expressions.&nbsp; (This was already done for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expressions attached to plan nodes in the bitmapqualplan tree.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;path.param_info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qpqual = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) qpqual);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitmapqualorig = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) bitmapqualorig);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finally ready to build the plan node */<br/></li>
<li></span>&nbsp; &nbsp; scan_plan = <a href="#L5625" title="optimizer/plan/createplan.c:5625">make_bitmap_heapscan</a>(tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bitmapqualplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bitmapqualorig,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; baserelid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;scan_plan-&gt;scan.plan, &amp;best_path-&gt;path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> scan_plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a bitmapqual tree, generate the Plan tree that implements it<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As byproducts, we also return in *qual and *indexqual the qual lists<br/></li>
<li></span><span class="Comment"> * (in implicit-AND form, without RestrictInfos) describing the original index<br/></li>
<li></span><span class="Comment"> * conditions and the generated indexqual conditions.&nbsp; (These are the same in<br/></li>
<li></span><span class="Comment"> * simple cases, but when special index operators are involved, the former<br/></li>
<li></span><span class="Comment"> * list includes the special conditions while the latter includes the actual<br/></li>
<li></span><span class="Comment"> * indexable conditions derived from them.)&nbsp; Both lists include partial-index<br/></li>
<li></span><span class="Comment"> * predicates, because we have to recheck predicates as well as index<br/></li>
<li></span><span class="Comment"> * conditions if the bitmap scan becomes lossy.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In addition, we return a list of EquivalenceClass pointers for all the<br/></li>
<li></span><span class="Comment"> * top-level indexquals that were possibly-redundantly derived from ECs.<br/></li>
<li></span><span class="Comment"> * This allows removal of scan_clauses that are redundant with such quals.<br/></li>
<li></span><span class="Comment"> * (We do not attempt to detect such redundancies for quals that are within<br/></li>
<li></span><span class="Comment"> * OR subtrees.&nbsp; This could be done in a less hacky way if we returned the<br/></li>
<li></span><span class="Comment"> * indexquals in RestrictInfo form, but that would be slower and still pretty<br/></li>
<li></span><span class="Comment"> * messy, since we'd have to build new RestrictInfos in many cases.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Plan *<br/></li>
<li><a id="L3331">&#x200c;</a><span class="linkable">create_bitmap_subplan</span>(PlannerInfo *root, Path *bitmapqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **qual, List **indexqual, List **indexECs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(bitmapqual, BitmapAndPath))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BitmapAndPath *apath = (BitmapAndPath *) bitmapqual;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *subplans = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *subquals = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *subindexquals = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *subindexECs = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There may well be redundant quals among the subplans, since a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * top-level WHERE qual might have gotten used to form several<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * different index quals.&nbsp; We don't try exceedingly hard to eliminate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * redundancies, but we do eliminate obvious duplicates by using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../nodes/list.c.html#L1405" title="nodes/list.c:1405">list_concat_unique</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, apath-&gt;bitmapquals)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *subqual;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *subindexqual;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *subindexEC;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subplan = <a href="#L3331" title="optimizer/plan/createplan.c:3331">create_bitmap_subplan</a>(root, (Path *) lfirst(l),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;subqual, &amp;subindexqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;subindexEC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subplans = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(subplans, subplan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subquals = <a href="../../nodes/list.c.html#L1405" title="nodes/list.c:1405">list_concat_unique</a>(subquals, subqual);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subindexquals = <a href="../../nodes/list.c.html#L1405" title="nodes/list.c:1405">list_concat_unique</a>(subindexquals, subindexqual);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Duplicates in indexECs aren't worth getting rid of */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subindexECs = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(subindexECs, subindexEC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L5918" title="optimizer/plan/createplan.c:5918">make_bitmap_and</a>(subplans);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;startup_cost = apath-&gt;path.startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;total_cost = apath-&gt;path.total_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;plan_rows =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(apath-&gt;bitmapselectivity * apath-&gt;path.parent-&gt;tuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;plan_width = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* meaningless */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;parallel_safe = apath-&gt;path.parallel_safe;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *qual = subquals;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *indexqual = subindexquals;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *indexECs = subindexECs;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(bitmapqual, BitmapOrPath))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BitmapOrPath *opath = (BitmapOrPath *) bitmapqual;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *subplans = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *subquals = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *subindexquals = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; const_true_subqual = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; const_true_subindexqual = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Here, we only detect qual-free subplans.&nbsp; A qual-free subplan would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cause us to generate &quot;... OR true ...&quot;&nbsp; which we may as well reduce<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to just &quot;true&quot;.&nbsp; We do not try to eliminate redundant subclauses<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because (a) it's not as likely as in the AND case, and (b) we might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * well be working with hundreds or even thousands of OR conditions,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * perhaps from a long IN list.&nbsp; The performance of <a href="../../nodes/list.c.html#L1343" title="nodes/list.c:1343">list_append_unique</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would be unacceptable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, opath-&gt;bitmapquals)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *subqual;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *subindexqual;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *subindexEC;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subplan = <a href="#L3331" title="optimizer/plan/createplan.c:3331">create_bitmap_subplan</a>(root, (Path *) lfirst(l),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;subqual, &amp;subindexqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;subindexEC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subplans = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(subplans, subplan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subqual == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const_true_subqual = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!const_true_subqual)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subquals = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(subquals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/makefuncs.c.html#L726" title="nodes/makefuncs.c:726">make_ands_explicit</a>(subqual));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subindexqual == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const_true_subindexqual = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!const_true_subindexqual)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subindexquals = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(subindexquals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/makefuncs.c.html#L726" title="nodes/makefuncs.c:726">make_ands_explicit</a>(subindexqual));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In the presence of ScalarArrayOpExpr quals, we might have built<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * BitmapOrPaths with just one subpath; don't add an OR step.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(subplans) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) linitial(subplans);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L5933" title="optimizer/plan/createplan.c:5933">make_bitmap_or</a>(subplans);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;startup_cost = opath-&gt;path.startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;total_cost = opath-&gt;path.total_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;plan_rows =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(opath-&gt;bitmapselectivity * opath-&gt;path.parent-&gt;tuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;plan_width = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* meaningless */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;parallel_safe = opath-&gt;path.parallel_safe;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there were constant-TRUE subquals, the OR reduces to constant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * TRUE.&nbsp; Also, avoid generating one-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> ORs, which could happen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * due to redundancy elimination or ScalarArrayOpExpr quals.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (const_true_subqual)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *qual = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (list_length(subquals) &lt;= <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *qual = subquals;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *qual = list_make1(<a href="../../nodes/makefuncs.c.html#L670" title="nodes/makefuncs.c:670">make_orclause</a>(subquals));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (const_true_subindexqual)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *indexqual = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (list_length(subindexquals) &lt;= <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *indexqual = subindexquals;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *indexqual = list_make1(<a href="../../nodes/makefuncs.c.html#L670" title="nodes/makefuncs.c:670">make_orclause</a>(subindexquals));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *indexECs = NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(bitmapqual, IndexPath))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexPath&nbsp; *ipath = (IndexPath *) bitmapqual;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexScan&nbsp; *iscan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *subquals;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *subindexquals;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *subindexECs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use the regular indexscan plan build machinery... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; iscan = castNode(IndexScan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L3005" title="optimizer/plan/createplan.c:3005">create_indexscan_plan</a>(root, ipath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NIL, NIL, <span class="Constant">false</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* then convert to a bitmap indexscan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; plan = (Plan *) <a href="#L5604" title="optimizer/plan/createplan.c:5604">make_bitmap_indexscan</a>(iscan-&gt;scan.scanrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iscan-&gt;indexid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iscan-&gt;indexqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iscan-&gt;indexqualorig);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and set its cost/width fields appropriately */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;startup_cost = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;total_cost = ipath-&gt;indextotalcost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;plan_rows =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(ipath-&gt;indexselectivity * ipath-&gt;path.parent-&gt;tuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;plan_width = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* meaningless */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;parallel_safe = ipath-&gt;path.parallel_safe;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Extract original index clauses, actual index quals, relevant ECs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; subquals = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subindexquals = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subindexECs = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, ipath-&gt;indexclauses)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexClause *iclause = (IndexClause *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = iclause-&gt;rinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!rinfo-&gt;pseudoconstant);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subquals = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(subquals, rinfo-&gt;clause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subindexquals = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(subindexquals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/restrictinfo.c.html#L469" title="optimizer/util/restrictinfo.c:469">get_actual_clauses</a>(iclause-&gt;indexquals));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rinfo-&gt;parent_ec)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subindexECs = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(subindexECs, rinfo-&gt;parent_ec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can add <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> index predicate conditions, too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, ipath-&gt;indexinfo-&gt;indpred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *pred = (Expr *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We know that the index predicate must have been implied by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * query condition as a whole, but it may or may not be implied by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the conditions that got pushed into the bitmapqual.&nbsp; Avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * generating redundant conditions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../util/predtest.c.html#L152" title="optimizer/util/predtest.c:152">predicate_implied_by</a>(list_make1(pred), subquals, <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subquals = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(subquals, pred);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subindexquals = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(subindexquals, pred);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *qual = subquals;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *indexqual = subindexquals;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *indexECs = subindexECs;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, nodeTag(bitmapqual));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3539" title="optimizer/plan/createplan.c:3539">create_tidscan_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Returns a tidscan plan for the base relation scanned by 'best_path'<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; with restriction clauses 'scan_clauses' and targetlist 'tlist'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TidScan *<br/></li>
<li><a id="L3539">&#x200c;</a><span class="linkable">create_tidscan_plan</span>(PlannerInfo *root, TidPath *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *tlist, List *scan_clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TidScan&nbsp; &nbsp; *scan_plan;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; scan_relid = best_path-&gt;path.parent-&gt;relid;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tidquals = best_path-&gt;tidquals;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* it should be a base rel... */<br/></li>
<li></span>&nbsp; &nbsp; Assert(scan_relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(best_path-&gt;path.parent-&gt;rtekind == RTE_RELATION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The qpqual list must contain all restrictions not enforced by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tidquals list.&nbsp; Since tidquals has OR semantics, we have to be careful<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * about matching it up to scan_clauses.&nbsp; It's convenient to handle the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * single-tidqual case separately from the multiple-tidqual case.&nbsp; In the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * single-tidqual case, we look through the scan_clauses while they are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * still in RestrictInfo form, and drop <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> that are redundant with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tidqual.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In normal cases simple pointer equality checks will be enough to spot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * duplicate RestrictInfos, so we try that first.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Another common case is that a scan_clauses entry is generated from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same EquivalenceClass as some tidqual, and is therefore redundant with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it, though not <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unlike indexpaths, we don't bother with <a href="../util/predtest.c.html#L152" title="optimizer/util/predtest.c:152">predicate_implied_by</a>(); the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number of cases where it could win are pretty small.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(tidquals) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *qpqual = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, scan_clauses)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rinfo-&gt;pseudoconstant)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we may drop pseudoconstants here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/list.c.html#L682" title="nodes/list.c:682">list_member_ptr</a>(tidquals, rinfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* simple duplicate */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../path/equivclass.c.html#L3281" title="optimizer/path/equivclass.c:3281">is_redundant_derived_clause</a>(rinfo, tidquals))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* derived from same EquivalenceClass */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qpqual = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(qpqual, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan_clauses = qpqual;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort clauses into best execution order */<br/></li>
<li></span>&nbsp; &nbsp; scan_clauses = <a href="#L5315" title="optimizer/plan/createplan.c:5315">order_qual_clauses</a>(root, scan_clauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reduce RestrictInfo lists to bare expressions; ignore pseudoconstants */<br/></li>
<li></span>&nbsp; &nbsp; tidquals = <a href="../util/restrictinfo.c.html#L494" title="optimizer/util/restrictinfo.c:494">extract_actual_clauses</a>(tidquals, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; scan_clauses = <a href="../util/restrictinfo.c.html#L494" title="optimizer/util/restrictinfo.c:494">extract_actual_clauses</a>(scan_clauses, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have multiple tidquals, it's more convenient to remove duplicate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan_clauses after stripping the RestrictInfos.&nbsp; In this situation,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because the tidquals represent OR sub-clauses, they could not have come<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from EquivalenceClasses so we don't have to worry about matching up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-identical clauses.&nbsp; On the other hand, because tidpath.c will have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * extracted those sub-clauses from some OR clause and built its own list,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we will certainly not have pointer equality to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> scan clause.&nbsp; So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * convert the tidquals list to an explicit OR clause and see if we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * match it via <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>() to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> scan clause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(tidquals) &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan_clauses = <a href="../../nodes/list.c.html#L1237" title="nodes/list.c:1237">list_difference</a>(scan_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_make1(<a href="../../nodes/makefuncs.c.html#L670" title="nodes/makefuncs.c:670">make_orclause</a>(tidquals)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Replace <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer-relation variables with nestloop params */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;path.param_info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tidquals = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) tidquals);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan_clauses = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) scan_clauses);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan_plan = <a href="#L5645" title="optimizer/plan/createplan.c:5645">make_tidscan</a>(tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scan_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scan_relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tidquals);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;scan_plan-&gt;scan.plan, &amp;best_path-&gt;path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> scan_plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3636" title="optimizer/plan/createplan.c:3636">create_tidrangescan_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Returns a tidrangescan plan for the base relation scanned by 'best_path'<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; with restriction clauses 'scan_clauses' and targetlist 'tlist'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TidRangeScan *<br/></li>
<li><a id="L3636">&#x200c;</a><span class="linkable">create_tidrangescan_plan</span>(PlannerInfo *root, TidRangePath *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *tlist, List *scan_clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TidRangeScan *scan_plan;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; scan_relid = best_path-&gt;path.parent-&gt;relid;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tidrangequals = best_path-&gt;tidrangequals;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* it should be a base rel... */<br/></li>
<li></span>&nbsp; &nbsp; Assert(scan_relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(best_path-&gt;path.parent-&gt;rtekind == RTE_RELATION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The qpqual list must contain all restrictions not enforced by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tidrangequals list.&nbsp; tidrangequals has AND semantics, so we can simply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> qual that appears in it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *qpqual = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, scan_clauses)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rinfo-&gt;pseudoconstant)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we may drop pseudoconstants here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/list.c.html#L682" title="nodes/list.c:682">list_member_ptr</a>(tidrangequals, rinfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* simple duplicate */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qpqual = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(qpqual, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan_clauses = qpqual;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort clauses into best execution order */<br/></li>
<li></span>&nbsp; &nbsp; scan_clauses = <a href="#L5315" title="optimizer/plan/createplan.c:5315">order_qual_clauses</a>(root, scan_clauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reduce RestrictInfo lists to bare expressions; ignore pseudoconstants */<br/></li>
<li></span>&nbsp; &nbsp; tidrangequals = <a href="../util/restrictinfo.c.html#L494" title="optimizer/util/restrictinfo.c:494">extract_actual_clauses</a>(tidrangequals, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; scan_clauses = <a href="../util/restrictinfo.c.html#L494" title="optimizer/util/restrictinfo.c:494">extract_actual_clauses</a>(scan_clauses, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Replace <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer-relation variables with nestloop params */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;path.param_info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tidrangequals = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) tidrangequals);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan_clauses = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) scan_clauses);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan_plan = <a href="#L5664" title="optimizer/plan/createplan.c:5664">make_tidrangescan</a>(tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan_relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tidrangequals);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;scan_plan-&gt;scan.plan, &amp;best_path-&gt;path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> scan_plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3701" title="optimizer/plan/createplan.c:3701">create_subqueryscan_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Returns a subqueryscan plan for the base relation scanned by 'best_path'<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; with restriction clauses 'scan_clauses' and targetlist 'tlist'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> SubqueryScan *<br/></li>
<li><a id="L3701">&#x200c;</a><span class="linkable">create_subqueryscan_plan</span>(PlannerInfo *root, SubqueryScanPath *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *tlist, List *scan_clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SubqueryScan *scan_plan;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *rel = best_path-&gt;path.parent;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; scan_relid = rel-&gt;relid;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* it should be a subquery base rel... */<br/></li>
<li></span>&nbsp; &nbsp; Assert(scan_relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(rel-&gt;rtekind == RTE_SUBQUERY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Recursively create Plan from Path for subquery.&nbsp; Since we are entering<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a different <a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> context (subroot), recurse to <a href="#L337" title="optimizer/plan/createplan.c:337">create_plan</a> not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; subplan = <a href="#L337" title="optimizer/plan/createplan.c:337">create_plan</a>(rel-&gt;subroot, best_path-&gt;subpath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort clauses into best execution order */<br/></li>
<li></span>&nbsp; &nbsp; scan_clauses = <a href="#L5315" title="optimizer/plan/createplan.c:5315">order_qual_clauses</a>(root, scan_clauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */<br/></li>
<li></span>&nbsp; &nbsp; scan_clauses = <a href="../util/restrictinfo.c.html#L494" title="optimizer/util/restrictinfo.c:494">extract_actual_clauses</a>(scan_clauses, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Replace <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer-relation variables with nestloop params.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must provide nestloop params for both lateral references of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subquery and outer <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> in the scan_clauses.&nbsp; It's better to assign the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * former first, because that code path requires specific param IDs, while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a> can adapt to the IDs assigned by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../util/paramassign.c.html#L480" title="optimizer/util/paramassign.c:480">process_subquery_nestloop_params</a>.&nbsp; This avoids possibly duplicating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nestloop params when the same Var is needed for both reasons.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;path.param_info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/paramassign.c.html#L480" title="optimizer/util/paramassign.c:480">process_subquery_nestloop_params</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;subplan_params);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan_clauses = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) scan_clauses);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan_plan = <a href="#L5683" title="optimizer/plan/createplan.c:5683">make_subqueryscan</a>(tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan_relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subplan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;scan_plan-&gt;scan.plan, &amp;best_path-&gt;path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> scan_plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3760" title="optimizer/plan/createplan.c:3760">create_functionscan_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Returns a functionscan plan for the base relation scanned by 'best_path'<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; with restriction clauses 'scan_clauses' and targetlist 'tlist'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> FunctionScan *<br/></li>
<li><a id="L3760">&#x200c;</a><span class="linkable">create_functionscan_plan</span>(PlannerInfo *root, Path *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *tlist, List *scan_clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FunctionScan *scan_plan;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; scan_relid = best_path-&gt;parent-&gt;relid;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* it should be a function base rel... */<br/></li>
<li></span>&nbsp; &nbsp; Assert(scan_relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; rte = planner_rt_fetch(scan_relid, root);<br/></li>
<li>&nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_FUNCTION);<br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> = rte-&gt;<a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort clauses into best execution order */<br/></li>
<li></span>&nbsp; &nbsp; scan_clauses = <a href="#L5315" title="optimizer/plan/createplan.c:5315">order_qual_clauses</a>(root, scan_clauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */<br/></li>
<li></span>&nbsp; &nbsp; scan_clauses = <a href="../util/restrictinfo.c.html#L494" title="optimizer/util/restrictinfo.c:494">extract_actual_clauses</a>(scan_clauses, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Replace <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer-relation variables with nestloop params */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;param_info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan_clauses = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) scan_clauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The function expressions could contain nestloop params, too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> = (List *) <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan_plan = <a href="#L5703" title="optimizer/plan/createplan.c:5703">make_functionscan</a>(tlist, scan_clauses, scan_relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, rte-&gt;funcordinality);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;scan_plan-&gt;scan.plan, best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> scan_plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3803" title="optimizer/plan/createplan.c:3803">create_tablefuncscan_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Returns a tablefuncscan plan for the base relation scanned by 'best_path'<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; with restriction clauses 'scan_clauses' and targetlist 'tlist'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TableFuncScan *<br/></li>
<li><a id="L3803">&#x200c;</a><span class="linkable">create_tablefuncscan_plan</span>(PlannerInfo *root, Path *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *tlist, List *scan_clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TableFuncScan *scan_plan;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; scan_relid = best_path-&gt;parent-&gt;relid;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li>&nbsp; &nbsp; TableFunc&nbsp; *tablefunc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* it should be a function base rel... */<br/></li>
<li></span>&nbsp; &nbsp; Assert(scan_relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; rte = planner_rt_fetch(scan_relid, root);<br/></li>
<li>&nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_TABLEFUNC);<br/></li>
<li>&nbsp; &nbsp; tablefunc = rte-&gt;tablefunc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort clauses into best execution order */<br/></li>
<li></span>&nbsp; &nbsp; scan_clauses = <a href="#L5315" title="optimizer/plan/createplan.c:5315">order_qual_clauses</a>(root, scan_clauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */<br/></li>
<li></span>&nbsp; &nbsp; scan_clauses = <a href="../util/restrictinfo.c.html#L494" title="optimizer/util/restrictinfo.c:494">extract_actual_clauses</a>(scan_clauses, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Replace <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer-relation variables with nestloop params */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;param_info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan_clauses = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) scan_clauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The function expressions could contain nestloop params, too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tablefunc = (TableFunc *) <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) tablefunc);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan_plan = <a href="#L5724" title="optimizer/plan/createplan.c:5724">make_tablefuncscan</a>(tlist, scan_clauses, scan_relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tablefunc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;scan_plan-&gt;scan.plan, best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> scan_plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3846" title="optimizer/plan/createplan.c:3846">create_valuesscan_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Returns a valuesscan plan for the base relation scanned by 'best_path'<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; with restriction clauses 'scan_clauses' and targetlist 'tlist'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ValuesScan *<br/></li>
<li><a id="L3846">&#x200c;</a><span class="linkable">create_valuesscan_plan</span>(PlannerInfo *root, Path *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *tlist, List *scan_clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ValuesScan *scan_plan;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; scan_relid = best_path-&gt;parent-&gt;relid;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *values_lists;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* it should be a <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> base rel... */<br/></li>
<li></span>&nbsp; &nbsp; Assert(scan_relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; rte = planner_rt_fetch(scan_relid, root);<br/></li>
<li>&nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_VALUES);<br/></li>
<li>&nbsp; &nbsp; values_lists = rte-&gt;values_lists;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort clauses into best execution order */<br/></li>
<li></span>&nbsp; &nbsp; scan_clauses = <a href="#L5315" title="optimizer/plan/createplan.c:5315">order_qual_clauses</a>(root, scan_clauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */<br/></li>
<li></span>&nbsp; &nbsp; scan_clauses = <a href="../util/restrictinfo.c.html#L494" title="optimizer/util/restrictinfo.c:494">extract_actual_clauses</a>(scan_clauses, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Replace <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer-relation variables with nestloop params */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;param_info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan_clauses = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) scan_clauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> lists could contain nestloop params, too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; values_lists = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) values_lists);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan_plan = <a href="#L5743" title="optimizer/plan/createplan.c:5743">make_valuesscan</a>(tlist, scan_clauses, scan_relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; values_lists);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;scan_plan-&gt;scan.plan, best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> scan_plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3890" title="optimizer/plan/createplan.c:3890">create_ctescan_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Returns a ctescan plan for the base relation scanned by 'best_path'<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; with restriction clauses 'scan_clauses' and targetlist 'tlist'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> CteScan *<br/></li>
<li><a id="L3890">&#x200c;</a><span class="linkable">create_ctescan_plan</span>(PlannerInfo *root, Path *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *tlist, List *scan_clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CteScan&nbsp; &nbsp; *scan_plan;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; scan_relid = best_path-&gt;parent-&gt;relid;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li>&nbsp; &nbsp; SubPlan&nbsp; &nbsp; *ctesplan = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan_id;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cte_param_id;<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *cteroot;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; levelsup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndx;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(scan_relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; rte = planner_rt_fetch(scan_relid, root);<br/></li>
<li>&nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_CTE);<br/></li>
<li>&nbsp; &nbsp; Assert(!rte-&gt;self_reference);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find the referenced CTE, and locate the SubPlan previously made for it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; levelsup = rte-&gt;ctelevelsup;<br/></li>
<li>&nbsp; &nbsp; cteroot = root;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (levelsup-- &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cteroot = cteroot-&gt;parent_root;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!cteroot)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;bad levelsup for CTE </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, rte-&gt;ctename);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: cte_plan_ids can be shorter than cteList, if we are still working<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on planning the CTEs (ie, this is a side-reference from another CTE).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * So we mustn't use forboth here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ndx = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, cteroot-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;cteList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CommonTableExpr *cte = (CommonTableExpr *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(cte-&gt;ctename, rte-&gt;ctename) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ndx++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lc == <span class="Constant">NULL</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> CTE </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, rte-&gt;ctename);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndx &gt;= list_length(cteroot-&gt;cte_plan_ids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> plan for CTE </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, rte-&gt;ctename);<br/></li>
<li>&nbsp; &nbsp; plan_id = list_nth_int(cteroot-&gt;cte_plan_ids, ndx);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plan_id &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;no plan was made for CTE </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, rte-&gt;ctename);<br/></li>
<li>&nbsp; &nbsp; foreach(lc, cteroot-&gt;init_plans)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctesplan = (SubPlan *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ctesplan-&gt;plan_id == plan_id)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lc == <span class="Constant">NULL</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> plan for CTE </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, rte-&gt;ctename);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need the CTE param ID, which is the sole member of the SubPlan's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * setParam list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cte_param_id = linitial_int(ctesplan-&gt;setParam);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort clauses into best execution order */<br/></li>
<li></span>&nbsp; &nbsp; scan_clauses = <a href="#L5315" title="optimizer/plan/createplan.c:5315">order_qual_clauses</a>(root, scan_clauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */<br/></li>
<li></span>&nbsp; &nbsp; scan_clauses = <a href="../util/restrictinfo.c.html#L494" title="optimizer/util/restrictinfo.c:494">extract_actual_clauses</a>(scan_clauses, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Replace <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer-relation variables with nestloop params */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;param_info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan_clauses = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) scan_clauses);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan_plan = <a href="#L5762" title="optimizer/plan/createplan.c:5762">make_ctescan</a>(tlist, scan_clauses, scan_relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plan_id, cte_param_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;scan_plan-&gt;scan.plan, best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> scan_plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3985" title="optimizer/plan/createplan.c:3985">create_namedtuplestorescan_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Returns a tuplestorescan plan for the base relation scanned by<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 'best_path' with restriction clauses 'scan_clauses' and targetlist<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 'tlist'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> NamedTuplestoreScan *<br/></li>
<li><a id="L3985">&#x200c;</a><span class="linkable">create_namedtuplestorescan_plan</span>(PlannerInfo *root, Path *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *tlist, List *scan_clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; NamedTuplestoreScan *scan_plan;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; scan_relid = best_path-&gt;parent-&gt;relid;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(scan_relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; rte = planner_rt_fetch(scan_relid, root);<br/></li>
<li>&nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_NAMEDTUPLESTORE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort clauses into best execution order */<br/></li>
<li></span>&nbsp; &nbsp; scan_clauses = <a href="#L5315" title="optimizer/plan/createplan.c:5315">order_qual_clauses</a>(root, scan_clauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */<br/></li>
<li></span>&nbsp; &nbsp; scan_clauses = <a href="../util/restrictinfo.c.html#L494" title="optimizer/util/restrictinfo.c:494">extract_actual_clauses</a>(scan_clauses, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Replace <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer-relation variables with nestloop params */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;param_info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan_clauses = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) scan_clauses);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan_plan = <a href="#L5783" title="optimizer/plan/createplan.c:5783">make_namedtuplestorescan</a>(tlist, scan_clauses, scan_relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rte-&gt;enrname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;scan_plan-&gt;scan.plan, best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> scan_plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4024" title="optimizer/plan/createplan.c:4024">create_resultscan_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Returns a Result plan for the RTE_RESULT base relation scanned by<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 'best_path' with restriction clauses 'scan_clauses' and targetlist<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 'tlist'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Result *<br/></li>
<li><a id="L4024">&#x200c;</a><span class="linkable">create_resultscan_plan</span>(PlannerInfo *root, Path *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *tlist, List *scan_clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Result&nbsp; &nbsp; &nbsp;&nbsp; *scan_plan;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; scan_relid = best_path-&gt;parent-&gt;relid;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte <a href="../../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(scan_relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; rte = planner_rt_fetch(scan_relid, root);<br/></li>
<li>&nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_RESULT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort clauses into best execution order */<br/></li>
<li></span>&nbsp; &nbsp; scan_clauses = <a href="#L5315" title="optimizer/plan/createplan.c:5315">order_qual_clauses</a>(root, scan_clauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */<br/></li>
<li></span>&nbsp; &nbsp; scan_clauses = <a href="../util/restrictinfo.c.html#L494" title="optimizer/util/restrictinfo.c:494">extract_actual_clauses</a>(scan_clauses, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Replace <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer-relation variables with nestloop params */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;param_info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan_clauses = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) scan_clauses);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan_plan = <a href="#L6988" title="optimizer/plan/createplan.c:6988">make_result</a>(tlist, (Node *) scan_clauses, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;scan_plan-&gt;plan, best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> scan_plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4061" title="optimizer/plan/createplan.c:4061">create_worktablescan_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Returns a worktablescan plan for the base relation scanned by 'best_path'<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; with restriction clauses 'scan_clauses' and targetlist 'tlist'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> WorkTableScan *<br/></li>
<li><a id="L4061">&#x200c;</a><span class="linkable">create_worktablescan_plan</span>(PlannerInfo *root, Path *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *tlist, List *scan_clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WorkTableScan *scan_plan;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; scan_relid = best_path-&gt;parent-&gt;relid;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; levelsup;<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *cteroot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(scan_relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; rte = planner_rt_fetch(scan_relid, root);<br/></li>
<li>&nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_CTE);<br/></li>
<li>&nbsp; &nbsp; Assert(rte-&gt;self_reference);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the worktable param ID, which is in the plan level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that's processing the recursive UNION, which is one level *below* where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the CTE comes from.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; levelsup = rte-&gt;ctelevelsup;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (levelsup == <span class="Constant">0</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;bad levelsup for CTE </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, rte-&gt;ctename);<br/></li>
<li>&nbsp; &nbsp; levelsup--;<br/></li>
<li>&nbsp; &nbsp; cteroot = root;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (levelsup-- &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cteroot = cteroot-&gt;parent_root;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!cteroot)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;bad levelsup for CTE </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, rte-&gt;ctename);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cteroot-&gt;wt_param_id &lt; <span class="Constant">0</span>)&nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> param ID for CTE </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, rte-&gt;ctename);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort clauses into best execution order */<br/></li>
<li></span>&nbsp; &nbsp; scan_clauses = <a href="#L5315" title="optimizer/plan/createplan.c:5315">order_qual_clauses</a>(root, scan_clauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */<br/></li>
<li></span>&nbsp; &nbsp; scan_clauses = <a href="../util/restrictinfo.c.html#L494" title="optimizer/util/restrictinfo.c:494">extract_actual_clauses</a>(scan_clauses, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Replace <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer-relation variables with nestloop params */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;param_info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan_clauses = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) scan_clauses);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan_plan = <a href="#L5803" title="optimizer/plan/createplan.c:5803">make_worktablescan</a>(tlist, scan_clauses, scan_relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cteroot-&gt;wt_param_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;scan_plan-&gt;scan.plan, best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> scan_plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4121" title="optimizer/plan/createplan.c:4121">create_foreignscan_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Returns a foreignscan plan for the relation scanned by 'best_path'<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; with restriction clauses 'scan_clauses' and targetlist 'tlist'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ForeignScan *<br/></li>
<li><a id="L4121">&#x200c;</a><span class="linkable">create_foreignscan_plan</span>(PlannerInfo *root, ForeignPath *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *tlist, List *scan_clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ForeignScan *scan_plan;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *rel = best_path-&gt;path.parent;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; scan_relid = rel-&gt;relid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel_oid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *outer_plan = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(rel-&gt;fdwroutine != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transform the child path if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;fdw_outerpath)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; outer_plan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;fdw_outerpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L69" title="optimizer/plan/createplan.c:69">CP_EXACT_TLIST</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're scanning a base relation, fetch its OID.&nbsp; (Irrelevant if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scanning a join relation.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scan_relid &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(rel-&gt;rtekind == RTE_RELATION);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rte = planner_rt_fetch(scan_relid, root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_RELATION);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel_oid = rte-&gt;relid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sort clauses into best execution order.&nbsp; We do this first since the FDW<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might have more info than we do and wish to adjust the ordering.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; scan_clauses = <a href="#L5315" title="optimizer/plan/createplan.c:5315">order_qual_clauses</a>(root, scan_clauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Let the FDW perform its processing on the restriction clauses and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * generate the plan node.&nbsp; Note that the FDW might remove restriction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clauses that it intends to execute remotely, or even add more (if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has selected some join clauses for remote use but also wants them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rechecked locally).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; scan_plan = rel-&gt;fdwroutine-&gt;GetForeignPlan(root, rel, rel_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tlist, scan_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_plan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy cost data from Path to Plan; no need to make FDW do this */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;scan_plan-&gt;scan.plan, &amp;best_path-&gt;path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy user OID to access as; likewise no need to make FDW do this */<br/></li>
<li></span>&nbsp; &nbsp; scan_plan-&gt;checkAsUser = rel-&gt;userid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy foreign server OID; likewise, no need to make FDW do this */<br/></li>
<li></span>&nbsp; &nbsp; scan_plan-&gt;fs_server = rel-&gt;serverid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Likewise, copy the relids that are represented by this foreign scan. An<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> rel doesn't have relids set, but it covers all the relations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * participating in the underlying scan/join, so use root-&gt;all_query_rels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;reloptkind == RELOPT_UPPER_REL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan_plan-&gt;fs_relids = root-&gt;all_query_rels;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; scan_plan-&gt;fs_relids = best_path-&gt;path.parent-&gt;relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Join relid sets include relevant outer joins, but FDWs may need to know<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which are the included base rels.&nbsp; That's a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> tedious to get without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * access to the plan-time data structures, so compute it here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; scan_plan-&gt;fs_base_relids = <a href="../../nodes/bitmapset.c.html#L346" title="nodes/bitmapset.c:346">bms_difference</a>(scan_plan-&gt;fs_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;outer_join_rels);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is a foreign join, and to make it valid to <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> down we had to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assume that the current user is the same as some user explicitly named<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the query, mark the finished plan as depending on the current user.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;useridiscurrent)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;glob-&gt;dependsOnRole = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Replace <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer-relation variables with nestloop params in the qual,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fdw_exprs and fdw_recheck_quals expressions.&nbsp; We do this last so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the FDW doesn't have to be involved.&nbsp; (Note that parts of fdw_exprs or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fdw_recheck_quals could have come from join clauses, so doing this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * beforehand on the scan_clauses wouldn't work.)&nbsp; We assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fdw_scan_tlist contains no such variables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;path.param_info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan_plan-&gt;scan.plan.qual = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) scan_plan-&gt;scan.plan.qual);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan_plan-&gt;fdw_exprs = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) scan_plan-&gt;fdw_exprs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan_plan-&gt;fdw_recheck_quals = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Node *) scan_plan-&gt;fdw_recheck_quals);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If rel is a base relation, detect whether <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> system columns are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * requested from the rel.&nbsp; (If rel is a join relation, rel-&gt;relid will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 0, but there can be no Var with relid 0 in the rel's targetlist or the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restriction clauses, so we <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this in that case.&nbsp; Note that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * columns in base relations that were joined are assumed to be contained<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in fdw_scan_tlist.)&nbsp; &nbsp; This is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of a kluge and might go away<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * someday, so we intentionally leave it out of the API presented to FDWs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; scan_plan-&gt;fsSystemCol = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (scan_relid &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *attrs_used = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First, examine all the attributes needed for joins or final output.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: we must look at rel's targetlist, not the attr_needed data,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because attr_needed isn't computed for inheritance child rels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/var.c.html#L291" title="optimizer/util/var.c:291">pull_varattnos</a>((Node *) rel-&gt;reltarget-&gt;exprs, scan_relid, &amp;attrs_used);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add all the attributes used by restriction clauses. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, rel-&gt;baserestrictinfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/var.c.html#L291" title="optimizer/util/var.c:291">pull_varattnos</a>((Node *) rinfo-&gt;clause, scan_relid, &amp;attrs_used);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now, are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> system columns requested from rel? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = FirstLowInvalidHeapAttributeNumber + <span class="Constant">1</span>; i &lt; <span class="Constant">0</span>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(i - FirstLowInvalidHeapAttributeNumber, attrs_used))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan_plan-&gt;fsSystemCol = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(attrs_used);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> scan_plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4276" title="optimizer/plan/createplan.c:4276">create_customscan_plan</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Transform a CustomPath into a Plan.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> CustomScan *<br/></li>
<li><a id="L4276">&#x200c;</a><span class="linkable">create_customscan_plan</span>(PlannerInfo *root, CustomPath *best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *tlist, List *scan_clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CustomScan *cplan;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *rel = best_path-&gt;path.parent;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *custom_plans = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Recursively transform child paths. */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, best_path-&gt;custom_paths)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, (Path *) lfirst(lc),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L69" title="optimizer/plan/createplan.c:69">CP_EXACT_TLIST</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; custom_plans = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(custom_plans, plan);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sort clauses into the best execution order, although custom-scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> can reorder them again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; scan_clauses = <a href="#L5315" title="optimizer/plan/createplan.c:5315">order_qual_clauses</a>(root, scan_clauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Invoke custom plan <a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> to create the Plan node represented by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CustomPath.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cplan = castNode(CustomScan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_path-&gt;methods-&gt;PlanCustomPath(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; custom_plans));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy cost data from Path to Plan; no need to make custom-plan providers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;cplan-&gt;scan.plan, &amp;best_path-&gt;path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Likewise, copy the relids that are represented by this custom scan */<br/></li>
<li></span>&nbsp; &nbsp; cplan-&gt;custom_relids = best_path-&gt;path.parent-&gt;relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Replace <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer-relation variables with nestloop params in the qual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and custom_exprs expressions.&nbsp; We do this last so that the custom-plan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> doesn't have to be involved.&nbsp; (Note that parts of custom_exprs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * could have come from join clauses, so doing this beforehand on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan_clauses wouldn't work.)&nbsp; We assume custom_scan_tlist contains no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * such variables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;path.param_info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cplan-&gt;scan.plan.qual = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) cplan-&gt;scan.plan.qual);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cplan-&gt;custom_exprs = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) cplan-&gt;custom_exprs);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cplan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; JOIN METHODS<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> NestLoop *<br/></li>
<li><a id="L4347">&#x200c;</a><span class="linkable">create_nestloop_plan</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NestPath *best_path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; NestLoop&nbsp;&nbsp; *join_plan;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *outer_plan;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *inner_plan;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist = <a href="#L825" title="optimizer/plan/createplan.c:825">build_path_tlist</a>(root, &amp;best_path-&gt;jpath.path);<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *joinrestrictclauses = best_path-&gt;jpath.joinrestrictinfo;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *joinclauses;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *otherclauses;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; outerrelids;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *nestParams;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; saveOuterRels = root-&gt;curOuterRels;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the inner path is parameterized by the topmost parent of the outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rel rather than the outer rel itself, fix that.&nbsp; (Nothing happens here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if it is not so parameterized.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; best_path-&gt;jpath.innerjoinpath =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L4112" title="optimizer/util/pathnode.c:4112">reparameterize_path_by_child</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_path-&gt;jpath.innerjoinpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_path-&gt;jpath.outerjoinpath-&gt;parent);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Failure here probably means that <a href="../util/pathnode.c.html#L4112" title="optimizer/util/pathnode.c:4112">reparameterize_path_by_child</a>() is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in sync with <a href="../util/pathnode.c.html#L4408" title="optimizer/util/pathnode.c:4408">path_is_reparameterizable_by_child</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(best_path-&gt;jpath.innerjoinpath != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* NestLoop can project, so no need to be picky about child tlists */<br/></li>
<li></span>&nbsp; &nbsp; outer_plan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;jpath.outerjoinpath, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For a nestloop, include outer relids in curOuterRels for inner side */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;curOuterRels = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(root-&gt;curOuterRels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_path-&gt;jpath.outerjoinpath-&gt;parent-&gt;relids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; inner_plan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;jpath.innerjoinpath, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore curOuterRels */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(root-&gt;curOuterRels);<br/></li>
<li>&nbsp; &nbsp; root-&gt;curOuterRels = saveOuterRels;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort join qual clauses into best execution order */<br/></li>
<li></span>&nbsp; &nbsp; joinrestrictclauses = <a href="#L5315" title="optimizer/plan/createplan.c:5315">order_qual_clauses</a>(root, joinrestrictclauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the join qual clauses (in plain expression form) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Any pseudoconstant clauses are ignored here */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IS_OUTER_JOIN(best_path-&gt;jpath.jointype))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/restrictinfo.c.html#L522" title="optimizer/util/restrictinfo.c:522">extract_actual_join_clauses</a>(joinrestrictclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;jpath.path.parent-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;joinclauses, &amp;otherclauses);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can treat all clauses alike for an inner join */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; joinclauses = <a href="../util/restrictinfo.c.html#L494" title="optimizer/util/restrictinfo.c:494">extract_actual_clauses</a>(joinrestrictclauses, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; otherclauses = NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Replace <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer-relation variables with nestloop params */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;jpath.path.param_info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; joinclauses = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) joinclauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; otherclauses = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) otherclauses);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Identify <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> nestloop parameters that should be supplied by this join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * node, and remove them from root-&gt;curOuterParams.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; outerrelids = best_path-&gt;jpath.outerjoinpath-&gt;parent-&gt;relids;<br/></li>
<li>&nbsp; &nbsp; nestParams = <a href="../util/paramassign.c.html#L582" title="optimizer/util/paramassign.c:582">identify_current_nestloop_params</a>(root, outerrelids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; join_plan = <a href="#L5948" title="optimizer/plan/createplan.c:5948">make_nestloop</a>(tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nestParams,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inner_plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;jpath.jointype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;jpath.inner_unique);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;join_plan-&gt;join.plan, &amp;best_path-&gt;jpath.path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> join_plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> MergeJoin *<br/></li>
<li><a id="L4439">&#x200c;</a><span class="linkable">create_mergejoin_plan</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MergePath *best_path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MergeJoin&nbsp; *join_plan;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *outer_plan;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *inner_plan;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist = <a href="#L825" title="optimizer/plan/createplan.c:825">build_path_tlist</a>(root, &amp;best_path-&gt;jpath.path);<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *joinclauses;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *otherclauses;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *mergeclauses;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *outerpathkeys;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *innerpathkeys;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nClauses;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *mergefamilies;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *mergecollations;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *mergestrategies;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *mergenullsfirst;<br/></li>
<li>&nbsp; &nbsp; PathKey&nbsp; &nbsp; *opathkey;<br/></li>
<li>&nbsp; &nbsp; EquivalenceClass *opeclass;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lop;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lip;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *outer_path = best_path-&gt;jpath.outerjoinpath;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *inner_path = best_path-&gt;jpath.innerjoinpath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * MergeJoin can project, so we don't have to demand exact tlists from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inputs.&nbsp; However, if we're intending to sort an input's result, it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * best to request a small tlist so we aren't sorting more data than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; outer_plan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;jpath.outerjoinpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (best_path-&gt;outersortkeys != NIL) ? <a href="#L70" title="optimizer/plan/createplan.c:70">CP_SMALL_TLIST</a> : <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; inner_plan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;jpath.innerjoinpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (best_path-&gt;innersortkeys != NIL) ? <a href="#L70" title="optimizer/plan/createplan.c:70">CP_SMALL_TLIST</a> : <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort join qual clauses into best execution order */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* NB: do NOT reorder the mergeclauses */<br/></li>
<li></span>&nbsp; &nbsp; joinclauses = <a href="#L5315" title="optimizer/plan/createplan.c:5315">order_qual_clauses</a>(root, best_path-&gt;jpath.joinrestrictinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the join qual clauses (in plain expression form) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Any pseudoconstant clauses are ignored here */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IS_OUTER_JOIN(best_path-&gt;jpath.jointype))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/restrictinfo.c.html#L522" title="optimizer/util/restrictinfo.c:522">extract_actual_join_clauses</a>(joinclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;jpath.path.parent-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;joinclauses, &amp;otherclauses);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can treat all clauses alike for an inner join */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; joinclauses = <a href="../util/restrictinfo.c.html#L494" title="optimizer/util/restrictinfo.c:494">extract_actual_clauses</a>(joinclauses, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; otherclauses = NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remove the mergeclauses from the list of join qual clauses, leaving the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list of quals that must be checked as qpquals.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; mergeclauses = <a href="../util/restrictinfo.c.html#L469" title="optimizer/util/restrictinfo.c:469">get_actual_clauses</a>(best_path-&gt;path_mergeclauses);<br/></li>
<li>&nbsp; &nbsp; joinclauses = <a href="../../nodes/list.c.html#L1237" title="nodes/list.c:1237">list_difference</a>(joinclauses, mergeclauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Replace <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer-relation variables with nestloop params.&nbsp; There<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should not be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> in the mergeclauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;jpath.path.param_info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; joinclauses = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) joinclauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; otherclauses = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) otherclauses);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Rearrange mergeclauses, if needed, so that the outer variable is always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on the left; mark the mergeclause restrictinfos with correct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * outer_is_left status.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; mergeclauses = <a href="#L5238" title="optimizer/plan/createplan.c:5238">get_switched_clauses</a>(best_path-&gt;path_mergeclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;jpath.outerjoinpath-&gt;parent-&gt;relids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create explicit sort nodes for the outer and inner paths if necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;outersortkeys)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; outer_relids = outer_path-&gt;parent-&gt;relids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Sort&nbsp; &nbsp; &nbsp;&nbsp; *sort = <a href="#L6346" title="optimizer/plan/createplan.c:6346">make_sort_from_pathkeys</a>(outer_plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_path-&gt;outersortkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outer_relids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5446" title="optimizer/plan/createplan.c:5446">label_sort_with_costsize</a>(root, sort, -<span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; outer_plan = (Plan *) sort;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; outerpathkeys = best_path-&gt;outersortkeys;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; outerpathkeys = best_path-&gt;jpath.outerjoinpath-&gt;pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;innersortkeys)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; inner_relids = inner_path-&gt;parent-&gt;relids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Sort&nbsp; &nbsp; &nbsp;&nbsp; *sort = <a href="#L6346" title="optimizer/plan/createplan.c:6346">make_sort_from_pathkeys</a>(inner_plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_path-&gt;innersortkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inner_relids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5446" title="optimizer/plan/createplan.c:5446">label_sort_with_costsize</a>(root, sort, -<span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inner_plan = (Plan *) sort;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; innerpathkeys = best_path-&gt;innersortkeys;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; innerpathkeys = best_path-&gt;jpath.innerjoinpath-&gt;pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If specified, add a materialize node to shield the inner plan from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to handle mark/restore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;materialize_inner)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *matplan = (Plan *) <a href="#L6505" title="optimizer/plan/createplan.c:6505">make_material</a>(inner_plan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We assume the materialize will not spill to disk, and therefore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> just <a href="../path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> per tuple.&nbsp; (Keep this estimate in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sync with <a href="../path/costsize.c.html#L3745" title="optimizer/path/costsize.c:3745">final_cost_mergejoin</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5424" title="optimizer/plan/createplan.c:5424">copy_plan_costsize</a>(matplan, inner_plan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; matplan-&gt;total_cost += <a href="../path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> * matplan-&gt;plan_rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inner_plan = matplan;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute the opfamily/collation/strategy/nullsfirst arrays needed by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * executor.&nbsp; The information is in the pathkeys for the two inputs, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we need to be careful about the possibility of mergeclauses sharing a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pathkey, as well as the possibility that the inner pathkeys are not in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an order matching the mergeclauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nClauses = list_length(mergeclauses);<br/></li>
<li>&nbsp; &nbsp; Assert(nClauses == list_length(best_path-&gt;path_mergeclauses));<br/></li>
<li>&nbsp; &nbsp; mergefamilies = (Oid *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nClauses * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; mergecollations = (Oid *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nClauses * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; mergestrategies = (<span class="Type">int</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nClauses * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; mergenullsfirst = (<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nClauses * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opathkey = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; opeclass = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; lop = list_head(outerpathkeys);<br/></li>
<li>&nbsp; &nbsp; lip = list_head(innerpathkeys);<br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, best_path-&gt;path_mergeclauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EquivalenceClass *oeclass;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EquivalenceClass *ieclass;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *ipathkey = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EquivalenceClass *ipeclass = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; first_inner_match = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fetch outer/inner <a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a> from mergeclause */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rinfo-&gt;outer_is_left)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oeclass = rinfo-&gt;left_ec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ieclass = rinfo-&gt;right_ec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oeclass = rinfo-&gt;right_ec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ieclass = rinfo-&gt;left_ec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(oeclass != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ieclass != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must identify the pathkey elements associated with this clause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by matching the eclasses (which should give a unique match, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the pathkey lists should be canonical).&nbsp; In typical cases the <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clauses are one-to-one with the pathkeys, but when dealing with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partially redundant query conditions, things are more complicated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lop and lip reference the first as-yet-unmatched pathkey elements.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If they're NULL then all pathkey elements have been matched.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The ordering of the outer pathkeys should match the mergeclauses,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by construction (see <a href="../path/pathkeys.c.html#L1527" title="optimizer/path/pathkeys.c:1527">find_mergeclauses_for_outer_pathkeys</a>()). There<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could be more than one mergeclause for the same outer pathkey, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no pathkey may be entirely skipped over.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oeclass != opeclass)&nbsp; &nbsp; <span class="Comment">/* multiple matches are not interesting */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* doesn't match the current opathkey, so must match the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lop == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;outer pathkeys do not match mergeclauses&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opathkey = (PathKey *) lfirst(lop);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opeclass = opathkey-&gt;pk_eclass;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lop = lnext(outerpathkeys, lop);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oeclass != opeclass)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;outer pathkeys do not match mergeclauses&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The inner pathkeys likewise should not have skipped-over keys, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's possible for a mergeclause to reference some earlier inner<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pathkey if we had redundant pathkeys.&nbsp; For example we might have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mergeclauses like &quot;o.a = i.x AND o.b = i.y AND o.c = i.x&quot;.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * implied inner ordering is then &quot;ORDER BY x, y, x&quot;, but the pathkey<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mechanism drops the second sort by x as redundant, and this code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must cope.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's also possible for the implied inner-rel ordering to be like<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;ORDER BY x, y, x DESC&quot;.&nbsp; We still drop the second instance of x as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * redundant; but this means that the sort ordering of a redundant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inner pathkey should not be considered significant.&nbsp; So we must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * detect whether this is the first clause matching an inner pathkey.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lip)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ipathkey = (PathKey *) lfirst(lip);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ipeclass = ipathkey-&gt;pk_eclass;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ieclass == ipeclass)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* successful first match to this inner pathkey */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lip = lnext(innerpathkeys, lip);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first_inner_match = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!first_inner_match)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* redundant clause ... must match something <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> lip */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l2, innerpathkeys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (l2 == lip)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ipathkey = (PathKey *) lfirst(l2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ipeclass = ipathkey-&gt;pk_eclass;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ieclass == ipeclass)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ieclass != ipeclass)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;inner pathkeys do not match mergeclauses&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The pathkeys should always match each other as to opfamily and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * collation (which affect equality), but if we're considering a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * redundant inner pathkey, its sort ordering might not match.&nbsp; In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * such cases we may ignore the inner pathkey's sort ordering and use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the outer's.&nbsp; (In effect, we're lying to the executor about the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sort direction of this inner column, but it does not matter since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the run-time row comparisons would only reach this column when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there's equality for the earlier column containing the same <a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There could be only one value in this column for the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of inner<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rows having a given value in the earlier column, so it does not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matter which way we imagine this column to be ordered.)&nbsp; But a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-redundant inner pathkey had better match outer's ordering too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (opathkey-&gt;pk_opfamily != ipathkey-&gt;pk_opfamily ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opathkey-&gt;pk_eclass-&gt;ec_collation != ipathkey-&gt;pk_eclass-&gt;ec_collation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;left and right pathkeys do not match in mergejoin&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (first_inner_match &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (opathkey-&gt;pk_strategy != ipathkey-&gt;pk_strategy ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; opathkey-&gt;pk_nulls_first != ipathkey-&gt;pk_nulls_first))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;left and right pathkeys do not match in mergejoin&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, save info for executor */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mergefamilies[i] = opathkey-&gt;pk_opfamily;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mergecollations[i] = opathkey-&gt;pk_eclass-&gt;ec_collation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mergestrategies[i] = opathkey-&gt;pk_strategy;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mergenullsfirst[i] = opathkey-&gt;pk_nulls_first;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: it is not an error if we have additional pathkey elements (i.e.,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lop or lip isn't NULL here).&nbsp; The input paths might be better-sorted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than we need for the current mergejoin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we can build the mergejoin node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; join_plan = <a href="#L6027" title="optimizer/plan/createplan.c:6027">make_mergejoin</a>(tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; joinclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; otherclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mergeclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mergefamilies,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mergecollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mergestrategies,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mergenullsfirst,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outer_plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inner_plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_path-&gt;jpath.jointype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_path-&gt;jpath.inner_unique,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_path-&gt;skip_mark_restore);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Costs of sort and material steps are included in path cost already */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;join_plan-&gt;join.plan, &amp;best_path-&gt;jpath.path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> join_plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> HashJoin *<br/></li>
<li><a id="L4746">&#x200c;</a><span class="linkable">create_hashjoin_plan</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HashPath *best_path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HashJoin&nbsp;&nbsp; *join_plan;<br/></li>
<li>&nbsp; &nbsp; Hash&nbsp; &nbsp; &nbsp;&nbsp; *hash_plan;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *outer_plan;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *inner_plan;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist = <a href="#L825" title="optimizer/plan/createplan.c:825">build_path_tlist</a>(root, &amp;best_path-&gt;jpath.path);<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *joinclauses;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *otherclauses;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *hashclauses;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *hashoperators = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *hashcollations = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *inner_hashkeys = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *outer_hashkeys = NIL;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skewTable = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; skewColumn = InvalidAttrNumber;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; skewInherit = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * HashJoin can project, so we don't have to demand exact tlists from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inputs.&nbsp; However, it's best to request a small tlist from the inner<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * side, so that we aren't storing more data than necessary.&nbsp; Likewise, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we anticipate batching, request a small tlist from the outer side so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that we don't put extra data in the outer batch files.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; outer_plan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;jpath.outerjoinpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (best_path-&gt;num_batches &gt; <span class="Constant">1</span>) ? <a href="#L70" title="optimizer/plan/createplan.c:70">CP_SMALL_TLIST</a> : <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; inner_plan = <a href="#L388" title="optimizer/plan/createplan.c:388">create_plan_recurse</a>(root, best_path-&gt;jpath.innerjoinpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L70" title="optimizer/plan/createplan.c:70">CP_SMALL_TLIST</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort join qual clauses into best execution order */<br/></li>
<li></span>&nbsp; &nbsp; joinclauses = <a href="#L5315" title="optimizer/plan/createplan.c:5315">order_qual_clauses</a>(root, best_path-&gt;jpath.joinrestrictinfo);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* There's no point in sorting the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> clauses ... */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the join qual clauses (in plain expression form) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Any pseudoconstant clauses are ignored here */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IS_OUTER_JOIN(best_path-&gt;jpath.jointype))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/restrictinfo.c.html#L522" title="optimizer/util/restrictinfo.c:522">extract_actual_join_clauses</a>(joinclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;jpath.path.parent-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;joinclauses, &amp;otherclauses);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can treat all clauses alike for an inner join */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; joinclauses = <a href="../util/restrictinfo.c.html#L494" title="optimizer/util/restrictinfo.c:494">extract_actual_clauses</a>(joinclauses, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; otherclauses = NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remove the hashclauses from the list of join qual clauses, leaving the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list of quals that must be checked as qpquals.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hashclauses = <a href="../util/restrictinfo.c.html#L469" title="optimizer/util/restrictinfo.c:469">get_actual_clauses</a>(best_path-&gt;path_hashclauses);<br/></li>
<li>&nbsp; &nbsp; joinclauses = <a href="../../nodes/list.c.html#L1237" title="nodes/list.c:1237">list_difference</a>(joinclauses, hashclauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Replace <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer-relation variables with nestloop params.&nbsp; There<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should not be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> in the hashclauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;jpath.path.param_info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; joinclauses = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) joinclauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; otherclauses = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, (Node *) otherclauses);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Rearrange hashclauses, if needed, so that the outer variable is always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on the left.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hashclauses = <a href="#L5238" title="optimizer/plan/createplan.c:5238">get_switched_clauses</a>(best_path-&gt;path_hashclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_path-&gt;jpath.outerjoinpath-&gt;parent-&gt;relids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is a single join clause and we can identify the outer variable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as a simple column reference, supply its identity for possible use in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * skew optimization.&nbsp; (Note: in principle we could do skew optimization<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with multiple join clauses, but we'd have to be able to determine the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * most common combinations of outer <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, which we don't currently have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enough stats for.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(hashclauses) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OpExpr&nbsp; &nbsp; &nbsp;&nbsp; *clause = (OpExpr *) linitial(hashclauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(is_opclause(clause));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node = (Node *) linitial(clause-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, RelabelType))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node = (Node *) ((RelabelType *) node)-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte = root-&gt;simple_rte_array[var-&gt;varno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind == RTE_RELATION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skewTable = rte-&gt;relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skewColumn = var-&gt;varattno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skewInherit = rte-&gt;inh;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Collect <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> related information. The hashed expressions are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deconstructed into outer/inner expressions, so they can be computed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * separately (inner expressions are used to build the hashtable via Hash,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * outer expressions to perform lookups of tuples from HashJoin's outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plan in the hashtable). Also collect operator information necessary to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * build the hashtable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, hashclauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OpExpr&nbsp; &nbsp; &nbsp;&nbsp; *hclause = lfirst_node(OpExpr, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashoperators = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(hashoperators, hclause-&gt;opno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashcollations = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(hashcollations, hclause-&gt;inputcollid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; outer_hashkeys = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(outer_hashkeys, linitial(hclause-&gt;args));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inner_hashkeys = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(inner_hashkeys, lsecond(hclause-&gt;args));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> node and <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> join node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hash_plan = <a href="#L6004" title="optimizer/plan/createplan.c:6004">make_hash</a>(inner_plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inner_hashkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skewTable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skewColumn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skewInherit);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set Hash node's startup &amp; total costs <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to total cost of input<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plan; this only affects EXPLAIN display not decisions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5424" title="optimizer/plan/createplan.c:5424">copy_plan_costsize</a>(&amp;hash_plan-&gt;plan, inner_plan);<br/></li>
<li>&nbsp; &nbsp; hash_plan-&gt;plan.startup_cost = hash_plan-&gt;plan.total_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If parallel-aware, the executor will also need an estimate of the total<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number of rows expected from all participants so that it can size the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shared <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (best_path-&gt;jpath.path.parallel_aware)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hash_plan-&gt;plan.parallel_aware = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hash_plan-&gt;rows_total = best_path-&gt;inner_rows_total;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; join_plan = <a href="#L5973" title="optimizer/plan/createplan.c:5973">make_hashjoin</a>(tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashoperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashcollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_hashkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Plan *) hash_plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;jpath.jointype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path-&gt;jpath.inner_unique);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>(&amp;join_plan-&gt;join.plan, &amp;best_path-&gt;jpath.path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> join_plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; SUPPORTING ROUTINES<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Replace outer-relation Vars and PlaceHolderVars in the given expression<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; with nestloop Params<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All Vars and PlaceHolderVars belonging to the relation(s) identified by<br/></li>
<li></span><span class="Comment"> * root-&gt;curOuterRels are replaced by Params, and entries are added to<br/></li>
<li></span><span class="Comment"> * root-&gt;curOuterParams if not already present.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Node *<br/></li>
<li><a id="L4935">&#x200c;</a><span class="linkable">replace_nestloop_params</span>(PlannerInfo *root, Node *expr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No setup needed for tree walk, so away we go */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L4942" title="optimizer/plan/createplan.c:4942">replace_nestloop_params_mutator</a>(expr, root);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Node *<br/></li>
<li><a id="L4942">&#x200c;</a><span class="linkable">replace_nestloop_params_mutator</span>(Node *node, PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Upper-level Vars should be long gone at this point */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(var-&gt;varlevelsup == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If not to be replaced, we can just return the Var unmodified */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IS_SPECIAL_VARNO(var-&gt;varno) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(var-&gt;varno, root-&gt;curOuterRels))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Replace the Var with a nestloop Param */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) <a href="../util/paramassign.c.html#L367" title="optimizer/util/paramassign.c:367">replace_nestloop_param_var</a>(root, var);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *phv = (PlaceHolderVar *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Upper-level PlaceHolderVars should be long gone at this point */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(phv-&gt;phlevelsup == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check whether we need to replace the PHV */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(<a href="../util/placeholder.c.html#L83" title="optimizer/util/placeholder.c:83">find_placeholder_info</a>(root, phv)-&gt;ph_eval_at,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;curOuterRels))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can't replace the whole PHV, but we might still need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * replace Vars or PHVs within its expression, in case it ends up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * actually getting evaluated here.&nbsp; (It might get evaluated in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this plan node, or some child node; in the latter case we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * really need to process the expression here, but we haven't got<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * enough info to tell if that's the case.)&nbsp; Flat-copy the PHV<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * node and then recurse on its expression.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that after doing this, we might have different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * representations of the contents of the same PHV in different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parts of the plan tree.&nbsp; This is OK because <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>() will just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * match on phid/phlevelsup, so setrefs.c will still recognize an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level reference to a <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-level copy of the same PHV.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *newphv = makeNode(PlaceHolderVar);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(newphv, phv, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PlaceHolderVar));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newphv-&gt;phexpr = (Expr *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4942" title="optimizer/plan/createplan.c:4942">replace_nestloop_params_mutator</a>((Node *) phv-&gt;phexpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) newphv;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Replace the PlaceHolderVar with a nestloop Param */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) <a href="../util/paramassign.c.html#L416" title="optimizer/util/paramassign.c:416">replace_nestloop_param_placeholdervar</a>(root, phv);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_mutator(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L4942" title="optimizer/plan/createplan.c:4942">replace_nestloop_params_mutator</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) root);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5022" title="optimizer/plan/createplan.c:5022">fix_indexqual_references</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Adjust indexqual clauses to the form the executor's indexqual<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; machinery needs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We have three tasks here:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * Select the actual qual clauses out of the input IndexClause list,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; and remove RestrictInfo nodes from the qual clauses.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * Replace <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer-relation Var or PHV nodes with nestloop Params.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; (</span><span class="Todo">XXX</span><span class="Comment"> eventually, that responsibility should go elsewhere?)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * Index keys must be represented by Var nodes with varattno set to the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; index's attribute number, not the attribute number in the original rel.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *stripped_indexquals_p receives a list of the actual qual clauses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *fixed_indexquals_p receives a list of the adjusted quals.&nbsp; This is a copy<br/></li>
<li></span><span class="Comment"> * that shares no substructure with the original; this is needed in case there<br/></li>
<li></span><span class="Comment"> * are subplans in it (we need two separate copies of the subplan tree, or<br/></li>
<li></span><span class="Comment"> * things will go awry).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5022">&#x200c;</a></span><span class="linkable">fix_indexqual_references</span>(PlannerInfo *root, IndexPath *index_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **stripped_indexquals_p, List **fixed_indexquals_p)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexOptInfo *index = index_path-&gt;indexinfo;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *stripped_indexquals;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *fixed_indexquals;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stripped_indexquals = fixed_indexquals = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, index_path-&gt;indexclauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexClause *iclause = lfirst_node(IndexClause, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexcol = iclause-&gt;indexcol;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, iclause-&gt;indexquals)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, lc2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *clause = (Node *) rinfo-&gt;clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stripped_indexquals = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(stripped_indexquals, clause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clause = <a href="#L5092" title="optimizer/plan/createplan.c:5092">fix_indexqual_clause</a>(root, index, indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clause, iclause-&gt;indexcols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fixed_indexquals = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(fixed_indexquals, clause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *stripped_indexquals_p = stripped_indexquals;<br/></li>
<li>&nbsp; &nbsp; *fixed_indexquals_p = fixed_indexquals;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5063" title="optimizer/plan/createplan.c:5063">fix_indexorderby_references</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Adjust indexorderby clauses to the form the executor's index<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; machinery needs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a simplified version of <a href="#L5022" title="optimizer/plan/createplan.c:5022">fix_indexqual_references</a>.&nbsp; The input is<br/></li>
<li></span><span class="Comment"> * bare clauses and a separate indexcol list, instead of IndexClauses.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L5063">&#x200c;</a><span class="linkable">fix_indexorderby_references</span>(PlannerInfo *root, IndexPath *index_path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexOptInfo *index = index_path-&gt;indexinfo;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *fixed_indexorderbys;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lcc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lci;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fixed_indexorderbys = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; forboth(lcc, index_path-&gt;indexorderbys, lci, index_path-&gt;indexorderbycols)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *clause = (Node *) lfirst(lcc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexcol = lfirst_int(lci);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; clause = <a href="#L5092" title="optimizer/plan/createplan.c:5092">fix_indexqual_clause</a>(root, index, indexcol, clause, NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fixed_indexorderbys = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(fixed_indexorderbys, clause);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> fixed_indexorderbys;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5092" title="optimizer/plan/createplan.c:5092">fix_indexqual_clause</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Convert a single indexqual clause to the form needed by the executor.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We replace nestloop params here, and replace the index key variables<br/></li>
<li></span><span class="Comment"> * or expressions by index Var nodes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Node *<br/></li>
<li><a id="L5092">&#x200c;</a><span class="linkable">fix_indexqual_clause</span>(PlannerInfo *root, IndexOptInfo *index, <span class="Type">int</span> indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *clause, List *indexcolnos)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Replace <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer-relation variables with nestloop params.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This also makes a copy of the clause, so it's safe to modify it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in-place below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; clause = <a href="#L4935" title="optimizer/plan/createplan.c:4935">replace_nestloop_params</a>(root, clause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(clause, OpExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OpExpr&nbsp; &nbsp; &nbsp;&nbsp; *op = (OpExpr *) clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Replace the indexkey expression with an index Var. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; linitial(op-&gt;args) = <a href="#L5163" title="optimizer/plan/createplan.c:5163">fix_indexqual_operand</a>(linitial(op-&gt;args),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexcol);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(clause, RowCompareExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RowCompareExpr *rc = (RowCompareExpr *) clause;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lca,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lcai;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Replace the indexkey expressions with index Vars. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(rc-&gt;largs) == list_length(indexcolnos));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; forboth(lca, rc-&gt;largs, lcai, indexcolnos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lfirst(lca) = <a href="#L5163" title="optimizer/plan/createplan.c:5163">fix_indexqual_operand</a>(lfirst(lca),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lfirst_int(lcai));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(clause, ScalarArrayOpExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Replace the indexkey expression with an index Var. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; linitial(saop-&gt;args) = <a href="#L5163" title="optimizer/plan/createplan.c:5163">fix_indexqual_operand</a>(linitial(saop-&gt;args),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexcol);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(clause, NullTest))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; NullTest&nbsp;&nbsp; *nt = (NullTest *) clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Replace the indexkey expression with an index Var. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nt-&gt;arg = (Expr *) <a href="#L5163" title="optimizer/plan/createplan.c:5163">fix_indexqual_operand</a>((Node *) nt-&gt;arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexcol);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unsupported indexqual type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) nodeTag(clause));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> clause;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5163" title="optimizer/plan/createplan.c:5163">fix_indexqual_operand</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Convert an indexqual expression to a Var referencing the index column.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We represent index keys by Var nodes having varno == INDEX_VAR and varattno<br/></li>
<li></span><span class="Comment"> * <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the index's attribute number (index column position).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Most of the code here is just for sanity cross-checking that the given<br/></li>
<li></span><span class="Comment"> * expression actually matches the index column it's claimed to.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Node *<br/></li>
<li><a id="L5163">&#x200c;</a><span class="linkable">fix_indexqual_operand</span>(Node *node, IndexOptInfo *index, <span class="Type">int</span> indexcol)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *indexpr_item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> binary-compatible relabeling of the indexkey<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, RelabelType))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node = (Node *) ((RelabelType *) node)-&gt;arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(indexcol &gt;= <span class="Constant">0</span> &amp;&amp; indexcol &lt; index-&gt;ncolumns);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;indexkeys[indexcol] != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It's a simple index column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((Var *) node)-&gt;varno == index-&gt;rel-&gt;relid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((Var *) node)-&gt;varattno == index-&gt;indexkeys[indexcol])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (Var *) copyObject(node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;varno = INDEX_VAR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;varattno = indexcol + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;index key does not match expected index column&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* It's an index expression, so <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> and cross-check the expression */<br/></li>
<li></span>&nbsp; &nbsp; indexpr_item = list_head(index-&gt;indexprs);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (pos = <span class="Constant">0</span>; pos &lt; index-&gt;ncolumns; pos++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;indexkeys[pos] == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexpr_item == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;too few entries in indexprs list&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pos == indexcol)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *indexkey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexkey = (Node *) lfirst(indexpr_item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexkey &amp;&amp; IsA(indexkey, RelabelType))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexkey = (Node *) ((RelabelType *) indexkey)-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(node, indexkey))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/makefuncs.c.html#L66" title="nodes/makefuncs.c:66">makeVar</a>(INDEX_VAR, indexcol + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(lfirst(indexpr_item)), -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>(lfirst(indexpr_item)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;index key does not match expected index column&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexpr_item = lnext(index-&gt;indexprs, indexpr_item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Oops... */<br/></li>
<li></span>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;index key does not match expected index column&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5238" title="optimizer/plan/createplan.c:5238">get_switched_clauses</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Given a list of <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> or <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> joinclauses (as RestrictInfo nodes),<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; extract the bare clauses, and rearrange the elements within the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; clauses, if needed, so the outer join variable is on the left and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the inner is on the right.&nbsp; The original clause data structure is not<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; touched; a modified list is returned.&nbsp; We do, however, set the transient<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; outer_is_left field in each RestrictInfo to show which side was which.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L5238">&#x200c;</a><span class="linkable">get_switched_clauses</span>(List *clauses, Relids outerrelids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *t_list = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, clauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *restrictinfo = (RestrictInfo *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OpExpr&nbsp; &nbsp; &nbsp;&nbsp; *clause = (OpExpr *) restrictinfo-&gt;clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(is_opclause(clause));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(restrictinfo-&gt;right_relids, outerrelids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Duplicate just enough of the structure to allow commuting the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clause without changing the original list.&nbsp; Could use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * copyObject, but a complete deep copy is overkill.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OpExpr&nbsp; &nbsp; &nbsp;&nbsp; *temp = makeNode(OpExpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp-&gt;opno = clause-&gt;opno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp-&gt;opfuncid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp-&gt;opresulttype = clause-&gt;opresulttype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp-&gt;opretset = clause-&gt;opretset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp-&gt;opcollid = clause-&gt;opcollid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp-&gt;inputcollid = clause-&gt;inputcollid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp-&gt;args = <a href="../../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(clause-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp-&gt;location = clause-&gt;location;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Commute it --- note this modifies the temp node in-place. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/clauses.c.html#L2147" title="optimizer/util/clauses.c:2147">CommuteOpExpr</a>(temp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t_list = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(t_list, temp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restrictinfo-&gt;outer_is_left = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(restrictinfo-&gt;left_relids, outerrelids));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t_list = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(t_list, clause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restrictinfo-&gt;outer_is_left = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> t_list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5315" title="optimizer/plan/createplan.c:5315">order_qual_clauses</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given a list of qual clauses that will all be evaluated at the same<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; plan node, sort the list into the order we want to check the quals<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; in at runtime.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When security barrier quals are used in the query, we may have quals with<br/></li>
<li></span><span class="Comment"> * different security levels in the list.&nbsp; Quals of <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> security_level<br/></li>
<li></span><span class="Comment"> * must go <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> quals of higher security_level, except that we can grant<br/></li>
<li></span><span class="Comment"> * exceptions to move up quals that are leakproof.&nbsp; When security level<br/></li>
<li></span><span class="Comment"> * doesn't force the decision, we prefer to order clauses by estimated<br/></li>
<li></span><span class="Comment"> * execution cost, cheapest first.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Ideally the order should be driven by a combination of execution cost and<br/></li>
<li></span><span class="Comment"> * selectivity, but it's not immediately clear how to account for both,<br/></li>
<li></span><span class="Comment"> * and given the uncertainty of the estimates the reliability of the decisions<br/></li>
<li></span><span class="Comment"> * would be doubtful anyway.&nbsp; So we just order by security level then<br/></li>
<li></span><span class="Comment"> * estimated per-tuple cost, being careful not to change the order when<br/></li>
<li></span><span class="Comment"> * (as is often the case) the estimates are identical.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Although this will work on either bare clauses or RestrictInfos, it's<br/></li>
<li></span><span class="Comment"> * much faster to apply it to RestrictInfos, since it can re-use cost<br/></li>
<li></span><span class="Comment"> * information that is cached in RestrictInfos.&nbsp; </span><span class="Todo">XXX</span><span class="Comment"> in the bare-clause<br/></li>
<li></span><span class="Comment"> * case, we are also not able to apply security considerations.&nbsp; That is<br/></li>
<li></span><span class="Comment"> * all right for the moment, because the bare-clause case doesn't occur<br/></li>
<li></span><span class="Comment"> * anywhere that barrier quals could be present, but it would be better to<br/></li>
<li></span><span class="Comment"> * get rid of it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: some callers pass lists that contain entries that will later be<br/></li>
<li></span><span class="Comment"> * removed; this is the easiest way to let this routine see RestrictInfos<br/></li>
<li></span><span class="Comment"> * instead of bare clauses.&nbsp; This is another reason why trying to consider<br/></li>
<li></span><span class="Comment"> * selectivity in the ordering would likely do the wrong thing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L5315">&#x200c;</a><span class="linkable">order_qual_clauses</span>(PlannerInfo *root, List *clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *clause;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; security_level;<br/></li>
<li>&nbsp; &nbsp; } QualItem;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems = list_length(clauses);<br/></li>
<li>&nbsp; &nbsp; QualItem&nbsp;&nbsp; *items;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No need to work hard for 0 or 1 clause */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nitems &lt;= <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> clauses;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Collect the items and costs into an array.&nbsp; This is to avoid repeated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../path/costsize.c.html#L4640" title="optimizer/path/costsize.c:4640">cost_qual_eval</a> work if the inputs aren't RestrictInfos.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; items = (QualItem *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nitems * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(QualItem));<br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, clauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *clause = (Node *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; QualCost&nbsp; &nbsp; qcost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L4666" title="optimizer/path/costsize.c:4666">cost_qual_eval_node</a>(&amp;qcost, clause, root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; items[i].clause = clause;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; items[i].cost = qcost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(clause, RestrictInfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If a clause is leakproof, it doesn't have to be constrained by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * its nominal security level.&nbsp; If it's also reasonably cheap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (here defined as 10X <a href="../path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>), pretend it has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * security_level 0, which will allow it to go in front of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * more-expensive quals of <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> security levels.&nbsp; Of course, that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will also force it to go in front of cheaper quals of its own<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * security level, which is not so great, but we can alleviate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that risk by applying the cost limit cutoff.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rinfo-&gt;leakproof &amp;&amp; items[i].cost &lt; <span class="Constant">10</span> * <a href="../path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; items[i].security_level = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; items[i].security_level = rinfo-&gt;security_level;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; items[i].security_level = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sort.&nbsp; We don't use qsort() because it's not guaranteed stable for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> keys.&nbsp; The expected number of entries is small enough that a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * simple insertion sort should be good enough.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; nitems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; QualItem&nbsp; &nbsp; newitem = items[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* insert newitem into the already-sorted subarray */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = i; j &gt; <span class="Constant">0</span>; j--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QualItem&nbsp;&nbsp; *olditem = &amp;items[j - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newitem.security_level &gt; olditem-&gt;security_level ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (newitem.security_level == olditem-&gt;security_level &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newitem.cost &gt;= olditem-&gt;cost))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; items[j] = *olditem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; items[j] = newitem;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert back to a list */<br/></li>
<li></span>&nbsp; &nbsp; result = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nitems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, items[i].clause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Copy cost and size info from a Path node to the Plan node created from it.<br/></li>
<li></span><span class="Comment"> * The executor usually won't use this info, but it's needed by EXPLAIN.<br/></li>
<li></span><span class="Comment"> * Also copy the parallel-related flags, which the executor *will* use.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5409">&#x200c;</a></span><span class="linkable">copy_generic_path_info</span>(Plan *dest, Path *src)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dest-&gt;startup_cost = src-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; dest-&gt;total_cost = src-&gt;total_cost;<br/></li>
<li>&nbsp; &nbsp; dest-&gt;plan_rows = src-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; dest-&gt;plan_width = src-&gt;pathtarget-&gt;width;<br/></li>
<li>&nbsp; &nbsp; dest-&gt;parallel_aware = src-&gt;parallel_aware;<br/></li>
<li>&nbsp; &nbsp; dest-&gt;parallel_safe = src-&gt;parallel_safe;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Copy cost and size info from a <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> plan node to an inserted node.<br/></li>
<li></span><span class="Comment"> * (Most callers alter the info after copying it.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5424">&#x200c;</a></span><span class="linkable">copy_plan_costsize</span>(Plan *dest, Plan *src)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dest-&gt;startup_cost = src-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; dest-&gt;total_cost = src-&gt;total_cost;<br/></li>
<li>&nbsp; &nbsp; dest-&gt;plan_rows = src-&gt;plan_rows;<br/></li>
<li>&nbsp; &nbsp; dest-&gt;plan_width = src-&gt;plan_width;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assume the inserted node is not parallel-aware. */<br/></li>
<li></span>&nbsp; &nbsp; dest-&gt;parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assume the inserted node is parallel-safe, if child plan is. */<br/></li>
<li></span>&nbsp; &nbsp; dest-&gt;parallel_safe = src-&gt;parallel_safe;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Some places in this file build Sort nodes that don't have a directly<br/></li>
<li></span><span class="Comment"> * corresponding Path node.&nbsp; The cost of the sort is, or should have been,<br/></li>
<li></span><span class="Comment"> * included in the cost of the Path node we're working from, but since it's<br/></li>
<li></span><span class="Comment"> * not split out, we have to re-figure it using <a href="../path/costsize.c.html#L2124" title="optimizer/path/costsize.c:2124">cost_sort</a>().&nbsp; This is just<br/></li>
<li></span><span class="Comment"> * to label the Sort node nicely for EXPLAIN.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * limit_tuples is as for <a href="../path/costsize.c.html#L2124" title="optimizer/path/costsize.c:2124">cost_sort</a> (in particular, pass -1 if no limit)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5446">&#x200c;</a></span><span class="linkable">label_sort_with_costsize</span>(PlannerInfo *root, Sort *plan, <span class="Type">double</span> limit_tuples)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *lefttree = plan-&gt;plan.lefttree;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp; &nbsp; sort_path;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dummy for result of <a href="../path/costsize.c.html#L2124" title="optimizer/path/costsize.c:2124">cost_sort</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This function shouldn't have to deal with IncrementalSort plans because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they are only created from corresponding Path nodes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(IsA(plan, Sort));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../path/costsize.c.html#L2124" title="optimizer/path/costsize.c:2124">cost_sort</a>(&amp;sort_path, root, NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lefttree-&gt;total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lefttree-&gt;plan_rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lefttree-&gt;plan_width,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0.0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; limit_tuples);<br/></li>
<li>&nbsp; &nbsp; plan-&gt;plan.startup_cost = sort_path.startup_cost;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;plan.total_cost = sort_path.total_cost;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;plan.plan_rows = lefttree-&gt;plan_rows;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;plan.plan_width = lefttree-&gt;plan_width;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;plan.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;plan.parallel_safe = lefttree-&gt;parallel_safe;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5478" title="optimizer/plan/createplan.c:5478">bitmap_subplan_mark_shared</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Set isshared flag in bitmap subplan so that it will be created in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; shared memory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5478">&#x200c;</a></span><span class="linkable">bitmap_subplan_mark_shared</span>(Plan *plan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(plan, BitmapAnd))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5478" title="optimizer/plan/createplan.c:5478">bitmap_subplan_mark_shared</a>(linitial(((BitmapAnd *) plan)-&gt;bitmapplans));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(plan, BitmapOr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((BitmapOr *) plan)-&gt;isshared = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5478" title="optimizer/plan/createplan.c:5478">bitmap_subplan_mark_shared</a>(linitial(((BitmapOr *) plan)-&gt;bitmapplans));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(plan, BitmapIndexScan))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((BitmapIndexScan *) plan)-&gt;isshared = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, nodeTag(plan));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; PLAN <a href="../../utils/adt/tsquery_cleanup.c.html#L22" title="utils/adt/tsquery_cleanup.c:22">NODE</a> BUILDING ROUTINES<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In general, these <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are not passed the original Path and therefore<br/></li>
<li></span><span class="Comment"> * leave it to the caller to fill in the cost/width fields from the Path,<br/></li>
<li></span><span class="Comment"> * typically by calling <a href="#L5409" title="optimizer/plan/createplan.c:5409">copy_generic_path_info</a>().&nbsp; This convention is<br/></li>
<li></span><span class="Comment"> * somewhat historical, but it does support a few places above where we build<br/></li>
<li></span><span class="Comment"> * a plan node without having an exactly corresponding Path node.&nbsp; Under no<br/></li>
<li></span><span class="Comment"> * circumstances should one of these <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> do its own cost calculations,<br/></li>
<li></span><span class="Comment"> * as that would be redundant with calculations done while building Paths.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> SeqScan *<br/></li>
<li><a id="L5508">&#x200c;</a><span class="linkable">make_seqscan</span>(List *qptlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index scanrelid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SeqScan&nbsp; &nbsp; *node = makeNode(SeqScan);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;scan.plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = qptlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = qpqual;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;scan.scanrelid = scanrelid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> SampleScan *<br/></li>
<li><a id="L5525">&#x200c;</a><span class="linkable">make_samplescan</span>(List *qptlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index scanrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TableSampleClause *tsc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SampleScan *node = makeNode(SampleScan);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;scan.plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = qptlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = qpqual;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;scan.scanrelid = scanrelid;<br/></li>
<li>&nbsp; &nbsp; node-&gt;tablesample = tsc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> IndexScan *<br/></li>
<li><a id="L5544">&#x200c;</a><span class="linkable">make_indexscan</span>(List *qptlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index scanrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid indexid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *indexqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *indexqualorig,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *indexorderby,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *indexorderbyorig,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *indexorderbyops,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanDirection indexscandir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexScan&nbsp; *node = makeNode(IndexScan);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;scan.plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = qptlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = qpqual;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;scan.scanrelid = scanrelid;<br/></li>
<li>&nbsp; &nbsp; node-&gt;indexid = indexid;<br/></li>
<li>&nbsp; &nbsp; node-&gt;indexqual = indexqual;<br/></li>
<li>&nbsp; &nbsp; node-&gt;indexqualorig = indexqualorig;<br/></li>
<li>&nbsp; &nbsp; node-&gt;indexorderby = indexorderby;<br/></li>
<li>&nbsp; &nbsp; node-&gt;indexorderbyorig = indexorderbyorig;<br/></li>
<li>&nbsp; &nbsp; node-&gt;indexorderbyops = indexorderbyops;<br/></li>
<li>&nbsp; &nbsp; node-&gt;indexorderdir = indexscandir;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> IndexOnlyScan *<br/></li>
<li><a id="L5575">&#x200c;</a><span class="linkable">make_indexonlyscan</span>(List *qptlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index scanrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid indexid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *indexqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *recheckqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *indexorderby,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *indextlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanDirection indexscandir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexOnlyScan *node = makeNode(IndexOnlyScan);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;scan.plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = qptlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = qpqual;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;scan.scanrelid = scanrelid;<br/></li>
<li>&nbsp; &nbsp; node-&gt;indexid = indexid;<br/></li>
<li>&nbsp; &nbsp; node-&gt;indexqual = indexqual;<br/></li>
<li>&nbsp; &nbsp; node-&gt;recheckqual = recheckqual;<br/></li>
<li>&nbsp; &nbsp; node-&gt;indexorderby = indexorderby;<br/></li>
<li>&nbsp; &nbsp; node-&gt;indextlist = indextlist;<br/></li>
<li>&nbsp; &nbsp; node-&gt;indexorderdir = indexscandir;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> BitmapIndexScan *<br/></li>
<li><a id="L5604">&#x200c;</a><span class="linkable">make_bitmap_indexscan</span>(Index scanrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid indexid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *indexqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *indexqualorig)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BitmapIndexScan *node = makeNode(BitmapIndexScan);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;scan.plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = NIL;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not used */<br/></li>
<li></span>&nbsp; &nbsp; plan-&gt;qual = NIL;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not used */<br/></li>
<li></span>&nbsp; &nbsp; plan-&gt;lefttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;scan.scanrelid = scanrelid;<br/></li>
<li>&nbsp; &nbsp; node-&gt;indexid = indexid;<br/></li>
<li>&nbsp; &nbsp; node-&gt;indexqual = indexqual;<br/></li>
<li>&nbsp; &nbsp; node-&gt;indexqualorig = indexqualorig;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> BitmapHeapScan *<br/></li>
<li><a id="L5625">&#x200c;</a><span class="linkable">make_bitmap_heapscan</span>(List *qptlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Plan *lefttree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *bitmapqualorig,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index scanrelid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BitmapHeapScan *node = makeNode(BitmapHeapScan);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;scan.plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = qptlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = qpqual;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = lefttree;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;scan.scanrelid = scanrelid;<br/></li>
<li>&nbsp; &nbsp; node-&gt;bitmapqualorig = bitmapqualorig;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> TidScan *<br/></li>
<li><a id="L5645">&#x200c;</a><span class="linkable">make_tidscan</span>(List *qptlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index scanrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *tidquals)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TidScan&nbsp; &nbsp; *node = makeNode(TidScan);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;scan.plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = qptlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = qpqual;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;scan.scanrelid = scanrelid;<br/></li>
<li>&nbsp; &nbsp; node-&gt;tidquals = tidquals;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> TidRangeScan *<br/></li>
<li><a id="L5664">&#x200c;</a><span class="linkable">make_tidrangescan</span>(List *qptlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index scanrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *tidrangequals)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TidRangeScan *node = makeNode(TidRangeScan);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;scan.plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = qptlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = qpqual;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;scan.scanrelid = scanrelid;<br/></li>
<li>&nbsp; &nbsp; node-&gt;tidrangequals = tidrangequals;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> SubqueryScan *<br/></li>
<li><a id="L5683">&#x200c;</a><span class="linkable">make_subqueryscan</span>(List *qptlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index scanrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Plan *subplan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SubqueryScan *node = makeNode(SubqueryScan);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;scan.plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = qptlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = qpqual;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;scan.scanrelid = scanrelid;<br/></li>
<li>&nbsp; &nbsp; node-&gt;subplan = subplan;<br/></li>
<li>&nbsp; &nbsp; node-&gt;scanstatus = SUBQUERY_SCAN_UNKNOWN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> FunctionScan *<br/></li>
<li><a id="L5703">&#x200c;</a><span class="linkable">make_functionscan</span>(List *qptlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index scanrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *<a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> funcordinality)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FunctionScan *node = makeNode(FunctionScan);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;scan.plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = qptlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = qpqual;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;scan.scanrelid = scanrelid;<br/></li>
<li>&nbsp; &nbsp; node-&gt;<a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> = <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;funcordinality = funcordinality;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> TableFuncScan *<br/></li>
<li><a id="L5724">&#x200c;</a><span class="linkable">make_tablefuncscan</span>(List *qptlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index scanrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TableFunc *tablefunc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TableFuncScan *node = makeNode(TableFuncScan);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;scan.plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = qptlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = qpqual;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;scan.scanrelid = scanrelid;<br/></li>
<li>&nbsp; &nbsp; node-&gt;tablefunc = tablefunc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> ValuesScan *<br/></li>
<li><a id="L5743">&#x200c;</a><span class="linkable">make_valuesscan</span>(List *qptlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index scanrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *values_lists)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ValuesScan *node = makeNode(ValuesScan);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;scan.plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = qptlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = qpqual;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;scan.scanrelid = scanrelid;<br/></li>
<li>&nbsp; &nbsp; node-&gt;values_lists = values_lists;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> CteScan *<br/></li>
<li><a id="L5762">&#x200c;</a><span class="linkable">make_ctescan</span>(List *qptlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index scanrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> ctePlanId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> cteParam)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CteScan&nbsp; &nbsp; *node = makeNode(CteScan);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;scan.plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = qptlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = qpqual;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;scan.scanrelid = scanrelid;<br/></li>
<li>&nbsp; &nbsp; node-&gt;ctePlanId = ctePlanId;<br/></li>
<li>&nbsp; &nbsp; node-&gt;cteParam = cteParam;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> NamedTuplestoreScan *<br/></li>
<li><a id="L5783">&#x200c;</a><span class="linkable">make_namedtuplestorescan</span>(List *qptlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index scanrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *enrname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; NamedTuplestoreScan *node = makeNode(NamedTuplestoreScan);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;scan.plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cost should be inserted by caller */<br/></li>
<li></span>&nbsp; &nbsp; plan-&gt;targetlist = qptlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = qpqual;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;scan.scanrelid = scanrelid;<br/></li>
<li>&nbsp; &nbsp; node-&gt;enrname = enrname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> WorkTableScan *<br/></li>
<li><a id="L5803">&#x200c;</a><span class="linkable">make_worktablescan</span>(List *qptlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index scanrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> wtParam)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WorkTableScan *node = makeNode(WorkTableScan);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;scan.plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = qptlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = qpqual;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;scan.scanrelid = scanrelid;<br/></li>
<li>&nbsp; &nbsp; node-&gt;wtParam = wtParam;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>ForeignScan *<br/></li>
<li><a id="L5822">&#x200c;</a><span class="linkable">make_foreignscan</span>(List *qptlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index scanrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *fdw_exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *fdw_private,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *fdw_scan_tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *fdw_recheck_quals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Plan *outer_plan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ForeignScan *node = makeNode(ForeignScan);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;scan.plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cost will be filled in by <a href="#L4121" title="optimizer/plan/createplan.c:4121">create_foreignscan_plan</a> */<br/></li>
<li></span>&nbsp; &nbsp; plan-&gt;targetlist = qptlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = qpqual;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = outer_plan;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;scan.scanrelid = scanrelid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* these may be overridden by the FDW's PlanDirectModify callback. */<br/></li>
<li></span>&nbsp; &nbsp; node-&gt;operation = CMD_SELECT;<br/></li>
<li>&nbsp; &nbsp; node-&gt;resultRelation = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* checkAsUser, fs_server will be filled in by <a href="#L4121" title="optimizer/plan/createplan.c:4121">create_foreignscan_plan</a> */<br/></li>
<li></span>&nbsp; &nbsp; node-&gt;checkAsUser = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; node-&gt;fs_server = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; node-&gt;fdw_exprs = fdw_exprs;<br/></li>
<li>&nbsp; &nbsp; node-&gt;fdw_private = fdw_private;<br/></li>
<li>&nbsp; &nbsp; node-&gt;fdw_scan_tlist = fdw_scan_tlist;<br/></li>
<li>&nbsp; &nbsp; node-&gt;fdw_recheck_quals = fdw_recheck_quals;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fs_relids, fs_base_relids will be filled by <a href="#L4121" title="optimizer/plan/createplan.c:4121">create_foreignscan_plan</a> */<br/></li>
<li></span>&nbsp; &nbsp; node-&gt;fs_relids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;fs_base_relids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fsSystemCol will be filled in by <a href="#L4121" title="optimizer/plan/createplan.c:4121">create_foreignscan_plan</a> */<br/></li>
<li></span>&nbsp; &nbsp; node-&gt;fsSystemCol = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> RecursiveUnion *<br/></li>
<li><a id="L5862">&#x200c;</a><span class="linkable">make_recursive_union</span>(List *tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Plan *lefttree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Plan *righttree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> wtParam,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *distinctList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">long</span> numGroups)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RecursiveUnion *node = makeNode(RecursiveUnion);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;plan;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numCols = list_length(distinctList);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = tlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = NIL;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = lefttree;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = righttree;<br/></li>
<li>&nbsp; &nbsp; node-&gt;wtParam = wtParam;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * convert SortGroupClause list into arrays of attr indexes and equality<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operators, as wanted by executor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; node-&gt;numCols = numCols;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numCols &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber *dupColIdx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dupOperators;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dupCollations;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *slitem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dupColIdx = (AttrNumber *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber) * numCols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dupOperators = (Oid *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * numCols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dupCollations = (Oid *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * numCols);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(slitem, distinctList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *sortcl = (SortGroupClause *) lfirst(slitem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = <a href="../util/tlist.c.html#L367" title="optimizer/util/tlist.c:367">get_sortgroupclause_tle</a>(sortcl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plan-&gt;targetlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dupColIdx[keyno] = tle-&gt;resno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dupOperators[keyno] = sortcl-&gt;eqop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dupCollations[keyno] = <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) tle-&gt;expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(OidIsValid(dupOperators[keyno]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyno++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;dupColIdx = dupColIdx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;dupOperators = dupOperators;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;dupCollations = dupCollations;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; node-&gt;numGroups = numGroups;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> BitmapAnd *<br/></li>
<li><a id="L5918">&#x200c;</a><span class="linkable">make_bitmap_and</span>(List *bitmapplans)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BitmapAnd&nbsp; *node = makeNode(BitmapAnd);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = NIL;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = NIL;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;bitmapplans = bitmapplans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> BitmapOr *<br/></li>
<li><a id="L5933">&#x200c;</a><span class="linkable">make_bitmap_or</span>(List *bitmapplans)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BitmapOr&nbsp;&nbsp; *node = makeNode(BitmapOr);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = NIL;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = NIL;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;bitmapplans = bitmapplans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> NestLoop *<br/></li>
<li><a id="L5948">&#x200c;</a><span class="linkable">make_nestloop</span>(List *tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *joinclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *otherclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *nestParams,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Plan *lefttree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Plan *righttree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JoinType jointype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> inner_unique)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; NestLoop&nbsp;&nbsp; *node = makeNode(NestLoop);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;join.plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = tlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = otherclauses;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = lefttree;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = righttree;<br/></li>
<li>&nbsp; &nbsp; node-&gt;join.jointype = jointype;<br/></li>
<li>&nbsp; &nbsp; node-&gt;join.inner_unique = inner_unique;<br/></li>
<li>&nbsp; &nbsp; node-&gt;join.joinqual = joinclauses;<br/></li>
<li>&nbsp; &nbsp; node-&gt;nestParams = nestParams;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> HashJoin *<br/></li>
<li><a id="L5973">&#x200c;</a><span class="linkable">make_hashjoin</span>(List *tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *joinclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *otherclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *hashclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *hashoperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *hashcollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *hashkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Plan *lefttree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Plan *righttree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JoinType jointype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> inner_unique)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HashJoin&nbsp;&nbsp; *node = makeNode(HashJoin);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;join.plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = tlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = otherclauses;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = lefttree;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = righttree;<br/></li>
<li>&nbsp; &nbsp; node-&gt;hashclauses = hashclauses;<br/></li>
<li>&nbsp; &nbsp; node-&gt;hashoperators = hashoperators;<br/></li>
<li>&nbsp; &nbsp; node-&gt;hashcollations = hashcollations;<br/></li>
<li>&nbsp; &nbsp; node-&gt;hashkeys = hashkeys;<br/></li>
<li>&nbsp; &nbsp; node-&gt;join.jointype = jointype;<br/></li>
<li>&nbsp; &nbsp; node-&gt;join.inner_unique = inner_unique;<br/></li>
<li>&nbsp; &nbsp; node-&gt;join.joinqual = joinclauses;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Hash *<br/></li>
<li><a id="L6004">&#x200c;</a><span class="linkable">make_hash</span>(Plan *lefttree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *hashkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid skewTable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber skewColumn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skewInherit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Hash&nbsp; &nbsp; &nbsp;&nbsp; *node = makeNode(Hash);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = lefttree-&gt;targetlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = NIL;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = lefttree;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node-&gt;hashkeys = hashkeys;<br/></li>
<li>&nbsp; &nbsp; node-&gt;skewTable = skewTable;<br/></li>
<li>&nbsp; &nbsp; node-&gt;skewColumn = skewColumn;<br/></li>
<li>&nbsp; &nbsp; node-&gt;skewInherit = skewInherit;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> MergeJoin *<br/></li>
<li><a id="L6027">&#x200c;</a><span class="linkable">make_mergejoin</span>(List *tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *joinclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *otherclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *mergeclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *mergefamilies,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *mergecollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *mergestrategies,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *mergenullsfirst,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Plan *lefttree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Plan *righttree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JoinType jointype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> inner_unique,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skip_mark_restore)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MergeJoin&nbsp; *node = makeNode(MergeJoin);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;join.plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = tlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = otherclauses;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = lefttree;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = righttree;<br/></li>
<li>&nbsp; &nbsp; node-&gt;skip_mark_restore = skip_mark_restore;<br/></li>
<li>&nbsp; &nbsp; node-&gt;mergeclauses = mergeclauses;<br/></li>
<li>&nbsp; &nbsp; node-&gt;mergeFamilies = mergefamilies;<br/></li>
<li>&nbsp; &nbsp; node-&gt;mergeCollations = mergecollations;<br/></li>
<li>&nbsp; &nbsp; node-&gt;mergeStrategies = mergestrategies;<br/></li>
<li>&nbsp; &nbsp; node-&gt;mergeNullsFirst = mergenullsfirst;<br/></li>
<li>&nbsp; &nbsp; node-&gt;join.jointype = jointype;<br/></li>
<li>&nbsp; &nbsp; node-&gt;join.inner_unique = inner_unique;<br/></li>
<li>&nbsp; &nbsp; node-&gt;join.joinqual = joinclauses;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6068" title="optimizer/plan/createplan.c:6068">make_sort</a> --- basic routine to build a Sort plan node<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must have built the sortColIdx, sortOperators, collations, and<br/></li>
<li></span><span class="Comment"> * nullsFirst arrays already.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Sort *<br/></li>
<li><a id="L6068">&#x200c;</a><span class="linkable">make_sort</span>(Plan *lefttree, <span class="Type">int</span> numCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber *sortColIdx, Oid *sortOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid *collations, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *nullsFirst)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Sort&nbsp; &nbsp; &nbsp;&nbsp; *node;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node = makeNode(Sort);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan = &amp;node-&gt;plan;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = lefttree-&gt;targetlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = NIL;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = lefttree;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;numCols = numCols;<br/></li>
<li>&nbsp; &nbsp; node-&gt;sortColIdx = sortColIdx;<br/></li>
<li>&nbsp; &nbsp; node-&gt;sortOperators = sortOperators;<br/></li>
<li>&nbsp; &nbsp; node-&gt;collations = collations;<br/></li>
<li>&nbsp; &nbsp; node-&gt;nullsFirst = nullsFirst;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6098" title="optimizer/plan/createplan.c:6098">make_incrementalsort</a> --- basic routine to build an IncrementalSort plan node<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must have built the sortColIdx, sortOperators, collations, and<br/></li>
<li></span><span class="Comment"> * nullsFirst arrays already.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> IncrementalSort *<br/></li>
<li><a id="L6098">&#x200c;</a><span class="linkable">make_incrementalsort</span>(Plan *lefttree, <span class="Type">int</span> numCols, <span class="Type">int</span> nPresortedCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AttrNumber *sortColIdx, Oid *sortOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *collations, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *nullsFirst)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IncrementalSort *node;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node = makeNode(IncrementalSort);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan = &amp;node-&gt;sort.plan;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = lefttree-&gt;targetlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = NIL;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = lefttree;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;nPresortedCols = nPresortedCols;<br/></li>
<li>&nbsp; &nbsp; node-&gt;sort.numCols = numCols;<br/></li>
<li>&nbsp; &nbsp; node-&gt;sort.sortColIdx = sortColIdx;<br/></li>
<li>&nbsp; &nbsp; node-&gt;sort.sortOperators = sortOperators;<br/></li>
<li>&nbsp; &nbsp; node-&gt;sort.collations = collations;<br/></li>
<li>&nbsp; &nbsp; node-&gt;sort.nullsFirst = nullsFirst;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6164" title="optimizer/plan/createplan.c:6164">prepare_sort_from_pathkeys</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Prepare to sort according to given pathkeys<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used to set up for Sort, MergeAppend, and Gather Merge nodes.&nbsp; It<br/></li>
<li></span><span class="Comment"> * calculates the executor's representation of the sort key information, and<br/></li>
<li></span><span class="Comment"> * adjusts the plan targetlist if needed to add resjunk sort columns.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Input parameters:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; 'lefttree' is the plan node which yields input tuples<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; 'pathkeys' is the list of pathkeys by which the result is to be sorted<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; 'relids' identifies the child relation being sorted, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; 'reqColIdx' is NULL or an array of required sort key column numbers<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; 'adjust_tlist_in_place' is true if lefttree must be modified in-place<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We must convert the pathkey information into arrays of sort key column<br/></li>
<li></span><span class="Comment"> * numbers, sort operator OIDs, collation OIDs, and nulls-first flags,<br/></li>
<li></span><span class="Comment"> * which is the representation the executor wants.&nbsp; These are returned into<br/></li>
<li></span><span class="Comment"> * the output parameters *p_numsortkeys etc.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When looking for matches to an EquivalenceClass's members, we will only<br/></li>
<li></span><span class="Comment"> * consider child EC members if they belong to given 'relids'.&nbsp; This protects<br/></li>
<li></span><span class="Comment"> * against possible incorrect matches to child expressions that contain no<br/></li>
<li></span><span class="Comment"> * Vars.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If reqColIdx isn't NULL then it contains sort key column numbers that<br/></li>
<li></span><span class="Comment"> * we should match.&nbsp; This is used when making child plans for a MergeAppend;<br/></li>
<li></span><span class="Comment"> * it's an error if we can't match the columns.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the pathkeys include expressions that aren't simple Vars, we will<br/></li>
<li></span><span class="Comment"> * usually need to add resjunk items to the input plan's targetlist to<br/></li>
<li></span><span class="Comment"> * compute these expressions, since a Sort or MergeAppend node itself won't<br/></li>
<li></span><span class="Comment"> * do <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such calculations.&nbsp; If the input plan type isn't one that can do<br/></li>
<li></span><span class="Comment"> * projections, this means adding a Result node just to do the projection.<br/></li>
<li></span><span class="Comment"> * However, the caller can pass adjust_tlist_in_place = true to force the<br/></li>
<li></span><span class="Comment"> * lefttree tlist to be modified in-place regardless of whether the node type<br/></li>
<li></span><span class="Comment"> * can project --- we use this for fixing the tlist of MergeAppend itself.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the node which is to be the input to the Sort (either lefttree,<br/></li>
<li></span><span class="Comment"> * or a Result stacked atop lefttree).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Plan *<br/></li>
<li><a id="L6164">&#x200c;</a><span class="linkable">prepare_sort_from_pathkeys</span>(Plan *lefttree, List *pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> AttrNumber *reqColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> adjust_tlist_in_place,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *p_numsortkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AttrNumber **p_sortColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid **p_sortOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid **p_collations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> **p_nullsFirst)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist = lefttree-&gt;targetlist;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numsortkeys;<br/></li>
<li>&nbsp; &nbsp; AttrNumber *sortColIdx;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *sortOperators;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *collations;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nullsFirst;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We will need at most list_length(pathkeys) sort columns; possibly less<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; numsortkeys = list_length(pathkeys);<br/></li>
<li>&nbsp; &nbsp; sortColIdx = (AttrNumber *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numsortkeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber));<br/></li>
<li>&nbsp; &nbsp; sortOperators = (Oid *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numsortkeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; collations = (Oid *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numsortkeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; nullsFirst = (<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numsortkeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; numsortkeys = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(i, pathkeys)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *pathkey = (PathKey *) lfirst(i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EquivalenceClass *ec = pathkey-&gt;pk_eclass;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EquivalenceMember *em;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pk_datatype = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ec-&gt;ec_has_volatile)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the pathkey's EquivalenceClass is volatile, then it must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have come from an ORDER BY clause, and we have to match it to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that same targetlist entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ec-&gt;ec_sortref == <span class="Constant">0</span>)&nbsp; &nbsp; <span class="Comment">/* can't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;volatile EquivalenceClass has no sortref&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../util/tlist.c.html#L345" title="optimizer/util/tlist.c:345">get_sortgroupref_tle</a>(ec-&gt;ec_sortref, tlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(tle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(ec-&gt;ec_members) == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pk_datatype = ((EquivalenceMember *) linitial(ec-&gt;ec_members))-&gt;em_datatype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (reqColIdx != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are given a sort column number to match, only consider<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the single TLE at that position.&nbsp; It's possible that there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no such TLE, in which case fall through and generate a resjunk<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * targetentry (we assume this must have happened in the parent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * plan as well).&nbsp; If there is a TLE but it doesn't match the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pathkey's EC, we do the same, which is probably the wrong thing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but we'll leave it to caller to complain about the mismatch.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../../parser/parse_relation.c.html#L3439" title="parser/parse_relation.c:3439">get_tle_by_resno</a>(tlist, reqColIdx[numsortkeys]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; em = <a href="../path/equivclass.c.html#L771" title="optimizer/path/equivclass.c:771">find_ec_member_matching_expr</a>(ec, tle-&gt;expr, relids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (em)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* found expr at right place in tlist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pk_datatype = em-&gt;em_datatype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, we can sort by <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-constant expression listed in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the pathkey's EquivalenceClass.&nbsp; For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we take the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tlist item found in the EC. If there's no match, we'll generate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a resjunk entry using the first EC member that is an expression<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the input's <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> if we have a choice, is there <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> way of figuring out which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might be cheapest to execute?&nbsp; (For example, <a href="../../utils/adt/int.c.html#L414" title="utils/adt/int.c:414">int4lt</a> is likely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * much cheaper to execute than numericlt, but both might appear<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the same equivalence class...)&nbsp; Not clear that we ever will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have an interesting choice in practice, so it may not matter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(j, tlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle = (TargetEntry *) lfirst(j);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; em = <a href="../path/equivclass.c.html#L771" title="optimizer/path/equivclass.c:771">find_ec_member_matching_expr</a>(ec, tle-&gt;expr, relids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (em)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* found expr already in tlist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pk_datatype = em-&gt;em_datatype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tle)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No matching tlist item; look for a computable expression.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; em = <a href="../path/equivclass.c.html#L836" title="optimizer/path/equivclass.c:836">find_computable_ec_member</a>(<span class="Constant">NULL</span>, ec, tlist, relids, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!em)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> pathkey item to sort&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pk_datatype = em-&gt;em_datatype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do we need to insert a Result node?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!adjust_tlist_in_place &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L7257" title="optimizer/plan/createplan.c:7257">is_projection_capable_plan</a>(lefttree))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy needed so we don't modify input's tlist below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tlist = copyObject(tlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lefttree = <a href="#L2120" title="optimizer/plan/createplan.c:2120">inject_projection_plan</a>(lefttree, tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lefttree-&gt;parallel_safe);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't bother testing <a href="#L7257" title="optimizer/plan/createplan.c:7257">is_projection_capable_plan</a> again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; adjust_tlist_in_place = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add resjunk entry to input's tlist<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>(copyObject(em-&gt;em_expr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(tlist) + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tlist, tle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lefttree-&gt;targetlist = tlist;&nbsp; &nbsp; <span class="Comment">/* just in case NIL <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Look up the correct sort operator from the PathKey's slightly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * abstracted representation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sortop = <a href="../../utils/cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(pathkey-&gt;pk_opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pk_datatype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pk_datatype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pathkey-&gt;pk_strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(sortop))&nbsp; &nbsp; <span class="Comment">/* should not happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing operator </span><span class="Special">%d</span><span class="Constant">(</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) in opfamily </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pathkey-&gt;pk_strategy, pk_datatype, pk_datatype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pathkey-&gt;pk_opfamily);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add the column to the sort arrays */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sortColIdx[numsortkeys] = tle-&gt;resno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortOperators[numsortkeys] = sortop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; collations[numsortkeys] = ec-&gt;ec_collation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nullsFirst[numsortkeys] = pathkey-&gt;pk_nulls_first;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numsortkeys++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return results */<br/></li>
<li></span>&nbsp; &nbsp; *p_numsortkeys = numsortkeys;<br/></li>
<li>&nbsp; &nbsp; *p_sortColIdx = sortColIdx;<br/></li>
<li>&nbsp; &nbsp; *p_sortOperators = sortOperators;<br/></li>
<li>&nbsp; &nbsp; *p_collations = collations;<br/></li>
<li>&nbsp; &nbsp; *p_nullsFirst = nullsFirst;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> lefttree;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6346" title="optimizer/plan/createplan.c:6346">make_sort_from_pathkeys</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create sort plan to sort according to given pathkeys<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; 'lefttree' is the node which yields input tuples<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; 'pathkeys' is the list of pathkeys by which the result is to be sorted<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; 'relids' is the set of relations required by <a href="#L6164" title="optimizer/plan/createplan.c:6164">prepare_sort_from_pathkeys</a>()<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Sort *<br/></li>
<li><a id="L6346">&#x200c;</a><span class="linkable">make_sort_from_pathkeys</span>(Plan *lefttree, List *pathkeys, Relids relids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numsortkeys;<br/></li>
<li>&nbsp; &nbsp; AttrNumber *sortColIdx;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *sortOperators;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *collations;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nullsFirst;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute sort column info, and adjust lefttree as needed */<br/></li>
<li></span>&nbsp; &nbsp; lefttree = <a href="#L6164" title="optimizer/plan/createplan.c:6164">prepare_sort_from_pathkeys</a>(lefttree, pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;numsortkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;sortColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;sortOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;collations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;nullsFirst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now build the Sort node */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L6068" title="optimizer/plan/createplan.c:6068">make_sort</a>(lefttree, numsortkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sortColIdx, sortOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collations, nullsFirst);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6381" title="optimizer/plan/createplan.c:6381">make_incrementalsort_from_pathkeys</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create sort plan to sort according to given pathkeys<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; 'lefttree' is the node which yields input tuples<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; 'pathkeys' is the list of pathkeys by which the result is to be sorted<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; 'relids' is the set of relations required by <a href="#L6164" title="optimizer/plan/createplan.c:6164">prepare_sort_from_pathkeys</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; 'nPresortedCols' is the number of presorted columns in input tuples<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> IncrementalSort *<br/></li>
<li><a id="L6381">&#x200c;</a><span class="linkable">make_incrementalsort_from_pathkeys</span>(Plan *lefttree, List *pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids relids, <span class="Type">int</span> nPresortedCols)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numsortkeys;<br/></li>
<li>&nbsp; &nbsp; AttrNumber *sortColIdx;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *sortOperators;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *collations;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nullsFirst;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute sort column info, and adjust lefttree as needed */<br/></li>
<li></span>&nbsp; &nbsp; lefttree = <a href="#L6164" title="optimizer/plan/createplan.c:6164">prepare_sort_from_pathkeys</a>(lefttree, pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;numsortkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;sortColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;sortOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;collations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;nullsFirst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now build the Sort node */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L6098" title="optimizer/plan/createplan.c:6098">make_incrementalsort</a>(lefttree, numsortkeys, nPresortedCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortColIdx, sortOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collations, nullsFirst);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6415" title="optimizer/plan/createplan.c:6415">make_sort_from_sortclauses</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create sort plan to sort according to given sortclauses<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; 'sortcls' is a list of SortGroupClauses<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; 'lefttree' is the node which yields input tuples<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Sort *<br/></li>
<li><a id="L6415">&#x200c;</a><span class="linkable">make_sort_from_sortclauses</span>(List *sortcls, Plan *lefttree)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sub_tlist = lefttree-&gt;targetlist;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numsortkeys;<br/></li>
<li>&nbsp; &nbsp; AttrNumber *sortColIdx;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *sortOperators;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *collations;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nullsFirst;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert list-ish representation to arrays wanted by executor */<br/></li>
<li></span>&nbsp; &nbsp; numsortkeys = list_length(sortcls);<br/></li>
<li>&nbsp; &nbsp; sortColIdx = (AttrNumber *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numsortkeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber));<br/></li>
<li>&nbsp; &nbsp; sortOperators = (Oid *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numsortkeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; collations = (Oid *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numsortkeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; nullsFirst = (<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numsortkeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; numsortkeys = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(l, sortcls)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *sortcl = (SortGroupClause *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = <a href="../util/tlist.c.html#L367" title="optimizer/util/tlist.c:367">get_sortgroupclause_tle</a>(sortcl, sub_tlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortColIdx[numsortkeys] = tle-&gt;resno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortOperators[numsortkeys] = sortcl-&gt;sortop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; collations[numsortkeys] = <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) tle-&gt;expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nullsFirst[numsortkeys] = sortcl-&gt;nulls_first;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numsortkeys++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L6068" title="optimizer/plan/createplan.c:6068">make_sort</a>(lefttree, numsortkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sortColIdx, sortOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collations, nullsFirst);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6464" title="optimizer/plan/createplan.c:6464">make_sort_from_groupcols</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create sort plan to sort based on grouping columns<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'groupcls' is the list of SortGroupClauses<br/></li>
<li></span><span class="Comment"> * 'grpColIdx' gives the column numbers to use<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This might look like it could be merged with <a href="#L6415" title="optimizer/plan/createplan.c:6415">make_sort_from_sortclauses</a>,<br/></li>
<li></span><span class="Comment"> * but presently we *must* use the grpColIdx[] array to locate sort columns,<br/></li>
<li></span><span class="Comment"> * because the child plan's tlist is not marked with ressortgroupref info<br/></li>
<li></span><span class="Comment"> * appropriate to the grouping node.&nbsp; So, only the sort ordering info<br/></li>
<li></span><span class="Comment"> * is used from the SortGroupClause entries.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Sort *<br/></li>
<li><a id="L6464">&#x200c;</a><span class="linkable">make_sort_from_groupcols</span>(List *groupcls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AttrNumber *grpColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Plan *lefttree)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sub_tlist = lefttree-&gt;targetlist;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numsortkeys;<br/></li>
<li>&nbsp; &nbsp; AttrNumber *sortColIdx;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *sortOperators;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *collations;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nullsFirst;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert list-ish representation to arrays wanted by executor */<br/></li>
<li></span>&nbsp; &nbsp; numsortkeys = list_length(groupcls);<br/></li>
<li>&nbsp; &nbsp; sortColIdx = (AttrNumber *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numsortkeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber));<br/></li>
<li>&nbsp; &nbsp; sortOperators = (Oid *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numsortkeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; collations = (Oid *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numsortkeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; nullsFirst = (<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numsortkeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; numsortkeys = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(l, groupcls)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *grpcl = (SortGroupClause *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = <a href="../../parser/parse_relation.c.html#L3439" title="parser/parse_relation.c:3439">get_tle_by_resno</a>(sub_tlist, grpColIdx[numsortkeys]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tle)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not retrieve tle for sort-from-groupcols&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortColIdx[numsortkeys] = tle-&gt;resno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortOperators[numsortkeys] = grpcl-&gt;sortop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; collations[numsortkeys] = <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) tle-&gt;expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nullsFirst[numsortkeys] = grpcl-&gt;nulls_first;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numsortkeys++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L6068" title="optimizer/plan/createplan.c:6068">make_sort</a>(lefttree, numsortkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sortColIdx, sortOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collations, nullsFirst);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Material *<br/></li>
<li><a id="L6505">&#x200c;</a><span class="linkable">make_material</span>(Plan *lefttree)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Material&nbsp;&nbsp; *node = makeNode(Material);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = lefttree-&gt;targetlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = NIL;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = lefttree;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6527" title="optimizer/plan/createplan.c:6527">materialize_finished_plan</a>: stick a Material node atop a completed plan<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There are a couple of places where we want to attach a Material node<br/></li>
<li></span><span class="Comment"> * after completion of <a href="#L337" title="optimizer/plan/createplan.c:337">create_plan</a>(), without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> MaterialPath path.<br/></li>
<li></span><span class="Comment"> * Those places should probably be refactored someday to do this on the<br/></li>
<li></span><span class="Comment"> * Path representation, but it's not worth the trouble yet.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Plan *<br/></li>
<li><a id="L6527">&#x200c;</a><span class="linkable">materialize_finished_plan</span>(Plan *subplan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *matplan;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp; &nbsp; matpath;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dummy for result of <a href="../path/costsize.c.html#L2453" title="optimizer/path/costsize.c:2453">cost_material</a> */<br/></li>
<li></span>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; initplan_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; unsafe_initplans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; matplan = (Plan *) <a href="#L6505" title="optimizer/plan/createplan.c:6505">make_material</a>(subplan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> horrid kluge: if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> initPlans attached to the subplan,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * move them up to the Material node, which is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> effectively the top<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plan node in its query level.&nbsp; This prevents failure in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="subselect.c.html#L2254" title="optimizer/plan/subselect.c:2254">SS_finalize_plan</a>(), which see for comments.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; matplan-&gt;initPlan = subplan-&gt;initPlan;<br/></li>
<li>&nbsp; &nbsp; subplan-&gt;initPlan = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Move the initplans' cost delta, as well */<br/></li>
<li></span>&nbsp; &nbsp; <a href="subselect.c.html#L2198" title="optimizer/plan/subselect.c:2198">SS_compute_initplan_cost</a>(matplan-&gt;initPlan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;initplan_cost, &amp;unsafe_initplans);<br/></li>
<li>&nbsp; &nbsp; subplan-&gt;startup_cost -= initplan_cost;<br/></li>
<li>&nbsp; &nbsp; subplan-&gt;total_cost -= initplan_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set cost data */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../path/costsize.c.html#L2453" title="optimizer/path/costsize.c:2453">cost_material</a>(&amp;matpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subplan-&gt;startup_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subplan-&gt;total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subplan-&gt;plan_rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subplan-&gt;plan_width);<br/></li>
<li>&nbsp; &nbsp; matplan-&gt;startup_cost = matpath.startup_cost + initplan_cost;<br/></li>
<li>&nbsp; &nbsp; matplan-&gt;total_cost = matpath.total_cost + initplan_cost;<br/></li>
<li>&nbsp; &nbsp; matplan-&gt;plan_rows = subplan-&gt;plan_rows;<br/></li>
<li>&nbsp; &nbsp; matplan-&gt;plan_width = subplan-&gt;plan_width;<br/></li>
<li>&nbsp; &nbsp; matplan-&gt;parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; matplan-&gt;parallel_safe = subplan-&gt;parallel_safe;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> matplan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Memoize *<br/></li>
<li><a id="L6568">&#x200c;</a><span class="linkable">make_memoize</span>(Plan *lefttree, Oid *hashoperators, Oid *collations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *param_exprs, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> singlerow, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> binary_mode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint32 est_entries, Bitmapset *keyparamids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Memoize&nbsp; &nbsp; *node = makeNode(Memoize);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = lefttree-&gt;targetlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = NIL;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = lefttree;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node-&gt;numKeys = list_length(param_exprs);<br/></li>
<li>&nbsp; &nbsp; node-&gt;hashOperators = hashoperators;<br/></li>
<li>&nbsp; &nbsp; node-&gt;collations = collations;<br/></li>
<li>&nbsp; &nbsp; node-&gt;param_exprs = param_exprs;<br/></li>
<li>&nbsp; &nbsp; node-&gt;singlerow = singlerow;<br/></li>
<li>&nbsp; &nbsp; node-&gt;binary_mode = binary_mode;<br/></li>
<li>&nbsp; &nbsp; node-&gt;est_entries = est_entries;<br/></li>
<li>&nbsp; &nbsp; node-&gt;keyparamids = keyparamids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Agg *<br/></li>
<li><a id="L6593">&#x200c;</a><span class="linkable">make_agg</span>(List *tlist, List *qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AggStrategy aggstrategy, AggSplit aggsplit,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> numGroupCols, AttrNumber *grpColIdx, Oid *grpOperators, Oid *grpCollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *groupingSets, List *chain, <span class="Type">double</span> dNumGroups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Size transitionSpace, Plan *lefttree)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Agg&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *node = makeNode(Agg);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;plan;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; numGroups;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reduce to long, but 'ware overflow! */<br/></li>
<li></span>&nbsp; &nbsp; numGroups = <a href="../path/costsize.c.html#L254" title="optimizer/path/costsize.c:254">clamp_cardinality_to_long</a>(dNumGroups);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node-&gt;aggstrategy = aggstrategy;<br/></li>
<li>&nbsp; &nbsp; node-&gt;aggsplit = aggsplit;<br/></li>
<li>&nbsp; &nbsp; node-&gt;numCols = numGroupCols;<br/></li>
<li>&nbsp; &nbsp; node-&gt;grpColIdx = grpColIdx;<br/></li>
<li>&nbsp; &nbsp; node-&gt;grpOperators = grpOperators;<br/></li>
<li>&nbsp; &nbsp; node-&gt;grpCollations = grpCollations;<br/></li>
<li>&nbsp; &nbsp; node-&gt;numGroups = numGroups;<br/></li>
<li>&nbsp; &nbsp; node-&gt;transitionSpace = transitionSpace;<br/></li>
<li>&nbsp; &nbsp; node-&gt;aggParams = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="subselect.c.html#L2254" title="optimizer/plan/subselect.c:2254">SS_finalize_plan</a>() will fill this */<br/></li>
<li></span>&nbsp; &nbsp; node-&gt;groupingSets = groupingSets;<br/></li>
<li>&nbsp; &nbsp; node-&gt;chain = chain;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = qual;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = tlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = lefttree;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> WindowAgg *<br/></li>
<li><a id="L6627">&#x200c;</a><span class="linkable">make_windowagg</span>(List *tlist, Index winref,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> partNumCols, AttrNumber *partColIdx, Oid *partOperators, Oid *partCollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> ordNumCols, AttrNumber *ordColIdx, Oid *ordOperators, Oid *ordCollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> frameOptions, Node *startOffset, Node *endOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid startInRangeFunc, Oid endInRangeFunc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid inRangeColl, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> inRangeAsc, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> inRangeNullsFirst,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *runCondition, List *qual, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> topWindow, Plan *lefttree)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WindowAgg&nbsp; *node = makeNode(WindowAgg);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node-&gt;winref = winref;<br/></li>
<li>&nbsp; &nbsp; node-&gt;partNumCols = partNumCols;<br/></li>
<li>&nbsp; &nbsp; node-&gt;partColIdx = partColIdx;<br/></li>
<li>&nbsp; &nbsp; node-&gt;partOperators = partOperators;<br/></li>
<li>&nbsp; &nbsp; node-&gt;partCollations = partCollations;<br/></li>
<li>&nbsp; &nbsp; node-&gt;ordNumCols = ordNumCols;<br/></li>
<li>&nbsp; &nbsp; node-&gt;ordColIdx = ordColIdx;<br/></li>
<li>&nbsp; &nbsp; node-&gt;ordOperators = ordOperators;<br/></li>
<li>&nbsp; &nbsp; node-&gt;ordCollations = ordCollations;<br/></li>
<li>&nbsp; &nbsp; node-&gt;frameOptions = frameOptions;<br/></li>
<li>&nbsp; &nbsp; node-&gt;startOffset = startOffset;<br/></li>
<li>&nbsp; &nbsp; node-&gt;endOffset = endOffset;<br/></li>
<li>&nbsp; &nbsp; node-&gt;runCondition = runCondition;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* a duplicate of the above for EXPLAIN */<br/></li>
<li></span>&nbsp; &nbsp; node-&gt;runConditionOrig = runCondition;<br/></li>
<li>&nbsp; &nbsp; node-&gt;startInRangeFunc = startInRangeFunc;<br/></li>
<li>&nbsp; &nbsp; node-&gt;endInRangeFunc = endInRangeFunc;<br/></li>
<li>&nbsp; &nbsp; node-&gt;inRangeColl = inRangeColl;<br/></li>
<li>&nbsp; &nbsp; node-&gt;inRangeAsc = inRangeAsc;<br/></li>
<li>&nbsp; &nbsp; node-&gt;inRangeNullsFirst = inRangeNullsFirst;<br/></li>
<li>&nbsp; &nbsp; node-&gt;topWindow = topWindow;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = tlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = lefttree;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = qual;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Group *<br/></li>
<li><a id="L6669">&#x200c;</a><span class="linkable">make_group</span>(List *tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> numGroupCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AttrNumber *grpColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *grpOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *grpCollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Plan *lefttree)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Group&nbsp; &nbsp; &nbsp;&nbsp; *node = makeNode(Group);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node-&gt;numCols = numGroupCols;<br/></li>
<li>&nbsp; &nbsp; node-&gt;grpColIdx = grpColIdx;<br/></li>
<li>&nbsp; &nbsp; node-&gt;grpOperators = grpOperators;<br/></li>
<li>&nbsp; &nbsp; node-&gt;grpCollations = grpCollations;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = qual;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = tlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = lefttree;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * distinctList is a list of SortGroupClauses, identifying the targetlist items<br/></li>
<li></span><span class="Comment"> * that should be considered by the Unique filter.&nbsp; The input path must<br/></li>
<li></span><span class="Comment"> * already be sorted accordingly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Unique *<br/></li>
<li><a id="L6699">&#x200c;</a><span class="linkable">make_unique_from_sortclauses</span>(Plan *lefttree, List *distinctList)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Unique&nbsp; &nbsp; &nbsp;&nbsp; *node = makeNode(Unique);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;plan;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numCols = list_length(distinctList);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; AttrNumber *uniqColIdx;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *uniqOperators;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *uniqCollations;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *slitem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = lefttree-&gt;targetlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = NIL;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = lefttree;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * convert SortGroupClause list into arrays of attr indexes and equality<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operators, as wanted by executor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(numCols &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; uniqColIdx = (AttrNumber *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber) * numCols);<br/></li>
<li>&nbsp; &nbsp; uniqOperators = (Oid *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * numCols);<br/></li>
<li>&nbsp; &nbsp; uniqCollations = (Oid *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * numCols);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(slitem, distinctList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *sortcl = (SortGroupClause *) lfirst(slitem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = <a href="../util/tlist.c.html#L367" title="optimizer/util/tlist.c:367">get_sortgroupclause_tle</a>(sortcl, plan-&gt;targetlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uniqColIdx[keyno] = tle-&gt;resno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uniqOperators[keyno] = sortcl-&gt;eqop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uniqCollations[keyno] = <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) tle-&gt;expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(OidIsValid(uniqOperators[keyno]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; keyno++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node-&gt;numCols = numCols;<br/></li>
<li>&nbsp; &nbsp; node-&gt;uniqColIdx = uniqColIdx;<br/></li>
<li>&nbsp; &nbsp; node-&gt;uniqOperators = uniqOperators;<br/></li>
<li>&nbsp; &nbsp; node-&gt;uniqCollations = uniqCollations;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * as above, but use pathkeys to identify the sort columns and semantics<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Unique *<br/></li>
<li><a id="L6748">&#x200c;</a><span class="linkable">make_unique_from_pathkeys</span>(Plan *lefttree, List *pathkeys, <span class="Type">int</span> numCols)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Unique&nbsp; &nbsp; &nbsp;&nbsp; *node = makeNode(Unique);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;plan;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; AttrNumber *uniqColIdx;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *uniqOperators;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *uniqCollations;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = lefttree-&gt;targetlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = NIL;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = lefttree;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Convert pathkeys list into arrays of attr indexes and equality<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operators, as wanted by executor.&nbsp; This has a lot in common with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L6164" title="optimizer/plan/createplan.c:6164">prepare_sort_from_pathkeys</a> ... maybe unify sometime?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(numCols &gt;= <span class="Constant">0</span> &amp;&amp; numCols &lt;= list_length(pathkeys));<br/></li>
<li>&nbsp; &nbsp; uniqColIdx = (AttrNumber *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber) * numCols);<br/></li>
<li>&nbsp; &nbsp; uniqOperators = (Oid *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * numCols);<br/></li>
<li>&nbsp; &nbsp; uniqCollations = (Oid *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * numCols);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, pathkeys)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *pathkey = (PathKey *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EquivalenceClass *ec = pathkey-&gt;pk_eclass;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EquivalenceMember *em;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pk_datatype = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eqop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore pathkeys beyond the specified number of columns */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (keyno &gt;= numCols)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ec-&gt;ec_has_volatile)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the pathkey's EquivalenceClass is volatile, then it must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have come from an ORDER BY clause, and we have to match it to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that same targetlist entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ec-&gt;ec_sortref == <span class="Constant">0</span>)&nbsp; &nbsp; <span class="Comment">/* can't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;volatile EquivalenceClass has no sortref&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../util/tlist.c.html#L345" title="optimizer/util/tlist.c:345">get_sortgroupref_tle</a>(ec-&gt;ec_sortref, plan-&gt;targetlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(tle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(ec-&gt;ec_members) == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pk_datatype = ((EquivalenceMember *) linitial(ec-&gt;ec_members))-&gt;em_datatype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, we can use <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-constant expression listed in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pathkey's EquivalenceClass.&nbsp; For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we take the first tlist<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * item found in the EC.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(j, plan-&gt;targetlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle = (TargetEntry *) lfirst(j);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; em = <a href="../path/equivclass.c.html#L771" title="optimizer/path/equivclass.c:771">find_ec_member_matching_expr</a>(ec, tle-&gt;expr, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (em)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* found expr already in tlist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pk_datatype = em-&gt;em_datatype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tle)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> pathkey item to sort&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Look up the correct equality operator from the PathKey's slightly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * abstracted representation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; eqop = <a href="../../utils/cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(pathkey-&gt;pk_opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pk_datatype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pk_datatype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTEqualStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(eqop))&nbsp; &nbsp; <span class="Comment">/* should not happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing operator </span><span class="Special">%d</span><span class="Constant">(</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) in opfamily </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTEqualStrategyNumber, pk_datatype, pk_datatype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pathkey-&gt;pk_opfamily);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uniqColIdx[keyno] = tle-&gt;resno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uniqOperators[keyno] = eqop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uniqCollations[keyno] = ec-&gt;ec_collation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; keyno++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node-&gt;numCols = numCols;<br/></li>
<li>&nbsp; &nbsp; node-&gt;uniqColIdx = uniqColIdx;<br/></li>
<li>&nbsp; &nbsp; node-&gt;uniqOperators = uniqOperators;<br/></li>
<li>&nbsp; &nbsp; node-&gt;uniqCollations = uniqCollations;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Gather *<br/></li>
<li><a id="L6854">&#x200c;</a><span class="linkable">make_gather</span>(List *qptlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *qpqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nworkers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> rescan_param,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> single_copy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Plan *subplan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Gather&nbsp; &nbsp; &nbsp;&nbsp; *node = makeNode(Gather);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = qptlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = qpqual;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = subplan;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;num_workers = nworkers;<br/></li>
<li>&nbsp; &nbsp; node-&gt;rescan_param = rescan_param;<br/></li>
<li>&nbsp; &nbsp; node-&gt;single_copy = single_copy;<br/></li>
<li>&nbsp; &nbsp; node-&gt;invisible = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;initParam = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * distinctList is a list of SortGroupClauses, identifying the targetlist<br/></li>
<li></span><span class="Comment"> * items that should be considered by the SetOp filter.&nbsp; The input path must<br/></li>
<li></span><span class="Comment"> * already be sorted accordingly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> SetOp *<br/></li>
<li><a id="L6883">&#x200c;</a><span class="linkable">make_setop</span>(SetOpCmd cmd, SetOpStrategy strategy, Plan *lefttree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *distinctList, AttrNumber flagColIdx, <span class="Type">int</span> firstFlag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">long</span> numGroups)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SetOp&nbsp; &nbsp; &nbsp;&nbsp; *node = makeNode(SetOp);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;plan;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numCols = list_length(distinctList);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; AttrNumber *dupColIdx;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dupOperators;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dupCollations;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *slitem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = lefttree-&gt;targetlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = NIL;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = lefttree;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * convert SortGroupClause list into arrays of attr indexes and equality<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operators, as wanted by executor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dupColIdx = (AttrNumber *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber) * numCols);<br/></li>
<li>&nbsp; &nbsp; dupOperators = (Oid *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * numCols);<br/></li>
<li>&nbsp; &nbsp; dupCollations = (Oid *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * numCols);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(slitem, distinctList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *sortcl = (SortGroupClause *) lfirst(slitem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = <a href="../util/tlist.c.html#L367" title="optimizer/util/tlist.c:367">get_sortgroupclause_tle</a>(sortcl, plan-&gt;targetlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dupColIdx[keyno] = tle-&gt;resno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dupOperators[keyno] = sortcl-&gt;eqop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dupCollations[keyno] = <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) tle-&gt;expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(OidIsValid(dupOperators[keyno]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; keyno++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node-&gt;cmd = cmd;<br/></li>
<li>&nbsp; &nbsp; node-&gt;strategy = strategy;<br/></li>
<li>&nbsp; &nbsp; node-&gt;numCols = numCols;<br/></li>
<li>&nbsp; &nbsp; node-&gt;dupColIdx = dupColIdx;<br/></li>
<li>&nbsp; &nbsp; node-&gt;dupOperators = dupOperators;<br/></li>
<li>&nbsp; &nbsp; node-&gt;dupCollations = dupCollations;<br/></li>
<li>&nbsp; &nbsp; node-&gt;flagColIdx = flagColIdx;<br/></li>
<li>&nbsp; &nbsp; node-&gt;firstFlag = firstFlag;<br/></li>
<li>&nbsp; &nbsp; node-&gt;numGroups = numGroups;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6939" title="optimizer/plan/createplan.c:6939">make_lockrows</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Build a LockRows plan node<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> LockRows *<br/></li>
<li><a id="L6939">&#x200c;</a><span class="linkable">make_lockrows</span>(Plan *lefttree, List *rowMarks, <span class="Type">int</span> epqParam)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LockRows&nbsp;&nbsp; *node = makeNode(LockRows);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = lefttree-&gt;targetlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = NIL;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = lefttree;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node-&gt;rowMarks = rowMarks;<br/></li>
<li>&nbsp; &nbsp; node-&gt;epqParam = epqParam;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6960" title="optimizer/plan/createplan.c:6960">make_limit</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Build a Limit plan node<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Limit *<br/></li>
<li><a id="L6960">&#x200c;</a><span class="linkable">make_limit</span>(Plan *lefttree, Node *limitOffset, Node *limitCount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LimitOption limitOption, <span class="Type">int</span> uniqNumCols, AttrNumber *uniqColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *uniqOperators, Oid *uniqCollations)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Limit&nbsp; &nbsp; &nbsp;&nbsp; *node = makeNode(Limit);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = lefttree-&gt;targetlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = NIL;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = lefttree;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node-&gt;limitOffset = limitOffset;<br/></li>
<li>&nbsp; &nbsp; node-&gt;limitCount = limitCount;<br/></li>
<li>&nbsp; &nbsp; node-&gt;limitOption = limitOption;<br/></li>
<li>&nbsp; &nbsp; node-&gt;uniqNumCols = uniqNumCols;<br/></li>
<li>&nbsp; &nbsp; node-&gt;uniqColIdx = uniqColIdx;<br/></li>
<li>&nbsp; &nbsp; node-&gt;uniqOperators = uniqOperators;<br/></li>
<li>&nbsp; &nbsp; node-&gt;uniqCollations = uniqCollations;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6988" title="optimizer/plan/createplan.c:6988">make_result</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Build a Result plan node<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Result *<br/></li>
<li><a id="L6988">&#x200c;</a><span class="linkable">make_result</span>(List *tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *resconstantqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Plan *subplan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Result&nbsp; &nbsp; &nbsp;&nbsp; *node = makeNode(Result);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = tlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = NIL;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = subplan;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;resconstantqual = resconstantqual;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7009" title="optimizer/plan/createplan.c:7009">make_project_set</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Build a ProjectSet plan node<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ProjectSet *<br/></li>
<li><a id="L7009">&#x200c;</a><span class="linkable">make_project_set</span>(List *tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Plan *subplan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ProjectSet *node = makeNode(ProjectSet);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = &amp;node-&gt;plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = tlist;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = NIL;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;lefttree = subplan;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7028" title="optimizer/plan/createplan.c:7028">make_modifytable</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Build a ModifyTable plan node<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ModifyTable *<br/></li>
<li><a id="L7028">&#x200c;</a><span class="linkable">make_modifytable</span>(PlannerInfo *root, Plan *subplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CmdType operation, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> canSetTag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index nominalRelation, Index rootRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> partColsUpdated,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *resultRelations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *updateColnosLists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *withCheckOptionLists, List *returningLists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *rowMarks, OnConflictExpr *onconflict,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *mergeActionLists, List *mergeJoinConditions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> epqParam)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ModifyTable *node = makeNode(ModifyTable);<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *fdw_private_list;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *direct_modify_plans;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(operation == CMD_MERGE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (operation == CMD_UPDATE ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(resultRelations) == list_length(updateColnosLists) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updateColnosLists == NIL));<br/></li>
<li>&nbsp; &nbsp; Assert(withCheckOptionLists == NIL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_length(resultRelations) == list_length(withCheckOptionLists));<br/></li>
<li>&nbsp; &nbsp; Assert(returningLists == NIL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_length(resultRelations) == list_length(returningLists));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node-&gt;plan.lefttree = subplan;<br/></li>
<li>&nbsp; &nbsp; node-&gt;plan.righttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;plan.qual = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* setrefs.c will fill in the targetlist, if needed */<br/></li>
<li></span>&nbsp; &nbsp; node-&gt;plan.targetlist = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node-&gt;operation = operation;<br/></li>
<li>&nbsp; &nbsp; node-&gt;canSetTag = canSetTag;<br/></li>
<li>&nbsp; &nbsp; node-&gt;nominalRelation = nominalRelation;<br/></li>
<li>&nbsp; &nbsp; node-&gt;rootRelation = rootRelation;<br/></li>
<li>&nbsp; &nbsp; node-&gt;partColsUpdated = partColsUpdated;<br/></li>
<li>&nbsp; &nbsp; node-&gt;resultRelations = resultRelations;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!onconflict)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;onConflictAction = ONCONFLICT_NONE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;onConflictSet = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;onConflictCols = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;onConflictWhere = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;arbiterIndexes = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;exclRelRTI = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;exclRelTlist = NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;onConflictAction = onconflict-&gt;action;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Here we convert the ON CONFLICT UPDATE tlist, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * executor's convention of having consecutive resno's.&nbsp; The actual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * target column numbers are saved in node-&gt;onConflictCols.&nbsp; (This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could be done earlier, but there seems no need to.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;onConflictSet = onconflict-&gt;onConflictSet;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;onConflictCols =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../prep/preptlist.c.html#L345" title="optimizer/prep/preptlist.c:345">extract_update_targetlist_colnos</a>(node-&gt;onConflictSet);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;onConflictWhere = onconflict-&gt;onConflictWhere;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If a set of unique index inference elements was provided (an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * INSERT...ON CONFLICT &quot;inference specification&quot;), then infer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * appropriate unique indexes (or throw an error if <a href="../util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * available).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;arbiterIndexes = <a href="../util/plancat.c.html#L693" title="optimizer/util/plancat.c:693">infer_arbiter_indexes</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;exclRelRTI = onconflict-&gt;exclRelIndex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;exclRelTlist = onconflict-&gt;exclRelTlist;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; node-&gt;updateColnosLists = updateColnosLists;<br/></li>
<li>&nbsp; &nbsp; node-&gt;withCheckOptionLists = withCheckOptionLists;<br/></li>
<li>&nbsp; &nbsp; node-&gt;returningLists = returningLists;<br/></li>
<li>&nbsp; &nbsp; node-&gt;rowMarks = rowMarks;<br/></li>
<li>&nbsp; &nbsp; node-&gt;mergeActionLists = mergeActionLists;<br/></li>
<li>&nbsp; &nbsp; node-&gt;mergeJoinConditions = mergeJoinConditions;<br/></li>
<li>&nbsp; &nbsp; node-&gt;epqParam = epqParam;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For each result relation that is a foreign table, allow the FDW to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * construct private plan data, and accumulate it all into a list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fdw_private_list = NIL;<br/></li>
<li>&nbsp; &nbsp; direct_modify_plans = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, resultRelations)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; rti = lfirst_int(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FdwRoutine *fdwroutine;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *fdw_private;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; direct_modify;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If possible, we want to get the FdwRoutine from our RelOptInfo for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the table.&nbsp; But sometimes we don't have a RelOptInfo and must get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it the hard way.&nbsp; (In INSERT, the target relation is not scanned,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so it's not a baserel; and there are also corner cases for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * updatable views where the target rel isn't a baserel.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rti &lt; root-&gt;simple_rel_array_size &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;simple_rel_array[rti] != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *resultRel = root-&gt;simple_rel_array[rti];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdwroutine = resultRel-&gt;fdwroutine;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = planner_rt_fetch(rti, root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind == RTE_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;relkind == RELKIND_FOREIGN_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdwroutine = <a href="../../foreign/foreign.c.html#L409" title="foreign/foreign.c:409">GetFdwRoutineByRelId</a>(rte-&gt;relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdwroutine = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * MERGE is not currently supported for foreign tables.&nbsp; We already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checked that when the table mentioned in the query is foreign; but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we can still get here if a partitioned table has a foreign table as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partition.&nbsp; Disallow that <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, to avoid an uglier error message<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (operation == CMD_MERGE &amp;&amp; fdwroutine != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = planner_rt_fetch(rti, root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot execute MERGE on relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/cache/lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(rte-&gt;relid)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/pg_class.c.html#L24" title="catalog/pg_class.c:24">errdetail_relkind_not_supported</a>(rte-&gt;relkind));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to modify the foreign table directly if (1) the FDW provides<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * callback <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> needed for that and (2) there are no local<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * structures that need to be run for each modified row: row-level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * triggers on the foreign table, stored generated columns, WITH CHECK<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OPTIONs from parent views.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; direct_modify = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fdwroutine != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdwroutine-&gt;PlanDirectModify != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdwroutine-&gt;BeginDirectModify != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdwroutine-&gt;IterateDirectModify != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdwroutine-&gt;EndDirectModify != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; withCheckOptionLists == NIL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../util/plancat.c.html#L2223" title="optimizer/util/plancat.c:2223">has_row_triggers</a>(root, rti, operation) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../util/plancat.c.html#L2273" title="optimizer/util/plancat.c:2273">has_stored_generated_columns</a>(root, rti))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; direct_modify = fdwroutine-&gt;PlanDirectModify(root, node, rti, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (direct_modify)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; direct_modify_plans = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(direct_modify_plans, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!direct_modify &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdwroutine != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdwroutine-&gt;PlanForeignModify != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdw_private = fdwroutine-&gt;PlanForeignModify(root, node, rti, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdw_private = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fdw_private_list = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(fdw_private_list, fdw_private);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; node-&gt;fdwPrivLists = fdw_private_list;<br/></li>
<li>&nbsp; &nbsp; node-&gt;fdwDirectModifyPlans = direct_modify_plans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7207" title="optimizer/plan/createplan.c:7207">is_projection_capable_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Check whether a given Path node is able to do projection.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L7207">&#x200c;</a></span><span class="linkable">is_projection_capable_path</span>(Path *path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Most plan types can project, so just list the ones that can't */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (path-&gt;pathtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Hash:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Material:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Memoize:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Sort:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IncrementalSort:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Unique:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SetOp:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_LockRows:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Limit:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ModifyTable:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_MergeAppend:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_RecursiveUnion:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_CustomScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (castNode(CustomPath, path)-&gt;flags &amp; CUSTOMPATH_SUPPORT_PROJECTION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Append:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Append can't project, but if an AppendPath is being used to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * represent a dummy path, what will actually be generated is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Result which can project.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> IS_DUMMY_APPEND(path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ProjectSet:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Although ProjectSet certainly projects, say &quot;no&quot; because we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't want the <a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> to randomly replace its tlist with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * something else; the SRFs have to stay at top level.&nbsp; This might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * get relaxed later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7257" title="optimizer/plan/createplan.c:7257">is_projection_capable_plan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Check whether a given Plan node is able to do projection.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L7257">&#x200c;</a></span><span class="linkable">is_projection_capable_plan</span>(Plan *plan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Most plan types can project, so just list the ones that can't */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (nodeTag(plan))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Hash:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Material:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Memoize:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Sort:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Unique:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SetOp:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_LockRows:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Limit:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ModifyTable:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Append:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_MergeAppend:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_RecursiveUnion:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_CustomScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((CustomScan *) plan)-&gt;flags &amp; CUSTOMPATH_SUPPORT_PROJECTION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ProjectSet:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Although ProjectSet certainly projects, say &quot;no&quot; because we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't want the <a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> to randomly replace its tlist with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * something else; the SRFs have to stay at top level.&nbsp; This might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * get relaxed later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
