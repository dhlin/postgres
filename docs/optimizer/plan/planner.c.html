<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>optimizer/plan/planner.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>optimizer/plan/planner.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L74">create_upper_paths_hook</a></li>
<li><a href="#L66">cursor_tuple_fraction</a></li>
<li><a href="#L67">debug_parallel_query</a></li>
<li><a href="#L68">parallel_leader_participation</a></li>
<li><a href="#L71">planner_hook</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L116">WindowClauseSortData</a></li>
<li><a href="#L105">grouping_sets_data</a></li>
<li><a href="#L125">standard_qp_extra</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L6842">add_paths_to_grouping_rel</a></li>
<li><a href="#L3173">adjust_group_pathkeys_for_groupagg</a></li>
<li><a href="#L6341">adjust_paths_for_srfs</a></li>
<li><a href="#L7503">apply_scanjoin_target_to_paths</a></li>
<li><a href="#L7461">can_partial_agg</a></li>
<li><a href="#L5812">common_prefix_cmp</a></li>
<li><a href="#L4048">consider_groupingsets_paths</a></li>
<li><a href="#L3845">create_degenerate_grouping_paths</a></li>
<li><a href="#L4630">create_distinct_paths</a></li>
<li><a href="#L4899">create_final_distinct_paths</a></li>
<li><a href="#L3658">create_grouping_paths</a></li>
<li><a href="#L4497">create_one_window_path</a></li>
<li><a href="#L5106">create_ordered_paths</a></li>
<li><a href="#L3909">create_ordinary_grouping_paths</a></li>
<li><a href="#L4700">create_partial_distinct_paths</a></li>
<li><a href="#L7077">create_partial_grouping_paths</a></li>
<li><a href="#L7738">create_partitionwise_grouping_paths</a></li>
<li><a href="#L4410">create_window_paths</a></li>
<li><a href="#L6457">expression_planner</a></li>
<li><a href="#L6484">expression_planner_with_deps</a></li>
<li><a href="#L2868">extract_rollup_sets</a></li>
<li><a href="#L7376">gather_grouping_paths</a></li>
<li><a href="#L7939">generate_setop_child_grouplist</a></li>
<li><a href="#L6298">get_cheapest_fractional_path</a></li>
<li><a href="#L3536">get_number_of_groups</a></li>
<li><a href="#L7882">group_by_has_partkey</a></li>
<li><a href="#L2832">groupclause_apply_groupingset</a></li>
<li><a href="#L1305">grouping_planner</a></li>
<li><a href="#L3128">has_volatile_pathkey</a></li>
<li><a href="#L3824">is_degenerate_grouping</a></li>
<li><a href="#L2628">limit_needed</a></li>
<li><a href="#L5321">make_group_input_target</a></li>
<li><a href="#L3771">make_grouping_rel</a></li>
<li><a href="#L6791">make_ordered_path</a></li>
<li><a href="#L5409">make_partial_grouping_target</a></li>
<li><a href="#L6001">make_pathkeys_for_window</a></li>
<li><a href="#L6127">make_sort_input_target</a></li>
<li><a href="#L5881">make_window_input_target</a></li>
<li><a href="#L5512">mark_partial_aggref</a></li>
<li><a href="#L5584">optimize_window_clauses</a></li>
<li><a href="#L6537">plan_cluster_use_sort</a></li>
<li><a href="#L6657">plan_create_index_workers</a></li>
<li><a href="#L274">planner</a></li>
<li><a href="#L5547">postprocess_setop_tlist</a></li>
<li><a href="#L1126">preprocess_expression</a></li>
<li><a href="#L2047">preprocess_grouping_sets</a></li>
<li><a href="#L2443">preprocess_limit</a></li>
<li><a href="#L1272">preprocess_phv_expression</a></li>
<li><a href="#L1228">preprocess_qual_conditions</a></li>
<li><a href="#L2265">preprocess_rowmarks</a></li>
<li><a href="#L2228">remap_to_groupclause_idx</a></li>
<li><a href="#L2687">remove_useless_groupby_columns</a></li>
<li><a href="#L3080">reorder_grouping_sets</a></li>
<li><a href="#L5724">select_active_windows</a></li>
<li><a href="#L2377">select_rowmark_type</a></li>
<li><a href="#L287">standard_planner</a></li>
<li><a href="#L3354">standard_qp_callback</a></li>
<li><a href="#L628">subquery_planner</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L85">EXPRKIND_APPINFO</a></li>
<li><a href="#L88">EXPRKIND_ARBITER_ELEM</a></li>
<li><a href="#L84">EXPRKIND_LIMIT</a></li>
<li><a href="#L86">EXPRKIND_PHV</a></li>
<li><a href="#L78">EXPRKIND_QUAL</a></li>
<li><a href="#L80">EXPRKIND_RTFUNC</a></li>
<li><a href="#L81">EXPRKIND_RTFUNC_LATERAL</a></li>
<li><a href="#L89">EXPRKIND_TABLEFUNC</a></li>
<li><a href="#L90">EXPRKIND_TABLEFUNC_LATERAL</a></li>
<li><a href="#L87">EXPRKIND_TABLESAMPLE</a></li>
<li><a href="#L79">EXPRKIND_TARGET</a></li>
<li><a href="#L82">EXPRKIND_VALUES</a></li>
<li><a href="#L83">EXPRKIND_VALUES_LATERAL</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L274" title="optimizer/plan/planner.c:274">planner</a>.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; The query optimizer external interface.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/optimizer/plan/<a href="#L274" title="optimizer/plan/planner.c:274">planner</a>.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/genam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/parallel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/sysattr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_aggregate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_constraint.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_inherits.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;foreign/fdwapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;jit/jit.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/bipartite_match.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/knapsack.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#ifdef OPTIMIZER_DEBUG<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/<a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/supportnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/appendinfo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/clauses.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/cost.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/paramassign.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/pathnode.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/paths.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/plancat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/planmain.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/<a href="#L274" title="optimizer/plan/planner.c:274">planner</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/prep.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/subselect.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/tlist.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/<a href="../../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_agg.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_clause.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_relation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parsetree.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;partitioning/partdesc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/selfuncs.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* GUC parameters */<br/></li>
<li><a id="L66">&#x200c;</a></span><span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">cursor_tuple_fraction</span> = DEFAULT_CURSOR_TUPLE_FRACTION;<br/></li>
<li><a id="L67">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">debug_parallel_query</span> = DEBUG_PARALLEL_OFF;<br/></li>
<li><a id="L68">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">parallel_leader_participation</span> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Hook for plugins to get control in <a href="#L274" title="optimizer/plan/planner.c:274">planner</a>() */<br/></li>
<li><a id="L71">&#x200c;</a></span>planner_hook_type <span class="linkable">planner_hook</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Hook for plugins to get control when <a href="#L1305" title="optimizer/plan/planner.c:1305">grouping_planner</a>() plans <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> rels */<br/></li>
<li><a id="L74">&#x200c;</a></span>create_upper_paths_hook_type <span class="linkable">create_upper_paths_hook</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* Expression kind codes for <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a> */<br/></li>
<li><a id="L78">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EXPRKIND_QUAL</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0<br/></li>
<li><a id="L79">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EXPRKIND_TARGET</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">1<br/></li>
<li><a id="L80">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EXPRKIND_RTFUNC</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">2<br/></li>
<li><a id="L81">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EXPRKIND_RTFUNC_LATERAL</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">3<br/></li>
<li><a id="L82">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EXPRKIND_VALUES</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">4<br/></li>
<li><a id="L83">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EXPRKIND_VALUES_LATERAL</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">5<br/></li>
<li><a id="L84">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EXPRKIND_LIMIT</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">6<br/></li>
<li><a id="L85">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EXPRKIND_APPINFO</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">7<br/></li>
<li><a id="L86">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EXPRKIND_PHV</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">8<br/></li>
<li><a id="L87">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EXPRKIND_TABLESAMPLE</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">9<br/></li>
<li><a id="L88">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EXPRKIND_ARBITER_ELEM</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">10<br/></li>
<li><a id="L89">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EXPRKIND_TABLEFUNC</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">11<br/></li>
<li><a id="L90">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EXPRKIND_TABLEFUNC_LATERAL</span>&nbsp; &nbsp; </span><span class="Constant">12<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Data specific to grouping sets<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *rollups;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *hash_sets_idx;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; dNumHashGroups;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; any_hashable;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *unsortable_refs;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *unhashable_refs;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *unsortable_sets;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tleref_to_colnum_map;<br/></li>
<li><a id="L105">&#x200c;</a>} <span class="linkable">grouping_sets_data</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Temporary structure for use during WindowClause reordering in order to be<br/></li>
<li></span><span class="Comment"> * able to sort WindowClauses on partitioning/ordering prefix.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; WindowClause *wc;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *uniqueOrder;&nbsp; &nbsp; <span class="Comment">/* A List of unique ordering/partitioning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clauses per Window */<br/></li>
<li><a id="L116">&#x200c;</a></span>} <span class="linkable">WindowClauseSortData</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Passthrough data for <a href="#L3354" title="optimizer/plan/planner.c:3354">standard_qp_callback</a> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *activeWindows;&nbsp; &nbsp; <span class="Comment">/* active windows, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L105" title="optimizer/plan/planner.c:105">grouping_sets_data</a> *gset_data;&nbsp; &nbsp; <span class="Comment">/* grouping sets data, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; SetOperationStmt *setop;&nbsp; &nbsp; <span class="Comment">/* parent set operation or NULL if not a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subquery belonging to a set operation */<br/></li>
<li><a id="L125">&#x200c;</a></span>} <span class="linkable">standard_qp_extra</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Local <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> Node *<a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>(PlannerInfo *root, Node *expr, <span class="Type">int</span> kind);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1228" title="optimizer/plan/planner.c:1228">preprocess_qual_conditions</a>(PlannerInfo *root, Node *jtnode);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1305" title="optimizer/plan/planner.c:1305">grouping_planner</a>(PlannerInfo *root, <span class="Type">double</span> tuple_fraction,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SetOperationStmt *setops);<br/></li>
<li><span class="Type">static</span> <a href="#L105" title="optimizer/plan/planner.c:105">grouping_sets_data</a> *<a href="#L2047" title="optimizer/plan/planner.c:2047">preprocess_grouping_sets</a>(PlannerInfo *root);<br/></li>
<li><span class="Type">static</span> List *<a href="#L2228" title="optimizer/plan/planner.c:2228">remap_to_groupclause_idx</a>(List *groupClause, List *gsets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *tleref_to_colnum_map);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2265" title="optimizer/plan/planner.c:2265">preprocess_rowmarks</a>(PlannerInfo *root);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L2443" title="optimizer/plan/planner.c:2443">preprocess_limit</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> tuple_fraction,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int64 *offset_est, int64 *count_est);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2687" title="optimizer/plan/planner.c:2687">remove_useless_groupby_columns</a>(PlannerInfo *root);<br/></li>
<li><span class="Type">static</span> List *<a href="#L2832" title="optimizer/plan/planner.c:2832">groupclause_apply_groupingset</a>(PlannerInfo *root, List *force);<br/></li>
<li><span class="Type">static</span> List *<a href="#L2868" title="optimizer/plan/planner.c:2868">extract_rollup_sets</a>(List *groupingSets);<br/></li>
<li><span class="Type">static</span> List *<a href="#L3080" title="optimizer/plan/planner.c:3080">reorder_grouping_sets</a>(List *groupingSets, List *sortclause);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3354" title="optimizer/plan/planner.c:3354">standard_qp_callback</a>(PlannerInfo *root, <span class="Type">void</span> *extra);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L3536" title="optimizer/plan/planner.c:3536">get_number_of_groups</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> path_rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L105" title="optimizer/plan/planner.c:105">grouping_sets_data</a> *gd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *target_list);<br/></li>
<li><span class="Type">static</span> RelOptInfo *<a href="#L3658" title="optimizer/plan/planner.c:3658">create_grouping_paths</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PathTarget *target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> target_parallel_safe,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L105" title="optimizer/plan/planner.c:105">grouping_sets_data</a> *gd);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3824" title="optimizer/plan/planner.c:3824">is_degenerate_grouping</a>(PlannerInfo *root);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3845" title="optimizer/plan/planner.c:3845">create_degenerate_grouping_paths</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *grouped_rel);<br/></li>
<li><span class="Type">static</span> RelOptInfo *<a href="#L3771" title="optimizer/plan/planner.c:3771">make_grouping_rel</a>(PlannerInfo *root, RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PathTarget *target, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> target_parallel_safe,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *havingQual);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3909" title="optimizer/plan/planner.c:3909">create_ordinary_grouping_paths</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> AggClauseCosts *agg_costs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L105" title="optimizer/plan/planner.c:105">grouping_sets_data</a> *gd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GroupPathExtraData *extra,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo **partially_grouped_rel_p);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4048" title="optimizer/plan/planner.c:4048">consider_groupingsets_paths</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path *path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_sorted,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> can_hash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L105" title="optimizer/plan/planner.c:105">grouping_sets_data</a> *gd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> AggClauseCosts *agg_costs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> dNumGroups);<br/></li>
<li><span class="Type">static</span> RelOptInfo *<a href="#L4410" title="optimizer/plan/planner.c:4410">create_window_paths</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PathTarget *input_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PathTarget *output_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> output_target_parallel_safe,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WindowFuncLists *wflists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *activeWindows);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4497" title="optimizer/plan/planner.c:4497">create_one_window_path</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *window_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Path *path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PathTarget *input_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PathTarget *output_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WindowFuncLists *wflists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *activeWindows);<br/></li>
<li><span class="Type">static</span> RelOptInfo *<a href="#L4630" title="optimizer/plan/planner.c:4630">create_distinct_paths</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PathTarget *target);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4700" title="optimizer/plan/planner.c:4700">create_partial_distinct_paths</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *final_distinct_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathTarget *target);<br/></li>
<li><span class="Type">static</span> RelOptInfo *<a href="#L4899" title="optimizer/plan/planner.c:4899">create_final_distinct_paths</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *distinct_rel);<br/></li>
<li><span class="Type">static</span> RelOptInfo *<a href="#L5106" title="optimizer/plan/planner.c:5106">create_ordered_paths</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathTarget *target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> target_parallel_safe,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> limit_tuples);<br/></li>
<li><span class="Type">static</span> PathTarget *<a href="#L5321" title="optimizer/plan/planner.c:5321">make_group_input_target</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PathTarget *final_target);<br/></li>
<li><span class="Type">static</span> PathTarget *<a href="#L5409" title="optimizer/plan/planner.c:5409">make_partial_grouping_target</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathTarget *grouping_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *havingQual);<br/></li>
<li><span class="Type">static</span> List *<a href="#L5547" title="optimizer/plan/planner.c:5547">postprocess_setop_tlist</a>(List *new_tlist, List *orig_tlist);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5584" title="optimizer/plan/planner.c:5584">optimize_window_clauses</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WindowFuncLists *wflists);<br/></li>
<li><span class="Type">static</span> List *<a href="#L5724" title="optimizer/plan/planner.c:5724">select_active_windows</a>(PlannerInfo *root, WindowFuncLists *wflists);<br/></li>
<li><span class="Type">static</span> PathTarget *<a href="#L5881" title="optimizer/plan/planner.c:5881">make_window_input_target</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathTarget *final_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *activeWindows);<br/></li>
<li><span class="Type">static</span> List *<a href="#L6001" title="optimizer/plan/planner.c:6001">make_pathkeys_for_window</a>(PlannerInfo *root, WindowClause *wc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *tlist);<br/></li>
<li><span class="Type">static</span> PathTarget *<a href="#L6127" title="optimizer/plan/planner.c:6127">make_sort_input_target</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathTarget *final_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *have_postponed_srfs);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L6341" title="optimizer/plan/planner.c:6341">adjust_paths_for_srfs</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *targets, List *targets_contain_srfs);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L6842" title="optimizer/plan/planner.c:6842">add_paths_to_grouping_rel</a>(PlannerInfo *root, RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *partially_grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> AggClauseCosts *agg_costs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L105" title="optimizer/plan/planner.c:105">grouping_sets_data</a> *gd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> dNumGroups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GroupPathExtraData *extra);<br/></li>
<li><span class="Type">static</span> RelOptInfo *<a href="#L7077" title="optimizer/plan/planner.c:7077">create_partial_grouping_paths</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L105" title="optimizer/plan/planner.c:105">grouping_sets_data</a> *gd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GroupPathExtraData *extra,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> force_rel_creation);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L7376" title="optimizer/plan/planner.c:7376">gather_grouping_paths</a>(PlannerInfo *root, RelOptInfo *rel);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L7461" title="optimizer/plan/planner.c:7461">can_partial_agg</a>(PlannerInfo *root);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L7503" title="optimizer/plan/planner.c:7503">apply_scanjoin_target_to_paths</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *scanjoin_targets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *scanjoin_targets_contain_srfs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> scanjoin_target_parallel_safe,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="../util/tlist.c.html#L218" title="optimizer/util/tlist.c:218">tlist_same_exprs</a>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L7738" title="optimizer/plan/planner.c:7738">create_partitionwise_grouping_paths</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *partially_grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> AggClauseCosts *agg_costs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L105" title="optimizer/plan/planner.c:105">grouping_sets_data</a> *gd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PartitionwiseAggregateType patype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GroupPathExtraData *extra);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L7882" title="optimizer/plan/planner.c:7882">group_by_has_partkey</a>(RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *groupClause);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L5812" title="optimizer/plan/planner.c:5812">common_prefix_cmp</a>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b);<br/></li>
<li><span class="Type">static</span> List *<a href="#L7939" title="optimizer/plan/planner.c:7939">generate_setop_child_grouplist</a>(SetOperationStmt *op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *targetlist);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; Query optimizer entry point<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To support loadable plugins that monitor or modify <a href="#L274" title="optimizer/plan/planner.c:274">planner</a> behavior,<br/></li>
<li></span><span class="Comment"> * we provide a hook variable that lets a plugin get control <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> and<br/></li>
<li></span><span class="Comment"> * after the standard planning process.&nbsp; The plugin would normally call<br/></li>
<li></span><span class="Comment"> * <a href="#L287" title="optimizer/plan/planner.c:287">standard_planner</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note to plugin authors: <a href="#L287" title="optimizer/plan/planner.c:287">standard_planner</a>() scribbles on its Query input,<br/></li>
<li></span><span class="Comment"> * so you'd better copy that data structure if you want to plan more than once.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span>PlannedStmt *<br/></li>
<li><a id="L274">&#x200c;</a><span class="linkable">planner</span>(Query *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>, <span class="Type">const</span> <span class="Type">char</span> *query_string, <span class="Type">int</span> cursorOptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ParamListInfo boundParams)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlannedStmt *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L71" title="optimizer/plan/planner.c:71">planner_hook</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (*<a href="#L71" title="optimizer/plan/planner.c:71">planner_hook</a>) (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>, query_string, cursorOptions, boundParams);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L287" title="optimizer/plan/planner.c:287">standard_planner</a>(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>, query_string, cursorOptions, boundParams);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>PlannedStmt *<br/></li>
<li><a id="L287">&#x200c;</a><span class="linkable">standard_planner</span>(Query *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>, <span class="Type">const</span> <span class="Type">char</span> *query_string, <span class="Type">int</span> cursorOptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ParamListInfo boundParams)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlannedStmt *result;<br/></li>
<li>&nbsp; &nbsp; PlannerGlobal *glob;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; tuple_fraction;<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *root;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *final_rel;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *best_path;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *top_plan;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up global state for this <a href="#L274" title="optimizer/plan/planner.c:274">planner</a> invocation.&nbsp; This data is needed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * across all levels of sub-Query that might exist in the given command,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so we keep it in a separate struct that's linked to by each per-Query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PlannerInfo.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; glob = makeNode(PlannerGlobal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; glob-&gt;boundParams = boundParams;<br/></li>
<li>&nbsp; &nbsp; glob-&gt;subplans = NIL;<br/></li>
<li>&nbsp; &nbsp; glob-&gt;subpaths = NIL;<br/></li>
<li>&nbsp; &nbsp; glob-&gt;subroots = NIL;<br/></li>
<li>&nbsp; &nbsp; glob-&gt;rewindPlanIDs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; glob-&gt;finalrtable = NIL;<br/></li>
<li>&nbsp; &nbsp; glob-&gt;finalrteperminfos = NIL;<br/></li>
<li>&nbsp; &nbsp; glob-&gt;finalrowmarks = NIL;<br/></li>
<li>&nbsp; &nbsp; glob-&gt;resultRelations = NIL;<br/></li>
<li>&nbsp; &nbsp; glob-&gt;appendRelations = NIL;<br/></li>
<li>&nbsp; &nbsp; glob-&gt;relationOids = NIL;<br/></li>
<li>&nbsp; &nbsp; glob-&gt;invalItems = NIL;<br/></li>
<li>&nbsp; &nbsp; glob-&gt;paramExecTypes = NIL;<br/></li>
<li>&nbsp; &nbsp; glob-&gt;lastPHId = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; glob-&gt;lastRowMarkId = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; glob-&gt;lastPlanNodeId = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; glob-&gt;transientPlan = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; glob-&gt;dependsOnRole = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Assess whether it's feasible to use parallel mode for this query. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't do this in a standalone backend, or if the command will try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * modify <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data, or if this is a cursor operation, or if GUCs are set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that don't permit parallelism, or if parallel-unsafe<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are present in the query tree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Note that we do allow CREATE TABLE AS, SELECT INTO, and CREATE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * MATERIALIZED VIEW to use parallel plans, but this is safe only because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the command is writing into a completely new table which workers won't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be able to see.&nbsp; If the workers could see the table, the fact that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * group locking would cause them to ignore the leader's heavyweight GIN<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page locks would make this unsafe.&nbsp; We'll have to fix that somehow if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we want to allow parallel inserts in general; updates and deletes have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * additional problems especially around combo CIDs.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we don't try to use parallel mode if we're running inside a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parallel worker.&nbsp; We might eventually be able to relax this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restriction, but for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> it seems best not to have parallel workers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trying to create their own parallel workers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((cursorOptions &amp; CURSOR_OPT_PARALLEL_OK) != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;commandType == CMD_SELECT &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasModifyingCTE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L132" title="optimizer/path/costsize.c:132">max_parallel_workers_per_gather</a> &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !IsParallelWorker())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* all the cheap tests pass, so scan the query tree */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; glob-&gt;maxParallelHazard = <a href="../util/clauses.c.html#L734" title="optimizer/util/clauses.c:734">max_parallel_hazard</a>(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; glob-&gt;parallelModeOK = (glob-&gt;maxParallelHazard != PROPARALLEL_UNSAFE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the query tree scan, just assume it's unsafe */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; glob-&gt;maxParallelHazard = PROPARALLEL_UNSAFE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; glob-&gt;parallelModeOK = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * glob-&gt;parallelModeNeeded is normally set to false here and changed to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * true during plan creation if a Gather or Gather Merge plan is actually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * created (cf. <a href="createplan.c.html#L1919" title="optimizer/plan/createplan.c:1919">create_gather_plan</a>, <a href="createplan.c.html#L1957" title="optimizer/plan/createplan.c:1957">create_gather_merge_plan</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, if <a href="#L67" title="optimizer/plan/planner.c:67">debug_parallel_query</a> = on or <a href="#L67" title="optimizer/plan/planner.c:67">debug_parallel_query</a> =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * regress, then we impose parallel mode whenever it's safe to do so, even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if the final plan doesn't use parallelism.&nbsp; It's not safe to do so if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the query contains anything parallel-unsafe; parallelModeOK will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * false in that case.&nbsp; Note that parallelModeOK can't change after this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * point. Otherwise, everything in the query is either parallel-safe or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parallel-restricted, and in either case it should be OK to impose<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parallel-mode restrictions.&nbsp; If that ends up breaking something, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * either some function the user included in the query is incorrectly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * labeled as parallel-safe or parallel-restricted when in reality it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parallel-unsafe, or else the query <a href="#L274" title="optimizer/plan/planner.c:274">planner</a> itself has a bug.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; glob-&gt;parallelModeNeeded = glob-&gt;parallelModeOK &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L67" title="optimizer/plan/planner.c:67">debug_parallel_query</a> != DEBUG_PARALLEL_OFF);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine what fraction of the plan is likely to be scanned */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cursorOptions &amp; CURSOR_OPT_FAST_PLAN)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have no real idea how many tuples the user will ultimately FETCH<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from a cursor, but it is often the case that he doesn't want 'em<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all, or would prefer a fast-start plan anyway so that he can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * process some of the tuples sooner.&nbsp; Use a GUC parameter to decide<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * what fraction to <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> for.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tuple_fraction = <a href="#L66" title="optimizer/plan/planner.c:66">cursor_tuple_fraction</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We document <a href="#L66" title="optimizer/plan/planner.c:66">cursor_tuple_fraction</a> as simply being a fraction, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * means the edge cases 0 and 1 have to be treated specially here.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * convert 1 to 0 (&quot;all the tuples&quot;) and 0 to a very small fraction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tuple_fraction &gt;= <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_fraction = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (tuple_fraction &lt;= <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_fraction = <span class="Constant">1e-10</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Default assumption is we need all the tuples */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tuple_fraction = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* primary planning entry point (may recurse for subqueries) */<br/></li>
<li></span>&nbsp; &nbsp; root = <a href="#L628" title="optimizer/plan/planner.c:628">subquery_planner</a>(glob, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>, <span class="Constant">NULL</span>, <span class="Constant">false</span>, tuple_fraction, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Select best Path and turn it into a Plan */<br/></li>
<li></span>&nbsp; &nbsp; final_rel = <a href="../util/relnode.c.html#L1470" title="optimizer/util/relnode.c:1470">fetch_upper_rel</a>(root, UPPERREL_FINAL, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; best_path = <a href="#L6298" title="optimizer/plan/planner.c:6298">get_cheapest_fractional_path</a>(final_rel, tuple_fraction);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; top_plan = <a href="createplan.c.html#L337" title="optimizer/plan/createplan.c:337">create_plan</a>(root, best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If creating a plan for a scrollable cursor, make sure it can run<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backwards on demand.&nbsp; Add a Material node at the top at need.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cursorOptions &amp; CURSOR_OPT_SCROLL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/execAmi.c.html#L510" title="executor/execAmi.c:510">ExecSupportsBackwardScan</a>(top_plan))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; top_plan = <a href="createplan.c.html#L6527" title="optimizer/plan/createplan.c:6527">materialize_finished_plan</a>(top_plan);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Optionally add a Gather node for testing purposes, provided this is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * actually a safe thing to do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can add Gather even when top_plan has parallel-safe initPlans, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then we have to move the initPlans to the Gather node because of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="subselect.c.html#L2254" title="optimizer/plan/subselect.c:2254">SS_finalize_plan</a>'s limitations.&nbsp; That would cause cosmetic breakage of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * regression tests when <a href="#L67" title="optimizer/plan/planner.c:67">debug_parallel_query</a> = regress, because initPlans<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that would normally appear on the top_plan move to the Gather, causing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them to disappear from EXPLAIN output.&nbsp; That doesn't seem worth kluging<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * EXPLAIN to hide, so <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it when <a href="#L67" title="optimizer/plan/planner.c:67">debug_parallel_query</a> = regress.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L67" title="optimizer/plan/planner.c:67">debug_parallel_query</a> != DEBUG_PARALLEL_OFF &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; top_plan-&gt;parallel_safe &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (top_plan-&gt;initPlan == NIL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L67" title="optimizer/plan/planner.c:67">debug_parallel_query</a> != DEBUG_PARALLEL_REGRESS))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Gather&nbsp; &nbsp; &nbsp;&nbsp; *gather = makeNode(Gather);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; initplan_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; unsafe_initplans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gather-&gt;plan.targetlist = top_plan-&gt;targetlist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gather-&gt;plan.qual = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gather-&gt;plan.lefttree = top_plan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gather-&gt;plan.righttree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gather-&gt;num_workers = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gather-&gt;single_copy = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gather-&gt;invisible = (<a href="#L67" title="optimizer/plan/planner.c:67">debug_parallel_query</a> == DEBUG_PARALLEL_REGRESS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Transfer <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> initPlans to the new top node */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; gather-&gt;plan.initPlan = top_plan-&gt;initPlan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; top_plan-&gt;initPlan = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since this Gather has no parallel-aware descendants to signal to,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we don't need a rescan Param.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; gather-&gt;rescan_param = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ideally we'd use <a href="../path/costsize.c.html#L436" title="optimizer/path/costsize.c:436">cost_gather</a> here, but setting up dummy path data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to satisfy it doesn't seem much cleaner than knowing what it does.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; gather-&gt;plan.startup_cost = top_plan-&gt;startup_cost +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L125" title="optimizer/path/costsize.c:125">parallel_setup_cost</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gather-&gt;plan.total_cost = top_plan-&gt;total_cost +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L125" title="optimizer/path/costsize.c:125">parallel_setup_cost</a> + <a href="../path/costsize.c.html#L124" title="optimizer/path/costsize.c:124">parallel_tuple_cost</a> * top_plan-&gt;plan_rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gather-&gt;plan.plan_rows = top_plan-&gt;plan_rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gather-&gt;plan.plan_width = top_plan-&gt;plan_width;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gather-&gt;plan.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gather-&gt;plan.parallel_safe = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> the initplans' cost from top_plan.&nbsp; We needn't add it to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Gather node, since the above coding already included it there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="subselect.c.html#L2198" title="optimizer/plan/subselect.c:2198">SS_compute_initplan_cost</a>(gather-&gt;plan.initPlan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;initplan_cost, &amp;unsafe_initplans);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; top_plan-&gt;startup_cost -= initplan_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; top_plan-&gt;total_cost -= initplan_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* use parallel mode for parallel plans. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;glob-&gt;parallelModeNeeded = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; top_plan = &amp;gather-&gt;plan;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> Params were generated, run through the plan tree and compute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * each plan node's extParam/allParam sets.&nbsp; Ideally we'd <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> this into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="setrefs.c.html#L287" title="optimizer/plan/setrefs.c:287">set_plan_references</a>' tree traversal, but for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> it has to be separate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because we need to visit subplans <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> not after <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (glob-&gt;paramExecTypes != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(glob-&gt;subplans) == list_length(glob-&gt;subroots));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; forboth(lp, glob-&gt;subplans, lr, glob-&gt;subroots)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan = (Plan *) lfirst(lp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlannerInfo *subroot = lfirst_node(PlannerInfo, lr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="subselect.c.html#L2254" title="optimizer/plan/subselect.c:2254">SS_finalize_plan</a>(subroot, subplan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="subselect.c.html#L2254" title="optimizer/plan/subselect.c:2254">SS_finalize_plan</a>(root, top_plan);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* final <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> of the plan */<br/></li>
<li></span>&nbsp; &nbsp; Assert(glob-&gt;finalrtable == NIL);<br/></li>
<li>&nbsp; &nbsp; Assert(glob-&gt;finalrteperminfos == NIL);<br/></li>
<li>&nbsp; &nbsp; Assert(glob-&gt;finalrowmarks == NIL);<br/></li>
<li>&nbsp; &nbsp; Assert(glob-&gt;resultRelations == NIL);<br/></li>
<li>&nbsp; &nbsp; Assert(glob-&gt;appendRelations == NIL);<br/></li>
<li>&nbsp; &nbsp; top_plan = <a href="setrefs.c.html#L287" title="optimizer/plan/setrefs.c:287">set_plan_references</a>(root, top_plan);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... and the subplans (both regular subplans and initplans) */<br/></li>
<li></span>&nbsp; &nbsp; Assert(list_length(glob-&gt;subplans) == list_length(glob-&gt;subroots));<br/></li>
<li>&nbsp; &nbsp; forboth(lp, glob-&gt;subplans, lr, glob-&gt;subroots)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan = (Plan *) lfirst(lp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlannerInfo *subroot = lfirst_node(PlannerInfo, lr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lfirst(lp) = <a href="setrefs.c.html#L287" title="optimizer/plan/setrefs.c:287">set_plan_references</a>(subroot, subplan);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build the PlannedStmt result */<br/></li>
<li></span>&nbsp; &nbsp; result = makeNode(PlannedStmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;commandType = <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;commandType;<br/></li>
<li>&nbsp; &nbsp; result-&gt;queryId = <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;queryId;<br/></li>
<li>&nbsp; &nbsp; result-&gt;hasReturning = (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;returningList != NIL);<br/></li>
<li>&nbsp; &nbsp; result-&gt;hasModifyingCTE = <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasModifyingCTE;<br/></li>
<li>&nbsp; &nbsp; result-&gt;canSetTag = <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;canSetTag;<br/></li>
<li>&nbsp; &nbsp; result-&gt;transientPlan = glob-&gt;transientPlan;<br/></li>
<li>&nbsp; &nbsp; result-&gt;dependsOnRole = glob-&gt;dependsOnRole;<br/></li>
<li>&nbsp; &nbsp; result-&gt;parallelModeNeeded = glob-&gt;parallelModeNeeded;<br/></li>
<li>&nbsp; &nbsp; result-&gt;planTree = top_plan;<br/></li>
<li>&nbsp; &nbsp; result-&gt;rtable = glob-&gt;finalrtable;<br/></li>
<li>&nbsp; &nbsp; result-&gt;permInfos = glob-&gt;finalrteperminfos;<br/></li>
<li>&nbsp; &nbsp; result-&gt;resultRelations = glob-&gt;resultRelations;<br/></li>
<li>&nbsp; &nbsp; result-&gt;appendRelations = glob-&gt;appendRelations;<br/></li>
<li>&nbsp; &nbsp; result-&gt;subplans = glob-&gt;subplans;<br/></li>
<li>&nbsp; &nbsp; result-&gt;rewindPlanIDs = glob-&gt;rewindPlanIDs;<br/></li>
<li>&nbsp; &nbsp; result-&gt;rowMarks = glob-&gt;finalrowmarks;<br/></li>
<li>&nbsp; &nbsp; result-&gt;relationOids = glob-&gt;relationOids;<br/></li>
<li>&nbsp; &nbsp; result-&gt;invalItems = glob-&gt;invalItems;<br/></li>
<li>&nbsp; &nbsp; result-&gt;paramExecTypes = glob-&gt;paramExecTypes;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* utilityStmt should be null, but we might as well copy it */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;utilityStmt = <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;utilityStmt;<br/></li>
<li>&nbsp; &nbsp; result-&gt;stmt_location = <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;stmt_location;<br/></li>
<li>&nbsp; &nbsp; result-&gt;stmt_len = <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;stmt_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;jitFlags = PGJIT_NONE;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../jit/jit.c.html#L32" title="jit/jit.c:32">jit_enabled</a> &amp;&amp; <a href="../../jit/jit.c.html#L39" title="jit/jit.c:39">jit_above_cost</a> &gt;= <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; top_plan-&gt;total_cost &gt; <a href="../../jit/jit.c.html#L39" title="jit/jit.c:39">jit_above_cost</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;jitFlags |= PGJIT_PERFORM;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Decide how much effort should be put into generating better code.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../jit/jit.c.html#L41" title="jit/jit.c:41">jit_optimize_above_cost</a> &gt;= <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; top_plan-&gt;total_cost &gt; <a href="../../jit/jit.c.html#L41" title="jit/jit.c:41">jit_optimize_above_cost</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;jitFlags |= PGJIT_OPT3;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../jit/jit.c.html#L40" title="jit/jit.c:40">jit_inline_above_cost</a> &gt;= <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; top_plan-&gt;total_cost &gt; <a href="../../jit/jit.c.html#L40" title="jit/jit.c:40">jit_inline_above_cost</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;jitFlags |= PGJIT_INLINE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Decide which operations should be JITed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../jit/jit.c.html#L36" title="jit/jit.c:36">jit_expressions</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;jitFlags |= PGJIT_EXPR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../jit/jit.c.html#L38" title="jit/jit.c:38">jit_tuple_deforming</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;jitFlags |= PGJIT_DEFORM;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (glob-&gt;partition_directory != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../partitioning/partdesc.c.html#L442" title="partitioning/partdesc.c:442">DestroyPartitionDirectory</a>(glob-&gt;partition_directory);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*--------------------<br/></li>
<li></span><span class="Comment"> * <a href="#L628" title="optimizer/plan/planner.c:628">subquery_planner</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Invokes the <a href="#L274" title="optimizer/plan/planner.c:274">planner</a> on a subquery.&nbsp; We recurse to here for each<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; sub-SELECT found in the query tree.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * glob is the global state for the current <a href="#L274" title="optimizer/plan/planner.c:274">planner</a> run.<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> is the querytree produced by the parser &amp; rewriter.<br/></li>
<li></span><span class="Comment"> * parent_root is the immediate parent Query's info (NULL at the top level).<br/></li>
<li></span><span class="Comment"> * hasRecursion is true if this is a recursive WITH query.<br/></li>
<li></span><span class="Comment"> * tuple_fraction is the fraction of tuples we expect will be retrieved.<br/></li>
<li></span><span class="Comment"> * tuple_fraction is interpreted as explained for <a href="#L1305" title="optimizer/plan/planner.c:1305">grouping_planner</a>, below.<br/></li>
<li></span><span class="Comment"> * setops is used for set operation subqueries to provide the subquery with<br/></li>
<li></span><span class="Comment"> * the context in which it's being used so that Paths correctly sorted for the<br/></li>
<li></span><span class="Comment"> * set operation can be generated.&nbsp; NULL when not planning a set operation<br/></li>
<li></span><span class="Comment"> * child.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Basically, this routine does the stuff that should only be done once<br/></li>
<li></span><span class="Comment"> * per Query object.&nbsp; It then calls <a href="#L1305" title="optimizer/plan/planner.c:1305">grouping_planner</a>.&nbsp; At one time,<br/></li>
<li></span><span class="Comment"> * <a href="#L1305" title="optimizer/plan/planner.c:1305">grouping_planner</a> could be invoked recursively on the same Query object;<br/></li>
<li></span><span class="Comment"> * that's not currently true, but we keep the separation between the two<br/></li>
<li></span><span class="Comment"> * routines anyway, in case we need it again someday.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L628" title="optimizer/plan/planner.c:628">subquery_planner</a> will be called recursively to handle sub-Query nodes<br/></li>
<li></span><span class="Comment"> * found within the query's expressions and rangetable.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the PlannerInfo struct (&quot;root&quot;) that contains all data generated<br/></li>
<li></span><span class="Comment"> * while planning the subquery.&nbsp; In particular, the Path(s) attached to<br/></li>
<li></span><span class="Comment"> * the (UPPERREL_FINAL, NULL) upperrel represent our conclusions about the<br/></li>
<li></span><span class="Comment"> * cheapest way(s) to implement the query.&nbsp; The top level will <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> the<br/></li>
<li></span><span class="Comment"> * best Path and pass it through createplan.c to produce a finished Plan.<br/></li>
<li></span><span class="Comment"> *--------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PlannerInfo *<br/></li>
<li><a id="L628">&#x200c;</a><span class="linkable">subquery_planner</span>(PlannerGlobal *glob, Query *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>, PlannerInfo *parent_root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> hasRecursion, <span class="Type">double</span> tuple_fraction,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SetOperationStmt *setops)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *root;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newWithCheckOptions;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newHaving;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasOuterJoins;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasResultRTEs;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *final_rel;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create a PlannerInfo data structure for this subquery */<br/></li>
<li></span>&nbsp; &nbsp; root = makeNode(PlannerInfo);<br/></li>
<li>&nbsp; &nbsp; root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;glob = glob;<br/></li>
<li>&nbsp; &nbsp; root-&gt;query_level = parent_root ? parent_root-&gt;query_level + <span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;parent_root = parent_root;<br/></li>
<li>&nbsp; &nbsp; root-&gt;plan_params = NIL;<br/></li>
<li>&nbsp; &nbsp; root-&gt;outer_params = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;planner_cxt = <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;init_plans = NIL;<br/></li>
<li>&nbsp; &nbsp; root-&gt;cte_plan_ids = NIL;<br/></li>
<li>&nbsp; &nbsp; root-&gt;multiexpr_params = NIL;<br/></li>
<li>&nbsp; &nbsp; root-&gt;join_domains = NIL;<br/></li>
<li>&nbsp; &nbsp; root-&gt;eq_classes = NIL;<br/></li>
<li>&nbsp; &nbsp; root-&gt;ec_merging_done = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;last_rinfo_serial = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;all_result_relids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;resultRelation ? <a href="../../nodes/bitmapset.c.html#L216" title="nodes/bitmapset.c:216">bms_make_singleton</a>(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;resultRelation) : <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;leaf_result_relids = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* we'll <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out leaf-ness later */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;append_rel_list = NIL;<br/></li>
<li>&nbsp; &nbsp; root-&gt;row_identity_vars = NIL;<br/></li>
<li>&nbsp; &nbsp; root-&gt;rowMarks = NIL;<br/></li>
<li>&nbsp; &nbsp; memset(root-&gt;upper_rels, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(root-&gt;upper_rels));<br/></li>
<li>&nbsp; &nbsp; memset(root-&gt;upper_targets, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(root-&gt;upper_targets));<br/></li>
<li>&nbsp; &nbsp; root-&gt;processed_groupClause = NIL;<br/></li>
<li>&nbsp; &nbsp; root-&gt;processed_distinctClause = NIL;<br/></li>
<li>&nbsp; &nbsp; root-&gt;processed_tlist = NIL;<br/></li>
<li>&nbsp; &nbsp; root-&gt;update_colnos = NIL;<br/></li>
<li>&nbsp; &nbsp; root-&gt;grouping_map = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;minmax_aggs = NIL;<br/></li>
<li>&nbsp; &nbsp; root-&gt;qual_security_level = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;hasPseudoConstantQuals = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;hasAlternativeSubPlans = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;placeholdersFrozen = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;hasRecursion = hasRecursion;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hasRecursion)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;wt_param_id = <a href="../util/paramassign.c.html#L664" title="optimizer/util/paramassign.c:664">assign_special_exec_param</a>(root);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;wt_param_id = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;non_recursive_path = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;partColsUpdated = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the top-level join domain.&nbsp; This won't have valid contents until<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="initsplan.c.html#L740" title="optimizer/plan/initsplan.c:740">deconstruct_jointree</a> fills it in, but the node needs to exist <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that so we can build EquivalenceClasses referencing it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;join_domains = list_make1(makeNode(JoinDomain));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is a WITH list, process each WITH query and either convert it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to RTE_SUBQUERY RTE(s) or build an initplan SubPlan structure for it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;cteList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="subselect.c.html#L880" title="optimizer/plan/subselect.c:880">SS_process_ctes</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's a MERGE command, transform the joinlist as appropriate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../prep/prepjointree.c.html#L152" title="optimizer/prep/prepjointree.c:152">transform_MERGE_to_join</a>(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the FROM clause is empty, replace it with a dummy RTE_RESULT RTE, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that we don't need so many special cases to deal with that situation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../prep/prepjointree.c.html#L284" title="optimizer/prep/prepjointree.c:284">replace_empty_jointree</a>(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look for ANY and EXISTS SubLinks in WHERE and JOIN/ON clauses, and try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to transform them into joins.&nbsp; Note that this step does not descend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into subqueries; if we <a href="../../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a> up <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subqueries below, their SubLinks are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processed just <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> pulling them up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasSubLinks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../prep/prepjointree.c.html#L342" title="optimizer/prep/prepjointree.c:342">pull_up_sublinks</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan the rangetable for function RTEs, do const-simplification on them,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and then inline them if possible (producing subqueries that might get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pulled up <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>).&nbsp; Recursion issues here are handled in the same way as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for SubLinks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../prep/prepjointree.c.html#L776" title="optimizer/prep/prepjointree.c:776">preprocess_function_rtes</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check to see if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subqueries in the jointree can be merged into this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../prep/prepjointree.c.html#L817" title="optimizer/prep/prepjointree.c:817">pull_up_subqueries</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is a simple UNION ALL query, flatten it into an appendrel. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do this <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> because it requires applying <a href="../prep/prepjointree.c.html#L817" title="optimizer/prep/prepjointree.c:817">pull_up_subqueries</a> to the leaf<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * queries of the UNION ALL, which weren't touched above because they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * weren't referenced by the jointree (they will be after we do this).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;setOperations)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../prep/prepjointree.c.html#L2594" title="optimizer/prep/prepjointree.c:2594">flatten_simple_union_all</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Survey the rangetable to see what kinds of entries are present.&nbsp; We can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> some later processing if relevant SQL features are not used; for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * example if there are no JOIN RTEs we can avoid the expense of doing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../util/var.c.html#L744" title="optimizer/util/var.c:744">flatten_join_alias_vars</a>().&nbsp; This must be done after we have finished<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * adding rangetable entries, of course.&nbsp; (Note: actually, processing of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inherited or partitioned rels can cause RTEs for their child tables to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get added later; but those must all be RTE_RELATION entries, so they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't invalidate the conclusions drawn here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;hasJoinRTEs = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;hasLateralRTEs = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; hasOuterJoins = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; hasResultRTEs = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(l, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rtable)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = lfirst_node(RangeTblEntry, l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (rte-&gt;rtekind)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_RELATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;inh)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check to see if the relation actually has <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> children;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if not, clear the inh flag so we can treat it as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * plain base relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: this could give a false-positive result, if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rel once had children but no longer does.&nbsp; We used to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be able to clear rte-&gt;inh later on when we discovered<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that, but no more; we have to handle such cases as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * full-fledged inheritance.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;inh = <a href="../../catalog/pg_inherits.c.html#L355" title="catalog/pg_inherits.c:355">has_subclass</a>(rte-&gt;relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_JOIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;hasJoinRTEs = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IS_OUTER_JOIN(rte-&gt;jointype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasOuterJoins = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_RESULT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasResultRTEs = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No work here for other RTE types */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;lateral)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;hasLateralRTEs = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can also determine the maximum security level required for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * securityQuals <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; Addition of inheritance-child RTEs won't affect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this, because child tables don't have their own securityQuals; see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../util/inherit.c.html#L453" title="optimizer/util/inherit.c:453">expand_single_inheritance_child</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;securityQuals)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;qual_security_level = Max(root-&gt;qual_security_level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(rte-&gt;securityQuals));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> verified that the query target relation is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-inheriting, mark it as a leaf target.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;resultRelation)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = rt_fetch(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;resultRelation, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rtable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rte-&gt;inh)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;leaf_result_relids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L216" title="nodes/bitmapset.c:216">bms_make_singleton</a>(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;resultRelation);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Preprocess RowMark information.&nbsp; We need to do this after subquery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pullup, so that all base relations are present.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2265" title="optimizer/plan/planner.c:2265">preprocess_rowmarks</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set hasHavingQual to remember if HAVING clause is present.&nbsp; Needed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a> will reduce a constant-true condition to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an empty qual list ... but &quot;HAVING TRUE&quot; is not a semantic no-op.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;hasHavingQual = (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;havingQual != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do expression preprocessing on targetlist and quals, as well as other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * random expressions in the querytree.&nbsp; Note that we do not need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handle sort/group expressions explicitly, because they are actually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * part of the targetlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;targetList = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>(root, (Node *) <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="optimizer/plan/planner.c:79">EXPRKIND_TARGET</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Constant-folding might have removed all set-returning <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasTargetSRFs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasTargetSRFs = <a href="../../nodes/nodeFuncs.c.html#L758" title="nodes/nodeFuncs.c:758">expression_returns_set</a>((Node *) <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;targetList);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newWithCheckOptions = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(l, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;withCheckOptions)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WithCheckOption *wco = lfirst_node(WithCheckOption, l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; wco-&gt;qual = <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>(root, wco-&gt;qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="optimizer/plan/planner.c:78">EXPRKIND_QUAL</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (wco-&gt;qual != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newWithCheckOptions = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newWithCheckOptions, wco);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;withCheckOptions = newWithCheckOptions;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;returningList = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>(root, (Node *) <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;returningList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="optimizer/plan/planner.c:79">EXPRKIND_TARGET</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1228" title="optimizer/plan/planner.c:1228">preprocess_qual_conditions</a>(root, (Node *) <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;jointree);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;havingQual = <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>(root, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;havingQual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="optimizer/plan/planner.c:78">EXPRKIND_QUAL</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;windowClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WindowClause *wc = lfirst_node(WindowClause, l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* partitionClause/orderClause are sort/group expressions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; wc-&gt;startOffset = <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>(root, wc-&gt;startOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="optimizer/plan/planner.c:84">EXPRKIND_LIMIT</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; wc-&gt;endOffset = <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>(root, wc-&gt;endOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="optimizer/plan/planner.c:84">EXPRKIND_LIMIT</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; wc-&gt;runCondition = (List *) <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Node *) wc-&gt;runCondition,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="optimizer/plan/planner.c:79">EXPRKIND_TARGET</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;limitOffset = <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>(root, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;limitOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L84" title="optimizer/plan/planner.c:84">EXPRKIND_LIMIT</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;limitCount = <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>(root, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;limitCount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="optimizer/plan/planner.c:84">EXPRKIND_LIMIT</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;onConflict)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;onConflict-&gt;arbiterElems = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Node *) <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;onConflict-&gt;arbiterElems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L88" title="optimizer/plan/planner.c:88">EXPRKIND_ARBITER_ELEM</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;onConflict-&gt;arbiterWhere =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;onConflict-&gt;arbiterWhere,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="optimizer/plan/planner.c:78">EXPRKIND_QUAL</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;onConflict-&gt;onConflictSet = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Node *) <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;onConflict-&gt;onConflictSet,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="optimizer/plan/planner.c:79">EXPRKIND_TARGET</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;onConflict-&gt;onConflictWhere =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;onConflict-&gt;onConflictWhere,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="optimizer/plan/planner.c:78">EXPRKIND_QUAL</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* exclRelTlist contains only Vars, so no preprocessing needed */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;mergeActionList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MergeAction *action = (MergeAction *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; action-&gt;targetList = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Node *) action-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="optimizer/plan/planner.c:79">EXPRKIND_TARGET</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; action-&gt;qual =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Node *) action-&gt;qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="optimizer/plan/planner.c:78">EXPRKIND_QUAL</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;mergeJoinCondition =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>(root, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;mergeJoinCondition, <a href="#L78" title="optimizer/plan/planner.c:78">EXPRKIND_QUAL</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; root-&gt;append_rel_list = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>(root, (Node *) root-&gt;append_rel_list,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L85" title="optimizer/plan/planner.c:85">EXPRKIND_APPINFO</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Also need to preprocess expressions within RTEs */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rtable)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = lfirst_node(RangeTblEntry, l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kind;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lcsq;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind == RTE_RELATION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;tablesample)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;tablesample = (TableSampleClause *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Node *) rte-&gt;tablesample,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L87" title="optimizer/plan/planner.c:87">EXPRKIND_TABLESAMPLE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rte-&gt;rtekind == RTE_SUBQUERY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't want to do all preprocessing yet on the subquery's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expressions, since that will happen when we plan it.&nbsp; But if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contains <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> join aliases of our level, those have to get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expanded <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, because planning of the subquery won't do it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * That's only possible if the subquery is LATERAL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;lateral &amp;&amp; root-&gt;hasJoinRTEs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;subquery = (Query *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/var.c.html#L744" title="optimizer/util/var.c:744">flatten_join_alias_vars</a>(root, root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Node *) rte-&gt;subquery);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rte-&gt;rtekind == RTE_FUNCTION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Preprocess the function expression(s) fully */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kind = rte-&gt;lateral ? <a href="#L81" title="optimizer/plan/planner.c:81">EXPRKIND_RTFUNC_LATERAL</a> : <a href="#L80" title="optimizer/plan/planner.c:80">EXPRKIND_RTFUNC</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;<a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>(root, (Node *) rte-&gt;<a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, kind);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rte-&gt;rtekind == RTE_TABLEFUNC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Preprocess the function expression(s) fully */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kind = rte-&gt;lateral ? <a href="#L90" title="optimizer/plan/planner.c:90">EXPRKIND_TABLEFUNC_LATERAL</a> : <a href="#L89" title="optimizer/plan/planner.c:89">EXPRKIND_TABLEFUNC</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;tablefunc = (TableFunc *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>(root, (Node *) rte-&gt;tablefunc, kind);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rte-&gt;rtekind == RTE_VALUES)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Preprocess the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> lists fully */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kind = rte-&gt;lateral ? <a href="#L83" title="optimizer/plan/planner.c:83">EXPRKIND_VALUES_LATERAL</a> : <a href="#L82" title="optimizer/plan/planner.c:82">EXPRKIND_VALUES</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;values_lists = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>(root, (Node *) rte-&gt;values_lists, kind);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Process each <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of the securityQuals list as if it were a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * separate qual expression (as indeed it is).&nbsp; We need to do it this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * way to get proper canonicalization of AND/OR structure.&nbsp; Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this converts each <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> into an implicit-AND sublist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lcsq, rte-&gt;securityQuals)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lfirst(lcsq) = <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) lfirst(lcsq),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L78" title="optimizer/plan/planner.c:78">EXPRKIND_QUAL</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we are done preprocessing expressions, and in particular done<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * flattening join alias variables, get rid of the joinaliasvars lists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * They no longer match what expressions in the rest of the tree look<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * like, because we have not preprocessed expressions in those lists (and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do not want to; for example, expanding a SubLink there would result in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a useless unreferenced subplan).&nbsp; Leaving them in place simply creates<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a hazard for later scans of the tree.&nbsp; We could try to prevent that by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * using QTW_IGNORE_JOINALIASES in every tree scan done after this point,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but that doesn't sound very reliable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;hasJoinRTEs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rtable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = lfirst_node(RangeTblEntry, l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;joinaliasvars = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In some cases we may want to transfer a HAVING clause into WHERE. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cannot do so if the HAVING clause contains aggregates (obviously) or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> (since a HAVING clause is supposed to be executed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only once per group).&nbsp; We also can't do this if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> nonempty<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * grouping sets; moving such a clause into WHERE would potentially change<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the results, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> referenced column isn't present in all the grouping<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sets.&nbsp; (If there are only empty grouping sets, then the HAVING clause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must be degenerate as discussed below.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, it may be that the clause is so expensive to execute that we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * better off doing it only once per group, despite the loss of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * selectivity.&nbsp; This is hard to estimate short of doing the entire<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * planning process twice, so we use a heuristic: clauses containing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subplans are left in HAVING.&nbsp; Otherwise, we move or copy the HAVING<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clause into WHERE, in hopes of eliminating tuples <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> aggregation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * instead of after.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the query has explicit grouping then we can simply move such a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clause into WHERE; <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> group that fails the clause will not be in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * output because <a href="../util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of its tuples will reach the grouping or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggregation stage.&nbsp; Otherwise we must have a degenerate (variable-free)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * HAVING clause, which we put in WHERE so that <a href="planmain.c.html#L54" title="optimizer/plan/planmain.c:54">query_planner</a>() can use it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in a gating Result node, but also keep in HAVING to ensure that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't emit a bogus aggregated row. (This could be done better, but it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * seems not worth optimizing.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that both havingQual and <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;jointree-&gt;quals are in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * implicitly-ANDed-list form at this point, even though they are declared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as Node *.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newHaving = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(l, (List *) <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;havingQual)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *havingclause = (Node *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause &amp;&amp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupingSets) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/clauses.c.html#L177" title="optimizer/util/clauses.c:177">contain_agg_clause</a>(havingclause) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>(havingclause) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/clauses.c.html#L330" title="optimizer/util/clauses.c:330">contain_subplans</a>(havingclause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep it in HAVING */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newHaving = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newHaving, havingclause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause &amp;&amp; !<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupingSets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* move it to WHERE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;jointree-&gt;quals = (Node *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>((List *) <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;jointree-&gt;quals, havingclause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* put a copy in WHERE, keep it in HAVING */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;jointree-&gt;quals = (Node *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>((List *) <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;jointree-&gt;quals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; copyObject(havingclause));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newHaving = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newHaving, havingclause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;havingQual = (Node *) newHaving;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer joins, try to reduce them to plain inner joins.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This step is most easily done after we've done expression<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * preprocessing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (hasOuterJoins)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../prep/prepjointree.c.html#L2713" title="optimizer/prep/prepjointree.c:2713">reduce_outer_joins</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> RTE_RESULT relations, see if they can be deleted from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the jointree.&nbsp; We also rely on this processing to flatten single-child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * FromExprs underneath outer joins.&nbsp; This step is most effectively done<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after we've done expression preprocessing and outer join reduction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (hasResultRTEs || hasOuterJoins)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../prep/prepjointree.c.html#L3207" title="optimizer/prep/prepjointree.c:3207">remove_useless_result_rtes</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> planning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1305" title="optimizer/plan/planner.c:1305">grouping_planner</a>(root, tuple_fraction, setops);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Capture the set of outer-level param IDs we have access to, for use in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * extParam/allParam calculations later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="subselect.c.html#L2072" title="optimizer/plan/subselect.c:2072">SS_identify_outer_params</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> initPlans were created in this query level, adjust the surviving<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Paths' costs and parallel-safety flags to account for them.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initPlans won't actually get attached to the plan tree till<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="createplan.c.html#L337" title="optimizer/plan/createplan.c:337">create_plan</a>() runs, but we must include their effects <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; final_rel = <a href="../util/relnode.c.html#L1470" title="optimizer/util/relnode.c:1470">fetch_upper_rel</a>(root, UPPERREL_FINAL, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="subselect.c.html#L2134" title="optimizer/plan/subselect.c:2134">SS_charge_for_initplans</a>(root, final_rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure we've identified the cheapest Path for the final rel.&nbsp; (By<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doing this here not in <a href="#L1305" title="optimizer/plan/planner.c:1305">grouping_planner</a>, we include initPlan costs in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the decision, though it's unlikely that will change anything.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/pathnode.c.html#L242" title="optimizer/util/pathnode.c:242">set_cheapest</a>(final_rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> root;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Do <a href="#L628" title="optimizer/plan/planner.c:628">subquery_planner</a>'s preprocessing work for an expression,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; which can be a targetlist, a WHERE clause (including JOIN/ON<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; conditions), a HAVING clause, or a few other things.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Node *<br/></li>
<li><a id="L1126">&#x200c;</a><span class="linkable">preprocess_expression</span>(PlannerInfo *root, Node *expr, <span class="Type">int</span> kind)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fall out quickly if expression is empty.&nbsp; This occurs often enough to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be worth checking.&nbsp; Note that null-&gt;null is the correct conversion for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * implicit-AND result format, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (expr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the query has <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> join RTEs, replace join alias variables with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * base-relation variables.&nbsp; We must do this first, since <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> expressions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we may extract from the joinaliasvars lists have not been preprocessed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For example, if we did this after sublink processing, sublinks expanded<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * out from join aliases would not get processed.&nbsp; But we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-lateral RTE <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, VALUES lists, and TABLESAMPLE clauses, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they can't contain <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> Vars of the current query level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;hasJoinRTEs &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !(kind == <a href="#L80" title="optimizer/plan/planner.c:80">EXPRKIND_RTFUNC</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kind == <a href="#L82" title="optimizer/plan/planner.c:82">EXPRKIND_VALUES</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kind == <a href="#L87" title="optimizer/plan/planner.c:87">EXPRKIND_TABLESAMPLE</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kind == <a href="#L89" title="optimizer/plan/planner.c:89">EXPRKIND_TABLEFUNC</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; expr = <a href="../util/var.c.html#L744" title="optimizer/util/var.c:744">flatten_join_alias_vars</a>(root, root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>, expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Simplify constant expressions.&nbsp; For function RTEs, this was already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * done by <a href="../prep/prepjointree.c.html#L776" title="optimizer/prep/prepjointree.c:776">preprocess_function_rtes</a>.&nbsp; (But note we must do it again for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L81" title="optimizer/plan/planner.c:81">EXPRKIND_RTFUNC_LATERAL</a>, because those might by <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> contain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * un-simplified subexpressions inserted by flattening of subqueries or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * join alias variables.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: an essential effect of this is to convert named-argument function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calls to positional notation and insert the current actual <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> default arguments for <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; To ensure that happens, we *must*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process all expressions here.&nbsp; Previous PG versions sometimes skipped<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * const-simplification if it didn't seem worth the trouble, but we can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do that anymore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: this also flattens nested AND and OR expressions into N-argument<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * form.&nbsp; All processing of a qual expression after this point must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * careful to maintain AND/OR flatness --- that is, do not generate a tree<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with AND directly under AND, nor OR directly under OR.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (kind != <a href="#L80" title="optimizer/plan/planner.c:80">EXPRKIND_RTFUNC</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; expr = <a href="../util/clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a>(root, expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's a qual or havingQual, canonicalize it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (kind == <a href="#L78" title="optimizer/plan/planner.c:78">EXPRKIND_QUAL</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; expr = (Node *) <a href="../prep/prepqual.c.html#L293" title="optimizer/prep/prepqual.c:293">canonicalize_qual</a>((Expr *) expr, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef OPTIMIZER_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; printf(<span class="Constant">&quot;After <a href="../prep/prepqual.c.html#L293" title="optimizer/prep/prepqual.c:293">canonicalize_qual</a>()</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/print.c.html#L54" title="nodes/print.c:54">pprint</a>(expr);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for ANY ScalarArrayOpExpr with Const arrays and set the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hashfuncid of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> that might execute more quickly by using <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> lookups<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * instead of a linear search.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (kind == <a href="#L78" title="optimizer/plan/planner.c:78">EXPRKIND_QUAL</a> || kind == <a href="#L79" title="optimizer/plan/planner.c:79">EXPRKIND_TARGET</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/clauses.c.html#L2287" title="optimizer/util/clauses.c:2287">convert_saop_to_hashed_saop</a>(expr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Expand SubLinks to SubPlans */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasSubLinks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; expr = <a href="subselect.c.html#L1919" title="optimizer/plan/subselect.c:1919">SS_process_sublinks</a>(root, expr, (kind == <a href="#L78" title="optimizer/plan/planner.c:78">EXPRKIND_QUAL</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> do not insert anything here unless you have grokked the comments in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="subselect.c.html#L1868" title="optimizer/plan/subselect.c:1868">SS_replace_correlation_vars</a> ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Replace uplevel <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> with Param nodes (this IS possible in VALUES) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;query_level &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; expr = <a href="subselect.c.html#L1868" title="optimizer/plan/subselect.c:1868">SS_replace_correlation_vars</a>(root, expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's a qual or havingQual, convert it to implicit-AND format. (We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't want to do this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../util/clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a>, since the latter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would be unable to simplify a top-level AND correctly. Also,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="subselect.c.html#L1919" title="optimizer/plan/subselect.c:1919">SS_process_sublinks</a> expects explicit-AND format.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (kind == <a href="#L78" title="optimizer/plan/planner.c:78">EXPRKIND_QUAL</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; expr = (Node *) <a href="../../nodes/makefuncs.c.html#L737" title="nodes/makefuncs.c:737">make_ands_implicit</a>((Expr *) expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1228" title="optimizer/plan/planner.c:1228">preprocess_qual_conditions</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Recursively scan the query's jointree and do <a href="#L628" title="optimizer/plan/planner.c:628">subquery_planner</a>'s<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; preprocessing work on each qual condition found therein.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1228">&#x200c;</a></span><span class="linkable">preprocess_qual_conditions</span>(PlannerInfo *root, Node *jtnode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (jtnode == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(jtnode, RangeTblRef))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do here */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(jtnode, FromExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FromExpr&nbsp;&nbsp; *f = (FromExpr *) jtnode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, f-&gt;fromlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1228" title="optimizer/plan/planner.c:1228">preprocess_qual_conditions</a>(root, lfirst(l));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; f-&gt;quals = <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>(root, f-&gt;quals, <a href="#L78" title="optimizer/plan/planner.c:78">EXPRKIND_QUAL</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(jtnode, JoinExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JoinExpr&nbsp;&nbsp; *j = (JoinExpr *) jtnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1228" title="optimizer/plan/planner.c:1228">preprocess_qual_conditions</a>(root, j-&gt;larg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1228" title="optimizer/plan/planner.c:1228">preprocess_qual_conditions</a>(root, j-&gt;rarg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; j-&gt;quals = <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>(root, j-&gt;quals, <a href="#L78" title="optimizer/plan/planner.c:78">EXPRKIND_QUAL</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) nodeTag(jtnode));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1272" title="optimizer/plan/planner.c:1272">preprocess_phv_expression</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Do preprocessing on a PlaceHolderVar expression that's been pulled up.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If a LATERAL subquery references an output of another subquery, and that<br/></li>
<li></span><span class="Comment"> * output must be wrapped in a PlaceHolderVar because of an intermediate outer<br/></li>
<li></span><span class="Comment"> * join, then we'll <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> the PlaceHolderVar expression down into the subquery<br/></li>
<li></span><span class="Comment"> * and later <a href="../../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a> it back up during <a href="initsplan.c.html#L358" title="optimizer/plan/initsplan.c:358">find_lateral_references</a>, which runs after<br/></li>
<li></span><span class="Comment"> * <a href="#L628" title="optimizer/plan/planner.c:628">subquery_planner</a> has preprocessed all the expressions that were in the<br/></li>
<li></span><span class="Comment"> * current query level to start with.&nbsp; So we need to preprocess it then.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Expr *<br/></li>
<li><a id="L1272">&#x200c;</a><span class="linkable">preprocess_phv_expression</span>(PlannerInfo *root, Expr *expr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Expr *) <a href="#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>(root, (Node *) expr, <a href="#L86" title="optimizer/plan/planner.c:86">EXPRKIND_PHV</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*--------------------<br/></li>
<li></span><span class="Comment"> * <a href="#L1305" title="optimizer/plan/planner.c:1305">grouping_planner</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Perform planning steps related to grouping, aggregation, etc.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function adds all required top-level processing to the scan/join<br/></li>
<li></span><span class="Comment"> * Path(s) produced by <a href="planmain.c.html#L54" title="optimizer/plan/planmain.c:54">query_planner</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * tuple_fraction is the fraction of tuples we expect will be retrieved.<br/></li>
<li></span><span class="Comment"> * tuple_fraction is interpreted as follows:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; 0: expect all tuples to be retrieved (normal case)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; 0 &lt; tuple_fraction &lt; 1: expect the given fraction of tuples available<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; from the plan to be retrieved<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; tuple_fraction &gt;= 1: tuple_fraction is the absolute number of tuples<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; expected to be retrieved (ie, a LIMIT specification).<br/></li>
<li></span><span class="Comment"> * setops is used for set operation subqueries to provide the subquery with<br/></li>
<li></span><span class="Comment"> * the context in which it's being used so that Paths correctly sorted for the<br/></li>
<li></span><span class="Comment"> * set operation can be generated.&nbsp; NULL when not planning a set operation<br/></li>
<li></span><span class="Comment"> * child.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns nothing; the useful output is in the Paths we attach to the<br/></li>
<li></span><span class="Comment"> * (UPPERREL_FINAL, NULL) upperrel in *root.&nbsp; In addition,<br/></li>
<li></span><span class="Comment"> * root-&gt;processed_tlist contains the final processed targetlist.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we have not done <a href="../util/pathnode.c.html#L242" title="optimizer/util/pathnode.c:242">set_cheapest</a>() on the final rel; it's convenient<br/></li>
<li></span><span class="Comment"> * to leave this to the caller.<br/></li>
<li></span><span class="Comment"> *--------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1305">&#x200c;</a></span><span class="linkable">grouping_planner</span>(PlannerInfo *root, <span class="Type">double</span> tuple_fraction,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SetOperationStmt *setops)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; offset_est = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; count_est = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; limit_tuples = -<span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_postponed_srfs = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; PathTarget *final_target;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *final_targets;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *final_targets_contain_srfs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; final_target_parallel_safe;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *current_rel;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *final_rel;<br/></li>
<li>&nbsp; &nbsp; FinalPathExtraData extra;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Tweak caller-supplied tuple_fraction if have LIMIT/OFFSET */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;limitCount || <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;limitOffset)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple_fraction = <a href="#L2443" title="optimizer/plan/planner.c:2443">preprocess_limit</a>(root, tuple_fraction,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;offset_est, &amp;count_est);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have a known LIMIT, and don't have an unknown OFFSET, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * estimate the effects of using a bounded sort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count_est &gt; <span class="Constant">0</span> &amp;&amp; offset_est &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; limit_tuples = (<span class="Type">double</span>) count_est + (<span class="Type">double</span>) offset_est;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make tuple_fraction accessible to <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-level routines */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;tuple_fraction = tuple_fraction;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;setOperations)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Construct Paths for set operations.&nbsp; The results will not need <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * work except perhaps a top-level sort and/or LIMIT.&nbsp; Note that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * special work for recursive unions is the responsibility of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../prep/prepunion.c.html#L99" title="optimizer/prep/prepunion.c:99">plan_set_operations</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; current_rel = <a href="../prep/prepunion.c.html#L99" title="optimizer/prep/prepunion.c:99">plan_set_operations</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We should not need to call <a href="../prep/preptlist.c.html#L62" title="optimizer/prep/preptlist.c:62">preprocess_targetlist</a>, since we must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in a SELECT query node.&nbsp; Instead, use the processed_tlist returned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by <a href="../prep/prepunion.c.html#L99" title="optimizer/prep/prepunion.c:99">plan_set_operations</a> (since this tells whether it returned <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * resjunk columns!), and transfer <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> sort key information from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * original tlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;commandType == CMD_SELECT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for safety, copy processed_tlist instead of modifying in-place */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;processed_tlist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5547" title="optimizer/plan/planner.c:5547">postprocess_setop_tlist</a>(copyObject(root-&gt;processed_tlist),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;targetList);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Also extract the PathTarget form of the setop result tlist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; final_target = current_rel-&gt;cheapest_total_path-&gt;pathtarget;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And check whether it's parallel safe */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; final_target_parallel_safe =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/clauses.c.html#L753" title="optimizer/util/clauses.c:753">is_parallel_safe</a>(root, (Node *) final_target-&gt;exprs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The setop result tlist couldn't contain <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SRFs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasTargetSRFs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; final_targets = final_targets_contain_srfs = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Can't handle FOR [<a href="../../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>] UPDATE/SHARE here (parser should have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checked already, but let's make sure).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rowMarks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translator: %s is a SQL row locking clause such as FOR UPDATE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> is not allowed with UNION/INTERSECT/EXCEPT&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../parser/analyze.c.html#L3213" title="parser/analyze.c:3213">LCS_asString</a>(linitial_node(RowMarkClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rowMarks)-&gt;strength))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Calculate pathkeys that represent result ordering requirements<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;distinctClause == NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;sort_pathkeys = <a href="../path/pathkeys.c.html#L1347" title="optimizer/path/pathkeys.c:1347">make_pathkeys_for_sortclauses</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;sortClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;processed_tlist);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No set operations, do regular planning */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PathTarget *sort_input_target;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sort_input_targets;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sort_input_targets_contain_srfs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sort_input_target_parallel_safe;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathTarget *grouping_target;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *grouping_targets;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *grouping_targets_contain_srfs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; grouping_target_parallel_safe;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathTarget *scanjoin_target;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *scanjoin_targets;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *scanjoin_targets_contain_srfs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; scanjoin_target_parallel_safe;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; scanjoin_target_same_exprs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_grouping;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WindowFuncLists *wflists = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *activeWindows = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L105" title="optimizer/plan/planner.c:105">grouping_sets_data</a> *gset_data = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L125" title="optimizer/plan/planner.c:125">standard_qp_extra</a> qp_extra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* A recursive query should always have setOperations */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!root-&gt;hasRecursion);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Preprocess grouping sets and GROUP BY clause, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupingSets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gset_data = <a href="#L2047" title="optimizer/plan/planner.c:2047">preprocess_grouping_sets</a>(root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Preprocess regular GROUP BY clause, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;processed_groupClause = <a href="../../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> redundant GROUP BY columns */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2687" title="optimizer/plan/planner.c:2687">remove_useless_groupby_columns</a>(root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Preprocess targetlist.&nbsp; Note that much of the remaining planning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * work will be done with the PathTarget representation of tlists, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we must also maintain the full representation of the final tlist so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that we can transfer its decoration (resnames etc) to the topmost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tlist of the finished Plan.&nbsp; This is kept in processed_tlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../prep/preptlist.c.html#L62" title="optimizer/prep/preptlist.c:62">preprocess_targetlist</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Mark all the aggregates with resolved aggtranstypes, and detect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aggregates that are duplicates or can share transition state.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must do this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> slicing and dicing the tlist into various<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pathtargets, else some copies of the Aggref nodes might escape<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * being marked.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasAggs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../prep/prepagg.c.html#L110" title="optimizer/prep/prepagg.c:110">preprocess_aggrefs</a>(root, (Node *) root-&gt;processed_tlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../prep/prepagg.c.html#L110" title="optimizer/prep/prepagg.c:110">preprocess_aggrefs</a>(root, (Node *) <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;havingQual);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Locate <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> window <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in the tlist.&nbsp; (We don't need to look<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anywhere else, since expressions used in ORDER BY will be in there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * too.)&nbsp; Note that they could all have been eliminated by constant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * folding, in which case we don't need to do <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasWindowFuncs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wflists = <a href="../util/clauses.c.html#L227" title="optimizer/util/clauses.c:227">find_window_functions</a>((Node *) root-&gt;processed_tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;windowClause));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (wflists-&gt;numWindowFuncs &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * See if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> modifications can be made to each WindowClause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to allow the executor to execute the WindowFuncs more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * quickly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5584" title="optimizer/plan/planner.c:5584">optimize_window_clauses</a>(root, wflists);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; activeWindows = <a href="#L5724" title="optimizer/plan/planner.c:5724">select_active_windows</a>(root, wflists);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasWindowFuncs = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Preprocess MIN/MAX aggregates, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.&nbsp; Note: be careful about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * adding logic between here and the <a href="planmain.c.html#L54" title="optimizer/plan/planmain.c:54">query_planner</a>() call.&nbsp; Anything<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that is needed in MIN/MAX-optimizable cases will have to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * duplicated in planagg.c.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasAggs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="planagg.c.html#L72" title="optimizer/plan/planagg.c:72">preprocess_minmax_aggregates</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Figure out whether there's a hard limit on the number of rows that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="planmain.c.html#L54" title="optimizer/plan/planmain.c:54">query_planner</a>'s result subplan needs to return.&nbsp; Even if we know a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hard limit overall, it doesn't apply if the query has <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * grouping/aggregation operations, or SRFs in the tlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupingSets ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;distinctClause ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasAggs ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasWindowFuncs ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasTargetSRFs ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;hasHavingQual)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;limit_tuples = -<span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;limit_tuples = limit_tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set up data needed by <a href="#L3354" title="optimizer/plan/planner.c:3354">standard_qp_callback</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qp_extra.activeWindows = activeWindows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qp_extra.gset_data = gset_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're a subquery for a set operation, store the SetOperationStmt<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in qp_extra.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qp_extra.setop = setops;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Generate the best unsorted and presorted paths for the scan/join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * portion of this Query, ie the processing represented by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * FROM/WHERE clauses.&nbsp; (Note there may not be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> presorted paths.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We also generate (in <a href="#L3354" title="optimizer/plan/planner.c:3354">standard_qp_callback</a>) pathkey representations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the query's sort clause, distinct clause, etc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; current_rel = <a href="planmain.c.html#L54" title="optimizer/plan/planmain.c:54">query_planner</a>(root, <a href="#L3354" title="optimizer/plan/planner.c:3354">standard_qp_callback</a>, &amp;qp_extra);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Convert the query's result tlist into PathTarget format.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: this cannot be done <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="planmain.c.html#L54" title="optimizer/plan/planmain.c:54">query_planner</a>() has performed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * appendrel expansion, because that might add resjunk entries to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * root-&gt;processed_tlist.&nbsp; Waiting till afterwards is also helpful<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because the target width estimates can use per-Var width numbers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that were obtained within <a href="planmain.c.html#L54" title="optimizer/plan/planmain.c:54">query_planner</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; final_target = create_pathtarget(root, root-&gt;processed_tlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; final_target_parallel_safe =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/clauses.c.html#L753" title="optimizer/util/clauses.c:753">is_parallel_safe</a>(root, (Node *) final_target-&gt;exprs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If ORDER BY was given, consider whether we should use a post-sort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * projection, and compute the adjusted target for preceding steps if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;sortClause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sort_input_target = <a href="#L6127" title="optimizer/plan/planner.c:6127">make_sort_input_target</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; final_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;have_postponed_srfs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sort_input_target_parallel_safe =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/clauses.c.html#L753" title="optimizer/util/clauses.c:753">is_parallel_safe</a>(root, (Node *) sort_input_target-&gt;exprs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sort_input_target = final_target;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sort_input_target_parallel_safe = final_target_parallel_safe;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have window <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to deal with, the output from <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * grouping step needs to be what the window <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> want;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise, it should be sort_input_target.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (activeWindows)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grouping_target = <a href="#L5881" title="optimizer/plan/planner.c:5881">make_window_input_target</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; final_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; activeWindows);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grouping_target_parallel_safe =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/clauses.c.html#L753" title="optimizer/util/clauses.c:753">is_parallel_safe</a>(root, (Node *) grouping_target-&gt;exprs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grouping_target = sort_input_target;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grouping_target_parallel_safe = sort_input_target_parallel_safe;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have grouping or aggregation to do, the topmost scan/join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * plan node must emit what the grouping step wants; otherwise, it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should emit grouping_target.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; have_grouping = (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause || <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupingSets ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasAggs || root-&gt;hasHavingQual);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (have_grouping)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanjoin_target = <a href="#L5321" title="optimizer/plan/planner.c:5321">make_group_input_target</a>(root, final_target);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanjoin_target_parallel_safe =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/clauses.c.html#L753" title="optimizer/util/clauses.c:753">is_parallel_safe</a>(root, (Node *) scanjoin_target-&gt;exprs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanjoin_target = grouping_target;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanjoin_target_parallel_safe = grouping_target_parallel_safe;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SRFs in the targetlist, we must separate each of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * these PathTargets into SRF-computing and SRF-free targets.&nbsp; Replace<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * each of the named targets with a SRF-free version, and remember the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list of additional projection steps we need to add afterwards.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasTargetSRFs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* final_target doesn't recompute <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SRFs in sort_input_target */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/tlist.c.html#L881" title="optimizer/util/tlist.c:881">split_pathtarget_at_srfs</a>(root, final_target, sort_input_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;final_targets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;final_targets_contain_srfs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final_target = linitial_node(PathTarget, final_targets);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!linitial_int(final_targets_contain_srfs));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* likewise for sort_input_target vs. grouping_target */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/tlist.c.html#L881" title="optimizer/util/tlist.c:881">split_pathtarget_at_srfs</a>(root, sort_input_target, grouping_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;sort_input_targets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;sort_input_targets_contain_srfs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sort_input_target = linitial_node(PathTarget, sort_input_targets);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!linitial_int(sort_input_targets_contain_srfs));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* likewise for grouping_target vs. scanjoin_target */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/tlist.c.html#L881" title="optimizer/util/tlist.c:881">split_pathtarget_at_srfs</a>(root, grouping_target, scanjoin_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;grouping_targets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;grouping_targets_contain_srfs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grouping_target = linitial_node(PathTarget, grouping_targets);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!linitial_int(grouping_targets_contain_srfs));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* scanjoin_target will not have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SRFs precomputed for it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/tlist.c.html#L881" title="optimizer/util/tlist.c:881">split_pathtarget_at_srfs</a>(root, scanjoin_target, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;scanjoin_targets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;scanjoin_targets_contain_srfs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanjoin_target = linitial_node(PathTarget, scanjoin_targets);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!linitial_int(scanjoin_targets_contain_srfs));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> lists; for most of these, dummy <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are OK */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final_targets = final_targets_contain_srfs = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sort_input_targets = sort_input_targets_contain_srfs = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grouping_targets = grouping_targets_contain_srfs = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanjoin_targets = list_make1(scanjoin_target);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanjoin_targets_contain_srfs = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Apply scan/join target. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; scanjoin_target_same_exprs = list_length(scanjoin_targets) == <span class="Constant">1<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(scanjoin_target-&gt;exprs, current_rel-&gt;reltarget-&gt;exprs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7503" title="optimizer/plan/planner.c:7503">apply_scanjoin_target_to_paths</a>(root, current_rel, scanjoin_targets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scanjoin_targets_contain_srfs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scanjoin_target_parallel_safe,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scanjoin_target_same_exprs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Save the various <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-rel PathTargets we just computed into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * root-&gt;upper_targets[].&nbsp; The core code doesn't use this, but it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * provides a convenient place for extensions to get at the info.&nbsp; For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consistency, we save all the intermediate targets, even though some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the corresponding upperrels might not be needed for this query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;upper_targets[UPPERREL_FINAL] = final_target;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;upper_targets[UPPERREL_ORDERED] = final_target;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;upper_targets[UPPERREL_DISTINCT] = sort_input_target;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;upper_targets[UPPERREL_PARTIAL_DISTINCT] = sort_input_target;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;upper_targets[UPPERREL_WINDOW] = sort_input_target;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;upper_targets[UPPERREL_GROUP_AGG] = grouping_target;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have grouping and/or aggregation, consider ways to implement<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that.&nbsp; We build a new upperrel representing the output of this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * phase.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (have_grouping)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_rel = <a href="#L3658" title="optimizer/plan/planner.c:3658">create_grouping_paths</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grouping_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grouping_target_parallel_safe,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gset_data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fix things up if grouping_target contains SRFs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasTargetSRFs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6341" title="optimizer/plan/planner.c:6341">adjust_paths_for_srfs</a>(root, current_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grouping_targets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grouping_targets_contain_srfs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have window <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, consider ways to implement those.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * build a new upperrel representing the output of this phase.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (activeWindows)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_rel = <a href="#L4410" title="optimizer/plan/planner.c:4410">create_window_paths</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grouping_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sort_input_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sort_input_target_parallel_safe,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wflists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; activeWindows);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fix things up if sort_input_target contains SRFs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasTargetSRFs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6341" title="optimizer/plan/planner.c:6341">adjust_paths_for_srfs</a>(root, current_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sort_input_targets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sort_input_targets_contain_srfs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there is a DISTINCT clause, consider ways to implement that. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * build a new upperrel representing the output of this phase.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;distinctClause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_rel = <a href="#L4630" title="optimizer/plan/planner.c:4630">create_distinct_paths</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sort_input_target);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of if (setOperations) */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If ORDER BY was given, consider ways to implement that, and generate a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new upperrel containing only paths that emit the correct ordering and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * project the correct final_target.&nbsp; We can apply the original<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * limit_tuples limit in sort costing here, but only if there are no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * postponed SRFs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;sortClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; current_rel = <a href="#L5106" title="optimizer/plan/planner.c:5106">create_ordered_paths</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; current_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; final_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; final_target_parallel_safe,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; have_postponed_srfs ? -<span class="Constant">1.0</span> :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; limit_tuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fix things up if final_target contains SRFs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasTargetSRFs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6341" title="optimizer/plan/planner.c:6341">adjust_paths_for_srfs</a>(root, current_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final_targets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final_targets_contain_srfs);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we are prepared to build the final-output upperrel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; final_rel = <a href="../util/relnode.c.html#L1470" title="optimizer/util/relnode.c:1470">fetch_upper_rel</a>(root, UPPERREL_FINAL, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the input rel is marked consider_parallel and there's nothing that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not parallel-safe in the LIMIT clause, then the final_rel can be marked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consider_parallel as well.&nbsp; Note that if the query has rowMarks or is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not a SELECT, consider_parallel will be false for every relation in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (current_rel-&gt;consider_parallel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/clauses.c.html#L753" title="optimizer/util/clauses.c:753">is_parallel_safe</a>(root, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;limitOffset) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/clauses.c.html#L753" title="optimizer/util/clauses.c:753">is_parallel_safe</a>(root, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;limitCount))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; final_rel-&gt;consider_parallel = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the current_rel belongs to a single FDW, so does the final_rel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; final_rel-&gt;serverid = current_rel-&gt;serverid;<br/></li>
<li>&nbsp; &nbsp; final_rel-&gt;userid = current_rel-&gt;userid;<br/></li>
<li>&nbsp; &nbsp; final_rel-&gt;useridiscurrent = current_rel-&gt;useridiscurrent;<br/></li>
<li>&nbsp; &nbsp; final_rel-&gt;fdwroutine = current_rel-&gt;fdwroutine;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate paths for the final_rel.&nbsp; <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> all surviving paths, with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LockRows, Limit, and/or ModifyTable steps added if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, current_rel-&gt;pathlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path = (Path *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there is a FOR [<a href="../../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>] UPDATE/SHARE clause, add the LockRows node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (Note: we intentionally test <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rowMarks not root-&gt;rowMarks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here.&nbsp; If there are only non-locking rowmarks, they should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * handled by the ModifyTable node instead.&nbsp; However, root-&gt;rowMarks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is what goes into the LockRows node.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rowMarks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path = (Path *) <a href="../util/pathnode.c.html#L3659" title="optimizer/util/pathnode.c:3659">create_lockrows_path</a>(root, final_rel, path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;rowMarks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/paramassign.c.html#L664" title="optimizer/util/paramassign.c:664">assign_special_exec_param</a>(root));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there is a LIMIT/OFFSET clause, add the LIMIT node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2628" title="optimizer/plan/planner.c:2628">limit_needed</a>(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path = (Path *) <a href="../util/pathnode.c.html#L3823" title="optimizer/util/pathnode.c:3823">create_limit_path</a>(root, final_rel, path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;limitOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;limitCount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;limitOption,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset_est, count_est);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is an INSERT/UPDATE/DELETE/MERGE, add the ModifyTable node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;commandType != CMD_SELECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; rootRelation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *resultRelations = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *updateColnosLists = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *withCheckOptionLists = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *returningLists = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *mergeActionLists = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *mergeJoinConditions = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *rowMarks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L781" title="nodes/bitmapset.c:781">bms_membership</a>(root-&gt;all_result_relids) == BMS_MULTIPLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Inherited UPDATE/DELETE/MERGE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *top_result_rel = <a href="../util/relnode.c.html#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;resultRelation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultRelation = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Pass the root result rel forward to the executor. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rootRelation = <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;resultRelation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add only leaf children to ModifyTable. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((resultRelation = <a href="../../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(root-&gt;leaf_result_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; resultRelation)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *this_result_rel = <a href="../util/relnode.c.html#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultRelation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also exclude <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> leaf rels that have turned dummy since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * being added to the list, for example, by being excluded<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by constraint exclusion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IS_DUMMY_REL(this_result_rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Build per-target-rel lists needed by ModifyTable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultRelations = <a href="../../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(resultRelations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultRelation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;commandType == CMD_UPDATE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *update_colnos = root-&gt;update_colnos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (this_result_rel != top_result_rel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; update_colnos =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/appendinfo.c.html#L662" title="optimizer/util/appendinfo.c:662">adjust_inherited_attnums_multilevel</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; update_colnos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_result_rel-&gt;relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; top_result_rel-&gt;relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updateColnosLists = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(updateColnosLists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; update_colnos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;withCheckOptions)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *withCheckOptions = <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;withCheckOptions;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (this_result_rel != top_result_rel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; withCheckOptions = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/appendinfo.c.html#L521" title="optimizer/util/appendinfo.c:521">adjust_appendrel_attrs_multilevel</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Node *) withCheckOptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_result_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; top_result_rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; withCheckOptionLists = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(withCheckOptionLists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; withCheckOptions);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;returningList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *returningList = <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;returningList;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (this_result_rel != top_result_rel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returningList = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/appendinfo.c.html#L521" title="optimizer/util/appendinfo.c:521">adjust_appendrel_attrs_multilevel</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Node *) returningList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_result_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; top_result_rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returningLists = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(returningLists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; returningList);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;mergeActionList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *mergeActionList = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy MergeActions and <a href="../../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> stuff that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * references attribute numbers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;mergeActionList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MergeAction *action = lfirst(l),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *leaf_action = copyObject(action);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leaf_action-&gt;qual =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/appendinfo.c.html#L521" title="optimizer/util/appendinfo.c:521">adjust_appendrel_attrs_multilevel</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Node *) action-&gt;qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_result_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; top_result_rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leaf_action-&gt;targetList = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/appendinfo.c.html#L521" title="optimizer/util/appendinfo.c:521">adjust_appendrel_attrs_multilevel</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Node *) action-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_result_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; top_result_rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (leaf_action-&gt;commandType == CMD_UPDATE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leaf_action-&gt;updateColnos =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/appendinfo.c.html#L662" title="optimizer/util/appendinfo.c:662">adjust_inherited_attnums_multilevel</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; action-&gt;updateColnos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_result_rel-&gt;relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; top_result_rel-&gt;relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mergeActionList = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(mergeActionList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leaf_action);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mergeActionLists = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(mergeActionLists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mergeActionList);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;commandType == CMD_MERGE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *mergeJoinCondition = <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;mergeJoinCondition;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (this_result_rel != top_result_rel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mergeJoinCondition =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/appendinfo.c.html#L521" title="optimizer/util/appendinfo.c:521">adjust_appendrel_attrs_multilevel</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mergeJoinCondition,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_result_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; top_result_rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mergeJoinConditions = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(mergeJoinConditions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mergeJoinCondition);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (resultRelations == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We managed to exclude every child rel, so generate a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dummy one-relation plan using info for the top target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rel (even though that may not be a leaf target).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Although it's clear that no data will be updated or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deleted, we still need to have a ModifyTable node so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> statement triggers will be executed.&nbsp; (This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could be cleaner if we fixed nodeModifyTable.c to allow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * zero target relations, but that probably wouldn't be a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * net win.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultRelations = list_make1_int(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;resultRelation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;commandType == CMD_UPDATE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updateColnosLists = list_make1(root-&gt;update_colnos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;withCheckOptions)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; withCheckOptionLists = list_make1(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;withCheckOptions);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;returningList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returningLists = list_make1(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;returningList);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;mergeActionList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mergeActionLists = list_make1(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;mergeActionList);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;commandType == CMD_MERGE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mergeJoinConditions = list_make1(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;mergeJoinCondition);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Single-relation INSERT/UPDATE/DELETE/MERGE. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rootRelation = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* there's no separate root rel */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultRelations = list_make1_int(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;resultRelation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;commandType == CMD_UPDATE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updateColnosLists = list_make1(root-&gt;update_colnos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;withCheckOptions)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; withCheckOptionLists = list_make1(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;withCheckOptions);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;returningList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returningLists = list_make1(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;returningList);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;mergeActionList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mergeActionLists = list_make1(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;mergeActionList);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;commandType == CMD_MERGE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mergeJoinConditions = list_make1(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;mergeJoinCondition);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there was a FOR [<a href="../../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>] UPDATE/SHARE clause, the LockRows node<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will have dealt with fetching non-locked marked rows, else we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to have ModifyTable do that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rowMarks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowMarks = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowMarks = root-&gt;rowMarks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path = (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L3722" title="optimizer/util/pathnode.c:3722">create_modifytable_path</a>(root, final_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;commandType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;canSetTag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;resultRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rootRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;partColsUpdated,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultRelations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updateColnosLists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; withCheckOptionLists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returningLists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowMarks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;onConflict,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mergeActionLists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mergeJoinConditions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/paramassign.c.html#L664" title="optimizer/util/paramassign.c:664">assign_special_exec_param</a>(root));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And shove it into final_rel */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(final_rel, path);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate partial paths for final_rel, too, if outer query levels might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be able to make use of them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (final_rel-&gt;consider_parallel &amp;&amp; root-&gt;query_level &gt; <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L2628" title="optimizer/plan/planner.c:2628">limit_needed</a>(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rowMarks &amp;&amp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;commandType == CMD_SELECT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, current_rel-&gt;partial_pathlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *partial_path = (Path *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L747" title="optimizer/util/pathnode.c:747">add_partial_path</a>(final_rel, partial_path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; extra.<a href="#L2628" title="optimizer/plan/planner.c:2628">limit_needed</a> = <a href="#L2628" title="optimizer/plan/planner.c:2628">limit_needed</a>(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>);<br/></li>
<li>&nbsp; &nbsp; extra.limit_tuples = limit_tuples;<br/></li>
<li>&nbsp; &nbsp; extra.count_est = count_est;<br/></li>
<li>&nbsp; &nbsp; extra.offset_est = offset_est;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is an FDW that's responsible for all baserels of the query,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * let it consider adding ForeignPaths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (final_rel-&gt;fdwroutine &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; final_rel-&gt;fdwroutine-&gt;GetForeignUpperPaths)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; final_rel-&gt;fdwroutine-&gt;GetForeignUpperPaths(root, UPPERREL_FINAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_rel, final_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;extra);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Let extensions possibly add some more paths */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L74" title="optimizer/plan/planner.c:74">create_upper_paths_hook</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*<a href="#L74" title="optimizer/plan/planner.c:74">create_upper_paths_hook</a>) (root, UPPERREL_FINAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_rel, final_rel, &amp;extra);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note: currently, we leave it to callers to do <a href="../util/pathnode.c.html#L242" title="optimizer/util/pathnode.c:242">set_cheapest</a>() */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Do preprocessing for groupingSets clause and related data.&nbsp; This handles the<br/></li>
<li></span><span class="Comment"> * preliminary steps of expanding the grouping sets, organizing them into lists<br/></li>
<li></span><span class="Comment"> * of rollups, and preparing annotations which will later be filled in with<br/></li>
<li></span><span class="Comment"> * size estimates.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L105" title="optimizer/plan/planner.c:105">grouping_sets_data</a> *<br/></li>
<li><a id="L2047">&#x200c;</a><span class="linkable">preprocess_grouping_sets</span>(PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sets;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxref = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc_set;<br/></li>
<li>&nbsp; &nbsp; <a href="#L105" title="optimizer/plan/planner.c:105">grouping_sets_data</a> *gd = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L105" title="optimizer/plan/planner.c:105">grouping_sets_data</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupingSets = <a href="../../parser/parse_agg.c.html#L1805" title="parser/parse_agg.c:1805">expand_grouping_sets</a>(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupingSets, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupDistinct, -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; gd-&gt;any_hashable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; gd-&gt;unhashable_refs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; gd-&gt;unsortable_refs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; gd-&gt;unsortable_sets = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't currently make <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> attempt to <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> the groupClause when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there are grouping sets, so just duplicate it in processed_groupClause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;processed_groupClause = <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *gc = lfirst_node(SortGroupClause, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; ref = gc-&gt;tleSortGroupRef;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ref &gt; maxref)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxref = ref;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!gc-&gt;hashable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gd-&gt;unhashable_refs = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(gd-&gt;unhashable_refs, ref);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(gc-&gt;sortop))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gd-&gt;unsortable_refs = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(gd-&gt;unsortable_refs, ref);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate workspace array for remapping */<br/></li>
<li></span>&nbsp; &nbsp; gd-&gt;tleref_to_colnum_map = (<span class="Type">int</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>((maxref + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unsortable sets, we must extract them <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> trying to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prepare rollups. Unsortable sets don't go through<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L3080" title="optimizer/plan/planner.c:3080">reorder_grouping_sets</a>, so we must apply the GroupingSetData annotation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!bms_is_empty(gd-&gt;unsortable_refs))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sortable_sets = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupingSets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *gset = (List *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L608" title="nodes/bitmapset.c:608">bms_overlap_list</a>(gd-&gt;unsortable_refs, gset))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GroupingSetData *gs = makeNode(GroupingSetData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gs-&gt;set = gset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gd-&gt;unsortable_sets = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(gd-&gt;unsortable_sets, gs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must enforce here that an unsortable set is hashable;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * later code assumes this.&nbsp; Parse analysis only checks that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * every individual column is either hashable or sortable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that passing this test doesn't guarantee we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * generate a plan; there might be other showstoppers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L608" title="nodes/bitmapset.c:608">bms_overlap_list</a>(gd-&gt;unhashable_refs, gset))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not implement GROUP BY&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Some of the datatypes only support hashing, while others only support sorting.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortable_sets = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(sortable_sets, gset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sortable_sets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sets = <a href="#L2868" title="optimizer/plan/planner.c:2868">extract_rollup_sets</a>(sortable_sets);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sets = NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sets = <a href="#L2868" title="optimizer/plan/planner.c:2868">extract_rollup_sets</a>(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupingSets);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc_set, sets)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *current_sets = (List *) lfirst(lc_set);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RollupData *rollup = makeNode(RollupData);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GroupingSetData *gs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reorder the current list of grouping sets into correct prefix<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * order.&nbsp; If only one aggregation pass is needed, try to make the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list match the ORDER BY clause; if more than one pass is needed, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't bother with that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that this reorders the sets from smallest-member-first to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * largest-member-first, and applies the GroupingSetData annotations,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * though the data will be filled in later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; current_sets = <a href="#L3080" title="optimizer/plan/planner.c:3080">reorder_grouping_sets</a>(current_sets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (list_length(sets) == <span class="Constant">1<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;sortClause<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : NIL));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get the initial (and therefore largest) grouping set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; gs = linitial_node(GroupingSetData, current_sets);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Order the groupClause appropriately.&nbsp; If the first grouping set is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * empty, then the groupClause must also be empty; otherwise we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to force the groupClause to match that grouping set's order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (The first grouping set can be empty even though <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is not empty only if all non-empty grouping sets are unsortable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The groupClauses for hashed grouping sets are built later on.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (gs-&gt;set)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;groupClause = <a href="#L2832" title="optimizer/plan/planner.c:2832">groupclause_apply_groupingset</a>(root, gs-&gt;set);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;groupClause = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Is it hashable? We pretend empty sets are hashable even though we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * actually force them not to be hashed later. But don't bother if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there's nothing but empty sets (since in that case we can't <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anything).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (gs-&gt;set &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../nodes/bitmapset.c.html#L608" title="nodes/bitmapset.c:608">bms_overlap_list</a>(gd-&gt;unhashable_refs, gs-&gt;set))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;hashable = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gd-&gt;any_hashable = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now that we've pinned down an order for the groupClause for this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list of grouping sets, we need to remap the entries in the grouping<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sets from sortgrouprefs to plain indices (0-based) into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * groupClause for this collection of grouping sets. We keep the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * original form for later use, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;gsets = <a href="#L2228" title="optimizer/plan/planner.c:2228">remap_to_groupclause_idx</a>(rollup-&gt;groupClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; current_sets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gd-&gt;tleref_to_colnum_map);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;gsets_data = current_sets;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gd-&gt;rollups = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(gd-&gt;rollups, rollup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (gd-&gt;unsortable_sets)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have not yet pinned down a groupclause for this, but we will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need index-based lists for estimation purposes. Construct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hash_sets_idx based on the entire original groupclause for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; gd-&gt;hash_sets_idx = <a href="#L2228" title="optimizer/plan/planner.c:2228">remap_to_groupclause_idx</a>(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gd-&gt;unsortable_sets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gd-&gt;tleref_to_colnum_map);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gd-&gt;any_hashable = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> gd;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a groupclause and a list of GroupingSetData, return equivalent sets<br/></li>
<li></span><span class="Comment"> * (without annotation) mapped to indexes into the given groupclause.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L2228">&#x200c;</a><span class="linkable">remap_to_groupclause_idx</span>(List *groupClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *gsets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *tleref_to_colnum_map)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ref = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, groupClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *gc = lfirst_node(SortGroupClause, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tleref_to_colnum_map[gc-&gt;tleSortGroupRef] = ref++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, gsets)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *set = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GroupingSetData *gs = lfirst_node(GroupingSetData, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, gs-&gt;set)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set = <a href="../../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(set, tleref_to_colnum_map[lfirst_int(lc2)]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, set);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2265" title="optimizer/plan/planner.c:2265">preprocess_rowmarks</a> - set up PlanRowMarks if needed<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2265">&#x200c;</a></span><span class="linkable">preprocess_rowmarks</span>(PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *rels;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *prowmarks;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rowMarks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We've got trouble if FOR [<a href="../../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>] UPDATE/SHARE appears inside<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * grouping, since grouping renders a reference to individual tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * CTIDs invalid.&nbsp; This is also checked at <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> time, but that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * insufficient because of rule substitution, query pullup, etc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../parser/analyze.c.html#L3238" title="parser/analyze.c:3238">CheckSelectLocking</a>(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>, linitial_node(RowMarkClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rowMarks)-&gt;strength);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We only need rowmarks for UPDATE, DELETE, MERGE, or FOR [<a href="../../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * UPDATE/SHARE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;commandType != CMD_UPDATE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;commandType != CMD_DELETE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;commandType != CMD_MERGE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to have rowmarks for all base relations except the target. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * make a bitmapset of all base rels and then remove the items we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need or have FOR [<a href="../../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>] UPDATE/SHARE marks for.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rels = <a href="../prep/prepjointree.c.html#L3861" title="optimizer/prep/prepjointree.c:3861">get_relids_in_jointree</a>((Node *) <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;jointree, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;resultRelation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rels = <a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(rels, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;resultRelation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Convert RowMarkClauses to PlanRowMark representation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; prowmarks = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(l, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rowMarks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RowMarkClause *rc = lfirst_node(RowMarkClause, l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = rt_fetch(rc-&gt;rti, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rtable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlanRowMark *newrc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Currently, it is syntactically impossible to have FOR UPDATE et al<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * applied to an update/delete target rel.&nbsp; If that ever becomes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible, we should drop the target from the PlanRowMark list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(rc-&gt;rti != <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;resultRelation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore RowMarkClauses for subqueries; they aren't real tables and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can't support true locking.&nbsp; Subqueries that got flattened into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> query should be ignored completely.&nbsp; Any that didn't will get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ROW_MARK_COPY items in the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind != RTE_RELATION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rels = <a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(rels, rc-&gt;rti);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newrc = makeNode(PlanRowMark);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newrc-&gt;rti = newrc-&gt;prti = rc-&gt;rti;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newrc-&gt;rowmarkId = ++(root-&gt;glob-&gt;lastRowMarkId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newrc-&gt;markType = <a href="#L2377" title="optimizer/plan/planner.c:2377">select_rowmark_type</a>(rte, rc-&gt;strength);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newrc-&gt;allMarkTypes = (<span class="Constant">1</span> &lt;&lt; newrc-&gt;markType);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newrc-&gt;strength = rc-&gt;strength;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newrc-&gt;waitPolicy = rc-&gt;waitPolicy;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newrc-&gt;isParent = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prowmarks = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(prowmarks, newrc);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now, add rowmarks for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-target, non-locked base relations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(l, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rtable)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = lfirst_node(RangeTblEntry, l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlanRowMark *newrc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(i, rels))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newrc = makeNode(PlanRowMark);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newrc-&gt;rti = newrc-&gt;prti = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newrc-&gt;rowmarkId = ++(root-&gt;glob-&gt;lastRowMarkId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newrc-&gt;markType = <a href="#L2377" title="optimizer/plan/planner.c:2377">select_rowmark_type</a>(rte, LCS_NONE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newrc-&gt;allMarkTypes = (<span class="Constant">1</span> &lt;&lt; newrc-&gt;markType);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newrc-&gt;strength = LCS_NONE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newrc-&gt;waitPolicy = LockWaitBlock;&nbsp; &nbsp; <span class="Comment">/* doesn't matter */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newrc-&gt;isParent = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prowmarks = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(prowmarks, newrc);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; root-&gt;rowMarks = prowmarks;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Select RowMarkType to use for a given table<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RowMarkType<br/></li>
<li><a id="L2377">&#x200c;</a><span class="linkable">select_rowmark_type</span>(RangeTblEntry *rte, LockClauseStrength strength)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind != RTE_RELATION)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's not a table at all, use ROW_MARK_COPY */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ROW_MARK_COPY;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rte-&gt;relkind == RELKIND_FOREIGN_TABLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Let the FDW <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> the rowmark type, if it wants to */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; FdwRoutine *fdwroutine = <a href="../../foreign/foreign.c.html#L409" title="foreign/foreign.c:409">GetFdwRoutineByRelId</a>(rte-&gt;relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fdwroutine-&gt;GetForeignRowMarkType != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> fdwroutine-&gt;GetForeignRowMarkType(rte, strength);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise, use ROW_MARK_COPY by default */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ROW_MARK_COPY;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Regular table, apply the appropriate lock type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (strength)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LCS_NONE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't need a tuple lock, only the ability to re-fetch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the row.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ROW_MARK_REFERENCE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LCS_FORKEYSHARE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ROW_MARK_KEYSHARE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LCS_FORSHARE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ROW_MARK_SHARE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LCS_FORNOKEYUPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ROW_MARK_NOKEYEXCLUSIVE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LCS_FORUPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ROW_MARK_EXCLUSIVE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized LockClauseStrength </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) strength);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ROW_MARK_EXCLUSIVE;&nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2443" title="optimizer/plan/planner.c:2443">preprocess_limit</a> - do pre-estimation for LIMIT and/or OFFSET clauses<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We try to estimate the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of the LIMIT/OFFSET clauses, and pass the<br/></li>
<li></span><span class="Comment"> * results back in *count_est and *offset_est.&nbsp; These variables are set to<br/></li>
<li></span><span class="Comment"> * 0 if the corresponding clause is not present, and -1 if it's present<br/></li>
<li></span><span class="Comment"> * but we couldn't estimate the value for it.&nbsp; (The &quot;0&quot; convention is OK<br/></li>
<li></span><span class="Comment"> * for OFFSET but a little <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> bogus for LIMIT: effectively we estimate<br/></li>
<li></span><span class="Comment"> * LIMIT 0 as though it were LIMIT 1.&nbsp; But this is in line with the <a href="#L274" title="optimizer/plan/planner.c:274">planner</a>'s<br/></li>
<li></span><span class="Comment"> * usual practice of never estimating less than one row.)&nbsp; These <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> will<br/></li>
<li></span><span class="Comment"> * be passed to <a href="../util/pathnode.c.html#L3823" title="optimizer/util/pathnode.c:3823">create_limit_path</a>, which see if you change this code.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The return value is the suitably adjusted tuple_fraction to use for<br/></li>
<li></span><span class="Comment"> * planning the query.&nbsp; This adjustment is not overridable, since it reflects<br/></li>
<li></span><span class="Comment"> * plan actions that <a href="#L1305" title="optimizer/plan/planner.c:1305">grouping_planner</a>() will certainly take, not assumptions<br/></li>
<li></span><span class="Comment"> * about context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L2443">&#x200c;</a></span><span class="linkable">preprocess_limit</span>(PlannerInfo *root, <span class="Type">double</span> tuple_fraction,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int64 *offset_est, int64 *count_est)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *est;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; limit_fraction;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should not be called unless LIMIT or OFFSET */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;limitCount || <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;limitOffset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to obtain the clause <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; We use <a href="../util/clauses.c.html#L2395" title="optimizer/util/clauses.c:2395">estimate_expression_value</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * primarily because it can sometimes do something useful with Params.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;limitCount)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; est = <a href="../util/clauses.c.html#L2395" title="optimizer/util/clauses.c:2395">estimate_expression_value</a>(root, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;limitCount);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (est &amp;&amp; IsA(est, Const))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((Const *) est)-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NULL indicates LIMIT ALL, ie, no limit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *count_est = <span class="Constant">0</span>; <span class="Comment">/* treat as not present */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *count_est = DatumGetInt64(((Const *) est)-&gt;constvalue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*count_est &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *count_est = <span class="Constant">1</span>; <span class="Comment">/* force to at least 1 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *count_est = -<span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* can't estimate */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *count_est = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not present */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;limitOffset)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; est = <a href="../util/clauses.c.html#L2395" title="optimizer/util/clauses.c:2395">estimate_expression_value</a>(root, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;limitOffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (est &amp;&amp; IsA(est, Const))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((Const *) est)-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Treat NULL as no offset; the executor will too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *offset_est = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* treat as not present */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *offset_est = DatumGetInt64(((Const *) est)-&gt;constvalue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*offset_est &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *offset_est = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* treat as not present */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *offset_est = -<span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* can't estimate */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *offset_est = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not present */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*count_est != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A LIMIT clause limits the absolute number of tuples returned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, if it's not a constant LIMIT then we have to guess; for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lack of a better idea, assume 10% of the plan's result is wanted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*count_est &lt; <span class="Constant">0</span> || *offset_est &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* LIMIT or OFFSET is an expression ... punt ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; limit_fraction = <span class="Constant">0.10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* LIMIT (plus OFFSET, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) is max number of tuples needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; limit_fraction = (<span class="Type">double</span>) *count_est + (<span class="Type">double</span>) *offset_est;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have absolute limits from both caller and LIMIT, use the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * smaller value; likewise if they are both fractional.&nbsp; If one is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fractional and the other absolute, we can't easily determine which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is smaller, but we use the heuristic that the absolute will usually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be smaller.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tuple_fraction &gt;= <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (limit_fraction &gt;= <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* both absolute */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_fraction = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(tuple_fraction, limit_fraction);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* caller absolute, limit fractional; use caller's value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (tuple_fraction &gt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (limit_fraction &gt;= <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* caller fractional, limit absolute; use limit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_fraction = limit_fraction;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* both fractional */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_fraction = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(tuple_fraction, limit_fraction);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no info from caller, just use limit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_fraction = limit_fraction;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*offset_est != <span class="Constant">0</span> &amp;&amp; tuple_fraction &gt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have an OFFSET but no LIMIT.&nbsp; This acts entirely differently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from the LIMIT case: here, we need to increase rather than decrease<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the caller's tuple_fraction, because the OFFSET acts to cause more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples to be fetched instead of fewer.&nbsp; This only matters if we got<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a tuple_fraction &gt; 0, however.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As above, use 10% if OFFSET is present but unestimatable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*offset_est &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; limit_fraction = <span class="Constant">0.10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; limit_fraction = (<span class="Type">double</span>) *offset_est;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have absolute counts from both caller and OFFSET, add them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * together; likewise if they are both fractional.&nbsp; If one is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fractional and the other absolute, we want to take the larger, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we heuristically assume that's the fractional one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tuple_fraction &gt;= <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (limit_fraction &gt;= <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* both absolute, so add them together */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_fraction += limit_fraction;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* caller absolute, limit fractional; use limit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_fraction = limit_fraction;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (limit_fraction &gt;= <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* caller fractional, limit absolute; use caller's value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* both fractional, so add them together */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_fraction += limit_fraction;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tuple_fraction &gt;= <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_fraction = <span class="Constant">0.0</span>;&nbsp; &nbsp; <span class="Comment">/* assume fetch all */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tuple_fraction;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2628" title="optimizer/plan/planner.c:2628">limit_needed</a> - do we actually need a Limit plan node?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If we have constant-zero OFFSET and constant-null LIMIT, we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> adding<br/></li>
<li></span><span class="Comment"> * a Limit node.&nbsp; This is worth checking for because &quot;OFFSET 0&quot; is a common<br/></li>
<li></span><span class="Comment"> * locution for an optimization fence.&nbsp; (Because other places in the <a href="#L274" title="optimizer/plan/planner.c:274">planner</a><br/></li>
<li></span><span class="Comment"> * merely check whether <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;limitOffset isn't NULL, it will still work as<br/></li>
<li></span><span class="Comment"> * an optimization fence --- we're just suppressing unnecessary run-time<br/></li>
<li></span><span class="Comment"> * overhead.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This might look like it could be merged into <a href="#L2443" title="optimizer/plan/planner.c:2443">preprocess_limit</a>, but there's<br/></li>
<li></span><span class="Comment"> * a key distinction: here we need hard constants in OFFSET/LIMIT, whereas<br/></li>
<li></span><span class="Comment"> * in <a href="#L2443" title="optimizer/plan/planner.c:2443">preprocess_limit</a> it's good enough to consider estimated <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2628">&#x200c;</a></span><span class="linkable">limit_needed</span>(Query *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node = <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;limitCount;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Const))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NULL indicates LIMIT ALL, ie, no limit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!((Const *) node)-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* LIMIT with a constant value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* non-constant LIMIT */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node = <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;limitOffset;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Const))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Treat NULL as no offset; the executor would too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!((Const *) node)-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; offset = DatumGetInt64(((Const *) node)-&gt;constvalue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offset != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* OFFSET with a nonzero value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* non-constant OFFSET */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't need a Limit plan node */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2687" title="optimizer/plan/planner.c:2687">remove_useless_groupby_columns</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> columns in the GROUP BY clause that are redundant due to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; being functionally dependent on other GROUP BY columns.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since some other DBMSes do not allow references to ungrouped columns, it's<br/></li>
<li></span><span class="Comment"> * not unusual to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> all columns listed in GROUP BY even though listing the<br/></li>
<li></span><span class="Comment"> * primary-key columns would be sufficient.&nbsp; Deleting such excess columns<br/></li>
<li></span><span class="Comment"> * avoids redundant sorting work, so it's worth doing.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Relcache invalidations will ensure that cached plans become invalidated<br/></li>
<li></span><span class="Comment"> * when the underlying index of the pkey constraint is dropped.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently, we only make use of pkey constraints for this, however, we may<br/></li>
<li></span><span class="Comment"> * wish to take this further in the future and also use unique constraints<br/></li>
<li></span><span class="Comment"> * which have NOT NULL columns.&nbsp; In that case, plan invalidation will still<br/></li>
<li></span><span class="Comment"> * work since relations will receive a relcache invalidation when a NOT NULL<br/></li>
<li></span><span class="Comment"> * constraint is dropped.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2687">&#x200c;</a></span><span class="linkable">remove_useless_groupby_columns</span>(PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; Bitmapset **groupbyattnos;<br/></li>
<li>&nbsp; &nbsp; Bitmapset **surplusvars;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No chance to do anything if there are less than two GROUP BY items */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(root-&gt;processed_groupClause) &lt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't fiddle with the GROUP BY clause if the query has grouping sets */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupingSets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan the GROUP BY clause to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> GROUP BY items that are simple Vars.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fill groupbyattnos[k] with a bitmapset of the column attnos of RTE k<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that are GROUP BY items.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; groupbyattnos = (Bitmapset **) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Bitmapset *) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (list_length(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rtable) + <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; foreach(lc, root-&gt;processed_groupClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *sgc = lfirst_node(SortGroupClause, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = <a href="../util/tlist.c.html#L367" title="optimizer/util/tlist.c:367">get_sortgroupclause_tle</a>(sgc, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;targetList);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) tle-&gt;expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore non-Vars and Vars from other query levels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> in principle, stable expressions containing Vars could also be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * removed, if all the Vars are functionally dependent on other GROUP<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * BY items.&nbsp; But it's not clear that such cases occur often enough to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be worth troubling over.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsA(var, Var) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varlevelsup &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, remember we have this Var */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relid = var-&gt;varno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(relid &lt;= list_length(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rtable));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; groupbyattnos[relid] = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(groupbyattnos[relid],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varattno - FirstLowInvalidHeapAttributeNumber);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Consider each relation and see if it is possible to remove some of its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Vars from GROUP BY.&nbsp; For simplicity and speed, we do the actual removal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in a separate pass.&nbsp; Here, we just fill surplusvars[k] with a bitmapset<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the column attnos of RTE k that are removable GROUP BY items.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; surplusvars = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't allocate array unless required */<br/></li>
<li></span>&nbsp; &nbsp; relid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rtable)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = lfirst_node(RangeTblEntry, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *relattnos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *pkattnos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraintOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relid++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Only plain relations could have primary-key constraints */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind != RTE_RELATION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> inheritance parent tables as some of the child rels<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * may cause duplicate rows.&nbsp; This cannot happen with partitioned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tables, however.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;inh &amp;&amp; rte-&gt;relkind != RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Nothing to do unless this rel has multiple Vars in GROUP BY */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relattnos = groupbyattnos[relid];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L781" title="nodes/bitmapset.c:781">bms_membership</a>(relattnos) != BMS_MULTIPLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Can't remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> columns for this rel if there is no suitable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (i.e., nondeferrable) primary key constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pkattnos = <a href="../../catalog/pg_constraint.c.html#L1583" title="catalog/pg_constraint.c:1583">get_primary_key_attnos</a>(rte-&gt;relid, <span class="Constant">false</span>, &amp;constraintOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pkattnos == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the primary key is a proper <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of relattnos then we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * some items in the GROUP BY that can be removed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L445" title="nodes/bitmapset.c:445">bms_subset_compare</a>(pkattnos, relattnos) == BMS_SUBSET1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To easily remember whether we've found anything to do, we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allocate the surplusvars[] array until we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> something.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (surplusvars == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; surplusvars = (Bitmapset **) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Bitmapset *) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (list_length(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rtable) + <span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remember the attnos of the removable columns */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; surplusvars[relid] = <a href="../../nodes/bitmapset.c.html#L346" title="nodes/bitmapset.c:346">bms_difference</a>(relattnos, pkattnos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we found <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> surplus Vars, build a new GROUP BY clause without them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Note: this may leave some TLEs with unreferenced ressortgroupref<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * markings, but that's harmless.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (surplusvars != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *new_groupby = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, root-&gt;processed_groupClause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *sgc = lfirst_node(SortGroupClause, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = <a href="../util/tlist.c.html#L367" title="optimizer/util/tlist.c:367">get_sortgroupclause_tle</a>(sgc, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;targetList);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) tle-&gt;expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * New list must include non-Vars, outer Vars, and anything not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * marked as surplus.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsA(var, Var) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varlevelsup &gt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(var-&gt;varattno - FirstLowInvalidHeapAttributeNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; surplusvars[var-&gt;varno]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_groupby = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(new_groupby, sgc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;processed_groupClause = new_groupby;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2832" title="optimizer/plan/planner.c:2832">groupclause_apply_groupingset</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Apply the order of GROUP BY clauses defined by grouping sets.&nbsp; Items<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; not in the grouping set are skipped.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L2832">&#x200c;</a><span class="linkable">groupclause_apply_groupingset</span>(PlannerInfo *root, List *gset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *new_groupclause = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *sl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(sl, gset)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; ref = lfirst_int(sl);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *cl = <a href="../util/tlist.c.html#L422" title="optimizer/util/tlist.c:422">get_sortgroupref_clause</a>(ref, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_groupclause = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(new_groupclause, cl);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> new_groupclause;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extract lists of grouping sets that can be implemented using a single<br/></li>
<li></span><span class="Comment"> * rollup-type aggregate pass each. Returns a list of lists of grouping sets.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Input must be sorted with smallest sets first. Result has each sublist<br/></li>
<li></span><span class="Comment"> * sorted with smallest sets first.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We want to produce the absolute minimum possible number of lists here to<br/></li>
<li></span><span class="Comment"> * avoid excess sorts. Fortunately, there is an algorithm for this; the problem<br/></li>
<li></span><span class="Comment"> * of finding the minimal partition of a partially-ordered set into chains<br/></li>
<li></span><span class="Comment"> * (which is what we need, taking the list of grouping sets as a poset ordered<br/></li>
<li></span><span class="Comment"> * by set inclusion) can be mapped to the problem of finding the maximum<br/></li>
<li></span><span class="Comment"> * cardinality matching on a bipartite graph, which is solvable in polynomial<br/></li>
<li></span><span class="Comment"> * time with a worst case of no worse than O(n^2.5) and usually much<br/></li>
<li></span><span class="Comment"> * better. Since our N is at most 4096, we don't need to consider fallbacks to<br/></li>
<li></span><span class="Comment"> * heuristic or approximate methods.&nbsp; (Planning time for a 12-d cube is under<br/></li>
<li></span><span class="Comment"> * half a second on my modest system even with optimization off and assertions<br/></li>
<li></span><span class="Comment"> * on.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L2868">&#x200c;</a><span class="linkable">extract_rollup_sets</span>(List *groupingSets)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_sets_raw = list_length(groupingSets);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_empty = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_sets = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* distinct sets */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_chains = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp; **results;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp; **orig_sets;<br/></li>
<li>&nbsp; &nbsp; Bitmapset **set_masks;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *chains;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">short</span>&nbsp; &nbsp; &nbsp; **adjacency;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">short</span>&nbsp; &nbsp; &nbsp;&nbsp; *adjacency_buf;<br/></li>
<li>&nbsp; &nbsp; BipartiteMatchState *state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j_size;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc1 = list_head(groupingSets);<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start by stripping out empty sets.&nbsp; The algorithm doesn't require this,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but the <a href="#L274" title="optimizer/plan/planner.c:274">planner</a> currently needs all empty sets to be returned in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first list, so we strip them here and add them back after.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (lc1 &amp;&amp; lfirst(lc1) == NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ++num_empty;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lc1 = lnext(groupingSets, lc1);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* bail out <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> if it turns out that all we had were empty sets. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!lc1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> list_make1(groupingSets);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't strictly need to remove duplicate sets here, but if we don't,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they tend to become scattered through the result, which is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * confusing (and irritating if we ever decide to <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> them out).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * So we remove them here and add them back after.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For each non-duplicate set, we fill in the following:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * orig_sets[i] = list of the original set lists<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set_masks[i] = bitmapset for testing inclusion<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * adjacency[i] = array [n, v1, v2, ... vn] of adjacency indices<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * chains[i] will be the result group this set is assigned to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We index all of these from 1 rather than 0 because it is convenient<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to leave 0 free for the NIL node in the graph algorithm.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; orig_sets = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>((num_sets_raw + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(List *));<br/></li>
<li>&nbsp; &nbsp; set_masks = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>((num_sets_raw + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Bitmapset *));<br/></li>
<li>&nbsp; &nbsp; adjacency = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>((num_sets_raw + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">short</span> *));<br/></li>
<li>&nbsp; &nbsp; adjacency_buf = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>((num_sets_raw + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">short</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; j_size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; j = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; for_each_cell(lc, groupingSets, lc1)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *candidate = (List *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *candidate_set = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dup_of = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, candidate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; candidate_set = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(candidate_set, lfirst_int(lc2));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we can only be a dup if we're the same length as a previous set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j_size == list_length(candidate))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (k = j; k &lt; i; ++k)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(set_masks[k], candidate_set))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dup_of = k;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (j_size &lt; list_length(candidate))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j_size = list_length(candidate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dup_of &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orig_sets[dup_of] = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(orig_sets[dup_of], candidate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(candidate_set);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n_adj = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orig_sets[i] = list_make1(candidate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_masks[i] = candidate_set;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fill in adjacency list; no need to <a href="../geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>-size sets */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (k = j - <span class="Constant">1</span>; k &gt; <span class="Constant">0</span>; --k)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(set_masks[k], candidate_set))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; adjacency_buf[++n_adj] = k;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (n_adj &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; adjacency_buf[<span class="Constant">0</span>] = n_adj;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; adjacency[i] = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>((n_adj + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">short</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(adjacency[i], adjacency_buf, (n_adj + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">short</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; adjacency[i] = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; num_sets = i - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Apply the graph matching algorithm to do the work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state = <a href="../../lib/bipartite_match.c.html#L39" title="lib/bipartite_match.c:39">BipartiteMatch</a>(num_sets, num_sets, adjacency);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now, the state-&gt;pair* fields have the info we need to assign sets to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * chains. Two sets (u,v) belong to the same chain if pair_uv[u] = v or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pair_vu[v] = u (both will be true, but we check both so that we can do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it in one pass)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; chains = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>((num_sets + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= num_sets; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; u = state-&gt;pair_vu[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v = state-&gt;pair_uv[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (u &gt; <span class="Constant">0</span> &amp;&amp; u &lt; i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chains[i] = chains[u];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (v &gt; <span class="Constant">0</span> &amp;&amp; v &lt; i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chains[i] = chains[v];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chains[i] = ++num_chains;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build result lists. */<br/></li>
<li></span>&nbsp; &nbsp; results = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>((num_chains + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(List *));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= num_sets; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c = chains[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(c &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; results[c] = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(results[c], orig_sets[i]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> empty sets back on the first list. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (num_empty-- &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; results[<span class="Constant">1</span>] = <a href="../../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(NIL, results[<span class="Constant">1</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make result list */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= num_chains; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, results[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Free all the things.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (This is over-fussy for small sets but for large sets we could have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tied up a nontrivial amount of memory.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../lib/bipartite_match.c.html#L78" title="lib/bipartite_match.c:78">BipartiteMatchFree</a>(state);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(results);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(chains);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= num_sets; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (adjacency[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(adjacency[i]);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(adjacency);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(adjacency_buf);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(orig_sets);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= num_sets; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(set_masks[i]);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(set_masks);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reorder the elements of a list of grouping sets such that they have correct<br/></li>
<li></span><span class="Comment"> * prefix relationships. Also inserts the GroupingSetData annotations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The input must be ordered with smallest sets first; the result is returned<br/></li>
<li></span><span class="Comment"> * with largest sets first.&nbsp; Note that the result shares no list substructure<br/></li>
<li></span><span class="Comment"> * with the input, so it's safe for the caller to modify it later.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If we're passed in a sortclause, we follow its order of columns to the<br/></li>
<li></span><span class="Comment"> * extent possible, to minimize the chance that we add unnecessary sorts.<br/></li>
<li></span><span class="Comment"> * (We're trying here to ensure that GROUPING SETS ((a,b,c),(c)) ORDER BY c,b,a<br/></li>
<li></span><span class="Comment"> * gets implemented in one pass.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L3080">&#x200c;</a><span class="linkable">reorder_grouping_sets</span>(List *groupingSets, List *sortclause)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *previous = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, groupingSets)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *candidate = (List *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *new_elems = <a href="../../nodes/list.c.html#L1288" title="nodes/list.c:1288">list_difference_int</a>(candidate, previous);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GroupingSetData *gs = makeNode(GroupingSetData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (list_length(sortclause) &gt; list_length(previous) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new_elems != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *sc = list_nth(sortclause, list_length(previous));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ref = sc-&gt;tleSortGroupRef;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/list.c.html#L702" title="nodes/list.c:702">list_member_int</a>(new_elems, ref))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; previous = <a href="../../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(previous, ref);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_elems = <a href="../../nodes/list.c.html#L891" title="nodes/list.c:891">list_delete_int</a>(new_elems, ref);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* diverged from the sortclause; give up on it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortclause = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; previous = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(previous, new_elems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gs-&gt;set = <a href="../../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(previous);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(gs, result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(previous);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3128" title="optimizer/plan/planner.c:3128">has_volatile_pathkey</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns true if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> PathKey in 'keys' has an EquivalenceClass<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; containing a volatile function.&nbsp; Otherwise returns false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3128">&#x200c;</a></span><span class="linkable">has_volatile_pathkey</span>(List *keys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, keys)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *pathkey = lfirst_node(PathKey, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pathkey-&gt;pk_eclass-&gt;ec_has_volatile)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3173" title="optimizer/plan/planner.c:3173">adjust_group_pathkeys_for_groupagg</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Add pathkeys to root-&gt;group_pathkeys to reflect the best set of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; pre-ordered input for ordered aggregates.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We define &quot;best&quot; as the pathkeys that suit the largest number of<br/></li>
<li></span><span class="Comment"> * aggregate <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; We <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> these by looking at the first ORDER BY /<br/></li>
<li></span><span class="Comment"> * DISTINCT aggregate and take the pathkeys for that <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> searching for<br/></li>
<li></span><span class="Comment"> * other aggregates that require the same or a more strict variation of the<br/></li>
<li></span><span class="Comment"> * same pathkeys.&nbsp; We then <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> that process for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining aggregates<br/></li>
<li></span><span class="Comment"> * with different pathkeys and if we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> another set of pathkeys that suits a<br/></li>
<li></span><span class="Comment"> * larger number of aggregates then we <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> those pathkeys instead.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When the best pathkeys are found we also mark each Aggref that can use<br/></li>
<li></span><span class="Comment"> * those pathkeys as aggpresorted = true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: When an aggregate function's ORDER BY / DISTINCT clause contains <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, we never make use of these pathkeys.&nbsp; We want to ensure<br/></li>
<li></span><span class="Comment"> * that sorts using volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are done independently in each Aggref<br/></li>
<li></span><span class="Comment"> * rather than once at the query level.&nbsp; If we were to allow this then Aggrefs<br/></li>
<li></span><span class="Comment"> * with compatible sort orders would all transition their rows in the same<br/></li>
<li></span><span class="Comment"> * order if those pathkeys were deemed to be the best pathkeys to sort on.<br/></li>
<li></span><span class="Comment"> * Whereas, if some other set of Aggref's pathkeys happened to be deemed<br/></li>
<li></span><span class="Comment"> * better pathkeys to sort on, then the volatile function Aggrefs would be<br/></li>
<li></span><span class="Comment"> * left to perform their sorts individually.&nbsp; To avoid this inconsistent<br/></li>
<li></span><span class="Comment"> * behavior which could make Aggref results depend on what other Aggrefs the<br/></li>
<li></span><span class="Comment"> * query contains, we always force Aggrefs with volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to perform<br/></li>
<li></span><span class="Comment"> * their own sorts.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3173">&#x200c;</a></span><span class="linkable">adjust_group_pathkeys_for_groupagg</span>(PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *grouppathkeys = root-&gt;group_pathkeys;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *bestpathkeys;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *bestaggs;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *unprocessed_aggs;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shouldn't be here if there are grouping sets */<br/></li>
<li></span>&nbsp; &nbsp; Assert(root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupingSets == NIL);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shouldn't be here unless there are some ordered aggregates */<br/></li>
<li></span>&nbsp; &nbsp; Assert(root-&gt;numOrderedAggs &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do nothing if disabled */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../path/costsize.c.html#L153" title="optimizer/path/costsize.c:153">enable_presorted_aggregate</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make a first pass over all AggInfos to collect a Bitmapset containing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the indexes of all AggInfos to be processed below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; unprocessed_aggs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, root-&gt;agginfos)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AggInfo&nbsp; &nbsp; *agginfo = lfirst_node(AggInfo, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Aggref&nbsp; &nbsp; &nbsp;&nbsp; *aggref = linitial_node(Aggref, agginfo-&gt;aggrefs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (AGGKIND_IS_ORDERED_SET(aggref-&gt;aggkind))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* only add aggregates with a DISTINCT or ORDER BY */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggref-&gt;aggdistinct != NIL || aggref-&gt;aggorder != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unprocessed_aggs = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(unprocessed_aggs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach_current_index(lc));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now process all the unprocessed_aggs to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the best set of pathkeys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the given set of aggregates.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On the first outer loop here 'bestaggs' will be empty.&nbsp;&nbsp; We'll populate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this during the first loop using the pathkeys for the very first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * AggInfo then taking <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> stronger pathkeys from <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other AggInfos with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a more strict set of compatible pathkeys.&nbsp; Once the outer loop is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * complete, we mark off all the aggregates with compatible pathkeys then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * remove those from the unprocessed_aggs and <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> the process to try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> another set of pathkeys that are suitable for a larger number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggregates.&nbsp; The outer loop will stop when there are not enough<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unprocessed aggregates for it to be possible to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a set of pathkeys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to suit a larger number of aggregates.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bestpathkeys = NIL;<br/></li>
<li>&nbsp; &nbsp; bestaggs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="../../nodes/bitmapset.c.html#L751" title="nodes/bitmapset.c:751">bms_num_members</a>(unprocessed_aggs) &gt; <a href="../../nodes/bitmapset.c.html#L751" title="nodes/bitmapset.c:751">bms_num_members</a>(bestaggs))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *aggindexes = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *currpathkeys = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((i = <a href="../../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(unprocessed_aggs, i)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggInfo&nbsp; &nbsp; *agginfo = list_nth_node(AggInfo, root-&gt;agginfos, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Aggref&nbsp; &nbsp; &nbsp;&nbsp; *aggref = linitial_node(Aggref, agginfo-&gt;aggrefs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sortlist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggref-&gt;aggdistinct != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortlist = aggref-&gt;aggdistinct;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortlist = aggref-&gt;aggorder;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkeys = <a href="../path/pathkeys.c.html#L1347" title="optimizer/path/pathkeys.c:1347">make_pathkeys_for_sortclauses</a>(root, sortlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggref-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore Aggrefs which have volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in their ORDER BY<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or DISTINCT clause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3128" title="optimizer/plan/planner.c:3128">has_volatile_pathkey</a>(pathkeys))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unprocessed_aggs = <a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(unprocessed_aggs, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When not set yet, take the pathkeys from the first unprocessed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aggregate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (currpathkeys == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currpathkeys = pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* include the GROUP BY pathkeys, if they exist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (grouppathkeys != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currpathkeys = <a href="../path/pathkeys.c.html#L106" title="optimizer/path/pathkeys.c:106">append_pathkeys</a>(<a href="../../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(grouppathkeys),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; currpathkeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* record that we found pathkeys for this aggregate */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggindexes = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(aggindexes, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> look for a stronger set of matching pathkeys */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* include the GROUP BY pathkeys, if they exist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (grouppathkeys != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkeys = <a href="../path/pathkeys.c.html#L106" title="optimizer/path/pathkeys.c:106">append_pathkeys</a>(<a href="../../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(grouppathkeys),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pathkeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* are 'pathkeys' compatible or better than 'currpathkeys'? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="../path/pathkeys.c.html#L302" title="optimizer/path/pathkeys.c:302">compare_pathkeys</a>(currpathkeys, pathkeys))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PATHKEYS_BETTER2:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* 'pathkeys' are stronger, use these ones instead */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currpathkeys = pathkeys;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALLTHROUGH */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PATHKEYS_BETTER1:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* 'pathkeys' are less strict */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALLTHROUGH */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PATHKEYS_EQUAL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mark this aggregate as covered by 'currpathkeys' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggindexes = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(aggindexes, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PATHKEYS_DIFFERENT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remove the aggregates that we've just processed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; unprocessed_aggs = <a href="../../nodes/bitmapset.c.html#L1161" title="nodes/bitmapset.c:1161">bms_del_members</a>(unprocessed_aggs, aggindexes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this pass included more aggregates than the previous best then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * use these ones as the best set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L751" title="nodes/bitmapset.c:751">bms_num_members</a>(aggindexes) &gt; <a href="../../nodes/bitmapset.c.html#L751" title="nodes/bitmapset.c:751">bms_num_members</a>(bestaggs))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bestaggs = aggindexes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bestpathkeys = currpathkeys;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we found <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> ordered aggregates, update root-&gt;group_pathkeys to add<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the best set of aggregate pathkeys.&nbsp; Note that bestpathkeys includes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the original GROUP BY pathkeys already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bestpathkeys != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;group_pathkeys = bestpathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we've found the best set of aggregates we can set the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * presorted flag to indicate to the executor that it needn't bother<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * performing a sort for these Aggrefs.&nbsp; We're able to do this <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there's no chance of a Hash Aggregate plan as <a href="#L3658" title="optimizer/plan/planner.c:3658">create_grouping_paths</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will not mark the GROUP BY as GROUPING_CAN_USE_HASH due to the presence<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of ordered aggregates.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; i = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((i = <a href="../../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(bestaggs, i)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AggInfo&nbsp; &nbsp; *agginfo = list_nth_node(AggInfo, root-&gt;agginfos, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, agginfo-&gt;aggrefs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Aggref&nbsp; &nbsp; &nbsp;&nbsp; *aggref = lfirst_node(Aggref, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggref-&gt;aggpresorted = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute query_pathkeys and other pathkeys during plan generation<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3354">&#x200c;</a></span><span class="linkable">standard_qp_callback</span>(PlannerInfo *root, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L125" title="optimizer/plan/planner.c:125">standard_qp_extra</a> *qp_extra = (<a href="#L125" title="optimizer/plan/planner.c:125">standard_qp_extra</a> *) extra;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist = root-&gt;processed_tlist;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *activeWindows = qp_extra-&gt;activeWindows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate pathkeys that represent grouping/ordering and/or ordered<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggregate requirements.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (qp_extra-&gt;gset_data)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * With grouping sets, just use the first RollupData's groupClause. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't make <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> effort to <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> grouping clauses when there are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * grouping sets, nor can we <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> aggregate ordering keys with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * grouping.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *rollups = qp_extra-&gt;gset_data-&gt;rollups;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *groupClause = (rollups ? linitial_node(RollupData, rollups)-&gt;groupClause : NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/tlist.c.html#L540" title="optimizer/util/tlist.c:540">grouping_is_sortable</a>(groupClause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;group_pathkeys = <a href="../path/pathkeys.c.html#L1347" title="optimizer/path/pathkeys.c:1347">make_pathkeys_for_sortclauses</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; groupClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;num_groupby_pathkeys = list_length(root-&gt;group_pathkeys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;group_pathkeys = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;num_groupby_pathkeys = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause || root-&gt;numOrderedAggs &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * With a plain GROUP BY list, we can remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> grouping items that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are proven redundant by EquivalenceClass processing.&nbsp; For example,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we can remove y given &quot;WHERE x = y GROUP BY x, y&quot;.&nbsp; These aren't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * especially common cases, but they're nearly free to detect.&nbsp; Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that we remove redundant items from processed_groupClause but not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the original <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sortable;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;group_pathkeys =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/pathkeys.c.html#L1384" title="optimizer/path/pathkeys.c:1384">make_pathkeys_for_sortclauses_extended</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;root-&gt;processed_groupClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;sortable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!sortable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can't sort; no point in considering aggregate ordering either */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;group_pathkeys = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;num_groupby_pathkeys = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;num_groupby_pathkeys = list_length(root-&gt;group_pathkeys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we have ordered aggs, consider adding onto group_pathkeys */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;numOrderedAggs &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3173" title="optimizer/plan/planner.c:3173">adjust_group_pathkeys_for_groupagg</a>(root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;group_pathkeys = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;num_groupby_pathkeys = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We consider only the first (bottom) window in pathkeys logic */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (activeWindows != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WindowClause *wc = linitial_node(WindowClause, activeWindows);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;window_pathkeys = <a href="#L6001" title="optimizer/plan/planner.c:6001">make_pathkeys_for_window</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tlist);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;window_pathkeys = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As with GROUP BY, we can discard <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> DISTINCT items that are proven<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * redundant by EquivalenceClass processing.&nbsp; The non-redundant list is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * kept in root-&gt;processed_distinctClause, leaving the original<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;distinctClause alone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;distinctClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sortable;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make a copy since pathkey processing can modify the list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;processed_distinctClause = <a href="../../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;distinctClause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;distinct_pathkeys =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/pathkeys.c.html#L1384" title="optimizer/path/pathkeys.c:1384">make_pathkeys_for_sortclauses_extended</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;root-&gt;processed_distinctClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;sortable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!sortable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;distinct_pathkeys = NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;distinct_pathkeys = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; root-&gt;sort_pathkeys =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/pathkeys.c.html#L1347" title="optimizer/path/pathkeys.c:1347">make_pathkeys_for_sortclauses</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;sortClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* setting setop_pathkeys might be useful to the union <a href="#L274" title="optimizer/plan/planner.c:274">planner</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (qp_extra-&gt;setop != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../prep/prepunion.c.html#L188" title="optimizer/prep/prepunion.c:188">set_operation_ordered_results_useful</a>(qp_extra-&gt;setop))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *groupClauses;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sortable;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; groupClauses = <a href="#L7939" title="optimizer/plan/planner.c:7939">generate_setop_child_grouplist</a>(qp_extra-&gt;setop, tlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;setop_pathkeys =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/pathkeys.c.html#L1384" title="optimizer/path/pathkeys.c:1384">make_pathkeys_for_sortclauses_extended</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;groupClauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;sortable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!sortable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;setop_pathkeys = NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;setop_pathkeys = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Figure out whether we want a sorted result from <a href="planmain.c.html#L54" title="optimizer/plan/planmain.c:54">query_planner</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have a sortable GROUP BY clause, then we want a result sorted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * properly for grouping.&nbsp; Otherwise, if we have window <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * evaluate, we try to sort for the first window.&nbsp; Otherwise, if there's a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sortable DISTINCT clause that's more rigorous than the ORDER BY clause,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we try to produce output that's sufficiently well sorted for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * DISTINCT.&nbsp; Otherwise, if there is an ORDER BY clause, we want to sort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by the ORDER BY clause.&nbsp; Otherwise, if we're a subquery being planned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for a set operation which can benefit from presorted results and have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sortable targetlist, we want to sort by the target list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: if we have both ORDER BY and GROUP BY, and ORDER BY is a superset<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of GROUP BY, it would be tempting to request sort by ORDER BY --- but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that might just leave us failing to exploit an available sort order at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all.&nbsp; Needs more thought.&nbsp; The choice for DISTINCT versus ORDER BY is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * much easier, since we know that the parser ensured that one is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * superset of the other.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;group_pathkeys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;query_pathkeys = root-&gt;group_pathkeys;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (root-&gt;window_pathkeys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;query_pathkeys = root-&gt;window_pathkeys;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (list_length(root-&gt;distinct_pathkeys) &gt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_length(root-&gt;sort_pathkeys))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;query_pathkeys = root-&gt;distinct_pathkeys;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (root-&gt;sort_pathkeys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;query_pathkeys = root-&gt;sort_pathkeys;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (root-&gt;setop_pathkeys != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;query_pathkeys = root-&gt;setop_pathkeys;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;query_pathkeys = NIL;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Estimate number of groups produced by grouping clauses (1 if not grouping)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * path_rows: number of output rows from scan/join step<br/></li>
<li></span><span class="Comment"> * gd: grouping sets data including list of grouping sets and their clauses<br/></li>
<li></span><span class="Comment"> * target_list: target list containing group clause references<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If doing grouping sets, we also annotate the gsets data with the estimates<br/></li>
<li></span><span class="Comment"> * for each set and each individual rollup list, with a view to later<br/></li>
<li></span><span class="Comment"> * determining whether some combination of them could be hashed instead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L3536">&#x200c;</a></span><span class="linkable">get_number_of_groups</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> path_rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L105" title="optimizer/plan/planner.c:105">grouping_sets_data</a> *gd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *target_list)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; dNumGroups;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *groupExprs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupingSets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add up the estimates for each grouping set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(gd);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep Coverity happy */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dNumGroups = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, gd-&gt;rollups)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RollupData *rollup = lfirst_node(RollupData, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc3;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; groupExprs = <a href="../util/tlist.c.html#L392" title="optimizer/util/tlist.c:392">get_sortgrouplist_exprs</a>(rollup-&gt;groupClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; target_list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;numGroups = <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; forboth(lc2, rollup-&gt;gsets, lc3, rollup-&gt;gsets_data)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *gset = (List *) lfirst(lc2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GroupingSetData *gs = lfirst_node(GroupingSetData, lc3);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; numGroups = <a href="../../utils/adt/selfuncs.c.html#L3416" title="utils/adt/selfuncs.c:3416">estimate_num_groups</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; groupExprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path_rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;gset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gs-&gt;numGroups = numGroups;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;numGroups += numGroups;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dNumGroups += rollup-&gt;numGroups;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (gd-&gt;hash_sets_idx)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gd-&gt;dNumHashGroups = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; groupExprs = <a href="../util/tlist.c.html#L392" title="optimizer/util/tlist.c:392">get_sortgrouplist_exprs</a>(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; target_list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; forboth(lc, gd-&gt;hash_sets_idx, lc2, gd-&gt;unsortable_sets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *gset = (List *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GroupingSetData *gs = lfirst_node(GroupingSetData, lc2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; numGroups = <a href="../../utils/adt/selfuncs.c.html#L3416" title="utils/adt/selfuncs.c:3416">estimate_num_groups</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; groupExprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path_rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;gset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gs-&gt;numGroups = numGroups;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gd-&gt;dNumHashGroups += numGroups;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dNumGroups += gd-&gt;dNumHashGroups;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Plain GROUP BY -- estimate based on optimized groupClause */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; groupExprs = <a href="../util/tlist.c.html#L392" title="optimizer/util/tlist.c:392">get_sortgrouplist_exprs</a>(root-&gt;processed_groupClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; target_list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dNumGroups = <a href="../../utils/adt/selfuncs.c.html#L3416" title="utils/adt/selfuncs.c:3416">estimate_num_groups</a>(root, groupExprs, path_rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupingSets)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Empty grouping sets ... one result row for each one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dNumGroups = list_length(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupingSets);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasAggs || root-&gt;hasHavingQual)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Plain aggregation, one result row */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dNumGroups = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not grouping */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dNumGroups = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> dNumGroups;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3658" title="optimizer/plan/planner.c:3658">create_grouping_paths</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Build a new upperrel containing Paths for grouping and/or aggregation.<br/></li>
<li></span><span class="Comment"> * Along the way, we also build an upperrel for Paths which are partially<br/></li>
<li></span><span class="Comment"> * grouped and/or aggregated.&nbsp; A partially grouped and/or aggregated path<br/></li>
<li></span><span class="Comment"> * needs a FinalizeAggregate node to complete the aggregation.&nbsp; Currently,<br/></li>
<li></span><span class="Comment"> * the only partially grouped paths we build are also partial paths; that<br/></li>
<li></span><span class="Comment"> * is, they need a Gather and then a FinalizeAggregate.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * input_rel: contains the source-data Paths<br/></li>
<li></span><span class="Comment"> * target: the pathtarget for the result Paths to compute<br/></li>
<li></span><span class="Comment"> * gd: grouping sets data including list of grouping sets and their clauses<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: all Paths in input_rel are expected to return the target computed<br/></li>
<li></span><span class="Comment"> * by <a href="#L5321" title="optimizer/plan/planner.c:5321">make_group_input_target</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> RelOptInfo *<br/></li>
<li><a id="L3658">&#x200c;</a><span class="linkable">create_grouping_paths</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathTarget *target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> target_parallel_safe,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L105" title="optimizer/plan/planner.c:105">grouping_sets_data</a> *gd)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *grouped_rel;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *partially_grouped_rel;<br/></li>
<li>&nbsp; &nbsp; AggClauseCosts agg_costs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemSet(&amp;agg_costs, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AggClauseCosts));<br/></li>
<li>&nbsp; &nbsp; <a href="../prep/prepagg.c.html#L560" title="optimizer/prep/prepagg.c:560">get_agg_clause_costs</a>(root, AGGSPLIT_SIMPLE, &amp;agg_costs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create grouping relation to hold fully aggregated grouping and/or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggregation paths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; grouped_rel = <a href="#L3771" title="optimizer/plan/planner.c:3771">make_grouping_rel</a>(root, input_rel, target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target_parallel_safe, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;havingQual);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create either paths for a degenerate grouping or paths for ordinary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * grouping, as appropriate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3824" title="optimizer/plan/planner.c:3824">is_degenerate_grouping</a>(root))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3845" title="optimizer/plan/planner.c:3845">create_degenerate_grouping_paths</a>(root, input_rel, grouped_rel);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GroupPathExtraData extra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Determine whether it's possible to perform sort-based<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * implementations of grouping.&nbsp; (Note that if processed_groupClause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is empty, <a href="../util/tlist.c.html#L540" title="optimizer/util/tlist.c:540">grouping_is_sortable</a>() is trivially true, and all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../path/pathkeys.c.html#L341" title="optimizer/path/pathkeys.c:341">pathkeys_contained_in</a>() tests will succeed too, so that we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consider every surviving input path.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have grouping sets, we might be able to sort some but not all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of them; in this case, we need can_sort to be true as long as we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must consider <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> sorted-input plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((gd &amp;&amp; gd-&gt;rollups != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || <a href="../util/tlist.c.html#L540" title="optimizer/util/tlist.c:540">grouping_is_sortable</a>(root-&gt;processed_groupClause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= GROUPING_CAN_USE_SORT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Determine whether we should consider <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>-based implementations of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * grouping.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Hashed aggregation only applies if we're grouping. If we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * grouping sets, some groups might be hashable but others not; in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this case we set can_hash true as long as there is nothing globally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * preventing us from hashing (and we should therefore consider plans<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with hashes).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Executor doesn't support hashed aggregation with DISTINCT or ORDER<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * BY aggregates.&nbsp; (Doing so would imply storing *all* the input<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table, and/or running many sorts in parallel,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * either of which seems like a certain loser.)&nbsp; We similarly don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * support ordered-set aggregates in hashed aggregation, but that case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is also included in the numOrderedAggs count.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: <a href="../util/tlist.c.html#L560" title="optimizer/util/tlist.c:560">grouping_is_hashable</a>() is much more expensive to check than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the other gating conditions, so we want to do it last.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause != NIL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;numOrderedAggs == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (gd ? gd-&gt;any_hashable : <a href="../util/tlist.c.html#L560" title="optimizer/util/tlist.c:560">grouping_is_hashable</a>(root-&gt;processed_groupClause))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= GROUPING_CAN_USE_HASH;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Determine whether partial aggregation is possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L7461" title="optimizer/plan/planner.c:7461">can_partial_agg</a>(root))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= GROUPING_CAN_PARTIAL_AGG;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; extra.flags = flags;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; extra.target_parallel_safe = target_parallel_safe;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; extra.havingQual = <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;havingQual;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; extra.targetList = <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;targetList;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; extra.partial_costs_set = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Determine whether partitionwise aggregation is in theory possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It can be disabled by the user, and for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we don't try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * support grouping sets.&nbsp; <a href="#L3909" title="optimizer/plan/planner.c:3909">create_ordinary_grouping_paths</a>() will check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * additional conditions, such as whether input_rel is partitioned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../path/costsize.c.html#L149" title="optimizer/path/costsize.c:149">enable_partitionwise_aggregate</a> &amp;&amp; !<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupingSets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra.patype = PARTITIONWISE_AGGREGATE_FULL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra.patype = PARTITIONWISE_AGGREGATE_NONE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3909" title="optimizer/plan/planner.c:3909">create_ordinary_grouping_paths</a>(root, input_rel, grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;agg_costs, gd, &amp;extra,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;partially_grouped_rel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../util/pathnode.c.html#L242" title="optimizer/util/pathnode.c:242">set_cheapest</a>(grouped_rel);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> grouped_rel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3771" title="optimizer/plan/planner.c:3771">make_grouping_rel</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Create a new grouping rel and set basic properties.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * input_rel represents the underlying scan/join relation.<br/></li>
<li></span><span class="Comment"> * target is the output expected from the grouping relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> RelOptInfo *<br/></li>
<li><a id="L3771">&#x200c;</a><span class="linkable">make_grouping_rel</span>(PlannerInfo *root, RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathTarget *target, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> target_parallel_safe,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *havingQual)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *grouped_rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IS_OTHER_REL(input_rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; grouped_rel = <a href="../util/relnode.c.html#L1470" title="optimizer/util/relnode.c:1470">fetch_upper_rel</a>(root, UPPERREL_GROUP_AGG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_rel-&gt;relids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; grouped_rel-&gt;reloptkind = RELOPT_OTHER_UPPER_REL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * By tradition, the relids set for the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> grouping relation is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NULL.&nbsp; (This could be changed, but might require adjustments<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * elsewhere.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; grouped_rel = <a href="../util/relnode.c.html#L1470" title="optimizer/util/relnode.c:1470">fetch_upper_rel</a>(root, UPPERREL_GROUP_AGG, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set target. */<br/></li>
<li></span>&nbsp; &nbsp; grouped_rel-&gt;reltarget = target;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the input relation is not parallel-safe, then the grouped relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't be parallel-safe, either.&nbsp; Otherwise, it's parallel-safe if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * target list and HAVING quals are parallel-safe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (input_rel-&gt;consider_parallel &amp;&amp; target_parallel_safe &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/clauses.c.html#L753" title="optimizer/util/clauses.c:753">is_parallel_safe</a>(root, (Node *) havingQual))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; grouped_rel-&gt;consider_parallel = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the input rel belongs to a single FDW, so does the grouped rel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; grouped_rel-&gt;serverid = input_rel-&gt;serverid;<br/></li>
<li>&nbsp; &nbsp; grouped_rel-&gt;userid = input_rel-&gt;userid;<br/></li>
<li>&nbsp; &nbsp; grouped_rel-&gt;useridiscurrent = input_rel-&gt;useridiscurrent;<br/></li>
<li>&nbsp; &nbsp; grouped_rel-&gt;fdwroutine = input_rel-&gt;fdwroutine;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> grouped_rel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3824" title="optimizer/plan/planner.c:3824">is_degenerate_grouping</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A degenerate grouping is one in which the query has a HAVING qual and/or<br/></li>
<li></span><span class="Comment"> * grouping sets, but no aggregates and no GROUP BY (which implies that the<br/></li>
<li></span><span class="Comment"> * grouping sets are all empty).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3824">&#x200c;</a></span><span class="linkable">is_degenerate_grouping</span>(PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (root-&gt;hasHavingQual || <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupingSets) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasAggs &amp;&amp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause == NIL;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3845" title="optimizer/plan/planner.c:3845">create_degenerate_grouping_paths</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When the grouping is degenerate (see <a href="#L3824" title="optimizer/plan/planner.c:3824">is_degenerate_grouping</a>), we are<br/></li>
<li></span><span class="Comment"> * supposed to emit either zero or one row for each grouping set depending on<br/></li>
<li></span><span class="Comment"> * whether HAVING succeeds.&nbsp; Furthermore, there cannot be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> variables in<br/></li>
<li></span><span class="Comment"> * either HAVING or the targetlist, so we actually do not need the FROM table<br/></li>
<li></span><span class="Comment"> * at all! We can just throw away the plan-so-far and generate a Result node.<br/></li>
<li></span><span class="Comment"> * This is a sufficiently unusual corner case that it's not worth contorting<br/></li>
<li></span><span class="Comment"> * the structure of this module to avoid having to generate the earlier paths<br/></li>
<li></span><span class="Comment"> * in the first place.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3845">&#x200c;</a></span><span class="linkable">create_degenerate_grouping_paths</span>(PlannerInfo *root, RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *grouped_rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrows;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nrows = list_length(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupingSets);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nrows &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Doesn't seem worthwhile writing code to cons up a generate_series<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or a <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> scan to emit multiple rows. Instead just make N clones<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and append them.&nbsp; (With a volatile HAVING clause, this means you<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might get between 0 and N output rows. Offhand I think that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * desired.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *paths = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (--nrows &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path = (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L1518" title="optimizer/util/pathnode.c:1518">create_group_result_path</a>(root, grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; grouped_rel-&gt;reltarget,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (List *) <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;havingQual);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paths = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(paths, path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path = (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L1244" title="optimizer/util/pathnode.c:1244">create_append_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; paths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No grouping sets, or just one, so one output row */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; path = (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L1518" title="optimizer/util/pathnode.c:1518">create_group_result_path</a>(root, grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; grouped_rel-&gt;reltarget,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (List *) <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;havingQual);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(grouped_rel, path);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3909" title="optimizer/plan/planner.c:3909">create_ordinary_grouping_paths</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Create grouping paths for the ordinary (that is, non-degenerate) case.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We need to consider sorted and hashed aggregation in the same function,<br/></li>
<li></span><span class="Comment"> * because otherwise (1) it would be harder to throw an appropriate error<br/></li>
<li></span><span class="Comment"> * message if neither way works, and (2) we should not allow hashtable size<br/></li>
<li></span><span class="Comment"> * considerations to dissuade us from using hashing if sorting is not possible.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *partially_grouped_rel_p will be set to the partially grouped rel which this<br/></li>
<li></span><span class="Comment"> * function creates, or to NULL if it doesn't create one.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3909">&#x200c;</a></span><span class="linkable">create_ordinary_grouping_paths</span>(PlannerInfo *root, RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> AggClauseCosts *agg_costs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L105" title="optimizer/plan/planner.c:105">grouping_sets_data</a> *gd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GroupPathExtraData *extra,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo **partially_grouped_rel_p)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *cheapest_path = input_rel-&gt;cheapest_total_path;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *partially_grouped_rel = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; dNumGroups;<br/></li>
<li>&nbsp; &nbsp; PartitionwiseAggregateType patype = PARTITIONWISE_AGGREGATE_NONE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is the topmost grouping relation or if the parent relation is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doing some form of partitionwise aggregation, then we may be able to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it at this level also.&nbsp; However, if the input relation is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partitioned, partitionwise aggregate is impossible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (extra-&gt;patype != PARTITIONWISE_AGGREGATE_NONE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IS_PARTITIONED_REL(input_rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is the topmost relation or if the parent relation is doing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * full partitionwise aggregation, then we can do full partitionwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aggregation provided that the GROUP BY clause contains all of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partitioning columns at this level.&nbsp; Otherwise, we can do at most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partial partitionwise aggregation.&nbsp; But if partial aggregation is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not supported in general then we can't use it for partitionwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aggregation either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause not processed_groupClause, because it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * okay if some of the partitioning columns were proved redundant.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (extra-&gt;patype == PARTITIONWISE_AGGREGATE_FULL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7882" title="optimizer/plan/planner.c:7882">group_by_has_partkey</a>(input_rel, extra-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; patype = PARTITIONWISE_AGGREGATE_FULL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((extra-&gt;flags &amp; GROUPING_CAN_PARTIAL_AGG) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; patype = PARTITIONWISE_AGGREGATE_PARTIAL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; patype = PARTITIONWISE_AGGREGATE_NONE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Before generating paths for grouped_rel, we first generate <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partially grouped paths; that way, later code can easily consider both<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parallel and non-parallel approaches to grouping.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((extra-&gt;flags &amp; GROUPING_CAN_PARTIAL_AGG) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; force_rel_creation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're doing partitionwise aggregation at this level, force<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * creation of a partially_grouped_rel so we can add partitionwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * paths to it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; force_rel_creation = (patype == PARTITIONWISE_AGGREGATE_PARTIAL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partially_grouped_rel =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7077" title="optimizer/plan/planner.c:7077">create_partial_grouping_paths</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; force_rel_creation);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set out parameter. */<br/></li>
<li></span>&nbsp; &nbsp; *partially_grouped_rel_p = partially_grouped_rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Apply partitionwise aggregation technique, if possible. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (patype != PARTITIONWISE_AGGREGATE_NONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7738" title="optimizer/plan/planner.c:7738">create_partitionwise_grouping_paths</a>(root, input_rel, grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partially_grouped_rel, agg_costs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gd, patype, extra);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we are doing partial aggregation only, return. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (extra-&gt;patype == PARTITIONWISE_AGGREGATE_PARTIAL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(partially_grouped_rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (partially_grouped_rel-&gt;pathlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L242" title="optimizer/util/pathnode.c:242">set_cheapest</a>(partially_grouped_rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Gather <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> partially grouped partial paths. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (partially_grouped_rel &amp;&amp; partially_grouped_rel-&gt;partial_pathlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7376" title="optimizer/plan/planner.c:7376">gather_grouping_paths</a>(root, partially_grouped_rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L242" title="optimizer/util/pathnode.c:242">set_cheapest</a>(partially_grouped_rel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate number of groups.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dNumGroups = <a href="#L3536" title="optimizer/plan/planner.c:3536">get_number_of_groups</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cheapest_path-&gt;rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra-&gt;targetList);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build final grouping paths */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L6842" title="optimizer/plan/planner.c:6842">add_paths_to_grouping_rel</a>(root, input_rel, grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partially_grouped_rel, agg_costs, gd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dNumGroups, extra);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Give a helpful error if we failed to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> implementation */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (grouped_rel-&gt;pathlist == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not implement GROUP BY&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Some of the datatypes only support hashing, while others only support sorting.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is an FDW that's responsible for all baserels of the query,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * let it consider adding ForeignPaths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (grouped_rel-&gt;fdwroutine &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; grouped_rel-&gt;fdwroutine-&gt;GetForeignUpperPaths)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; grouped_rel-&gt;fdwroutine-&gt;GetForeignUpperPaths(root, UPPERREL_GROUP_AGG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_rel, grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Let extensions possibly add some more paths */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L74" title="optimizer/plan/planner.c:74">create_upper_paths_hook</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*<a href="#L74" title="optimizer/plan/planner.c:74">create_upper_paths_hook</a>) (root, UPPERREL_GROUP_AGG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_rel, grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * For a given input path, consider the possible ways of doing grouping sets on<br/></li>
<li></span><span class="Comment"> * it, by combinations of hashing and sorting.&nbsp; This can be called multiple<br/></li>
<li></span><span class="Comment"> * times, so it's important that it not scribble on input.&nbsp; No result is<br/></li>
<li></span><span class="Comment"> * returned, but <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> generated paths are added to grouped_rel.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4048">&#x200c;</a></span><span class="linkable">consider_groupingsets_paths</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path *path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_sorted,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> can_hash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L105" title="optimizer/plan/planner.c:105">grouping_sets_data</a> *gd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> AggClauseCosts *agg_costs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> dNumGroups)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; hash_mem_limit = <a href="../../executor/nodeHash.c.html#L3595" title="executor/nodeHash.c:3595">get_hash_memory_limit</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're not being offered sorted input, then only consider plans that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can be done entirely by hashing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> everything if it looks like it'll fit in hash_mem. But if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the input is actually sorted despite not being advertised as such, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prefer to make use of that in order to use less memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="../util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of the grouping sets are sortable, then ignore the hash_mem<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * limit and generate a path anyway, since otherwise we'll just fail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!is_sorted)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *new_rollups = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RollupData *unhashed_rollup = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sets_data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *empty_sets_data = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *empty_sets = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l_start = list_head(gd-&gt;rollups);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AggStrategy strat = AGG_HASHED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; hashsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; exclude_groups = <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(can_hash);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the input is coincidentally sorted usefully (which can happen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * even if is_sorted is false, since that only means that our caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * has set up the sorting for us), then save some hashtable space by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * making use of that. But we need to watch out for degenerate cases:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 1) If there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> empty grouping sets, then group_pathkeys might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be NIL if all non-empty grouping sets are unsortable. In this case,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there will be a rollup containing only empty groups, and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../path/pathkeys.c.html#L341" title="optimizer/path/pathkeys.c:341">pathkeys_contained_in</a> test is vacuously true; this is ok.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: the above relies on the fact that group_pathkeys is generated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from the first rollup. If we add the ability to consider multiple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sort orders for grouping input, this assumption might fail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 2) If there are no empty sets and only unsortable sets, then the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rollups list will be empty (and thus l_start == NULL), and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * group_pathkeys will be NIL; we must ensure that the vacuously-true<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../path/pathkeys.c.html#L341" title="optimizer/path/pathkeys.c:341">pathkeys_contained_in</a> test doesn't cause us to crash.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (l_start != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/pathkeys.c.html#L341" title="optimizer/path/pathkeys.c:341">pathkeys_contained_in</a>(root-&gt;group_pathkeys, path-&gt;pathkeys))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unhashed_rollup = lfirst_node(RollupData, l_start);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exclude_groups = unhashed_rollup-&gt;numGroups;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l_start = lnext(gd-&gt;rollups, l_start);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashsize = <a href="../../utils/adt/selfuncs.c.html#L3917" title="utils/adt/selfuncs.c:3917">estimate_hashagg_tablesize</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; agg_costs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dNumGroups - exclude_groups);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * gd-&gt;rollups is empty if we have only unsortable columns to work<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with.&nbsp; Override hash_mem in that case; otherwise, we'll rely on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sorted-input case to generate usable mixed paths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hashsize &gt; hash_mem_limit &amp;&amp; gd-&gt;rollups)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nope, won't fit */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need to burst the existing rollups list into individual grouping<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sets and recompute a groupClause for each set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sets_data = <a href="../../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(gd-&gt;unsortable_sets);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; for_each_cell(lc, gd-&gt;rollups, l_start)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RollupData *rollup = lfirst_node(RollupData, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an unhashable rollup that's not been skipped by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;actually sorted&quot; check above, we can't cope; we'd need sorted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * input (with a different sort order) but we can't get that here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * So bail out; we'll get a valid path from the is_sorted case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The mere presence of empty grouping sets doesn't make a rollup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unhashable (see <a href="#L2047" title="optimizer/plan/planner.c:2047">preprocess_grouping_sets</a>), we handle those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * specially below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rollup-&gt;hashable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sets_data = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(sets_data, rollup-&gt;gsets_data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, sets_data)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GroupingSetData *gs = lfirst_node(GroupingSetData, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *gset = gs-&gt;set;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RollupData *rollup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (gset == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Empty grouping sets can't be hashed. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; empty_sets_data = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(empty_sets_data, gs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; empty_sets = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(empty_sets, NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup = makeNode(RollupData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;groupClause = <a href="#L2832" title="optimizer/plan/planner.c:2832">groupclause_apply_groupingset</a>(root, gset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;gsets_data = list_make1(gs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;gsets = <a href="#L2228" title="optimizer/plan/planner.c:2228">remap_to_groupclause_idx</a>(rollup-&gt;groupClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rollup-&gt;gsets_data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gd-&gt;tleref_to_colnum_map);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;numGroups = gs-&gt;numGroups;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;hashable = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;is_hashed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_rollups = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(new_rollups, rollup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> anything nonempty to <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>, then bail.&nbsp; We'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * generate a path from the is_sorted case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (new_rollups == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there were empty grouping sets they should have been in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first rollup.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!unhashed_rollup || !empty_sets);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unhashed_rollup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_rollups = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(new_rollups, unhashed_rollup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strat = AGG_MIXED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (empty_sets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RollupData *rollup = makeNode(RollupData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;groupClause = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;gsets_data = empty_sets_data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;gsets = empty_sets;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;numGroups = list_length(empty_sets);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;hashable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;is_hashed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_rollups = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(new_rollups, rollup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strat = AGG_MIXED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(grouped_rel, (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/pathnode.c.html#L3237" title="optimizer/util/pathnode.c:3237">create_groupingsets_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (List *) <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;havingQual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strat,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_rollups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; agg_costs));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have sorted input but nothing we can do with it, bail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (gd-&gt;rollups == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Given sorted input, we try and make two paths: one sorted and one mixed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sort/<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>. (We need to try both because hashagg might be disabled, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some columns might not be sortable.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can_hash is passed in as false if some obstacle elsewhere (such as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ordered aggs) means that we shouldn't consider hashing at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (can_hash &amp;&amp; gd-&gt;any_hashable)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *rollups = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *hash_sets = <a href="../../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(gd-&gt;unsortable_sets);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; availspace = hash_mem_limit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Account first for space needed for groups we can't sort at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; availspace -= <a href="../../utils/adt/selfuncs.c.html#L3917" title="utils/adt/selfuncs.c:3917">estimate_hashagg_tablesize</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; agg_costs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gd-&gt;dNumHashGroups);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (availspace &gt; <span class="Constant">0</span> &amp;&amp; list_length(gd-&gt;rollups) &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; scale;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_rollups = list_length(gd-&gt;rollups);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k_capacity;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *k_weights = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(num_rollups * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *hash_items = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We treat this as a knapsack problem: the knapsack capacity<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * represents hash_mem, the item <a href="../../utils/adt/tsrank.c.html#L24" title="utils/adt/tsrank.c:24">weights</a> are the estimated memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * usage of the hashtables needed to implement a single rollup,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and we really ought to use the cost saving as the item value;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * however, currently the costs assigned to sort nodes don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reflect the comparison costs well, and so we treat all items as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> value (each rollup we <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> instead saves us one sort).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To use the discrete knapsack, we need to scale the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reasonably small bounded <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.&nbsp; We choose to allow a 5% error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * margin; we have no more than 4096 rollups in the worst possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case, which with a 5% error margin will require a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> over 42MB<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of workspace. (Anyone wanting to plan queries that complex had<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * better have the memory for it.&nbsp; In more reasonable cases, with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no more than a couple of dozen rollups, the memory usage will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be negligible.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * k_capacity is naturally bounded, but we clamp the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scale and weight (below) to avoid overflows or underflows (or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * uselessly trying to use a scale factor less than 1 byte).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scale = Max(availspace / (<span class="Constant">20.0</span> * num_rollups), <span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k_capacity = (<span class="Type">int</span>) floor(availspace / scale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We leave the first rollup out of consideration since it's the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one that matches the input sort order.&nbsp; We assign indexes &quot;i&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to only those entries considered for hashing; the second loop,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * below, must use the same condition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for_each_from(lc, gd-&gt;rollups, <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RollupData *rollup = lfirst_node(RollupData, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rollup-&gt;hashable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; sz = <a href="../../utils/adt/selfuncs.c.html#L3917" title="utils/adt/selfuncs.c:3917">estimate_hashagg_tablesize</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; agg_costs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;numGroups);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If sz is enormous, but hash_mem (and hence scale) is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * small, avoid integer overflow here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k_weights[i] = (<span class="Type">int</span>) <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(floor(sz / scale),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; k_capacity + <span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Apply knapsack algorithm; compute the set of items which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * maximizes the value stored (in this case the number of sorts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * saved) while keeping the total size (approximately) within<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * capacity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash_items = <a href="../../lib/knapsack.c.html#L52" title="lib/knapsack.c:52">DiscreteKnapsack</a>(k_capacity, i, k_weights, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!bms_is_empty(hash_items))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollups = list_make1(linitial(gd-&gt;rollups));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for_each_from(lc, gd-&gt;rollups, <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RollupData *rollup = lfirst_node(RollupData, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rollup-&gt;hashable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(i, hash_items))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash_sets = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(hash_sets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;gsets_data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollups = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rollups, rollup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollups = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rollups, rollup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rollups &amp;&amp; hash_sets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollups = <a href="../../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(gd-&gt;rollups);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, hash_sets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GroupingSetData *gs = lfirst_node(GroupingSetData, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RollupData *rollup = makeNode(RollupData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(gs-&gt;set != NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;groupClause = <a href="#L2832" title="optimizer/plan/planner.c:2832">groupclause_apply_groupingset</a>(root, gs-&gt;set);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;gsets_data = list_make1(gs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;gsets = <a href="#L2228" title="optimizer/plan/planner.c:2228">remap_to_groupclause_idx</a>(rollup-&gt;groupClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rollup-&gt;gsets_data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gd-&gt;tleref_to_colnum_map);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;numGroups = gs-&gt;numGroups;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;hashable = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollup-&gt;is_hashed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollups = <a href="../../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(rollup, rollups);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rollups)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(grouped_rel, (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/pathnode.c.html#L3237" title="optimizer/util/pathnode.c:3237">create_groupingsets_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (List *) <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;havingQual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AGG_MIXED,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; agg_costs));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now try the simple sorted case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!gd-&gt;unsortable_sets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(grouped_rel, (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/pathnode.c.html#L3237" title="optimizer/util/pathnode.c:3237">create_groupingsets_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (List *) <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;havingQual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AGG_SORTED,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gd-&gt;rollups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; agg_costs));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4410" title="optimizer/plan/planner.c:4410">create_window_paths</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Build a new upperrel containing Paths for window-function evaluation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * input_rel: contains the source-data Paths<br/></li>
<li></span><span class="Comment"> * input_target: result of <a href="#L5881" title="optimizer/plan/planner.c:5881">make_window_input_target</a><br/></li>
<li></span><span class="Comment"> * output_target: what the topmost WindowAggPath should return<br/></li>
<li></span><span class="Comment"> * wflists: result of <a href="../util/clauses.c.html#L227" title="optimizer/util/clauses.c:227">find_window_functions</a><br/></li>
<li></span><span class="Comment"> * activeWindows: result of <a href="#L5724" title="optimizer/plan/planner.c:5724">select_active_windows</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: all Paths in input_rel are expected to return input_target.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> RelOptInfo *<br/></li>
<li><a id="L4410">&#x200c;</a><span class="linkable">create_window_paths</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathTarget *input_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathTarget *output_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> output_target_parallel_safe,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WindowFuncLists *wflists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *activeWindows)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *window_rel;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, do all work in the (WINDOW, NULL) upperrel */<br/></li>
<li></span>&nbsp; &nbsp; window_rel = <a href="../util/relnode.c.html#L1470" title="optimizer/util/relnode.c:1470">fetch_upper_rel</a>(root, UPPERREL_WINDOW, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the input relation is not parallel-safe, then the window relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't be parallel-safe, either.&nbsp; Otherwise, we need to examine the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * target list and active windows for non-parallel-safe constructs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (input_rel-&gt;consider_parallel &amp;&amp; output_target_parallel_safe &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/clauses.c.html#L753" title="optimizer/util/clauses.c:753">is_parallel_safe</a>(root, (Node *) activeWindows))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; window_rel-&gt;consider_parallel = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the input rel belongs to a single FDW, so does the window rel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; window_rel-&gt;serverid = input_rel-&gt;serverid;<br/></li>
<li>&nbsp; &nbsp; window_rel-&gt;userid = input_rel-&gt;userid;<br/></li>
<li>&nbsp; &nbsp; window_rel-&gt;useridiscurrent = input_rel-&gt;useridiscurrent;<br/></li>
<li>&nbsp; &nbsp; window_rel-&gt;fdwroutine = input_rel-&gt;fdwroutine;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Consider computing window <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> starting from the existing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cheapest-total path (which will likely require a sort) as well as <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * existing paths that satisfy or partially satisfy root-&gt;window_pathkeys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, input_rel-&gt;pathlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path = (Path *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; presorted_keys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path == input_rel-&gt;cheapest_total_path ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/pathkeys.c.html#L573" title="optimizer/path/pathkeys.c:573">pathkeys_count_contained_in</a>(root-&gt;window_pathkeys, path-&gt;pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;presorted_keys) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; presorted_keys &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4497" title="optimizer/plan/planner.c:4497">create_one_window_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; window_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; input_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; output_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wflists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; activeWindows);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is an FDW that's responsible for all baserels of the query,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * let it consider adding ForeignPaths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (window_rel-&gt;fdwroutine &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; window_rel-&gt;fdwroutine-&gt;GetForeignUpperPaths)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; window_rel-&gt;fdwroutine-&gt;GetForeignUpperPaths(root, UPPERREL_WINDOW,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; input_rel, window_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Let extensions possibly add some more paths */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L74" title="optimizer/plan/planner.c:74">create_upper_paths_hook</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*<a href="#L74" title="optimizer/plan/planner.c:74">create_upper_paths_hook</a>) (root, UPPERREL_WINDOW,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_rel, window_rel, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now choose the best path(s) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/pathnode.c.html#L242" title="optimizer/util/pathnode.c:242">set_cheapest</a>(window_rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> window_rel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Stack window-function implementation steps atop the given Path, and<br/></li>
<li></span><span class="Comment"> * add the result to window_rel.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * window_rel: upperrel to contain result<br/></li>
<li></span><span class="Comment"> * path: input Path to use (must return input_target)<br/></li>
<li></span><span class="Comment"> * input_target: result of <a href="#L5881" title="optimizer/plan/planner.c:5881">make_window_input_target</a><br/></li>
<li></span><span class="Comment"> * output_target: what the topmost WindowAggPath should return<br/></li>
<li></span><span class="Comment"> * wflists: result of <a href="../util/clauses.c.html#L227" title="optimizer/util/clauses.c:227">find_window_functions</a><br/></li>
<li></span><span class="Comment"> * activeWindows: result of <a href="#L5724" title="optimizer/plan/planner.c:5724">select_active_windows</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4497">&#x200c;</a></span><span class="linkable">create_one_window_path</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *window_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Path *path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PathTarget *input_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PathTarget *output_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WindowFuncLists *wflists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *activeWindows)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PathTarget *window_target;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *topqual = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since each window clause could require a different sort order, we stack<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up a WindowAgg node for each clause, with sort steps between them as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needed.&nbsp; (We assume that <a href="#L5724" title="optimizer/plan/planner.c:5724">select_active_windows</a> chose a good order for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * executing the clauses in.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * input_target should contain all Vars and Aggs needed for the result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (In some cases we wouldn't need to propagate all of these all the way<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the top, since they might only be needed as inputs to WindowFuncs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's probably not worth trying to <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> that though.)&nbsp; It must also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contain all window partitioning and sorting expressions, to ensure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they're computed only once at the bottom of the stack (that's critical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>).&nbsp; As we climb up the stack, we'll add outputs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the WindowFuncs computed at each level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; window_target = input_target;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, activeWindows)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WindowClause *wc = lfirst_node(WindowClause, l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *window_pathkeys;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; presorted_keys;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_sorted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; topwindow;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; window_pathkeys = <a href="#L6001" title="optimizer/plan/planner.c:6001">make_pathkeys_for_window</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;processed_tlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; is_sorted = <a href="../path/pathkeys.c.html#L573" title="optimizer/path/pathkeys.c:573">pathkeys_count_contained_in</a>(window_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path-&gt;pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;presorted_keys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sort if necessary */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!is_sorted)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No presorted keys or incremental sort disabled, just perform a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * complete sort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (presorted_keys == <span class="Constant">0</span> || !<a href="../path/costsize.c.html#L140" title="optimizer/path/costsize.c:140">enable_incremental_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path = (Path *) <a href="../util/pathnode.c.html#L3000" title="optimizer/util/pathnode.c:3000">create_sort_path</a>(root, window_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; window_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -<span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since we have presorted keys and incremental sort is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * enabled, just use incremental sort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path = (Path *) <a href="../util/pathnode.c.html#L2951" title="optimizer/util/pathnode.c:2951">create_incremental_sort_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; window_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; window_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; presorted_keys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -<span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lnext(activeWindows, l))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add the current WindowFuncs to the output target for this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * intermediate WindowAggPath.&nbsp; We must copy window_target to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * avoid changing the previous path's target.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: a WindowFunc adds nothing to the target's eval costs; but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we do need to account for the increase in tlist width.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; tuple_width = window_target-&gt;width;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; window_target = <a href="../util/tlist.c.html#L657" title="optimizer/util/tlist.c:657">copy_pathtarget</a>(window_target);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, wflists-&gt;windowFuncs[wc-&gt;winref])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WindowFunc *wfunc = lfirst_node(WindowFunc, lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/tlist.c.html#L695" title="optimizer/util/tlist.c:695">add_column_to_pathtarget</a>(window_target, (Expr *) wfunc, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_width += <a href="../../utils/cache/lsyscache.c.html#L2578" title="utils/cache/lsyscache.c:2578">get_typavgwidth</a>(wfunc-&gt;wintype, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; window_target-&gt;width = <a href="../path/costsize.c.html#L231" title="optimizer/path/costsize.c:231">clamp_width_est</a>(tuple_width);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Install the goal target in the topmost WindowAgg */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; window_target = output_target;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mark the final item in the list as the top-level window */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; topwindow = foreach_current_index(l) == list_length(activeWindows) - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Accumulate all of the runConditions from each intermediate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WindowClause.&nbsp; The top-level WindowAgg must pass these as a qual so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that it filters out unwanted tuples correctly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!topwindow)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; topqual = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(topqual, wc-&gt;runCondition);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path = (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L3484" title="optimizer/util/pathnode.c:3484">create_windowagg_path</a>(root, window_rel, path, window_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wflists-&gt;windowFuncs[wc-&gt;winref],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wc, topwindow ? topqual : NIL, topwindow);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(window_rel, path);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4630" title="optimizer/plan/planner.c:4630">create_distinct_paths</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Build a new upperrel containing Paths for SELECT DISTINCT evaluation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * input_rel: contains the source-data Paths<br/></li>
<li></span><span class="Comment"> * target: the pathtarget for the result Paths to compute<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: input paths should already compute the desired pathtarget, since<br/></li>
<li></span><span class="Comment"> * Sort/Unique won't project anything.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> RelOptInfo *<br/></li>
<li><a id="L4630">&#x200c;</a><span class="linkable">create_distinct_paths</span>(PlannerInfo *root, RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathTarget *target)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *distinct_rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, do all work in the (DISTINCT, NULL) upperrel */<br/></li>
<li></span>&nbsp; &nbsp; distinct_rel = <a href="../util/relnode.c.html#L1470" title="optimizer/util/relnode.c:1470">fetch_upper_rel</a>(root, UPPERREL_DISTINCT, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't compute anything at this level, so distinct_rel will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parallel-safe if the input rel is parallel-safe.&nbsp; In particular, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there is a DISTINCT ON (...) clause, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> path for the input_rel will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * output those expressions, and will not be parallel-safe unless those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expressions are parallel-safe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; distinct_rel-&gt;consider_parallel = input_rel-&gt;consider_parallel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the input rel belongs to a single FDW, so does the distinct_rel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; distinct_rel-&gt;serverid = input_rel-&gt;serverid;<br/></li>
<li>&nbsp; &nbsp; distinct_rel-&gt;userid = input_rel-&gt;userid;<br/></li>
<li>&nbsp; &nbsp; distinct_rel-&gt;useridiscurrent = input_rel-&gt;useridiscurrent;<br/></li>
<li>&nbsp; &nbsp; distinct_rel-&gt;fdwroutine = input_rel-&gt;fdwroutine;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build distinct paths based on input_rel's pathlist */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4899" title="optimizer/plan/planner.c:4899">create_final_distinct_paths</a>(root, input_rel, distinct_rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> build distinct paths based on input_rel's partial_pathlist */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4700" title="optimizer/plan/planner.c:4700">create_partial_distinct_paths</a>(root, input_rel, distinct_rel, target);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Give a helpful error if we failed to create <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> paths */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (distinct_rel-&gt;pathlist == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not implement DISTINCT&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Some of the datatypes only support hashing, while others only support sorting.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is an FDW that's responsible for all baserels of the query,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * let it consider adding ForeignPaths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (distinct_rel-&gt;fdwroutine &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; distinct_rel-&gt;fdwroutine-&gt;GetForeignUpperPaths)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; distinct_rel-&gt;fdwroutine-&gt;GetForeignUpperPaths(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; UPPERREL_DISTINCT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; distinct_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Let extensions possibly add some more paths */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L74" title="optimizer/plan/planner.c:74">create_upper_paths_hook</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*<a href="#L74" title="optimizer/plan/planner.c:74">create_upper_paths_hook</a>) (root, UPPERREL_DISTINCT, input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; distinct_rel, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now choose the best path(s) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/pathnode.c.html#L242" title="optimizer/util/pathnode.c:242">set_cheapest</a>(distinct_rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> distinct_rel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4700" title="optimizer/plan/planner.c:4700">create_partial_distinct_paths</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Process 'input_rel' partial paths and add unique/aggregate paths to the<br/></li>
<li></span><span class="Comment"> * UPPERREL_PARTIAL_DISTINCT rel.&nbsp; For paths created, add Gather/GatherMerge<br/></li>
<li></span><span class="Comment"> * paths on top and add a final unique/aggregate path to remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> duplicate<br/></li>
<li></span><span class="Comment"> * produced from combining rows from parallel workers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4700">&#x200c;</a></span><span class="linkable">create_partial_distinct_paths</span>(PlannerInfo *root, RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *final_distinct_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathTarget *target)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *partial_distinct_rel;<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *distinctExprs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; numDistinctRows;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *cheapest_partial_path;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* nothing to do when there are no partial paths in the input rel */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!input_rel-&gt;consider_parallel || input_rel-&gt;partial_pathlist == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* can't do parallel DISTINCT ON */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasDistinctOn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; partial_distinct_rel = <a href="../util/relnode.c.html#L1470" title="optimizer/util/relnode.c:1470">fetch_upper_rel</a>(root, UPPERREL_PARTIAL_DISTINCT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; partial_distinct_rel-&gt;reltarget = target;<br/></li>
<li>&nbsp; &nbsp; partial_distinct_rel-&gt;consider_parallel = input_rel-&gt;consider_parallel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If input_rel belongs to a single FDW, so does the partial_distinct_rel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; partial_distinct_rel-&gt;serverid = input_rel-&gt;serverid;<br/></li>
<li>&nbsp; &nbsp; partial_distinct_rel-&gt;userid = input_rel-&gt;userid;<br/></li>
<li>&nbsp; &nbsp; partial_distinct_rel-&gt;useridiscurrent = input_rel-&gt;useridiscurrent;<br/></li>
<li>&nbsp; &nbsp; partial_distinct_rel-&gt;fdwroutine = input_rel-&gt;fdwroutine;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cheapest_partial_path = linitial(input_rel-&gt;partial_pathlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; distinctExprs = <a href="../util/tlist.c.html#L392" title="optimizer/util/tlist.c:392">get_sortgrouplist_exprs</a>(root-&gt;processed_distinctClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;targetList);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* estimate how many distinct rows we'll get from each worker */<br/></li>
<li></span>&nbsp; &nbsp; numDistinctRows = <a href="../../utils/adt/selfuncs.c.html#L3416" title="utils/adt/selfuncs.c:3416">estimate_num_groups</a>(root, distinctExprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cheapest_partial_path-&gt;rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try sorting the cheapest path and incrementally sorting <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> paths with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * presorted keys and put a unique paths atop of those.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/tlist.c.html#L540" title="optimizer/util/tlist.c:540">grouping_is_sortable</a>(root-&gt;processed_distinctClause))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, input_rel-&gt;partial_pathlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *input_path = (Path *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *sorted_path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_sorted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; presorted_keys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_sorted = <a href="../path/pathkeys.c.html#L573" title="optimizer/path/pathkeys.c:573">pathkeys_count_contained_in</a>(root-&gt;distinct_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_path-&gt;pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;presorted_keys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_sorted)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sorted_path = input_path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try at least sorting the cheapest path and also try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * incrementally sorting <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> path which is partially sorted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already (no need to deal with paths which have presorted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keys when incremental sort is disabled unless it's the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cheapest partial path).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (input_path != cheapest_partial_path &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (presorted_keys == <span class="Constant">0</span> || !<a href="../path/costsize.c.html#L140" title="optimizer/path/costsize.c:140">enable_incremental_sort</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We've no need to consider both a sort and incremental sort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We'll just do a sort if there are no presorted keys and an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * incremental sort when there are presorted keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (presorted_keys == <span class="Constant">0</span> || !<a href="../path/costsize.c.html#L140" title="optimizer/path/costsize.c:140">enable_incremental_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sorted_path = (Path *) <a href="../util/pathnode.c.html#L3000" title="optimizer/util/pathnode.c:3000">create_sort_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partial_distinct_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;distinct_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sorted_path = (Path *) <a href="../util/pathnode.c.html#L2951" title="optimizer/util/pathnode.c:2951">create_incremental_sort_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partial_distinct_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;distinct_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; presorted_keys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * An empty distinct_pathkeys means all tuples have the same value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for the DISTINCT clause.&nbsp; See <a href="#L4899" title="optimizer/plan/planner.c:4899">create_final_distinct_paths</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;distinct_pathkeys == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *limitCount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; limitCount = (Node *) <a href="../../nodes/makefuncs.c.html#L301" title="nodes/makefuncs.c:301">makeConst</a>(INT8OID, -<span class="Constant">1</span>, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(<span class="Constant">1</span>), <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FLOAT8PASSBYVAL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Apply a LimitPath onto the partial path to restrict the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples from each worker to 1.&nbsp; <a href="#L4899" title="optimizer/plan/planner.c:4899">create_final_distinct_paths</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will need to apply an additional LimitPath to restrict this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to a single row after the Gather node.&nbsp; If the query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already has a LIMIT clause, then we could end up with three<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Limit nodes in the final plan.&nbsp; Consolidating the top two<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of these could be done, but does not seem worth troubling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * over.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L747" title="optimizer/util/pathnode.c:747">add_partial_path</a>(partial_distinct_rel, (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/pathnode.c.html#L3823" title="optimizer/util/pathnode.c:3823">create_limit_path</a>(root, partial_distinct_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sorted_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; limitCount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LIMIT_OPTION_COUNT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>, <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L747" title="optimizer/util/pathnode.c:747">add_partial_path</a>(partial_distinct_rel, (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/pathnode.c.html#L3103" title="optimizer/util/pathnode.c:3103">create_upper_unique_path</a>(root, partial_distinct_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sorted_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(root-&gt;distinct_pathkeys),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numDistinctRows));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now try <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> aggregate paths, if enabled and hashing is possible. Since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're not on the hook to ensure we do our best to create at least one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * path here, we treat <a href="../path/costsize.c.html#L141" title="optimizer/path/costsize.c:141">enable_hashagg</a> as a hard off-switch rather than the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slightly softer variant in <a href="#L4899" title="optimizer/plan/planner.c:4899">create_final_distinct_paths</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../path/costsize.c.html#L141" title="optimizer/path/costsize.c:141">enable_hashagg</a> &amp;&amp; <a href="../util/tlist.c.html#L560" title="optimizer/util/tlist.c:560">grouping_is_hashable</a>(root-&gt;processed_distinctClause))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L747" title="optimizer/util/pathnode.c:747">add_partial_path</a>(partial_distinct_rel, (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/pathnode.c.html#L3155" title="optimizer/util/pathnode.c:3155">create_agg_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; partial_distinct_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cheapest_partial_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cheapest_partial_path-&gt;pathtarget,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AGG_HASHED,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AGGSPLIT_SIMPLE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;processed_distinctClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numDistinctRows));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is an FDW that's responsible for all baserels of the query,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * let it consider adding ForeignPaths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (partial_distinct_rel-&gt;fdwroutine &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partial_distinct_rel-&gt;fdwroutine-&gt;GetForeignUpperPaths)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partial_distinct_rel-&gt;fdwroutine-&gt;GetForeignUpperPaths(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; UPPERREL_PARTIAL_DISTINCT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; partial_distinct_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Let extensions possibly add some more partial paths */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L74" title="optimizer/plan/planner.c:74">create_upper_paths_hook</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*<a href="#L74" title="optimizer/plan/planner.c:74">create_upper_paths_hook</a>) (root, UPPERREL_PARTIAL_DISTINCT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_rel, partial_distinct_rel, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (partial_distinct_rel-&gt;partial_pathlist != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/allpaths.c.html#L3202" title="optimizer/path/allpaths.c:3202">generate_useful_gather_paths</a>(root, partial_distinct_rel, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L242" title="optimizer/util/pathnode.c:242">set_cheapest</a>(partial_distinct_rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Finally, create paths to distinctify the final result.&nbsp; This step<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is needed to remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> duplicates due to combining rows from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parallel workers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4899" title="optimizer/plan/planner.c:4899">create_final_distinct_paths</a>(root, partial_distinct_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final_distinct_rel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4899" title="optimizer/plan/planner.c:4899">create_final_distinct_paths</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Create distinct paths in 'distinct_rel' based on 'input_rel' pathlist<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * input_rel: contains the source-data paths<br/></li>
<li></span><span class="Comment"> * distinct_rel: destination relation for storing created paths<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> RelOptInfo *<br/></li>
<li><a id="L4899">&#x200c;</a><span class="linkable">create_final_distinct_paths</span>(PlannerInfo *root, RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *distinct_rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *cheapest_input_path = input_rel-&gt;cheapest_total_path;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; numDistinctRows;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; allow_hash;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Estimate number of distinct rows there will be */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause || <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupingSets || <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasAggs ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;hasHavingQual)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there was grouping or aggregation, use the number of input rows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as the estimated number of DISTINCT rows (ie, assume the input is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already mostly unique).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; numDistinctRows = cheapest_input_path-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, the UNIQUE filter has effects comparable to GROUP BY.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *distinctExprs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; distinctExprs = <a href="../util/tlist.c.html#L392" title="optimizer/util/tlist.c:392">get_sortgrouplist_exprs</a>(root-&gt;processed_distinctClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;targetList);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numDistinctRows = <a href="../../utils/adt/selfuncs.c.html#L3416" title="utils/adt/selfuncs.c:3416">estimate_num_groups</a>(root, distinctExprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cheapest_input_path-&gt;rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Consider sort-based implementations of DISTINCT, if possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/tlist.c.html#L540" title="optimizer/util/tlist.c:540">grouping_is_sortable</a>(root-&gt;processed_distinctClause))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Firstly, if we have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> adequately-presorted paths, just stick a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Unique node on those.&nbsp; We also, consider doing an explicit sort of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the cheapest input path and Unique'ing that.&nbsp; If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> paths have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * presorted keys then we'll create an incremental sort atop of those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> adding a unique node on the top.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When we have DISTINCT ON, we must sort by the more rigorous of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * DISTINCT and ORDER BY, else it won't have the desired behavior.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also, if we do have to do an explicit sort, we might as well use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the more rigorous ordering to avoid a second sort later.&nbsp; (Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that the parser will have ensured that one clause is a prefix of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the other.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *needed_pathkeys;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; limittuples = root-&gt;distinct_pathkeys == NIL ? <span class="Constant">1.0</span> : -<span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasDistinctOn &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(root-&gt;distinct_pathkeys) &lt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(root-&gt;sort_pathkeys))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needed_pathkeys = root-&gt;sort_pathkeys;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needed_pathkeys = root-&gt;distinct_pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, input_rel-&gt;pathlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *input_path = (Path *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *sorted_path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_sorted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; presorted_keys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_sorted = <a href="../path/pathkeys.c.html#L573" title="optimizer/path/pathkeys.c:573">pathkeys_count_contained_in</a>(needed_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_path-&gt;pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;presorted_keys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_sorted)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sorted_path = input_path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try at least sorting the cheapest path and also try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * incrementally sorting <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> path which is partially sorted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already (no need to deal with paths which have presorted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keys when incremental sort is disabled unless it's the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cheapest input path).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (input_path != cheapest_input_path &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (presorted_keys == <span class="Constant">0</span> || !<a href="../path/costsize.c.html#L140" title="optimizer/path/costsize.c:140">enable_incremental_sort</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We've no need to consider both a sort and incremental sort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We'll just do a sort if there are no presorted keys and an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * incremental sort when there are presorted keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (presorted_keys == <span class="Constant">0</span> || !<a href="../path/costsize.c.html#L140" title="optimizer/path/costsize.c:140">enable_incremental_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sorted_path = (Path *) <a href="../util/pathnode.c.html#L3000" title="optimizer/util/pathnode.c:3000">create_sort_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; distinct_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needed_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; limittuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sorted_path = (Path *) <a href="../util/pathnode.c.html#L2951" title="optimizer/util/pathnode.c:2951">create_incremental_sort_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; distinct_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needed_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; presorted_keys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; limittuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * distinct_pathkeys may have become empty if all of the pathkeys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * were determined to be redundant.&nbsp; If all of the pathkeys are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * redundant then each DISTINCT target must only allow a single<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * value, therefore all resulting tuples must be identical (or at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * least indistinguishable by an equality check).&nbsp; We can uniquify<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * these tuples simply by just taking the first tuple.&nbsp; All we do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here is add a path to do &quot;LIMIT 1&quot; atop of 'sorted_path'.&nbsp; When<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doing a DISTINCT ON we may still have a non-NIL sort_pathkeys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list, so we must still only do this with paths which are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * correctly sorted by sort_pathkeys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;distinct_pathkeys == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *limitCount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; limitCount = (Node *) <a href="../../nodes/makefuncs.c.html#L301" title="nodes/makefuncs.c:301">makeConst</a>(INT8OID, -<span class="Constant">1</span>, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(<span class="Constant">1</span>), <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FLOAT8PASSBYVAL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the query already has a LIMIT clause, then we could end<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * up with a duplicate LimitPath in the final plan. That does<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not seem worth troubling over too much.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(distinct_rel, (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/pathnode.c.html#L3823" title="optimizer/util/pathnode.c:3823">create_limit_path</a>(root, distinct_rel, sorted_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, limitCount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LIMIT_OPTION_COUNT, <span class="Constant">0</span>, <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(distinct_rel, (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/pathnode.c.html#L3103" title="optimizer/util/pathnode.c:3103">create_upper_unique_path</a>(root, distinct_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sorted_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(root-&gt;distinct_pathkeys),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numDistinctRows));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Consider <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>-based implementations of DISTINCT, if possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we were not able to make <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other types of path, we *must* <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> trying.&nbsp; If we do have other choices, there are two things that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should prevent selection of hashing: if the query uses DISTINCT ON<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (because it won't really have the expected behavior if we <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>), or if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../path/costsize.c.html#L141" title="optimizer/path/costsize.c:141">enable_hashagg</a> is off.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: <a href="../util/tlist.c.html#L560" title="optimizer/util/tlist.c:560">grouping_is_hashable</a>() is much more expensive to check than the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other gating conditions, so we want to do it last.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (distinct_rel-&gt;pathlist == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; allow_hash = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we have no alternatives */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasDistinctOn || !<a href="../path/costsize.c.html#L141" title="optimizer/path/costsize.c:141">enable_hashagg</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; allow_hash = <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* policy-based decision not to <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; allow_hash = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* default */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (allow_hash &amp;&amp; <a href="../util/tlist.c.html#L560" title="optimizer/util/tlist.c:560">grouping_is_hashable</a>(root-&gt;processed_distinctClause))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Generate hashed aggregate path --- no sort needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(distinct_rel, (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/pathnode.c.html#L3155" title="optimizer/util/pathnode.c:3155">create_agg_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; distinct_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cheapest_input_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cheapest_input_path-&gt;pathtarget,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AGG_HASHED,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AGGSPLIT_SIMPLE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;processed_distinctClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numDistinctRows));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> distinct_rel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5106" title="optimizer/plan/planner.c:5106">create_ordered_paths</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Build a new upperrel containing Paths for ORDER BY evaluation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All paths in the result must satisfy the ORDER BY ordering.<br/></li>
<li></span><span class="Comment"> * The only new paths we need consider are an explicit full sort<br/></li>
<li></span><span class="Comment"> * and incremental sort on the cheapest-total existing path.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * input_rel: contains the source-data Paths<br/></li>
<li></span><span class="Comment"> * target: the output tlist the result Paths must emit<br/></li>
<li></span><span class="Comment"> * limit_tuples: estimated bound on the number of output tuples,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; or -1 if no LIMIT or couldn't estimate<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> This only looks at sort_pathkeys. I wonder if it needs to look at the<br/></li>
<li></span><span class="Comment"> * other pathkeys (grouping, ...) like <a href="../path/allpaths.c.html#L3202" title="optimizer/path/allpaths.c:3202">generate_useful_gather_paths</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> RelOptInfo *<br/></li>
<li><a id="L5106">&#x200c;</a><span class="linkable">create_ordered_paths</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PathTarget *target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> target_parallel_safe,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> limit_tuples)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *cheapest_input_path = input_rel-&gt;cheapest_total_path;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *ordered_rel;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, do all work in the (ORDERED, NULL) upperrel */<br/></li>
<li></span>&nbsp; &nbsp; ordered_rel = <a href="../util/relnode.c.html#L1470" title="optimizer/util/relnode.c:1470">fetch_upper_rel</a>(root, UPPERREL_ORDERED, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the input relation is not parallel-safe, then the ordered relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't be parallel-safe, either.&nbsp; Otherwise, it's parallel-safe if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * target list is parallel-safe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (input_rel-&gt;consider_parallel &amp;&amp; target_parallel_safe)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ordered_rel-&gt;consider_parallel = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the input rel belongs to a single FDW, so does the ordered_rel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ordered_rel-&gt;serverid = input_rel-&gt;serverid;<br/></li>
<li>&nbsp; &nbsp; ordered_rel-&gt;userid = input_rel-&gt;userid;<br/></li>
<li>&nbsp; &nbsp; ordered_rel-&gt;useridiscurrent = input_rel-&gt;useridiscurrent;<br/></li>
<li>&nbsp; &nbsp; ordered_rel-&gt;fdwroutine = input_rel-&gt;fdwroutine;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, input_rel-&gt;pathlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *input_path = (Path *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *sorted_path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_sorted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; presorted_keys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; is_sorted = <a href="../path/pathkeys.c.html#L573" title="optimizer/path/pathkeys.c:573">pathkeys_count_contained_in</a>(root-&gt;sort_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_path-&gt;pathkeys, &amp;presorted_keys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_sorted)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sorted_path = input_path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try at least sorting the cheapest path and also try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * incrementally sorting <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> path which is partially sorted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already (no need to deal with paths which have presorted keys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when incremental sort is disabled unless it's the cheapest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * input path).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (input_path != cheapest_input_path &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (presorted_keys == <span class="Constant">0</span> || !<a href="../path/costsize.c.html#L140" title="optimizer/path/costsize.c:140">enable_incremental_sort</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We've no need to consider both a sort and incremental sort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We'll just do a sort if there are no presorted keys and an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * incremental sort when there are presorted keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (presorted_keys == <span class="Constant">0</span> || !<a href="../path/costsize.c.html#L140" title="optimizer/path/costsize.c:140">enable_incremental_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sorted_path = (Path *) <a href="../util/pathnode.c.html#L3000" title="optimizer/util/pathnode.c:3000">create_sort_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ordered_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;sort_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; limit_tuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sorted_path = (Path *) <a href="../util/pathnode.c.html#L2951" title="optimizer/util/pathnode.c:2951">create_incremental_sort_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ordered_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;sort_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; presorted_keys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; limit_tuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add projection step if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sorted_path-&gt;pathtarget != target)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sorted_path = <a href="../util/pathnode.c.html#L2793" title="optimizer/util/pathnode.c:2793">apply_projection_to_path</a>(root, ordered_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sorted_path, target);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(ordered_rel, sorted_path);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../path/allpaths.c.html#L3064" title="optimizer/path/allpaths.c:3064">generate_gather_paths</a>() will have already generated a simple Gather<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * path for the best parallel path, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, and the loop above will have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * considered sorting it.&nbsp; Similarly, <a href="../path/allpaths.c.html#L3064" title="optimizer/path/allpaths.c:3064">generate_gather_paths</a>() will also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have generated order-preserving Gather Merge plans which can be used<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * without sorting if they happen to match the sort_pathkeys, and the loop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * above will have handled those as well.&nbsp; However, there's one more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possibility: it may make sense to sort the cheapest partial path or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * incrementally sort <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> partial path that is partially sorted according<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the required output order and then use Gather Merge.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ordered_rel-&gt;consider_parallel &amp;&amp; root-&gt;sort_pathkeys != NIL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; input_rel-&gt;partial_pathlist != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *cheapest_partial_path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cheapest_partial_path = linitial(input_rel-&gt;partial_pathlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, input_rel-&gt;partial_pathlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *input_path = (Path *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *sorted_path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_sorted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; presorted_keys;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; total_groups;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_sorted = <a href="../path/pathkeys.c.html#L573" title="optimizer/path/pathkeys.c:573">pathkeys_count_contained_in</a>(root-&gt;sort_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_path-&gt;pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;presorted_keys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_sorted)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try at least sorting the cheapest path and also try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * incrementally sorting <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> path which is partially sorted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already (no need to deal with paths which have presorted keys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when incremental sort is disabled unless it's the cheapest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partial path).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (input_path != cheapest_partial_path &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (presorted_keys == <span class="Constant">0</span> || !<a href="../path/costsize.c.html#L140" title="optimizer/path/costsize.c:140">enable_incremental_sort</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We've no need to consider both a sort and incremental sort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We'll just do a sort if there are no presorted keys and an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * incremental sort when there are presorted keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (presorted_keys == <span class="Constant">0</span> || !<a href="../path/costsize.c.html#L140" title="optimizer/path/costsize.c:140">enable_incremental_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sorted_path = (Path *) <a href="../util/pathnode.c.html#L3000" title="optimizer/util/pathnode.c:3000">create_sort_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ordered_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;sort_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; limit_tuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sorted_path = (Path *) <a href="../util/pathnode.c.html#L2951" title="optimizer/util/pathnode.c:2951">create_incremental_sort_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ordered_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;sort_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; presorted_keys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; limit_tuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_groups = input_path-&gt;rows *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_path-&gt;parallel_workers;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sorted_path = (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L1881" title="optimizer/util/pathnode.c:1881">create_gather_merge_path</a>(root, ordered_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sorted_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sorted_path-&gt;pathtarget,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;sort_pathkeys, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;total_groups);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add projection step if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sorted_path-&gt;pathtarget != target)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sorted_path = <a href="../util/pathnode.c.html#L2793" title="optimizer/util/pathnode.c:2793">apply_projection_to_path</a>(root, ordered_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sorted_path, target);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(ordered_rel, sorted_path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is an FDW that's responsible for all baserels of the query,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * let it consider adding ForeignPaths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ordered_rel-&gt;fdwroutine &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ordered_rel-&gt;fdwroutine-&gt;GetForeignUpperPaths)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ordered_rel-&gt;fdwroutine-&gt;GetForeignUpperPaths(root, UPPERREL_ORDERED,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_rel, ordered_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Let extensions possibly add some more paths */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L74" title="optimizer/plan/planner.c:74">create_upper_paths_hook</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*<a href="#L74" title="optimizer/plan/planner.c:74">create_upper_paths_hook</a>) (root, UPPERREL_ORDERED,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_rel, ordered_rel, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No need to bother with <a href="../util/pathnode.c.html#L242" title="optimizer/util/pathnode.c:242">set_cheapest</a> here; <a href="#L1305" title="optimizer/plan/planner.c:1305">grouping_planner</a> does not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need us to do it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ordered_rel-&gt;pathlist != NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ordered_rel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5321" title="optimizer/plan/planner.c:5321">make_group_input_target</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Generate appropriate PathTarget for initial input to grouping nodes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If there is grouping or aggregation, the scan/join subplan cannot emit<br/></li>
<li></span><span class="Comment"> * the query's final targetlist; for example, it certainly can't emit <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * aggregate function calls.&nbsp; This routine generates the correct target<br/></li>
<li></span><span class="Comment"> * for the scan/join subplan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The query target list passed from the parser already contains entries<br/></li>
<li></span><span class="Comment"> * for all ORDER BY and GROUP BY expressions, but it will not have entries<br/></li>
<li></span><span class="Comment"> * for variables used only in HAVING clauses; so we need to add those<br/></li>
<li></span><span class="Comment"> * variables to the subplan target list.&nbsp; Also, we flatten all expressions<br/></li>
<li></span><span class="Comment"> * except GROUP BY items into their component variables; other expressions<br/></li>
<li></span><span class="Comment"> * will be computed by the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> plan nodes rather than by the subplan.<br/></li>
<li></span><span class="Comment"> * For example, given a query like<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; SELECT a+b,SUM(c+d) FROM table GROUP BY a+b;<br/></li>
<li></span><span class="Comment"> * we want to pass this targetlist to the subplan:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; a+b,c,d<br/></li>
<li></span><span class="Comment"> * where the a+b target will be used by the Sort/Group steps, and the<br/></li>
<li></span><span class="Comment"> * other targets will be used for computing the final results.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'final_target' is the query's final target list (in PathTarget form)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is the PathTarget to be computed by the Paths returned from<br/></li>
<li></span><span class="Comment"> * <a href="planmain.c.html#L54" title="optimizer/plan/planmain.c:54">query_planner</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> PathTarget *<br/></li>
<li><a id="L5321">&#x200c;</a><span class="linkable">make_group_input_target</span>(PlannerInfo *root, PathTarget *final_target)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; PathTarget *input_target;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *non_group_cols;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *non_group_vars;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must build a target containing all grouping columns, plus <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Vars mentioned in the query's targetlist and HAVING qual.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; input_target = <a href="../util/tlist.c.html#L681" title="optimizer/util/tlist.c:681">create_empty_pathtarget</a>();<br/></li>
<li>&nbsp; &nbsp; non_group_cols = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, final_target-&gt;exprs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *expr = (Expr *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; sgref = get_pathtarget_sortgroupref(final_target, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sgref &amp;&amp; root-&gt;processed_groupClause &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/tlist.c.html#L443" title="optimizer/util/tlist.c:443">get_sortgroupref_clause_noerr</a>(sgref,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;processed_groupClause) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's a grouping column, so add it to the input target as-is.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/tlist.c.html#L695" title="optimizer/util/tlist.c:695">add_column_to_pathtarget</a>(input_target, expr, sgref);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Non-grouping column, so just remember the expression for later<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * call to <a href="../util/var.c.html#L607" title="optimizer/util/var.c:607">pull_var_clause</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; non_group_cols = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(non_group_cols, expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there's a HAVING clause, we'll need the Vars it uses, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;havingQual)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; non_group_cols = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(non_group_cols, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;havingQual);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Pull out all the Vars mentioned in non-group cols (plus HAVING), and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * add them to the input target if not already present.&nbsp; (A Var used<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * directly as a GROUP BY item will be present already.)&nbsp; Note this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * includes Vars used in resjunk items, so we are covering the needs of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ORDER BY and window specifications.&nbsp; Vars used within Aggrefs and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WindowFuncs will be pulled out here, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; non_group_vars = <a href="../util/var.c.html#L607" title="optimizer/util/var.c:607">pull_var_clause</a>((Node *) non_group_cols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PVC_RECURSE_AGGREGATES |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PVC_RECURSE_WINDOWFUNCS |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PVC_INCLUDE_PLACEHOLDERS);<br/></li>
<li>&nbsp; &nbsp; <a href="../util/tlist.c.html#L752" title="optimizer/util/tlist.c:752">add_new_columns_to_pathtarget</a>(input_target, non_group_vars);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* clean up cruft */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(non_group_vars);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(non_group_cols);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> this causes some redundant cost calculation ... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../path/costsize.c.html#L6256" title="optimizer/path/costsize.c:6256">set_pathtarget_cost_width</a>(root, input_target);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5409" title="optimizer/plan/planner.c:5409">make_partial_grouping_target</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Generate appropriate PathTarget for output of partial aggregate<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; (or partial grouping, if there are no aggregates) nodes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A partial aggregation node needs to emit all the same aggregates that<br/></li>
<li></span><span class="Comment"> * a regular aggregation node would, plus <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> aggregates used in HAVING;<br/></li>
<li></span><span class="Comment"> * except that the Aggref nodes should be marked as partial aggregates.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In addition, we'd better emit <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> Vars and PlaceHolderVars that are<br/></li>
<li></span><span class="Comment"> * used outside of Aggrefs in the aggregation tlist and HAVING.&nbsp; (Presumably,<br/></li>
<li></span><span class="Comment"> * these would be Vars that are grouped by or used in grouping expressions.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * grouping_target is the tlist to be emitted by the topmost aggregation step.<br/></li>
<li></span><span class="Comment"> * havingQual represents the HAVING clause.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> PathTarget *<br/></li>
<li><a id="L5409">&#x200c;</a><span class="linkable">make_partial_grouping_target</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PathTarget *grouping_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *havingQual)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PathTarget *partial_target;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *non_group_cols;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *non_group_exprs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; partial_target = <a href="../util/tlist.c.html#L681" title="optimizer/util/tlist.c:681">create_empty_pathtarget</a>();<br/></li>
<li>&nbsp; &nbsp; non_group_cols = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, grouping_target-&gt;exprs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *expr = (Expr *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; sgref = get_pathtarget_sortgroupref(grouping_target, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sgref &amp;&amp; root-&gt;processed_groupClause &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/tlist.c.html#L443" title="optimizer/util/tlist.c:443">get_sortgroupref_clause_noerr</a>(sgref,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;processed_groupClause) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's a grouping column, so add it to the partial_target as-is.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (This allows the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> agg step to <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> the grouping calcs.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/tlist.c.html#L695" title="optimizer/util/tlist.c:695">add_column_to_pathtarget</a>(partial_target, expr, sgref);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Non-grouping column, so just remember the expression for later<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * call to <a href="../util/var.c.html#L607" title="optimizer/util/var.c:607">pull_var_clause</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; non_group_cols = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(non_group_cols, expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there's a HAVING clause, we'll need the Vars/Aggrefs it uses, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (havingQual)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; non_group_cols = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(non_group_cols, havingQual);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Pull out all the Vars, PlaceHolderVars, and Aggrefs mentioned in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-group cols (plus HAVING), and add them to the partial_target if not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already present.&nbsp; (An expression used directly as a GROUP BY item will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be present already.)&nbsp; Note this includes Vars used in resjunk items, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we are covering the needs of ORDER BY and window specifications.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; non_group_exprs = <a href="../util/var.c.html#L607" title="optimizer/util/var.c:607">pull_var_clause</a>((Node *) non_group_cols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PVC_INCLUDE_AGGREGATES |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PVC_RECURSE_WINDOWFUNCS |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PVC_INCLUDE_PLACEHOLDERS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../util/tlist.c.html#L752" title="optimizer/util/tlist.c:752">add_new_columns_to_pathtarget</a>(partial_target, non_group_exprs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Adjust Aggrefs to put them in partial mode.&nbsp; At this point all Aggrefs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are at the top level of the target list, so we can just scan the list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rather than recursing through the expression trees.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, partial_target-&gt;exprs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Aggref&nbsp; &nbsp; &nbsp;&nbsp; *aggref = (Aggref *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(aggref, Aggref))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Aggref&nbsp; &nbsp; &nbsp;&nbsp; *newaggref;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We shouldn't need to copy the substructure of the Aggref node,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but flat-copy the node itself to avoid damaging other trees.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newaggref = makeNode(Aggref);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(newaggref, aggref, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Aggref));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, assume serialization is required */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5512" title="optimizer/plan/planner.c:5512">mark_partial_aggref</a>(newaggref, AGGSPLIT_INITIAL_SERIAL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lfirst(lc) = newaggref;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* clean up cruft */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(non_group_exprs);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(non_group_cols);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> this causes some redundant cost calculation ... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../path/costsize.c.html#L6256" title="optimizer/path/costsize.c:6256">set_pathtarget_cost_width</a>(root, partial_target);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5512" title="optimizer/plan/planner.c:5512">mark_partial_aggref</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Adjust an Aggref to make it represent a partial-aggregation step.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The Aggref node is modified in-place; caller must do <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> copying required.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5512">&#x200c;</a></span><span class="linkable">mark_partial_aggref</span>(Aggref *agg, AggSplit aggsplit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* aggtranstype should be computed by this point */<br/></li>
<li></span>&nbsp; &nbsp; Assert(OidIsValid(agg-&gt;aggtranstype));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... but aggsplit should still be as the parser left it */<br/></li>
<li></span>&nbsp; &nbsp; Assert(agg-&gt;aggsplit == AGGSPLIT_SIMPLE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark the Aggref with the intended partial-aggregation mode */<br/></li>
<li></span>&nbsp; &nbsp; agg-&gt;aggsplit = aggsplit;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Adjust result type if needed.&nbsp; Normally, a partial aggregate returns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the aggregate's transition type; but if that's INTERNAL and we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * serializing, it returns BYTEA instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (DO_AGGSPLIT_SKIPFINAL(aggsplit))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (agg-&gt;aggtranstype == INTERNALOID &amp;&amp; DO_AGGSPLIT_SERIALIZE(aggsplit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; agg-&gt;aggtype = BYTEAOID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; agg-&gt;aggtype = agg-&gt;aggtranstype;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5547" title="optimizer/plan/planner.c:5547">postprocess_setop_tlist</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Fix up targetlist returned by <a href="../prep/prepunion.c.html#L99" title="optimizer/prep/prepunion.c:99">plan_set_operations</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We need to transpose sort key info from the orig_tlist into new_tlist.<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: this would not be good enough if we supported resjunk sort keys<br/></li>
<li></span><span class="Comment"> * for results of set operations --- then, we'd need to project a whole<br/></li>
<li></span><span class="Comment"> * new tlist to evaluate the resjunk columns.&nbsp; For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, just ereport if we<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> resjunk columns in orig_tlist.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L5547">&#x200c;</a><span class="linkable">postprocess_setop_tlist</span>(List *new_tlist, List *orig_tlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *orig_tlist_item = list_head(orig_tlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, new_tlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *new_tle = lfirst_node(TargetEntry, l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *orig_tle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore resjunk columns in setop result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (new_tle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(orig_tlist_item != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; orig_tle = lfirst_node(TargetEntry, orig_tlist_item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; orig_tlist_item = lnext(orig_tlist, orig_tlist_item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (orig_tle-&gt;resjunk)&nbsp; &nbsp; <span class="Comment">/* should not happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;resjunk output columns are not implemented&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(new_tle-&gt;resno == orig_tle-&gt;resno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_tle-&gt;ressortgroupref = orig_tle-&gt;ressortgroupref;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (orig_tlist_item != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;resjunk output columns are not implemented&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> new_tlist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5584" title="optimizer/plan/planner.c:5584">optimize_window_clauses</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Call each WindowFunc's prosupport function to see if we're able to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; make <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> adjustments to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the WindowClause's so that the executor<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; can execute the window <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in a more optimal way.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently we only allow adjustments to the WindowClause's frameOptions.&nbsp; We<br/></li>
<li></span><span class="Comment"> * may allow more things to be done here in the future.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5584">&#x200c;</a></span><span class="linkable">optimize_window_clauses</span>(PlannerInfo *root, WindowFuncLists *wflists)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *windowClause = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;windowClause;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, windowClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WindowClause *wc = lfirst_node(WindowClause, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; optimizedFrameOptions = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(wc-&gt;winref &lt;= wflists-&gt;maxWinRef);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> WindowClauses that have no WindowFuncs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (wflists-&gt;windowFuncs[wc-&gt;winref] == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, wflists-&gt;windowFuncs[wc-&gt;winref])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SupportRequestOptimizeWindowClause req;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SupportRequestOptimizeWindowClause *res;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WindowFunc *wfunc = lfirst_node(WindowFunc, lc2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prosupport;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prosupport = <a href="../../utils/cache/lsyscache.c.html#L1858" title="utils/cache/lsyscache.c:1858">get_func_support</a>(wfunc-&gt;winfnoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check if there's a support function for 'wfunc' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(prosupport))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can't <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> this WindowClause */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; req.type = T_SupportRequestOptimizeWindowClause;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; req.window_clause = wc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; req.window_func = wfunc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; req.frameOptions = wc-&gt;frameOptions;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* call the support function */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = (SupportRequestOptimizeWindowClause *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetPointer(OidFunctionCall1(prosupport,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(&amp;req)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Skip to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> WindowClause if the support function does not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * support this request type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Save these frameOptions for the first WindowFunc for this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WindowClause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (foreach_current_index(lc2) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; optimizedFrameOptions = res-&gt;frameOptions;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * On subsequent WindowFuncs, if the frameOptions are not the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then we're unable to <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> the frameOptions for this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WindowClause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (optimizedFrameOptions != res-&gt;frameOptions)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> WindowClause, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* adjust the frameOptions if all WindowFunc's agree that it's ok */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lc2 == <span class="Constant">NULL</span> &amp;&amp; wc-&gt;frameOptions != optimizedFrameOptions)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc3;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* apply the new frame options */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wc-&gt;frameOptions = optimizedFrameOptions;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> check to see if changing the frameOptions has caused<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this WindowClause to be a duplicate of some other WindowClause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This can only happen if we have multiple WindowClauses, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't bother if there's only 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(windowClause) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do the duplicate check and reuse the existing WindowClause if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a duplicate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc3, windowClause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WindowClause *existing_wc = lfirst_node(WindowClause, lc3);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> over the WindowClause we're currently editing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (existing_wc == wc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Perform the same duplicate check that is done in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../parser/parse_agg.c.html#L822" title="parser/parse_agg.c:822">transformWindowFuncCall</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(wc-&gt;partitionClause, existing_wc-&gt;partitionClause) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(wc-&gt;orderClause, existing_wc-&gt;orderClause) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wc-&gt;frameOptions == existing_wc-&gt;frameOptions &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(wc-&gt;startOffset, existing_wc-&gt;startOffset) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(wc-&gt;endOffset, existing_wc-&gt;endOffset))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc4;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now move each WindowFunc in 'wc' into 'existing_wc'.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This required adjusting each WindowFunc's winref and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * moving the WindowFuncs in 'wc' to the list of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WindowFuncs in 'existing_wc'.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc4, wflists-&gt;windowFuncs[wc-&gt;winref])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WindowFunc *wfunc = lfirst_node(WindowFunc, lc4);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wfunc-&gt;winref = existing_wc-&gt;winref;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* move list items */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wflists-&gt;windowFuncs[existing_wc-&gt;winref] = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(wflists-&gt;windowFuncs[existing_wc-&gt;winref],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wflists-&gt;windowFuncs[wc-&gt;winref]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wflists-&gt;windowFuncs[wc-&gt;winref] = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../parser/parse_agg.c.html#L822" title="parser/parse_agg.c:822">transformWindowFuncCall</a>() should have made sure there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are no other duplicates, so we needn't bother looking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> further.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5724" title="optimizer/plan/planner.c:5724">select_active_windows</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Create a list of the &quot;active&quot; window clauses (ie, those referenced<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; by non-deleted WindowFuncs) in the order they are to be executed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L5724">&#x200c;</a><span class="linkable">select_active_windows</span>(PlannerInfo *root, WindowFuncLists *wflists)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *windowClause = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;windowClause;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nActive = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L116" title="optimizer/plan/planner.c:116">WindowClauseSortData</a> *actives = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L116" title="optimizer/plan/planner.c:116">WindowClauseSortData</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list_length(windowClause));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First, construct an array of the active windows */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, windowClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WindowClause *wc = lfirst_node(WindowClause, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It's only active if wflists shows some related WindowFuncs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(wc-&gt;winref &lt;= wflists-&gt;maxWinRef);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (wflists-&gt;windowFuncs[wc-&gt;winref] == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; actives[nActive].wc = wc;&nbsp; &nbsp; <span class="Comment">/* original clause */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For sorting, we want the list of partition keys followed by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list of sort keys. But pathkeys construction will remove duplicates<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * between the two, so we can as well (even though we can't detect all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the duplicates, since some may come from ECs - that might mean<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> optimization chances here). We must, however, ensure that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the order of entries is preserved with respect to the ones we do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keep.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partitionClause and orderClause had their own duplicates removed in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis, so we're only concerned here with removing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * orderClause entries that also appear in partitionClause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; actives[nActive].uniqueOrder =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1405" title="nodes/list.c:1405">list_concat_unique</a>(<a href="../../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(wc-&gt;partitionClause),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wc-&gt;orderClause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nActive++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sort active windows by their partitioning/ordering clauses, ignoring<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> framing clauses, so that the windows that need the same sorting are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * adjacent in the list. When we come to generate paths, this will avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inserting additional Sort nodes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is how we implement a specific requirement from the SQL standard,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which says that when two or more windows are order-equivalent (i.e.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have matching partition and order clauses, even if their names or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * framing clauses differ), then all peer rows must be presented in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same order in all of them. If we allowed multiple sort nodes for such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases, we'd risk having the peer rows end up in different orders in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * equivalent windows due to sort instability. (See General Rule 4 of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &lt;window clause&gt; in SQL2008 - SQL2016.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Additionally, if the entire list of clauses of one window is a prefix<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of another, put first the window with stronger sorting requirements.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This way we will first sort for stronger window, and won't have to sort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * again for the weaker one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; qsort(actives, nActive, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L116" title="optimizer/plan/planner.c:116">WindowClauseSortData</a>), <a href="#L5812" title="optimizer/plan/planner.c:5812">common_prefix_cmp</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build ordered list of the original WindowClause nodes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; nActive; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, actives[i].wc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(actives);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5812" title="optimizer/plan/planner.c:5812">common_prefix_cmp</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; QSort comparison function for <a href="#L116" title="optimizer/plan/planner.c:116">WindowClauseSortData</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Sort the windows by the required sorting clauses. First, <a href="../geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the sort<br/></li>
<li></span><span class="Comment"> * clauses themselves. Second, if one window's clauses are a prefix of another<br/></li>
<li></span><span class="Comment"> * one's clauses, put the window with more sort clauses first.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We purposefully sort by the highest tleSortGroupRef first.&nbsp; Since<br/></li>
<li></span><span class="Comment"> * tleSortGroupRefs are assigned for the query's DISTINCT and ORDER BY first<br/></li>
<li></span><span class="Comment"> * and because here we sort the lowest tleSortGroupRefs last, if a<br/></li>
<li></span><span class="Comment"> * WindowClause is sharing a tleSortGroupRef with the query's DISTINCT or<br/></li>
<li></span><span class="Comment"> * ORDER BY clause, this makes it more likely that the final WindowAgg will<br/></li>
<li></span><span class="Comment"> * provide presorted input for the query's DISTINCT or ORDER BY clause, thus<br/></li>
<li></span><span class="Comment"> * reducing the total number of sorts required for the query.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L5812">&#x200c;</a></span><span class="linkable">common_prefix_cmp</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L116" title="optimizer/plan/planner.c:116">WindowClauseSortData</a> *wcsa = a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L116" title="optimizer/plan/planner.c:116">WindowClauseSortData</a> *wcsb = b;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *item_a;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *item_b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; forboth(item_a, wcsa-&gt;uniqueOrder, item_b, wcsb-&gt;uniqueOrder)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *sca = lfirst_node(SortGroupClause, item_a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *scb = lfirst_node(SortGroupClause, item_b);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sca-&gt;tleSortGroupRef &gt; scb-&gt;tleSortGroupRef)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (sca-&gt;tleSortGroupRef &lt; scb-&gt;tleSortGroupRef)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (sca-&gt;sortop &gt; scb-&gt;sortop)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (sca-&gt;sortop &lt; scb-&gt;sortop)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (sca-&gt;nulls_first &amp;&amp; !scb-&gt;nulls_first)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!sca-&gt;nulls_first &amp;&amp; scb-&gt;nulls_first)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no need to <a href="../geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> eqop, since it is fully determined by sortop */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(wcsa-&gt;uniqueOrder) &gt; list_length(wcsb-&gt;uniqueOrder))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (list_length(wcsa-&gt;uniqueOrder) &lt; list_length(wcsb-&gt;uniqueOrder))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5881" title="optimizer/plan/planner.c:5881">make_window_input_target</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Generate appropriate PathTarget for initial input to WindowAgg nodes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When the query has window <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, this function computes the desired<br/></li>
<li></span><span class="Comment"> * target to be computed by the node just below the first WindowAgg.<br/></li>
<li></span><span class="Comment"> * This tlist must contain all <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> needed to evaluate the window <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>,<br/></li>
<li></span><span class="Comment"> * compute the final target list, and perform <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> required final sort step.<br/></li>
<li></span><span class="Comment"> * If multiple WindowAggs are needed, each intermediate one adds its window<br/></li>
<li></span><span class="Comment"> * function results onto this base tlist; only the topmost WindowAgg computes<br/></li>
<li></span><span class="Comment"> * the actual desired target list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is much like <a href="#L5321" title="optimizer/plan/planner.c:5321">make_group_input_target</a>, though not quite enough<br/></li>
<li></span><span class="Comment"> * like it to share code.&nbsp; As in that function, we flatten most expressions<br/></li>
<li></span><span class="Comment"> * into their component variables.&nbsp; But we do not want to flatten window<br/></li>
<li></span><span class="Comment"> * PARTITION BY/ORDER BY clauses, since that might result in multiple<br/></li>
<li></span><span class="Comment"> * evaluations of them, which would be bad (possibly even resulting in<br/></li>
<li></span><span class="Comment"> * inconsistent answers, if they contain volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>).<br/></li>
<li></span><span class="Comment"> * Also, we must not flatten GROUP BY clauses that were left unflattened by<br/></li>
<li></span><span class="Comment"> * <a href="#L5321" title="optimizer/plan/planner.c:5321">make_group_input_target</a>, because we may no longer have access to the<br/></li>
<li></span><span class="Comment"> * individual Vars in them.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Another key difference from <a href="#L5321" title="optimizer/plan/planner.c:5321">make_group_input_target</a> is that we don't<br/></li>
<li></span><span class="Comment"> * flatten Aggref expressions, since those are to be computed below the<br/></li>
<li></span><span class="Comment"> * window <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> and just referenced like Vars above that.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'final_target' is the query's final target list (in PathTarget form)<br/></li>
<li></span><span class="Comment"> * 'activeWindows' is the list of active windows previously identified by<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5724" title="optimizer/plan/planner.c:5724">select_active_windows</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is the PathTarget to be computed by the plan node immediately<br/></li>
<li></span><span class="Comment"> * below the first WindowAgg node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> PathTarget *<br/></li>
<li><a id="L5881">&#x200c;</a><span class="linkable">make_window_input_target</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PathTarget *final_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *activeWindows)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PathTarget *input_target;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *sgrefs;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *flattenable_cols;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *flattenable_vars;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasWindowFuncs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Collect the sortgroupref numbers of window PARTITION/ORDER BY clauses<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into a bitmapset for convenient reference below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sgrefs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, activeWindows)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WindowClause *wc = lfirst_node(WindowClause, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, wc-&gt;partitionClause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *sortcl = lfirst_node(SortGroupClause, lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sgrefs = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(sgrefs, sortcl-&gt;tleSortGroupRef);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, wc-&gt;orderClause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *sortcl = lfirst_node(SortGroupClause, lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sgrefs = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(sgrefs, sortcl-&gt;tleSortGroupRef);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add in sortgroupref numbers of GROUP BY clauses, too */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, root-&gt;processed_groupClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *grpcl = lfirst_node(SortGroupClause, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sgrefs = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(sgrefs, grpcl-&gt;tleSortGroupRef);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Construct a target containing all the non-flattenable targetlist items,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and save aside the others for a moment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; input_target = <a href="../util/tlist.c.html#L681" title="optimizer/util/tlist.c:681">create_empty_pathtarget</a>();<br/></li>
<li>&nbsp; &nbsp; flattenable_cols = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, final_target-&gt;exprs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *expr = (Expr *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; sgref = get_pathtarget_sortgroupref(final_target, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't want to deconstruct window clauses or GROUP BY items.&nbsp; (Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that such items can't contain window <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, so it's okay to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * compute them below the WindowAgg nodes.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sgref != <span class="Constant">0</span> &amp;&amp; <a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(sgref, sgrefs))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't want to deconstruct this value, so add it to the input<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * target as-is.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/tlist.c.html#L695" title="optimizer/util/tlist.c:695">add_column_to_pathtarget</a>(input_target, expr, sgref);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Column is to be flattened, so just remember the expression for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * later call to <a href="../util/var.c.html#L607" title="optimizer/util/var.c:607">pull_var_clause</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flattenable_cols = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(flattenable_cols, expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Pull out all the Vars and Aggrefs mentioned in flattenable columns, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * add them to the input target if not already present.&nbsp; (Some might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there already because they're used directly as window/group clauses.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: it's essential to use PVC_INCLUDE_AGGREGATES here, so that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Aggrefs are placed in the Agg node's tlist and not left to be computed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * at higher levels.&nbsp; On the other hand, we should recurse into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WindowFuncs to make sure their input expressions are available.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; flattenable_vars = <a href="../util/var.c.html#L607" title="optimizer/util/var.c:607">pull_var_clause</a>((Node *) flattenable_cols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PVC_INCLUDE_AGGREGATES |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PVC_RECURSE_WINDOWFUNCS |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PVC_INCLUDE_PLACEHOLDERS);<br/></li>
<li>&nbsp; &nbsp; <a href="../util/tlist.c.html#L752" title="optimizer/util/tlist.c:752">add_new_columns_to_pathtarget</a>(input_target, flattenable_vars);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* clean up cruft */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(flattenable_vars);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(flattenable_cols);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> this causes some redundant cost calculation ... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../path/costsize.c.html#L6256" title="optimizer/path/costsize.c:6256">set_pathtarget_cost_width</a>(root, input_target);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6001" title="optimizer/plan/planner.c:6001">make_pathkeys_for_window</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Create a pathkeys list describing the required input ordering<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; for the given WindowClause.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Modifies wc's partitionClause to remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> clauses which are deemed<br/></li>
<li></span><span class="Comment"> * redundant by the pathkey logic.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The required ordering is first the PARTITION keys, then the ORDER keys.<br/></li>
<li></span><span class="Comment"> * In the future we might try to implement windowing using hashing, in which<br/></li>
<li></span><span class="Comment"> * case the ordering could be relaxed, but for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we always sort.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L6001">&#x200c;</a><span class="linkable">make_pathkeys_for_window</span>(PlannerInfo *root, WindowClause *wc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *tlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *window_pathkeys = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Throw error if can't sort */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../util/tlist.c.html#L540" title="optimizer/util/tlist.c:540">grouping_is_sortable</a>(wc-&gt;partitionClause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not implement window PARTITION BY&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Window partitioning columns must be of sortable datatypes.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../util/tlist.c.html#L540" title="optimizer/util/tlist.c:540">grouping_is_sortable</a>(wc-&gt;orderClause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not implement window ORDER BY&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Window ordering columns must be of sortable datatypes.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First fetch the pathkeys for the PARTITION BY clause.&nbsp; We can safely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> clauses from the wc-&gt;partitionClause for redundant pathkeys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (wc-&gt;partitionClause != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sortable;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; window_pathkeys = <a href="../path/pathkeys.c.html#L1384" title="optimizer/path/pathkeys.c:1384">make_pathkeys_for_sortclauses_extended</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;wc-&gt;partitionClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;sortable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(sortable);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In principle, we could also consider removing redundant ORDER BY items<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * too as doing so does not alter the result of peer row checks done by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the executor.&nbsp; However, we must *not* remove the ordering column for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L339" title="regex/regcomp.c:339">RANGE</a> OFFSET cases, as the executor needs that for in_range tests even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if it's known to be <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to some partitioning column.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (wc-&gt;orderClause != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *orderby_pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; orderby_pathkeys = <a href="../path/pathkeys.c.html#L1347" title="optimizer/path/pathkeys.c:1347">make_pathkeys_for_sortclauses</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wc-&gt;orderClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Okay, make the combined pathkeys */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (window_pathkeys != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; window_pathkeys = <a href="../path/pathkeys.c.html#L106" title="optimizer/path/pathkeys.c:106">append_pathkeys</a>(window_pathkeys, orderby_pathkeys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; window_pathkeys = orderby_pathkeys;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> window_pathkeys;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6127" title="optimizer/plan/planner.c:6127">make_sort_input_target</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Generate appropriate PathTarget for initial input to Sort step.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the query has ORDER BY, this function chooses the target to be computed<br/></li>
<li></span><span class="Comment"> * by the node just below the Sort (and DISTINCT, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, since Unique can't<br/></li>
<li></span><span class="Comment"> * project) steps.&nbsp; This might or might not be identical to the query's final<br/></li>
<li></span><span class="Comment"> * output target.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> argument for keeping the sort-input tlist the same as the final<br/></li>
<li></span><span class="Comment"> * is that we avoid a separate projection node (which will be needed if<br/></li>
<li></span><span class="Comment"> * they're different, because Sort can't project).&nbsp; However, there are also<br/></li>
<li></span><span class="Comment"> * advantages to postponing tlist evaluation till after the Sort: it ensures<br/></li>
<li></span><span class="Comment"> * a consistent order of evaluation for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in the tlist,<br/></li>
<li></span><span class="Comment"> * and if there's also a LIMIT, we can stop the query without ever computing<br/></li>
<li></span><span class="Comment"> * tlist <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for later rows, which is beneficial for both volatile and<br/></li>
<li></span><span class="Comment"> * expensive <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Our current policy is to postpone volatile expressions till after the sort<br/></li>
<li></span><span class="Comment"> * unconditionally (assuming that that's possible, ie they are in plain tlist<br/></li>
<li></span><span class="Comment"> * columns and not ORDER BY/GROUP BY/DISTINCT columns).&nbsp; We also prefer to<br/></li>
<li></span><span class="Comment"> * postpone set-returning expressions, because running them beforehand would<br/></li>
<li></span><span class="Comment"> * bloat the sort dataset, and because it might cause unexpected output order<br/></li>
<li></span><span class="Comment"> * if the sort isn't stable.&nbsp; However there's a constraint on that: all SRFs<br/></li>
<li></span><span class="Comment"> * in the tlist should be evaluated at the same plan step, so that they can<br/></li>
<li></span><span class="Comment"> * run in sync in nodeProjectSet.&nbsp; So if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SRFs are in sort columns, we<br/></li>
<li></span><span class="Comment"> * mustn't postpone <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SRFs.&nbsp; (Note that in principle that policy should<br/></li>
<li></span><span class="Comment"> * probably get applied to the group/window input targetlists too, but we<br/></li>
<li></span><span class="Comment"> * have not done that historically.)&nbsp; Lastly, expensive expressions are<br/></li>
<li></span><span class="Comment"> * postponed if there is a LIMIT, or if root-&gt;tuple_fraction shows that<br/></li>
<li></span><span class="Comment"> * partial evaluation of the query is possible (if neither is true, we expect<br/></li>
<li></span><span class="Comment"> * to have to evaluate the expressions for every row anyway), or if there are<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> volatile or set-returning expressions (since once we've put in a<br/></li>
<li></span><span class="Comment"> * projection at all, it won't cost <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more to postpone more stuff).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Another issue that could potentially be considered here is that<br/></li>
<li></span><span class="Comment"> * evaluating tlist expressions could result in data that's either wider<br/></li>
<li></span><span class="Comment"> * or narrower than the input Vars, thus changing the volume of data that<br/></li>
<li></span><span class="Comment"> * has to go through the Sort.&nbsp; However, we usually have only a very bad<br/></li>
<li></span><span class="Comment"> * idea of the output width of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> expression more complex than a Var,<br/></li>
<li></span><span class="Comment"> * so for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> it seems too risky to try to <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> on that basis.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that if we do produce a modified sort-input target, and then the<br/></li>
<li></span><span class="Comment"> * query ends up not using an explicit Sort, no particular harm is done:<br/></li>
<li></span><span class="Comment"> * we'll initially use the modified target for the preceding path nodes,<br/></li>
<li></span><span class="Comment"> * but then change them to the final target with <a href="../util/pathnode.c.html#L2793" title="optimizer/util/pathnode.c:2793">apply_projection_to_path</a>.<br/></li>
<li></span><span class="Comment"> * Moreover, in such a case the guarantees about evaluation order of<br/></li>
<li></span><span class="Comment"> * volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> still hold, since the rows are sorted already.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function has some things in common with <a href="#L5321" title="optimizer/plan/planner.c:5321">make_group_input_target</a> and<br/></li>
<li></span><span class="Comment"> * <a href="#L5881" title="optimizer/plan/planner.c:5881">make_window_input_target</a>, though the detailed rules for what to do are<br/></li>
<li></span><span class="Comment"> * different.&nbsp; We never flatten/postpone <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> grouping or ordering columns;<br/></li>
<li></span><span class="Comment"> * those are needed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the sort.&nbsp; If we do flatten a particular<br/></li>
<li></span><span class="Comment"> * expression, we leave Aggref and WindowFunc nodes alone, since those were<br/></li>
<li></span><span class="Comment"> * computed earlier.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'final_target' is the query's final target list (in PathTarget form)<br/></li>
<li></span><span class="Comment"> * 'have_postponed_srfs' is an output argument, see below<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is the PathTarget to be computed by the plan node immediately<br/></li>
<li></span><span class="Comment"> * below the Sort step (and the Distinct step, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>).&nbsp; This will be<br/></li>
<li></span><span class="Comment"> * exactly final_target if we decide a projection step wouldn't be helpful.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In addition, *have_postponed_srfs is set to true if we choose to postpone<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> set-returning <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to after the Sort.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> PathTarget *<br/></li>
<li><a id="L6127">&#x200c;</a><span class="linkable">make_sort_input_target</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PathTarget *final_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *have_postponed_srfs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; PathTarget *input_target;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncols;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *col_is_srf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *postpone_col;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_srf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_volatile;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_expensive;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_srf_sortcols;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; postpone_srfs;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *postponable_cols;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *postponable_vars;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shouldn't get here unless query has ORDER BY */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;sortClause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *have_postponed_srfs = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* default result */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Inspect tlist and collect per-column information */<br/></li>
<li></span>&nbsp; &nbsp; ncols = list_length(final_target-&gt;exprs);<br/></li>
<li>&nbsp; &nbsp; col_is_srf = (<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(ncols * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; postpone_col = (<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(ncols * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; have_srf = have_volatile = have_expensive = have_srf_sortcols = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, final_target-&gt;exprs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *expr = (Expr *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the column has a sortgroupref, assume it has to be evaluated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> sorting.&nbsp; Generally such columns would be ORDER BY, GROUP<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * BY, etc targets.&nbsp; One exception is columns that were removed from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * GROUP BY by <a href="#L2687" title="optimizer/plan/planner.c:2687">remove_useless_groupby_columns</a>() ... but those would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only be Vars anyway.&nbsp; There don't seem to be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> cases where it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would be worth the trouble to double-check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (get_pathtarget_sortgroupref(final_target, i) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for SRF or volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; Check the SRF case first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because we must know whether we have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> postponed SRFs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasTargetSRFs &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L758" title="nodes/nodeFuncs.c:758">expression_returns_set</a>((Node *) expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We'll decide below whether these are postponable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; col_is_srf[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_srf = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>((Node *) expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Unconditionally postpone */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; postpone_col[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_volatile = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Else check the cost.&nbsp; </span><span class="Todo">XXX</span><span class="Comment"> it's annoying to have to do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when <a href="../path/costsize.c.html#L6256" title="optimizer/path/costsize.c:6256">set_pathtarget_cost_width</a>() just did it.&nbsp; Refactor to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allow sharing the work?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QualCost&nbsp; &nbsp; cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L4666" title="optimizer/path/costsize.c:4666">cost_qual_eval_node</a>(&amp;cost, (Node *) expr, root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We arbitrarily define &quot;expensive&quot; as &quot;more than 10X<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>&quot;.&nbsp; Note this will take in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> PL function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with default cost.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cost.per_tuple &gt; <span class="Constant">10</span> * <a href="../path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; postpone_col[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_expensive = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* For sortgroupref cols, just check if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> contain SRFs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!have_srf_sortcols &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasTargetSRFs &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L758" title="nodes/nodeFuncs.c:758">expression_returns_set</a>((Node *) expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_srf_sortcols = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can postpone SRFs if we have some but <a href="../util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> are in sortgroupref cols.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; postpone_srfs = (have_srf &amp;&amp; !have_srf_sortcols);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we don't need a post-sort projection, just return final_target.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(postpone_srfs || have_volatile ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (have_expensive &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;limitCount || root-&gt;tuple_fraction &gt; <span class="Constant">0</span>))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> final_target;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Report whether the post-sort projection will contain set-returning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; This is important because it affects whether the Sort can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rely on the query's LIMIT (if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) to bound the number of rows it needs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to return.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *have_postponed_srfs = postpone_srfs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Construct the sort-input target, taking all non-postponable columns and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then adding Vars, PlaceHolderVars, Aggrefs, and WindowFuncs found in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the postponable ones.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; input_target = <a href="../util/tlist.c.html#L681" title="optimizer/util/tlist.c:681">create_empty_pathtarget</a>();<br/></li>
<li>&nbsp; &nbsp; postponable_cols = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, final_target-&gt;exprs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *expr = (Expr *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (postpone_col[i] || (postpone_srfs &amp;&amp; col_is_srf[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; postponable_cols = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(postponable_cols, expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/tlist.c.html#L695" title="optimizer/util/tlist.c:695">add_column_to_pathtarget</a>(input_target, expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; get_pathtarget_sortgroupref(final_target, i));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Pull out all the Vars, Aggrefs, and WindowFuncs mentioned in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * postponable columns, and add them to the sort-input target if not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already present.&nbsp; (Some might be there already.)&nbsp; We mustn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deconstruct Aggrefs or WindowFuncs here, since the projection node<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would be unable to recompute them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; postponable_vars = <a href="../util/var.c.html#L607" title="optimizer/util/var.c:607">pull_var_clause</a>((Node *) postponable_cols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PVC_INCLUDE_AGGREGATES |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PVC_INCLUDE_WINDOWFUNCS |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PVC_INCLUDE_PLACEHOLDERS);<br/></li>
<li>&nbsp; &nbsp; <a href="../util/tlist.c.html#L752" title="optimizer/util/tlist.c:752">add_new_columns_to_pathtarget</a>(input_target, postponable_vars);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* clean up cruft */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(postponable_vars);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(postponable_cols);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> this represents even more redundant cost calculation ... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../path/costsize.c.html#L6256" title="optimizer/path/costsize.c:6256">set_pathtarget_cost_width</a>(root, input_target);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6298" title="optimizer/plan/planner.c:6298">get_cheapest_fractional_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Find the cheapest path for retrieving a specified fraction of all<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the tuples expected to be returned by the given relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We interpret tuple_fraction the same way as <a href="#L1305" title="optimizer/plan/planner.c:1305">grouping_planner</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We assume <a href="../util/pathnode.c.html#L242" title="optimizer/util/pathnode.c:242">set_cheapest</a>() has been run on the given rel.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Path *<br/></li>
<li><a id="L6298">&#x200c;</a><span class="linkable">get_cheapest_fractional_path</span>(RelOptInfo *rel, <span class="Type">double</span> tuple_fraction)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *best_path = rel-&gt;cheapest_total_path;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If all tuples will be retrieved, just return the cheapest-total path */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tuple_fraction &lt;= <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> best_path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert absolute # of tuples to a fraction; no need to clamp to 0..1 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tuple_fraction &gt;= <span class="Constant">1.0</span> &amp;&amp; best_path-&gt;rows &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple_fraction /= best_path-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, rel-&gt;pathlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path = (Path *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path == rel-&gt;cheapest_total_path ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L115" title="optimizer/util/pathnode.c:115">compare_fractional_path_costs</a>(best_path, path, tuple_fraction) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; best_path = path;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> best_path;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6341" title="optimizer/plan/planner.c:6341">adjust_paths_for_srfs</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Fix up the Paths of the given upperrel to handle tSRFs properly.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The executor can only handle set-returning <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that appear at the<br/></li>
<li></span><span class="Comment"> * top level of the targetlist of a ProjectSet plan node.&nbsp; If we have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SRFs<br/></li>
<li></span><span class="Comment"> * that are not at top level, we need to split up the evaluation into multiple<br/></li>
<li></span><span class="Comment"> * plan levels in which each level satisfies this constraint.&nbsp; This function<br/></li>
<li></span><span class="Comment"> * modifies each Path of an upperrel that (might) compute <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SRFs in its<br/></li>
<li></span><span class="Comment"> * output tlist to insert appropriate projection steps.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The given targets and targets_contain_srfs lists are from<br/></li>
<li></span><span class="Comment"> * <a href="../util/tlist.c.html#L881" title="optimizer/util/tlist.c:881">split_pathtarget_at_srfs</a>().&nbsp; We assume the existing Paths emit the first<br/></li>
<li></span><span class="Comment"> * target in targets.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6341">&#x200c;</a></span><span class="linkable">adjust_paths_for_srfs</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *targets, List *targets_contain_srfs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(list_length(targets) == list_length(targets_contain_srfs));<br/></li>
<li>&nbsp; &nbsp; Assert(!linitial_int(targets_contain_srfs));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If no SRFs appear at this plan level, nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(targets) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Stack SRF-evaluation nodes atop each path for the rel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In principle we should re-run <a href="../util/pathnode.c.html#L242" title="optimizer/util/pathnode.c:242">set_cheapest</a>() here to identify the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cheapest path, but it seems unlikely that adding the same tlist eval<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * costs to all the paths would change that, so we don't bother. Instead,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just assume that the cheapest-startup and cheapest-total paths remain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so.&nbsp; (There should be no parameterized paths anymore, so we needn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worry about updating cheapest_parameterized_paths.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, rel-&gt;pathlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *subpath = (Path *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *newpath = subpath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(subpath-&gt;param_info == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; forboth(lc1, targets, lc2, targets_contain_srfs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathTarget *thistarget = lfirst_node(PathTarget, lc1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; contains_srfs = (<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) lfirst_int(lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If this level doesn't contain SRFs, do regular projection */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (contains_srfs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newpath = (Path *) <a href="../util/pathnode.c.html#L2882" title="optimizer/util/pathnode.c:2882">create_set_projection_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thistarget);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newpath = (Path *) <a href="../util/pathnode.c.html#L2793" title="optimizer/util/pathnode.c:2793">apply_projection_to_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thistarget);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lfirst(lc) = newpath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subpath == rel-&gt;cheapest_startup_path)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;cheapest_startup_path = newpath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subpath == rel-&gt;cheapest_total_path)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;cheapest_total_path = newpath;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Likewise for partial paths, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, rel-&gt;partial_pathlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *subpath = (Path *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *newpath = subpath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(subpath-&gt;param_info == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; forboth(lc1, targets, lc2, targets_contain_srfs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathTarget *thistarget = lfirst_node(PathTarget, lc1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; contains_srfs = (<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) lfirst_int(lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If this level doesn't contain SRFs, do regular projection */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (contains_srfs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newpath = (Path *) <a href="../util/pathnode.c.html#L2882" title="optimizer/util/pathnode.c:2882">create_set_projection_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thistarget);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* avoid <a href="../util/pathnode.c.html#L2793" title="optimizer/util/pathnode.c:2793">apply_projection_to_path</a>, in case of multiple refs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newpath = (Path *) <a href="../util/pathnode.c.html#L2685" title="optimizer/util/pathnode.c:2685">create_projection_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thistarget);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lfirst(lc) = newpath;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6457" title="optimizer/plan/planner.c:6457">expression_planner</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Perform <a href="#L274" title="optimizer/plan/planner.c:274">planner</a>'s transformations on a standalone expression.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Various utility commands need to evaluate expressions that are not part<br/></li>
<li></span><span class="Comment"> * of a plannable query.&nbsp; They can do so using the executor's regular<br/></li>
<li></span><span class="Comment"> * expression-execution machinery, but first the expression has to be fed<br/></li>
<li></span><span class="Comment"> * through here to transform it from parser output to something executable.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently, we disallow sublinks in standalone expressions, so there's no<br/></li>
<li></span><span class="Comment"> * real &quot;planning&quot; involved here.&nbsp; (That might not always be true though.)<br/></li>
<li></span><span class="Comment"> * What we must do is run <a href="../util/clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a> to ensure that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> function<br/></li>
<li></span><span class="Comment"> * calls are converted to positional notation and function default arguments<br/></li>
<li></span><span class="Comment"> * get inserted.&nbsp; The fact that constant subexpressions get simplified is a<br/></li>
<li></span><span class="Comment"> * side-effect that is useful when the expression will get evaluated more than<br/></li>
<li></span><span class="Comment"> * once.&nbsp; Also, we must fix operator function IDs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This does not return <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> information about dependencies of the expression.<br/></li>
<li></span><span class="Comment"> * Hence callers should use the results only for the duration of the current<br/></li>
<li></span><span class="Comment"> * query.&nbsp; Callers that would like to cache the results for longer should use<br/></li>
<li></span><span class="Comment"> * <a href="#L6484" title="optimizer/plan/planner.c:6484">expression_planner_with_deps</a>, probably via the plancache.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this must not make <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> damaging changes to the passed-in expression<br/></li>
<li></span><span class="Comment"> * tree.&nbsp; (It would actually be okay to apply <a href="../../nodes/nodeFuncs.c.html#L1837" title="nodes/nodeFuncs.c:1837">fix_opfuncids</a> to it, but since<br/></li>
<li></span><span class="Comment"> * we first do an expression_tree_mutator-based walk, what is returned will<br/></li>
<li></span><span class="Comment"> * be a new node tree.)&nbsp; The result is constructed in the current memory<br/></li>
<li></span><span class="Comment"> * context; beware that this can leak a lot of additional stuff there, too.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Expr *<br/></li>
<li><a id="L6457">&#x200c;</a><span class="linkable">expression_planner</span>(Expr *expr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Convert named-argument function calls, insert default arguments and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * simplify constant subexprs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="../util/clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a>(<span class="Constant">NULL</span>, (Node *) expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fill in opfuncid <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> if missing */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L1837" title="nodes/nodeFuncs.c:1837">fix_opfuncids</a>(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Expr *) result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6484" title="optimizer/plan/planner.c:6484">expression_planner_with_deps</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Perform <a href="#L274" title="optimizer/plan/planner.c:274">planner</a>'s transformations on a standalone expression,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; returning expression dependency information along with the result.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is identical to <a href="#L6457" title="optimizer/plan/planner.c:6457">expression_planner</a>() except that it also returns<br/></li>
<li></span><span class="Comment"> * information about possible dependencies of the expression, ie identities of<br/></li>
<li></span><span class="Comment"> * objects whose definitions affect the result.&nbsp; As in a PlannedStmt, these<br/></li>
<li></span><span class="Comment"> * are expressed as a list of relation Oids and a list of PlanInvalItems.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Expr *<br/></li>
<li><a id="L6484">&#x200c;</a><span class="linkable">expression_planner_with_deps</span>(Expr *expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **relationOids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **invalItems)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; PlannerGlobal glob;<br/></li>
<li>&nbsp; &nbsp; PlannerInfo root;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make up dummy <a href="#L274" title="optimizer/plan/planner.c:274">planner</a> state so we can use setrefs machinery */<br/></li>
<li></span>&nbsp; &nbsp; MemSet(&amp;glob, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(glob));<br/></li>
<li>&nbsp; &nbsp; glob.type = T_PlannerGlobal;<br/></li>
<li>&nbsp; &nbsp; glob.relationOids = NIL;<br/></li>
<li>&nbsp; &nbsp; glob.invalItems = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemSet(&amp;root, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(root));<br/></li>
<li>&nbsp; &nbsp; root.type = T_PlannerInfo;<br/></li>
<li>&nbsp; &nbsp; root.glob = &amp;glob;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Convert named-argument function calls, insert default arguments and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * simplify constant subexprs.&nbsp; Collect identities of inlined <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and elided domains, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="../util/clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a>(&amp;root, (Node *) expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fill in opfuncid <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> if missing */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L1837" title="nodes/nodeFuncs.c:1837">fix_opfuncids</a>(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now walk the finished expression to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> anything else we ought to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record as an expression dependency.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="setrefs.c.html#L3577" title="optimizer/plan/setrefs.c:3577">extract_query_dependencies_walker</a>(result, &amp;root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *relationOids = glob.relationOids;<br/></li>
<li>&nbsp; &nbsp; *invalItems = glob.invalItems;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Expr *) result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6537" title="optimizer/plan/planner.c:6537">plan_cluster_use_sort</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Use the <a href="#L274" title="optimizer/plan/planner.c:274">planner</a> to decide how CLUSTER should implement sorting<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * tableOid is the OID of a table to be clustered on its index indexOid<br/></li>
<li></span><span class="Comment"> * (which is already known to be a btree index).&nbsp; Decide whether it's<br/></li>
<li></span><span class="Comment"> * cheaper to do an indexscan or a seqscan-plus-sort to execute the CLUSTER.<br/></li>
<li></span><span class="Comment"> * Return true to use sorting, false to use an indexscan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: caller had better already hold some type of lock on the table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L6537">&#x200c;</a></span><span class="linkable">plan_cluster_use_sort</span>(Oid tableOid, Oid indexOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *root;<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query;<br/></li>
<li>&nbsp; &nbsp; PlannerGlobal *glob;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *rel;<br/></li>
<li>&nbsp; &nbsp; IndexOptInfo *indexInfo;<br/></li>
<li>&nbsp; &nbsp; QualCost&nbsp; &nbsp; indexExprCost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; comparisonCost;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *seqScanPath;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp; &nbsp; seqScanAndSortPath;<br/></li>
<li>&nbsp; &nbsp; IndexPath&nbsp; *indexScanPath;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can short-circuit the cost comparison if indexscans are disabled */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../path/costsize.c.html#L135" title="optimizer/path/costsize.c:135">enable_indexscan</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* use sort */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up mostly-dummy <a href="#L274" title="optimizer/plan/planner.c:274">planner</a> state */<br/></li>
<li></span>&nbsp; &nbsp; query = makeNode(Query);<br/></li>
<li>&nbsp; &nbsp; query-&gt;commandType = CMD_SELECT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; glob = makeNode(PlannerGlobal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; root = makeNode(PlannerInfo);<br/></li>
<li>&nbsp; &nbsp; root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = query;<br/></li>
<li>&nbsp; &nbsp; root-&gt;glob = glob;<br/></li>
<li>&nbsp; &nbsp; root-&gt;query_level = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;planner_cxt = <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;wt_param_id = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;join_domains = list_make1(makeNode(JoinDomain));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build a minimal RTE for the rel */<br/></li>
<li></span>&nbsp; &nbsp; rte = makeNode(RangeTblEntry);<br/></li>
<li>&nbsp; &nbsp; rte-&gt;rtekind = RTE_RELATION;<br/></li>
<li>&nbsp; &nbsp; rte-&gt;relid = tableOid;<br/></li>
<li>&nbsp; &nbsp; rte-&gt;relkind = RELKIND_RELATION;&nbsp; &nbsp; <span class="Comment">/* Don't be too picky. */<br/></li>
<li></span>&nbsp; &nbsp; rte-&gt;rellockmode = AccessShareLock;<br/></li>
<li>&nbsp; &nbsp; rte-&gt;lateral = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; rte-&gt;inh = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; rte-&gt;inFromCl = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; query-&gt;rtable = list_make1(rte);<br/></li>
<li>&nbsp; &nbsp; <a href="../../parser/parse_relation.c.html#L3874" title="parser/parse_relation.c:3874">addRTEPermissionInfo</a>(&amp;query-&gt;rteperminfos, rte);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up RTE/RelOptInfo arrays */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/relnode.c.html#L94" title="optimizer/util/relnode.c:94">setup_simple_rel_arrays</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build RelOptInfo */<br/></li>
<li></span>&nbsp; &nbsp; rel = <a href="../util/relnode.c.html#L192" title="optimizer/util/relnode.c:192">build_simple_rel</a>(root, <span class="Constant">1</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Locate IndexOptInfo for the target index */<br/></li>
<li></span>&nbsp; &nbsp; indexInfo = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, rel-&gt;indexlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexInfo = lfirst_node(IndexOptInfo, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexInfo-&gt;indexoid == indexOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's possible that <a href="../util/plancat.c.html#L115" title="optimizer/util/plancat.c:115">get_relation_info</a> did not generate an IndexOptInfo<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the desired index; this could happen if it's not yet reached its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indcheckxmin usability horizon, or if it's a system index and we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ignoring system indexes.&nbsp; In such cases we should tell CLUSTER to not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trust the index contents but use seqscan-and-sort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lc == <span class="Constant">NULL</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not in the list? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* use sort */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Rather than doing all the pushups that would be needed to use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../path/costsize.c.html#L5239" title="optimizer/path/costsize.c:5239">set_baserel_size_estimates</a>, just do a quick hack for rows and width.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;rows = rel-&gt;tuples;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;reltarget-&gt;width = <a href="../util/plancat.c.html#L1208" title="optimizer/util/plancat.c:1208">get_relation_data_width</a>(tableOid, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; root-&gt;total_table_pages = rel-&gt;pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine eval cost of the index expressions, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.&nbsp; We need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> twice that amount for each tuple comparison that happens during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the sort, since tuplesort.c will have to re-evaluate the index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expressions each time.&nbsp; (</span><span class="Todo">XXX</span><span class="Comment"> that's pretty inefficient...)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../path/costsize.c.html#L4640" title="optimizer/path/costsize.c:4640">cost_qual_eval</a>(&amp;indexExprCost, indexInfo-&gt;indexprs, root);<br/></li>
<li>&nbsp; &nbsp; comparisonCost = <span class="Constant">2.0</span> * (indexExprCost.startup + indexExprCost.per_tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Estimate the cost of seq scan + sort */<br/></li>
<li></span>&nbsp; &nbsp; seqScanPath = <a href="../util/pathnode.c.html#L927" title="optimizer/util/pathnode.c:927">create_seqscan_path</a>(root, rel, <span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../path/costsize.c.html#L2124" title="optimizer/path/costsize.c:2124">cost_sort</a>(&amp;seqScanAndSortPath, root, NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seqScanPath-&gt;total_cost, rel-&gt;tuples, rel-&gt;reltarget-&gt;width,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; comparisonCost, <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a>, -<span class="Constant">1.0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Estimate the cost of index scan */<br/></li>
<li></span>&nbsp; &nbsp; indexScanPath = <a href="../util/pathnode.c.html#L993" title="optimizer/util/pathnode.c:993">create_index_path</a>(root, indexInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NIL, NIL, NIL, NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForwardScanDirection, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">1.0</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (seqScanAndSortPath.total_cost &lt; indexScanPath-&gt;path.total_cost);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6657" title="optimizer/plan/planner.c:6657">plan_create_index_workers</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Use the <a href="#L274" title="optimizer/plan/planner.c:274">planner</a> to decide how many parallel worker processes<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; CREATE INDEX should request for use<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * tableOid is the table on which the index is to be built.&nbsp; indexOid is the<br/></li>
<li></span><span class="Comment"> * OID of an index to be created or reindexed (which must be a btree index).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return value is the number of parallel worker processes to request.&nbsp; It<br/></li>
<li></span><span class="Comment"> * may be unsafe to proceed if this is 0.&nbsp; Note that this does not include the<br/></li>
<li></span><span class="Comment"> * leader participating as a worker (value is always a number of parallel<br/></li>
<li></span><span class="Comment"> * worker processes).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: caller had better already hold some type of lock on the table and<br/></li>
<li></span><span class="Comment"> * index.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L6657">&#x200c;</a></span><span class="linkable">plan_create_index_workers</span>(Oid tableOid, Oid indexOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *root;<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query;<br/></li>
<li>&nbsp; &nbsp; PlannerGlobal *glob;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; heap;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; index;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *rel;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parallel_workers;<br/></li>
<li>&nbsp; &nbsp; BlockNumber heap_blocks;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; reltuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; allvisfrac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't allow performing parallel operation in standalone backend or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when parallelism is disabled.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a> || <a href="../../utils/init/globals.c.html#L131" title="utils/init/globals.c:131">max_parallel_maintenance_workers</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up largely-dummy <a href="#L274" title="optimizer/plan/planner.c:274">planner</a> state */<br/></li>
<li></span>&nbsp; &nbsp; query = makeNode(Query);<br/></li>
<li>&nbsp; &nbsp; query-&gt;commandType = CMD_SELECT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; glob = makeNode(PlannerGlobal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; root = makeNode(PlannerInfo);<br/></li>
<li>&nbsp; &nbsp; root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = query;<br/></li>
<li>&nbsp; &nbsp; root-&gt;glob = glob;<br/></li>
<li>&nbsp; &nbsp; root-&gt;query_level = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;planner_cxt = <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;wt_param_id = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;join_domains = list_make1(makeNode(JoinDomain));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build a minimal RTE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark the RTE with inh = true.&nbsp; This is a kludge to prevent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../util/plancat.c.html#L115" title="optimizer/util/plancat.c:115">get_relation_info</a>() from fetching index info, which is necessary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because it does not expect that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> IndexOptInfo is currently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * undergoing REINDEX.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rte = makeNode(RangeTblEntry);<br/></li>
<li>&nbsp; &nbsp; rte-&gt;rtekind = RTE_RELATION;<br/></li>
<li>&nbsp; &nbsp; rte-&gt;relid = tableOid;<br/></li>
<li>&nbsp; &nbsp; rte-&gt;relkind = RELKIND_RELATION;&nbsp; &nbsp; <span class="Comment">/* Don't be too picky. */<br/></li>
<li></span>&nbsp; &nbsp; rte-&gt;rellockmode = AccessShareLock;<br/></li>
<li>&nbsp; &nbsp; rte-&gt;lateral = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; rte-&gt;inh = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; rte-&gt;inFromCl = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; query-&gt;rtable = list_make1(rte);<br/></li>
<li>&nbsp; &nbsp; <a href="../../parser/parse_relation.c.html#L3874" title="parser/parse_relation.c:3874">addRTEPermissionInfo</a>(&amp;query-&gt;rteperminfos, rte);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up RTE/RelOptInfo arrays */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/relnode.c.html#L94" title="optimizer/util/relnode.c:94">setup_simple_rel_arrays</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build RelOptInfo */<br/></li>
<li></span>&nbsp; &nbsp; rel = <a href="../util/relnode.c.html#L192" title="optimizer/util/relnode.c:192">build_simple_rel</a>(root, <span class="Constant">1</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Rels are assumed already locked by the caller */<br/></li>
<li></span>&nbsp; &nbsp; heap = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(tableOid, NoLock);<br/></li>
<li>&nbsp; &nbsp; index = <a href="../../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(indexOid, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine if it's safe to proceed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Currently, parallel workers can't access the leader's temporary tables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Furthermore, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> index predicate or index expressions must be parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * safe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (heap-&gt;rd_rel-&gt;relpersistence == RELPERSISTENCE_TEMP ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../util/clauses.c.html#L753" title="optimizer/util/clauses.c:753">is_parallel_safe</a>(root, (Node *) <a href="../../utils/cache/relcache.c.html#L5025" title="utils/cache/relcache.c:5025">RelationGetIndexExpressions</a>(index)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../util/clauses.c.html#L753" title="optimizer/util/clauses.c:753">is_parallel_safe</a>(root, (Node *) <a href="../../utils/cache/relcache.c.html#L5138" title="utils/cache/relcache.c:5138">RelationGetIndexPredicate</a>(index)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parallel_workers = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> done;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If parallel_workers storage parameter is set for the table, <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as the number of parallel worker processes to launch (though still cap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * at <a href="../../utils/init/globals.c.html#L131" title="utils/init/globals.c:131">max_parallel_maintenance_workers</a>).&nbsp; Note that we deliberately do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consider <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other factor when parallel_workers is set. (e.g., memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use by workers.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rel_parallel_workers != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parallel_workers = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(rel-&gt;rel_parallel_workers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/init/globals.c.html#L131" title="utils/init/globals.c:131">max_parallel_maintenance_workers</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> done;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate heap relation size ourselves, since rel-&gt;pages cannot be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trusted (heap RTE was marked as inheritance parent)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/plancat.c.html#L1041" title="optimizer/util/plancat.c:1041">estimate_rel_size</a>(heap, <span class="Constant">NULL</span>, &amp;heap_blocks, &amp;reltuples, &amp;allvisfrac);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine number of workers to scan the heap relation using generic<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * model<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; parallel_workers = <a href="../path/allpaths.c.html#L4215" title="optimizer/path/allpaths.c:4215">compute_parallel_worker</a>(rel, heap_blocks, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/init/globals.c.html#L131" title="utils/init/globals.c:131">max_parallel_maintenance_workers</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Cap workers based on available <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a> as needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that each tuplesort participant receives an even share of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * total <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a> budget.&nbsp; Aim to leave participants<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (including the leader as a participant) with no less than 32MB of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory.&nbsp; This leaves cases where <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a> is set to 64MB<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * immediately past the threshold of being capable of launching a single<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parallel worker to sort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (parallel_workers &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a> / (parallel_workers + <span class="Constant">1</span>) &lt; <span class="Constant">32768L</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parallel_workers--;<br/></li>
<li><br/></li>
<li><span class="Statement">done</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(index, NoLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(heap, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> parallel_workers;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6791" title="optimizer/plan/planner.c:6791">make_ordered_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return a path ordered by 'pathkeys' based on the given 'path'.&nbsp; May<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; return NULL if it doesn't make sense to generate an ordered path in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; this case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Path *<br/></li>
<li><a id="L6791">&#x200c;</a><span class="linkable">make_ordered_path</span>(PlannerInfo *root, RelOptInfo *rel, Path *path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path *cheapest_path, List *pathkeys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_sorted;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; presorted_keys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; is_sorted = <a href="../path/pathkeys.c.html#L573" title="optimizer/path/pathkeys.c:573">pathkeys_count_contained_in</a>(pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path-&gt;pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;presorted_keys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!is_sorted)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try at least sorting the cheapest path and also try incrementally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sorting <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> path which is partially sorted already (no need to deal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with paths which have presorted keys when incremental sort is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * disabled unless it's the cheapest input path).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path != cheapest_path &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (presorted_keys == <span class="Constant">0</span> || !<a href="../path/costsize.c.html#L140" title="optimizer/path/costsize.c:140">enable_incremental_sort</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We've no need to consider both a sort and incremental sort. We'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just do a sort if there are no presorted keys and an incremental<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sort when there are presorted keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (presorted_keys == <span class="Constant">0</span> || !<a href="../path/costsize.c.html#L140" title="optimizer/path/costsize.c:140">enable_incremental_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path = (Path *) <a href="../util/pathnode.c.html#L3000" title="optimizer/util/pathnode.c:3000">create_sort_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -<span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path = (Path *) <a href="../util/pathnode.c.html#L2951" title="optimizer/util/pathnode.c:2951">create_incremental_sort_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; presorted_keys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -<span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> path;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6842" title="optimizer/plan/planner.c:6842">add_paths_to_grouping_rel</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Add non-partial paths to grouping relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6842">&#x200c;</a></span><span class="linkable">add_paths_to_grouping_rel</span>(PlannerInfo *root, RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *partially_grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> AggClauseCosts *agg_costs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L105" title="optimizer/plan/planner.c:105">grouping_sets_data</a> *gd, <span class="Type">double</span> dNumGroups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GroupPathExtraData *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *cheapest_path = input_rel-&gt;cheapest_total_path;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; can_hash = (extra-&gt;flags &amp; GROUPING_CAN_USE_HASH) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; can_sort = (extra-&gt;flags &amp; GROUPING_CAN_USE_SORT) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *havingQual = (List *) extra-&gt;havingQual;<br/></li>
<li>&nbsp; &nbsp; AggClauseCosts *agg_final_costs = &amp;extra-&gt;agg_final_costs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (can_sort)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> available suitably-sorted path as input, and also consider<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sorting the cheapest-total path and incremental sort on <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> paths<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with presorted keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, input_rel-&gt;pathlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path = (Path *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path_save = path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pathkey_orderings = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* generate alternative group orderings that might be useful */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkey_orderings = <a href="../path/pathkeys.c.html#L485" title="optimizer/path/pathkeys.c:485">get_useful_group_keys_orderings</a>(root, path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(pathkey_orderings) &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, pathkey_orderings)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathKeyInfo *info = (PathKeyInfo *) lfirst(lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* restore the path (we replace it in the loop) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path = path_save;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path = <a href="#L6791" title="optimizer/plan/planner.c:6791">make_ordered_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cheapest_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; info-&gt;pathkeys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now decide what to stick atop it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupingSets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4048" title="optimizer/plan/planner.c:4048">consider_groupingsets_paths</a>(root, grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path, <span class="Constant">true</span>, can_hash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gd, agg_costs, dNumGroups);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasAggs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have aggregation, possibly with plain GROUP BY. Make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an AggPath.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(grouped_rel, (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/pathnode.c.html#L3155" title="optimizer/util/pathnode.c:3155">create_agg_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; grouped_rel-&gt;reltarget,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause ? AGG_SORTED : AGG_PLAIN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AGGSPLIT_SIMPLE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; info-&gt;clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; havingQual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; agg_costs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dNumGroups));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have GROUP BY without aggregation or grouping sets.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make a GroupPath.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(grouped_rel, (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/pathnode.c.html#L3044" title="optimizer/util/pathnode.c:3044">create_group_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; info-&gt;clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; havingQual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dNumGroups));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Other cases should have been handled above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Instead of operating directly on the input relation, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consider finalizing a partially aggregated path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (partially_grouped_rel != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, partially_grouped_rel-&gt;pathlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path = (Path *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path_save = path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pathkey_orderings = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* generate alternative group orderings that might be useful */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkey_orderings = <a href="../path/pathkeys.c.html#L485" title="optimizer/path/pathkeys.c:485">get_useful_group_keys_orderings</a>(root, path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(pathkey_orderings) &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* process all potentially interesting grouping reorderings */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, pathkey_orderings)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathKeyInfo *info = (PathKeyInfo *) lfirst(lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* restore the path (we replace it in the loop) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path = path_save;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path = <a href="#L6791" title="optimizer/plan/planner.c:6791">make_ordered_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; partially_grouped_rel-&gt;cheapest_total_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; info-&gt;pathkeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasAggs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(grouped_rel, (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/pathnode.c.html#L3155" title="optimizer/util/pathnode.c:3155">create_agg_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; grouped_rel-&gt;reltarget,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause ? AGG_SORTED : AGG_PLAIN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AGGSPLIT_FINAL_DESERIAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; info-&gt;clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; havingQual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; agg_final_costs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dNumGroups));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(grouped_rel, (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/pathnode.c.html#L3044" title="optimizer/util/pathnode.c:3044">create_group_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; info-&gt;clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; havingQual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dNumGroups));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (can_hash)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupingSets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try for a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>-only groupingsets path over unsorted input.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4048" title="optimizer/plan/planner.c:4048">consider_groupingsets_paths</a>(root, grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cheapest_path, <span class="Constant">false</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gd, agg_costs, dNumGroups);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Generate a HashAgg Path.&nbsp; We just need an Agg over the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cheapest-total input path, since input order won't matter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(grouped_rel, (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/pathnode.c.html#L3155" title="optimizer/util/pathnode.c:3155">create_agg_path</a>(root, grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cheapest_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; grouped_rel-&gt;reltarget,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AGG_HASHED,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AGGSPLIT_SIMPLE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;processed_groupClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; havingQual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; agg_costs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dNumGroups));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Generate a Finalize HashAgg Path atop of the cheapest partially<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * grouped path, assuming there is one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (partially_grouped_rel &amp;&amp; partially_grouped_rel-&gt;pathlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path = partially_grouped_rel-&gt;cheapest_total_path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(grouped_rel, (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/pathnode.c.html#L3155" title="optimizer/util/pathnode.c:3155">create_agg_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; grouped_rel-&gt;reltarget,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AGG_HASHED,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AGGSPLIT_FINAL_DESERIAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;processed_groupClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; havingQual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; agg_final_costs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dNumGroups));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When partitionwise aggregate is used, we might have fully aggregated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * paths in the partial pathlist, because <a href="../path/allpaths.c.html#L1302" title="optimizer/path/allpaths.c:1302">add_paths_to_append_rel</a>() will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consider a path for grouped_rel consisting of a Parallel Append of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-partial paths from each child.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (grouped_rel-&gt;partial_pathlist != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7376" title="optimizer/plan/planner.c:7376">gather_grouping_paths</a>(root, grouped_rel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7077" title="optimizer/plan/planner.c:7077">create_partial_grouping_paths</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Create a new <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> relation representing the result of partial aggregation<br/></li>
<li></span><span class="Comment"> * and populate it with appropriate paths.&nbsp; Note that we don't finalize the<br/></li>
<li></span><span class="Comment"> * lists of paths here, so the caller can add additional partial or non-partial<br/></li>
<li></span><span class="Comment"> * paths and must afterward call <a href="#L7376" title="optimizer/plan/planner.c:7376">gather_grouping_paths</a> and <a href="../util/pathnode.c.html#L242" title="optimizer/util/pathnode.c:242">set_cheapest</a> on<br/></li>
<li></span><span class="Comment"> * the returned <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All paths for this new <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> relation -- both partial and non-partial --<br/></li>
<li></span><span class="Comment"> * have been partially aggregated but require a subsequent FinalizeAggregate<br/></li>
<li></span><span class="Comment"> * step.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: This function is allowed to return NULL if it determines that there is<br/></li>
<li></span><span class="Comment"> * no real need to create a new RelOptInfo.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> RelOptInfo *<br/></li>
<li><a id="L7077">&#x200c;</a><span class="linkable">create_partial_grouping_paths</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L105" title="optimizer/plan/planner.c:105">grouping_sets_data</a> *gd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GroupPathExtraData *extra,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> force_rel_creation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *partially_grouped_rel;<br/></li>
<li>&nbsp; &nbsp; AggClauseCosts *agg_partial_costs = &amp;extra-&gt;agg_partial_costs;<br/></li>
<li>&nbsp; &nbsp; AggClauseCosts *agg_final_costs = &amp;extra-&gt;agg_final_costs;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *cheapest_partial_path = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *cheapest_total_path = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; dNumPartialGroups = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; dNumPartialPartialGroups = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; can_hash = (extra-&gt;flags &amp; GROUPING_CAN_USE_HASH) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; can_sort = (extra-&gt;flags &amp; GROUPING_CAN_USE_SORT) != <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Consider whether we should generate partially aggregated non-partial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * paths.&nbsp; We can only do this if we have a non-partial path, and only if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the parent of the input rel is performing partial partitionwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggregation.&nbsp; (Note that extra-&gt;patype is the type of partitionwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggregation being used at the parent level, not this level.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (input_rel-&gt;pathlist != NIL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; extra-&gt;patype == PARTITIONWISE_AGGREGATE_PARTIAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cheapest_total_path = input_rel-&gt;cheapest_total_path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If parallelism is possible for grouped_rel, then we should consider<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * generating partially-grouped partial paths.&nbsp; However, if the input rel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has no partial paths, then we can't.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (grouped_rel-&gt;consider_parallel &amp;&amp; input_rel-&gt;partial_pathlist != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cheapest_partial_path = linitial(input_rel-&gt;partial_pathlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we can't partially aggregate partial paths, and we can't partially<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggregate non-partial paths, then don't bother creating the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * RelOptInfo at all, unless the caller specified force_rel_creation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cheapest_total_path == <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cheapest_partial_path == <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !force_rel_creation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build a new <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> relation to represent the result of partially<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggregating the rows from the input relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; partially_grouped_rel = <a href="../util/relnode.c.html#L1470" title="optimizer/util/relnode.c:1470">fetch_upper_rel</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UPPERREL_PARTIAL_GROUP_AGG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grouped_rel-&gt;relids);<br/></li>
<li>&nbsp; &nbsp; partially_grouped_rel-&gt;consider_parallel =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; grouped_rel-&gt;consider_parallel;<br/></li>
<li>&nbsp; &nbsp; partially_grouped_rel-&gt;reloptkind = grouped_rel-&gt;reloptkind;<br/></li>
<li>&nbsp; &nbsp; partially_grouped_rel-&gt;serverid = grouped_rel-&gt;serverid;<br/></li>
<li>&nbsp; &nbsp; partially_grouped_rel-&gt;userid = grouped_rel-&gt;userid;<br/></li>
<li>&nbsp; &nbsp; partially_grouped_rel-&gt;useridiscurrent = grouped_rel-&gt;useridiscurrent;<br/></li>
<li>&nbsp; &nbsp; partially_grouped_rel-&gt;fdwroutine = grouped_rel-&gt;fdwroutine;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build target list for partial aggregate paths.&nbsp; These paths cannot just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * emit the same tlist as regular aggregate paths, because (1) we must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * include Vars and Aggrefs needed in HAVING, which might not appear in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the result tlist, and (2) the Aggrefs must be set in partial mode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; partially_grouped_rel-&gt;reltarget =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5409" title="optimizer/plan/planner.c:5409">make_partial_grouping_target</a>(root, grouped_rel-&gt;reltarget,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; extra-&gt;havingQual);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!extra-&gt;partial_costs_set)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Collect statistics about aggregates for estimating costs of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * performing aggregation in parallel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(agg_partial_costs, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AggClauseCosts));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(agg_final_costs, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AggClauseCosts));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasAggs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* partial phase */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../prep/prepagg.c.html#L560" title="optimizer/prep/prepagg.c:560">get_agg_clause_costs</a>(root, AGGSPLIT_INITIAL_SERIAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; agg_partial_costs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* final phase */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../prep/prepagg.c.html#L560" title="optimizer/prep/prepagg.c:560">get_agg_clause_costs</a>(root, AGGSPLIT_FINAL_DESERIAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; agg_final_costs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; extra-&gt;partial_costs_set = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Estimate number of partial groups. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cheapest_total_path != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dNumPartialGroups =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3536" title="optimizer/plan/planner.c:3536">get_number_of_groups</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cheapest_total_path-&gt;rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; extra-&gt;targetList);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cheapest_partial_path != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dNumPartialPartialGroups =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3536" title="optimizer/plan/planner.c:3536">get_number_of_groups</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cheapest_partial_path-&gt;rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; extra-&gt;targetList);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (can_sort &amp;&amp; cheapest_total_path != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This should have been checked previously */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasAggs || <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> available suitably-sorted path as input, and also consider<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sorting the cheapest partial path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, input_rel-&gt;pathlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path = (Path *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path_save = path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pathkey_orderings = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* generate alternative group orderings that might be useful */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkey_orderings = <a href="../path/pathkeys.c.html#L485" title="optimizer/path/pathkeys.c:485">get_useful_group_keys_orderings</a>(root, path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(pathkey_orderings) &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* process all potentially interesting grouping reorderings */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, pathkey_orderings)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathKeyInfo *info = (PathKeyInfo *) lfirst(lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* restore the path (we replace it in the loop) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path = path_save;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path = <a href="#L6791" title="optimizer/plan/planner.c:6791">make_ordered_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; partially_grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cheapest_total_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; info-&gt;pathkeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasAggs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(partially_grouped_rel, (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/pathnode.c.html#L3155" title="optimizer/util/pathnode.c:3155">create_agg_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; partially_grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; partially_grouped_rel-&gt;reltarget,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause ? AGG_SORTED : AGG_PLAIN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AGGSPLIT_INITIAL_SERIAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; info-&gt;clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; agg_partial_costs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dNumPartialGroups));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(partially_grouped_rel, (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/pathnode.c.html#L3044" title="optimizer/util/pathnode.c:3044">create_group_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; partially_grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; info-&gt;clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dNumPartialGroups));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (can_sort &amp;&amp; cheapest_partial_path != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Similar to above logic, but for partial paths. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, input_rel-&gt;partial_pathlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path = (Path *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path_save = path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pathkey_orderings = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* generate alternative group orderings that might be useful */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkey_orderings = <a href="../path/pathkeys.c.html#L485" title="optimizer/path/pathkeys.c:485">get_useful_group_keys_orderings</a>(root, path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(pathkey_orderings) &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* process all potentially interesting grouping reorderings */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, pathkey_orderings)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathKeyInfo *info = (PathKeyInfo *) lfirst(lc2);<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* restore the path (we replace it in the loop) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path = path_save;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path = <a href="#L6791" title="optimizer/plan/planner.c:6791">make_ordered_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; partially_grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cheapest_partial_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; info-&gt;pathkeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasAggs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L747" title="optimizer/util/pathnode.c:747">add_partial_path</a>(partially_grouped_rel, (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/pathnode.c.html#L3155" title="optimizer/util/pathnode.c:3155">create_agg_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; partially_grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; partially_grouped_rel-&gt;reltarget,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause ? AGG_SORTED : AGG_PLAIN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AGGSPLIT_INITIAL_SERIAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; info-&gt;clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; agg_partial_costs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dNumPartialPartialGroups));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L747" title="optimizer/util/pathnode.c:747">add_partial_path</a>(partially_grouped_rel, (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/pathnode.c.html#L3044" title="optimizer/util/pathnode.c:3044">create_group_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; partially_grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; info-&gt;clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dNumPartialPartialGroups));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add a partially-grouped HashAgg Path where possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (can_hash &amp;&amp; cheapest_total_path != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Checked above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasAggs || <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(partially_grouped_rel, (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/pathnode.c.html#L3155" title="optimizer/util/pathnode.c:3155">create_agg_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; partially_grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cheapest_total_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; partially_grouped_rel-&gt;reltarget,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AGG_HASHED,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AGGSPLIT_INITIAL_SERIAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;processed_groupClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; agg_partial_costs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dNumPartialGroups));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now add a partially-grouped HashAgg partial Path where possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (can_hash &amp;&amp; cheapest_partial_path != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L747" title="optimizer/util/pathnode.c:747">add_partial_path</a>(partially_grouped_rel, (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/pathnode.c.html#L3155" title="optimizer/util/pathnode.c:3155">create_agg_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; partially_grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cheapest_partial_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; partially_grouped_rel-&gt;reltarget,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AGG_HASHED,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AGGSPLIT_INITIAL_SERIAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;processed_groupClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; agg_partial_costs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dNumPartialPartialGroups));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is an FDW that's responsible for all baserels of the query,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * let it consider adding partially grouped ForeignPaths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (partially_grouped_rel-&gt;fdwroutine &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partially_grouped_rel-&gt;fdwroutine-&gt;GetForeignUpperPaths)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FdwRoutine *fdwroutine = partially_grouped_rel-&gt;fdwroutine;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fdwroutine-&gt;GetForeignUpperPaths(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; UPPERREL_PARTIAL_GROUP_AGG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; input_rel, partially_grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; extra);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> partially_grouped_rel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generate Gather and Gather Merge paths for a grouping relation or partial<br/></li>
<li></span><span class="Comment"> * grouping relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../path/allpaths.c.html#L3202" title="optimizer/path/allpaths.c:3202">generate_useful_gather_paths</a> does most of the work, but we also consider a<br/></li>
<li></span><span class="Comment"> * special case: we could try sorting the data by the group_pathkeys and then<br/></li>
<li></span><span class="Comment"> * applying Gather Merge.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: This function shouldn't be used for anything other than a grouped or<br/></li>
<li></span><span class="Comment"> * partially grouped relation not only because of the fact that it explicitly<br/></li>
<li></span><span class="Comment"> * references group_pathkeys but we pass &quot;true&quot; as the third argument to<br/></li>
<li></span><span class="Comment"> * <a href="../path/allpaths.c.html#L3202" title="optimizer/path/allpaths.c:3202">generate_useful_gather_paths</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L7376">&#x200c;</a></span><span class="linkable">gather_grouping_paths</span>(PlannerInfo *root, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *cheapest_partial_path;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *groupby_pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This occurs after <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> partial aggregation has taken place, so trim off<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pathkeys added for ORDER BY / DISTINCT aggregates.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(root-&gt;group_pathkeys) &gt; root-&gt;num_groupby_pathkeys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; groupby_pathkeys = <a href="../../nodes/list.c.html#L1593" title="nodes/list.c:1593">list_copy_head</a>(root-&gt;group_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;num_groupby_pathkeys);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; groupby_pathkeys = root-&gt;group_pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try Gather for unordered paths and Gather Merge for ordered ones. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../path/allpaths.c.html#L3202" title="optimizer/path/allpaths.c:3202">generate_useful_gather_paths</a>(root, rel, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cheapest_partial_path = linitial(rel-&gt;partial_pathlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> Shouldn't this also consider the group-key-reordering? */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, rel-&gt;partial_pathlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path = (Path *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_sorted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; presorted_keys;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; total_groups;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; is_sorted = <a href="../path/pathkeys.c.html#L573" title="optimizer/path/pathkeys.c:573">pathkeys_count_contained_in</a>(groupby_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path-&gt;pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;presorted_keys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_sorted)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try at least sorting the cheapest path and also try incrementally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sorting <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> path which is partially sorted already (no need to deal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with paths which have presorted keys when incremental sort is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * disabled unless it's the cheapest input path).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path != cheapest_partial_path &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (presorted_keys == <span class="Constant">0</span> || !<a href="../path/costsize.c.html#L140" title="optimizer/path/costsize.c:140">enable_incremental_sort</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; total_groups = path-&gt;rows * path-&gt;parallel_workers;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We've no need to consider both a sort and incremental sort. We'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just do a sort if there are no presorted keys and an incremental<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sort when there are presorted keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (presorted_keys == <span class="Constant">0</span> || !<a href="../path/costsize.c.html#L140" title="optimizer/path/costsize.c:140">enable_incremental_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path = (Path *) <a href="../util/pathnode.c.html#L3000" title="optimizer/util/pathnode.c:3000">create_sort_path</a>(root, rel, path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; groupby_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -<span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path = (Path *) <a href="../util/pathnode.c.html#L2951" title="optimizer/util/pathnode.c:2951">create_incremental_sort_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; groupby_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; presorted_keys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -<span class="Constant">1.0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path = (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L1881" title="optimizer/util/pathnode.c:1881">create_gather_merge_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;reltarget,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; groupby_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;total_groups);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, path);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7461" title="optimizer/plan/planner.c:7461">can_partial_agg</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Determines whether or not partial grouping and/or aggregation is possible.<br/></li>
<li></span><span class="Comment"> * Returns true when possible, false otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L7461">&#x200c;</a></span><span class="linkable">can_partial_agg</span>(PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasAggs &amp;&amp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause == NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't know how to do parallel aggregation unless we have either<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * some aggregates or a grouping clause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupingSets)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't know how to do grouping sets in parallel. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (root-&gt;hasNonPartialAggs || root-&gt;hasNonSerialAggs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Insufficient support for partial mode. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Everything looks good. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7503" title="optimizer/plan/planner.c:7503">apply_scanjoin_target_to_paths</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Adjust the final scan/join relation, and recursively all of its children,<br/></li>
<li></span><span class="Comment"> * to generate the final scan/join target.&nbsp; It would be more correct to model<br/></li>
<li></span><span class="Comment"> * this as a separate planning step with a new RelOptInfo at the toplevel and<br/></li>
<li></span><span class="Comment"> * for each child relation, but doing it this way is noticeably cheaper.<br/></li>
<li></span><span class="Comment"> * Maybe that problem can be solved at some point, but for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we do this.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If <a href="../util/tlist.c.html#L218" title="optimizer/util/tlist.c:218">tlist_same_exprs</a> is true, then the scan/join target to be applied has<br/></li>
<li></span><span class="Comment"> * the same expressions as the existing reltarget, so we need only insert the<br/></li>
<li></span><span class="Comment"> * appropriate sortgroupref information.&nbsp; By avoiding the creation of<br/></li>
<li></span><span class="Comment"> * projection paths we save effort both immediately and at plan creation time.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L7503">&#x200c;</a></span><span class="linkable">apply_scanjoin_target_to_paths</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *scanjoin_targets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *scanjoin_targets_contain_srfs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> scanjoin_target_parallel_safe,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="../util/tlist.c.html#L218" title="optimizer/util/tlist.c:218">tlist_same_exprs</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; rel_is_partitioned = IS_PARTITIONED_REL(rel);<br/></li>
<li>&nbsp; &nbsp; PathTarget *scanjoin_target;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This recurses, so be paranoid. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the rel is partitioned, we want to drop its existing paths and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * generate new ones.&nbsp; This function would still be correct if we kept the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * existing paths: we'd modify them to generate the correct target above<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the partitioning Append, and then they'd compete on cost with paths<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * generating the target below the Append.&nbsp; However, in our current cost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * model the latter way is always the same or cheaper cost, so modifying<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the existing paths would just be useless work.&nbsp; Moreover, when the cost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is the same, varying roundoff errors might sometimes allow an existing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * path to be picked, resulting in undesirable cross-platform plan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * variations.&nbsp; So we drop old paths and thereby force the work to be done<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * below the Append, except in the case of a non-parallel-safe target.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Some care is needed, because we have to allow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../path/allpaths.c.html#L3202" title="optimizer/path/allpaths.c:3202">generate_useful_gather_paths</a> to see the old partial paths in the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stanza.&nbsp; Hence, zap the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> pathlist here, then allow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../path/allpaths.c.html#L3202" title="optimizer/path/allpaths.c:3202">generate_useful_gather_paths</a> to add path(s) to the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> list, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * finally zap the partial pathlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel_is_partitioned)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;pathlist = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the scan/join target is not parallel-safe, partial paths cannot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * generate it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!scanjoin_target_parallel_safe)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since we can't generate the final scan/join target in parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * workers, this is our last opportunity to use <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> partial paths that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exist; so build Gather path(s) that use them and emit whatever the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current reltarget is.&nbsp; We don't do this in the case where the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * target is parallel-safe, since we will be able to generate superior<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * paths by doing it after the final scan/join target has been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * applied.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/allpaths.c.html#L3202" title="optimizer/path/allpaths.c:3202">generate_useful_gather_paths</a>(root, rel, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can't use parallel query above this level. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;partial_pathlist = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;consider_parallel = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finish dropping old paths for a partitioned rel, per comment above */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel_is_partitioned)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;partial_pathlist = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Extract SRF-free scan/join target. */<br/></li>
<li></span>&nbsp; &nbsp; scanjoin_target = linitial_node(PathTarget, scanjoin_targets);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Apply the SRF-free scan/join target to each existing path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the tlist exprs are the same, we can just inject the sortgroupref<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * information into the existing pathtargets.&nbsp; Otherwise, replace each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * path with a projection path that generates the SRF-free scan/join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * target.&nbsp; This can't change the ordering of paths within rel-&gt;pathlist,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so we just modify the list in place.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, rel-&gt;pathlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *subpath = (Path *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Shouldn't have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> parameterized paths anymore */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(subpath-&gt;param_info == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/tlist.c.html#L218" title="optimizer/util/tlist.c:218">tlist_same_exprs</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;pathtarget-&gt;sortgrouprefs =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanjoin_target-&gt;sortgrouprefs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *newpath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newpath = (Path *) <a href="../util/pathnode.c.html#L2685" title="optimizer/util/pathnode.c:2685">create_projection_path</a>(root, rel, subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanjoin_target);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lfirst(lc) = newpath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Likewise adjust the targets for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> partial paths. */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, rel-&gt;partial_pathlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *subpath = (Path *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Shouldn't have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> parameterized paths anymore */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(subpath-&gt;param_info == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/tlist.c.html#L218" title="optimizer/util/tlist.c:218">tlist_same_exprs</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;pathtarget-&gt;sortgrouprefs =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanjoin_target-&gt;sortgrouprefs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *newpath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newpath = (Path *) <a href="../util/pathnode.c.html#L2685" title="optimizer/util/pathnode.c:2685">create_projection_path</a>(root, rel, subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanjoin_target);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lfirst(lc) = newpath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now, if final scan/join target contains SRFs, insert ProjectSetPath(s)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * atop each existing path.&nbsp; (Note that this function doesn't look at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cheapest-path fields, which is a good thing because they're bogus right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasTargetSRFs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6341" title="optimizer/plan/planner.c:6341">adjust_paths_for_srfs</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanjoin_targets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanjoin_targets_contain_srfs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update the rel's target to be the final (with SRFs) scan/join target.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> matches the actual output of all the paths, and we might get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * confused in createplan.c if they don't agree.&nbsp; We must do this <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> append paths made in the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> part will use the correct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pathtarget (cf. <a href="../util/pathnode.c.html#L1244" title="optimizer/util/pathnode.c:1244">create_append_path</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that this is also necessary if GetForeignUpperPaths() gets called<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on the final scan/join relation or on <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of its children, since the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * FDW might look at the rel's target to create ForeignPaths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;reltarget = llast_node(PathTarget, scanjoin_targets);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the relation is partitioned, recursively apply the scan/join target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to all partitions, and generate brand-new Append paths in which the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan/join target is computed below the Append rather than above it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since Append is not projection-capable, that might save a separate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Result node, and it also is important for partitionwise aggregate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel_is_partitioned)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *live_children = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Adjust each partition. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; i = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((i = <a href="../../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(rel-&gt;live_parts, i)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *child_rel = rel-&gt;part_rels[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AppendRelInfo **appinfos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nappinfos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *child_scanjoin_targets = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(child_rel != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Dummy children can be ignored. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IS_DUMMY_REL(child_rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Translate scan/join targets for this child. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appinfos = <a href="../util/appendinfo.c.html#L733" title="optimizer/util/appendinfo.c:733">find_appinfos_by_relids</a>(root, child_rel-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;nappinfos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, scanjoin_targets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathTarget *target = lfirst_node(PathTarget, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target = <a href="../util/tlist.c.html#L657" title="optimizer/util/tlist.c:657">copy_pathtarget</a>(target);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target-&gt;exprs = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/appendinfo.c.html#L196" title="optimizer/util/appendinfo.c:196">adjust_appendrel_attrs</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) target-&gt;exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nappinfos, appinfos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_scanjoin_targets = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(child_scanjoin_targets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; target);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(appinfos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recursion does the real work. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7503" title="optimizer/plan/planner.c:7503">apply_scanjoin_target_to_paths</a>(root, child_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; child_scanjoin_targets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scanjoin_targets_contain_srfs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scanjoin_target_parallel_safe,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/tlist.c.html#L218" title="optimizer/util/tlist.c:218">tlist_same_exprs</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Save non-dummy children for Append paths. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IS_DUMMY_REL(child_rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; live_children = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(live_children, child_rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Build new paths for this relation by appending child paths. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/allpaths.c.html#L1302" title="optimizer/path/allpaths.c:1302">add_paths_to_append_rel</a>(root, rel, live_children);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Consider generating Gather or Gather Merge paths.&nbsp; We must only do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if the relation is parallel safe, and we don't do it for child rels to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * avoid creating multiple Gather nodes within the same plan. We must do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this after all paths have been generated and <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../util/pathnode.c.html#L242" title="optimizer/util/pathnode.c:242">set_cheapest</a>, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one of the generated paths may turn out to be the cheapest one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;consider_parallel &amp;&amp; !IS_OTHER_REL(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/allpaths.c.html#L3202" title="optimizer/path/allpaths.c:3202">generate_useful_gather_paths</a>(root, rel, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reassess which paths are the cheapest, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that we've potentially added<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new Gather (or Gather Merge) and/or Append (or MergeAppend) paths to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/pathnode.c.html#L242" title="optimizer/util/pathnode.c:242">set_cheapest</a>(rel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7738" title="optimizer/plan/planner.c:7738">create_partitionwise_grouping_paths</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the partition keys of input relation are part of the GROUP BY clause, all<br/></li>
<li></span><span class="Comment"> * the rows belonging to a given group come from a single partition.&nbsp; This<br/></li>
<li></span><span class="Comment"> * allows aggregation/grouping over a partitioned relation to be broken down<br/></li>
<li></span><span class="Comment"> * into aggregation/grouping on each partition.&nbsp; This should be no worse, and<br/></li>
<li></span><span class="Comment"> * often better, than the normal approach.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * However, if the GROUP BY clause does not contain all the partition keys,<br/></li>
<li></span><span class="Comment"> * rows from a given group may be spread across multiple partitions. In that<br/></li>
<li></span><span class="Comment"> * case, we perform partial aggregation for each group, append the results,<br/></li>
<li></span><span class="Comment"> * and then finalize aggregation.&nbsp; This is less certain to win than the<br/></li>
<li></span><span class="Comment"> * previous case.&nbsp; It may win if the PartialAggregate stage greatly reduces<br/></li>
<li></span><span class="Comment"> * the number of groups, because fewer rows will pass through the Append node.<br/></li>
<li></span><span class="Comment"> * It may lose if we have lots of small groups.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L7738">&#x200c;</a></span><span class="linkable">create_partitionwise_grouping_paths</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *partially_grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> AggClauseCosts *agg_costs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L105" title="optimizer/plan/planner.c:105">grouping_sets_data</a> *gd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PartitionwiseAggregateType patype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GroupPathExtraData *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *grouped_live_children = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *partially_grouped_live_children = NIL;<br/></li>
<li>&nbsp; &nbsp; PathTarget *target = grouped_rel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; partial_grouping_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(patype != PARTITIONWISE_AGGREGATE_NONE);<br/></li>
<li>&nbsp; &nbsp; Assert(patype != PARTITIONWISE_AGGREGATE_PARTIAL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; partially_grouped_rel != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add paths for partitionwise aggregation/grouping. */<br/></li>
<li></span>&nbsp; &nbsp; i = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((i = <a href="../../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(input_rel-&gt;live_parts, i)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *child_input_rel = input_rel-&gt;part_rels[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathTarget *child_target;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AppendRelInfo **appinfos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nappinfos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GroupPathExtraData child_extra;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *child_grouped_rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *child_partially_grouped_rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(child_input_rel != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Dummy children can be ignored. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IS_DUMMY_REL(child_input_rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; child_target = <a href="../util/tlist.c.html#L657" title="optimizer/util/tlist.c:657">copy_pathtarget</a>(target);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy the given &quot;extra&quot; structure as is and then override the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * members specific to this child.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;child_extra, extra, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(child_extra));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appinfos = <a href="../util/appendinfo.c.html#L733" title="optimizer/util/appendinfo.c:733">find_appinfos_by_relids</a>(root, child_input_rel-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;nappinfos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; child_target-&gt;exprs = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/appendinfo.c.html#L196" title="optimizer/util/appendinfo.c:196">adjust_appendrel_attrs</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) target-&gt;exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nappinfos, appinfos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Translate havingQual and targetList. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; child_extra.havingQual = (Node *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/appendinfo.c.html#L196" title="optimizer/util/appendinfo.c:196">adjust_appendrel_attrs</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; extra-&gt;havingQual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nappinfos, appinfos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; child_extra.targetList = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/appendinfo.c.html#L196" title="optimizer/util/appendinfo.c:196">adjust_appendrel_attrs</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) extra-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nappinfos, appinfos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * extra-&gt;patype was the value computed for our parent rel; patype is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the value for this relation.&nbsp; For the child, our value is its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parent rel's value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; child_extra.patype = patype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create grouping relation to hold fully aggregated grouping and/or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aggregation paths for the child.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; child_grouped_rel = <a href="#L3771" title="optimizer/plan/planner.c:3771">make_grouping_rel</a>(root, child_input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra-&gt;target_parallel_safe,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_extra.havingQual);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create grouping paths for this child relation. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3909" title="optimizer/plan/planner.c:3909">create_ordinary_grouping_paths</a>(root, child_input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; child_grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; agg_costs, gd, &amp;child_extra,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;child_partially_grouped_rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (child_partially_grouped_rel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partially_grouped_live_children =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(partially_grouped_live_children,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_partially_grouped_rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partial_grouping_valid = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (patype == PARTITIONWISE_AGGREGATE_FULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L242" title="optimizer/util/pathnode.c:242">set_cheapest</a>(child_grouped_rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grouped_live_children = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(grouped_live_children,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_grouped_rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(appinfos);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to create append paths for partially grouped children. For full<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partitionwise aggregation, we might have paths in the partial_pathlist<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if parallel aggregation is possible.&nbsp; For partial partitionwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggregation, we may have paths in both pathlist and partial_pathlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: We must have a partially grouped path for every child in order to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * generate a partially grouped path for this relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (partially_grouped_rel &amp;&amp; partial_grouping_valid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(partially_grouped_live_children != NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/allpaths.c.html#L1302" title="optimizer/path/allpaths.c:1302">add_paths_to_append_rel</a>(root, partially_grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partially_grouped_live_children);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need call <a href="../util/pathnode.c.html#L242" title="optimizer/util/pathnode.c:242">set_cheapest</a>, since the finalization step will use the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cheapest path from the rel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (partially_grouped_rel-&gt;pathlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L242" title="optimizer/util/pathnode.c:242">set_cheapest</a>(partially_grouped_rel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If possible, create append paths for fully grouped children. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (patype == PARTITIONWISE_AGGREGATE_FULL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(grouped_live_children != NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/allpaths.c.html#L1302" title="optimizer/path/allpaths.c:1302">add_paths_to_append_rel</a>(root, grouped_rel, grouped_live_children);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7882" title="optimizer/plan/planner.c:7882">group_by_has_partkey</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true, if all the partition keys of the given relation are part of<br/></li>
<li></span><span class="Comment"> * the GROUP BY clauses, false otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L7882">&#x200c;</a></span><span class="linkable">group_by_has_partkey</span>(RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *groupClause)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *groupexprs = <a href="../util/tlist.c.html#L392" title="optimizer/util/tlist.c:392">get_sortgrouplist_exprs</a>(groupClause, targetList);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partnatts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Input relation should be partitioned. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(input_rel-&gt;part_scheme);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Rule out early, if there are no partition keys present. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!input_rel-&gt;partexprs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; partnatts = input_rel-&gt;part_scheme-&gt;partnatts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (cnt = <span class="Constant">0</span>; cnt &lt; partnatts; cnt++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *partexprs = input_rel-&gt;partexprs[cnt];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, partexprs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *partexpr = lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/list.c.html#L661" title="nodes/list.c:661">list_member</a>(groupexprs, partexpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If <a href="../util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of the partition key expressions match with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * GROUP BY expression, return false.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7939" title="optimizer/plan/planner.c:7939">generate_setop_child_grouplist</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Build a SortGroupClause list defining the sort/grouping properties<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; of the child of a set operation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is similar to <a href="../prep/prepunion.c.html#L1674" title="optimizer/prep/prepunion.c:1674">generate_setop_grouplist</a>() but differs as the setop<br/></li>
<li></span><span class="Comment"> * child query's targetlist entries may already have a tleSortGroupRef<br/></li>
<li></span><span class="Comment"> * assigned for other purposes, such as GROUP BYs.&nbsp; Here we keep the<br/></li>
<li></span><span class="Comment"> * SortGroupClause list in the same order as 'op' groupClauses and just adjust<br/></li>
<li></span><span class="Comment"> * the tleSortGroupRef to reference the TargetEntry's 'ressortgroupref'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L7939">&#x200c;</a><span class="linkable">generate_setop_child_grouplist</span>(SetOperationStmt *op, List *targetlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *grouplist = copyObject(op-&gt;groupClauses);<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lg;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lg = list_head(grouplist);<br/></li>
<li>&nbsp; &nbsp; foreach(lt, targetlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(lt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *sgc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* resjunk columns could have sortgrouprefs.&nbsp; Leave these alone */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we expect every non-resjunk target to have a SortGroupClause */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(lg != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sgc = (SortGroupClause *) lfirst(lg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lg = lnext(grouplist, lg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* assign a tleSortGroupRef, or reuse the existing one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sgc-&gt;tleSortGroupRef = <a href="../../parser/parse_clause.c.html#L3592" title="parser/parse_clause.c:3592">assignSortGroupRef</a>(tle, targetlist);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(lg == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> grouplist;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
