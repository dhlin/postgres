<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>optimizer/plan/subselect.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>optimizer/plan/subselect.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L42">convert_testexpr_context</a></li>
<li><a href="#L46">convert_testexpr_context</a></li>
<li><a href="#L54">finalize_primnode_context</a></li>
<li><a href="#L58">finalize_primnode_context</a></li>
<li><a href="#L60">inline_cte_walker_context</a></li>
<li><a href="#L65">inline_cte_walker_context</a></li>
<li><a href="#L48">process_sublinks_context</a></li>
<li><a href="#L52">process_sublinks_context</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L2239">SS_attach_initplans</a></li>
<li><a href="#L2134">SS_charge_for_initplans</a></li>
<li><a href="#L2198">SS_compute_initplan_cost</a></li>
<li><a href="#L2254">SS_finalize_plan</a></li>
<li><a href="#L2072">SS_identify_outer_params</a></li>
<li><a href="#L3017">SS_make_initplan_from_plan</a></li>
<li><a href="#L3001">SS_make_initplan_output_param</a></li>
<li><a href="#L880">SS_process_ctes</a></li>
<li><a href="#L1919">SS_process_sublinks</a></li>
<li><a href="#L1868">SS_replace_correlation_vars</a></li>
<li><a href="#L319">build_subplan</a></li>
<li><a href="#L1056">contain_dml</a></li>
<li><a href="#L1062">contain_dml_walker</a></li>
<li><a href="#L1083">contain_outer_selfref</a></li>
<li><a href="#L1097">contain_outer_selfref_walker</a></li>
<li><a href="#L1254">convert_ANY_sublink_to_join</a></li>
<li><a href="#L1371">convert_EXISTS_sublink_to_join</a></li>
<li><a href="#L1628">convert_EXISTS_to_ANY</a></li>
<li><a href="#L642">convert_testexpr</a></li>
<li><a href="#L654">convert_testexpr_mutator</a></li>
<li><a href="#L2974">finalize_agg_primnode</a></li>
<li><a href="#L2292">finalize_plan</a></li>
<li><a href="#L2890">finalize_primnode</a></li>
<li><a href="#L580">generate_subquery_params</a></li>
<li><a href="#L613">generate_subquery_vars</a></li>
<li><a href="#L118">get_first_col_type</a></li>
<li><a href="#L832">hash_ok_operator</a></li>
<li><a href="#L1138">inline_cte</a></li>
<li><a href="#L1151">inline_cte_walker</a></li>
<li><a href="#L162">make_subplan</a></li>
<li><a href="#L1929">process_sublinks_mutator</a></li>
<li><a href="#L1875">replace_correlation_vars_mutator</a></li>
<li><a href="#L1540">simplify_EXISTS_query</a></li>
<li><a href="#L736">subpath_is_hashable</a></li>
<li><a href="#L712">subplan_is_hashable</a></li>
<li><a href="#L792">test_opexpr_is_hashable</a></li>
<li><a href="#L761">testexpr_is_hashable</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * subselect.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Planning routines for subselects.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This module deals with SubLinks and CTEs, but not subquery RTEs (i.e.,<br/></li>
<li></span><span class="Comment"> * not sub-SELECT-in-FROM cases).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/optimizer/plan/subselect.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_operator.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/clauses.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/cost.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/paramassign.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/pathnode.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/planmain.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/<a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/prep.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/subselect.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_relation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;rewrite/rewriteManip.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L42">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">convert_testexpr_context</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *root;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *subst_nodes;&nbsp; &nbsp; <span class="Comment">/* Nodes to substitute for Params */<br/></li>
<li><a id="L46">&#x200c;</a></span>} <span class="linkable">convert_testexpr_context</span>;<br/></li>
<li><br/></li>
<li><a id="L48">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">process_sublinks_context</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *root;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isTopQual;<br/></li>
<li><a id="L52">&#x200c;</a>} <span class="linkable">process_sublinks_context</span>;<br/></li>
<li><br/></li>
<li><a id="L54">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">finalize_primnode_context</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *root;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *paramids;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Non-local PARAM_EXEC paramids found */<br/></li>
<li><a id="L58">&#x200c;</a></span>} <span class="linkable">finalize_primnode_context</span>;<br/></li>
<li><br/></li>
<li><a id="L60">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">inline_cte_walker_context</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *ctename;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* name and relative level of target CTE */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; levelsup;<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *ctequery;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* query to substitute */<br/></li>
<li><a id="L65">&#x200c;</a></span>} <span class="linkable">inline_cte_walker_context</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> Node *<a href="#L319" title="optimizer/plan/subselect.c:319">build_subplan</a>(PlannerInfo *root, Plan *plan, Path *path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PlannerInfo *subroot, List *plan_params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SubLinkType subLinkType, <span class="Type">int</span> subLinkId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *testexpr, List *testexpr_paramids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> unknownEqFalse);<br/></li>
<li><span class="Type">static</span> List *<a href="#L580" title="optimizer/plan/subselect.c:580">generate_subquery_params</a>(PlannerInfo *root, List *tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **paramIds);<br/></li>
<li><span class="Type">static</span> List *<a href="#L613" title="optimizer/plan/subselect.c:613">generate_subquery_vars</a>(PlannerInfo *root, List *tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index varno);<br/></li>
<li><span class="Type">static</span> Node *<a href="#L642" title="optimizer/plan/subselect.c:642">convert_testexpr</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *testexpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *subst_nodes);<br/></li>
<li><span class="Type">static</span> Node *<a href="#L654" title="optimizer/plan/subselect.c:654">convert_testexpr_mutator</a>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L42" title="optimizer/plan/subselect.c:42">convert_testexpr_context</a> *context);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L712" title="optimizer/plan/subselect.c:712">subplan_is_hashable</a>(Plan *plan);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L736" title="optimizer/plan/subselect.c:736">subpath_is_hashable</a>(Path *path);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L761" title="optimizer/plan/subselect.c:761">testexpr_is_hashable</a>(Node *testexpr, List *param_ids);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L792" title="optimizer/plan/subselect.c:792">test_opexpr_is_hashable</a>(OpExpr *testexpr, List *param_ids);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L832" title="optimizer/plan/subselect.c:832">hash_ok_operator</a>(OpExpr *expr);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1056" title="optimizer/plan/subselect.c:1056">contain_dml</a>(Node *node);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1062" title="optimizer/plan/subselect.c:1062">contain_dml_walker</a>(Node *node, <span class="Type">void</span> *context);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1083" title="optimizer/plan/subselect.c:1083">contain_outer_selfref</a>(Node *node);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1097" title="optimizer/plan/subselect.c:1097">contain_outer_selfref_walker</a>(Node *node, Index *depth);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1138" title="optimizer/plan/subselect.c:1138">inline_cte</a>(PlannerInfo *root, CommonTableExpr *cte);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1151" title="optimizer/plan/subselect.c:1151">inline_cte_walker</a>(Node *node, <a href="#L60" title="optimizer/plan/subselect.c:60">inline_cte_walker_context</a> *context);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1540" title="optimizer/plan/subselect.c:1540">simplify_EXISTS_query</a>(PlannerInfo *root, Query *query);<br/></li>
<li><span class="Type">static</span> Query *<a href="#L1628" title="optimizer/plan/subselect.c:1628">convert_EXISTS_to_ANY</a>(PlannerInfo *root, Query *subselect,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node **testexpr, List **paramIds);<br/></li>
<li><span class="Type">static</span> Node *<a href="#L1875" title="optimizer/plan/subselect.c:1875">replace_correlation_vars_mutator</a>(Node *node, PlannerInfo *root);<br/></li>
<li><span class="Type">static</span> Node *<a href="#L1929" title="optimizer/plan/subselect.c:1929">process_sublinks_mutator</a>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L48" title="optimizer/plan/subselect.c:48">process_sublinks_context</a> *context);<br/></li>
<li><span class="Type">static</span> Bitmapset *<a href="#L2292" title="optimizer/plan/subselect.c:2292">finalize_plan</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Plan *plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> gather_param,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bitmapset *valid_params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bitmapset *scan_params);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>(Node *node, <a href="#L54" title="optimizer/plan/subselect.c:54">finalize_primnode_context</a> *context);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2974" title="optimizer/plan/subselect.c:2974">finalize_agg_primnode</a>(Node *node, <a href="#L54" title="optimizer/plan/subselect.c:54">finalize_primnode_context</a> *context);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the datatype/typmod/collation of the first column of the plan's output.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This information is stored for ARRAY_SUBLINK execution and for<br/></li>
<li></span><span class="Comment"> * <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>()/<a href="../../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>()/<a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>(), which have no way to get at the<br/></li>
<li></span><span class="Comment"> * plan associated with a SubPlan node.&nbsp; We really only need the info for<br/></li>
<li></span><span class="Comment"> * EXPR_SUBLINK and ARRAY_SUBLINK subplans, but for consistency we save it<br/></li>
<li></span><span class="Comment"> * always.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L118">&#x200c;</a></span><span class="linkable">get_first_col_type</span>(Plan *plan, Oid *coltype, int32 *coltypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *colcollation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* In cases such as EXISTS, tlist might be empty; arbitrarily use VOID */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plan-&gt;targetlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tent = linitial_node(TargetEntry, plan-&gt;targetlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tent-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *coltype = <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) tent-&gt;expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *coltypmod = <a href="../../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>((Node *) tent-&gt;expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *colcollation = <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) tent-&gt;expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *coltype = VOIDOID;<br/></li>
<li>&nbsp; &nbsp; *coltypmod = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; *colcollation = InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert a SubLink (as created by the parser) into a SubPlan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We are given the SubLink's contained query, type, ID, and testexpr.&nbsp; We are<br/></li>
<li></span><span class="Comment"> * also told if this expression appears at top level of a WHERE/HAVING qual.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we assume that the testexpr has been AND/OR flattened (actually,<br/></li>
<li></span><span class="Comment"> * it's been through <a href="../util/clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a>), but not converted to<br/></li>
<li></span><span class="Comment"> * implicit-AND form; and <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SubLinks in it should already have been<br/></li>
<li></span><span class="Comment"> * converted to SubPlans.&nbsp; The subquery is as yet untouched, however.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is whatever we need to substitute in place of the SubLink node<br/></li>
<li></span><span class="Comment"> * in the executable expression.&nbsp; If we're going to do the subplan as a<br/></li>
<li></span><span class="Comment"> * regular subplan, this will be the constructed SubPlan node.&nbsp; If we're going<br/></li>
<li></span><span class="Comment"> * to do the subplan as an <a href="../../executor/execMain.c.html#L833" title="executor/execMain.c:833">InitPlan</a>, the SubPlan node instead goes into<br/></li>
<li></span><span class="Comment"> * root-&gt;init_plans, and what we return here is an expression tree<br/></li>
<li></span><span class="Comment"> * representing the <a href="../../executor/execMain.c.html#L833" title="executor/execMain.c:833">InitPlan</a>'s result: usually just a Param node representing<br/></li>
<li></span><span class="Comment"> * a single scalar result, but possibly a row comparison tree containing<br/></li>
<li></span><span class="Comment"> * multiple Param nodes, or for a MULTIEXPR subquery a simple NULL constant<br/></li>
<li></span><span class="Comment"> * (since the real output Params are elsewhere in the tree, and the MULTIEXPR<br/></li>
<li></span><span class="Comment"> * subquery itself is in a resjunk tlist entry whose value is uninteresting).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Node *<br/></li>
<li><a id="L162">&#x200c;</a><span class="linkable">make_subplan</span>(PlannerInfo *root, Query *orig_subquery,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SubLinkType subLinkType, <span class="Type">int</span> subLinkId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *testexpr, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isTopQual)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *subquery;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; simple_exists = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; tuple_fraction;<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *subroot;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *final_rel;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *best_path;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *plan_params;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy the source Query node.&nbsp; This is a quick and dirty kluge to resolve<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the fact that the parser can generate trees with multiple links to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same sub-Query node, but the <a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> wants to scribble on the Query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to clean this up when we do querytree redesign...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; subquery = copyObject(orig_subquery);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's an EXISTS subplan, we might be able to simplify it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (subLinkType == EXISTS_SUBLINK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; simple_exists = <a href="#L1540" title="optimizer/plan/subselect.c:1540">simplify_EXISTS_query</a>(root, subquery);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For an EXISTS subplan, tell <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-level <a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> to expect that only the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first tuple will be retrieved.&nbsp; For ALL and ANY subplans, we will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * able to stop evaluating if the test condition fails or matches, so very<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * often not all the tuples will be retrieved; for lack of a better idea,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * specify 50% retrieval.&nbsp; For EXPR, MULTIEXPR, and ROWCOMPARE subplans,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use default behavior (we're only expecting one row out, anyway).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: if you change these numbers, also change <a href="../path/costsize.c.html#L4435" title="optimizer/path/costsize.c:4435">cost_subplan</a>() in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * path/costsize.c.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> If an ANY subplan is uncorrelated, <a href="#L319" title="optimizer/plan/subselect.c:319">build_subplan</a> may decide to <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its output.&nbsp; In that case it would've been better to specify full<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * retrieval.&nbsp; At present, however, we can only check hashability after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we've made the subplan :-(.&nbsp; (Determining whether it'll fit in hash_mem<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is the really hard part.)&nbsp; Therefore, we don't want to be too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * optimistic about the percentage of tuples retrieved, for fear of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * selecting a plan that's bad for the materialization case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (subLinkType == EXISTS_SUBLINK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple_fraction = <span class="Constant">1.0</span>;&nbsp; &nbsp; <span class="Comment">/* just like a LIMIT 1 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (subLinkType == ALL_SUBLINK ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subLinkType == ANY_SUBLINK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple_fraction = <span class="Constant">0.5</span>;&nbsp; &nbsp; <span class="Comment">/* 50% */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tuple_fraction = <span class="Constant">0.0</span>;&nbsp; &nbsp; <span class="Comment">/* default behavior */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* plan_params should not be in use in current query level */<br/></li>
<li></span>&nbsp; &nbsp; Assert(root-&gt;plan_params == NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Generate Paths for the subquery */<br/></li>
<li></span>&nbsp; &nbsp; subroot = <a href="planner.c.html#L628" title="optimizer/plan/planner.c:628">subquery_planner</a>(root-&gt;glob, subquery, root, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tuple_fraction, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Isolate the params needed by this specific subplan */<br/></li>
<li></span>&nbsp; &nbsp; plan_params = root-&gt;plan_params;<br/></li>
<li>&nbsp; &nbsp; root-&gt;plan_params = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Select best Path and turn it into a Plan.&nbsp; At least for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * seems no reason to postpone doing that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; final_rel = <a href="../util/relnode.c.html#L1470" title="optimizer/util/relnode.c:1470">fetch_upper_rel</a>(subroot, UPPERREL_FINAL, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; best_path = <a href="planner.c.html#L6298" title="optimizer/plan/planner.c:6298">get_cheapest_fractional_path</a>(final_rel, tuple_fraction);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan = <a href="createplan.c.html#L337" title="optimizer/plan/createplan.c:337">create_plan</a>(subroot, best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And convert to SubPlan or <a href="../../executor/execMain.c.html#L833" title="executor/execMain.c:833">InitPlan</a> format. */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="#L319" title="optimizer/plan/subselect.c:319">build_subplan</a>(root, plan, best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subroot, plan_params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subLinkType, subLinkId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; testexpr, NIL, isTopQual);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's a correlated EXISTS with an unimportant targetlist, we might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * able to transform it to the equivalent of an IN and then implement it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by hashing.&nbsp; We don't have enough information yet to tell which way is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * likely to be better (it depends on the expected number of executions of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the EXISTS qual, and we are much too early in planning the outer query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to be able to guess that).&nbsp; So we generate both plans, if possible, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leave it to setrefs.c to decide which to use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (simple_exists &amp;&amp; IsA(result, SubPlan))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *newtestexpr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *paramIds;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make a second copy of the original subquery */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; subquery = copyObject(orig_subquery);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and re-simplify */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; simple_exists = <a href="#L1540" title="optimizer/plan/subselect.c:1540">simplify_EXISTS_query</a>(root, subquery);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(simple_exists);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See if it can be converted to an ANY query */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; subquery = <a href="#L1628" title="optimizer/plan/subselect.c:1628">convert_EXISTS_to_ANY</a>(root, subquery,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;newtestexpr, &amp;paramIds);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subquery)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Generate Paths for the ANY subquery; we'll need all rows */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subroot = <a href="planner.c.html#L628" title="optimizer/plan/planner.c:628">subquery_planner</a>(root-&gt;glob, subquery, root, <span class="Constant">false</span>, <span class="Constant">0.0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Isolate the params needed by this specific subplan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan_params = root-&gt;plan_params;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;plan_params = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Select best Path */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final_rel = <a href="../util/relnode.c.html#L1470" title="optimizer/util/relnode.c:1470">fetch_upper_rel</a>(subroot, UPPERREL_FINAL, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_path = final_rel-&gt;cheapest_total_path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now we can check if it'll fit in hash_mem */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L736" title="optimizer/plan/subselect.c:736">subpath_is_hashable</a>(best_path))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SubPlan&nbsp; &nbsp; *hashplan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlternativeSubPlan *asplan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, finish planning the ANY subquery */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = <a href="createplan.c.html#L337" title="optimizer/plan/createplan.c:337">create_plan</a>(subroot, best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and convert to SubPlan format */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashplan = castNode(SubPlan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L319" title="optimizer/plan/subselect.c:319">build_subplan</a>(root, plan, best_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subroot, plan_params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ANY_SUBLINK, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtestexpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramIds,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check we got what we expected */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(hashplan-&gt;parParam == NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(hashplan-&gt;useHashTable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Leave it to setrefs.c to decide which plan to use */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; asplan = makeNode(AlternativeSubPlan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; asplan-&gt;subplans = list_make2(result, hashplan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (Node *) asplan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;hasAlternativeSubPlans = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Build a SubPlan node given the raw inputs --- subroutine for <a href="#L162" title="optimizer/plan/subselect.c:162">make_subplan</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns either the SubPlan, or a replacement expression if we decide to<br/></li>
<li></span><span class="Comment"> * make it an <a href="../../executor/execMain.c.html#L833" title="executor/execMain.c:833">InitPlan</a>, as explained in the comments for <a href="#L162" title="optimizer/plan/subselect.c:162">make_subplan</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Node *<br/></li>
<li><a id="L319">&#x200c;</a><span class="linkable">build_subplan</span>(PlannerInfo *root, Plan *plan, Path *path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlannerInfo *subroot, List *plan_params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SubLinkType subLinkType, <span class="Type">int</span> subLinkId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *testexpr, List *testexpr_paramids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> unknownEqFalse)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; SubPlan&nbsp; &nbsp; *splan;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isInitPlan;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize the SubPlan node.&nbsp; Note plan_id, plan_name, and cost fields<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are set further down.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; splan = makeNode(SubPlan);<br/></li>
<li>&nbsp; &nbsp; splan-&gt;subLinkType = subLinkType;<br/></li>
<li>&nbsp; &nbsp; splan-&gt;testexpr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; splan-&gt;paramIds = NIL;<br/></li>
<li>&nbsp; &nbsp; <a href="#L118" title="optimizer/plan/subselect.c:118">get_first_col_type</a>(plan, &amp;splan-&gt;firstColType, &amp;splan-&gt;firstColTypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;splan-&gt;firstColCollation);<br/></li>
<li>&nbsp; &nbsp; splan-&gt;useHashTable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; splan-&gt;unknownEqFalse = unknownEqFalse;<br/></li>
<li>&nbsp; &nbsp; splan-&gt;parallel_safe = plan-&gt;parallel_safe;<br/></li>
<li>&nbsp; &nbsp; splan-&gt;setParam = NIL;<br/></li>
<li>&nbsp; &nbsp; splan-&gt;parParam = NIL;<br/></li>
<li>&nbsp; &nbsp; splan-&gt;args = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make parParam and args lists of param IDs and expressions that current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * query level will pass to this child plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, plan_params)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlannerParamItem *pitem = (PlannerParamItem *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *arg = pitem-&gt;item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The Var, PlaceHolderVar, Aggref or GroupingFunc has already been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * adjusted to have the correct varlevelsup, phlevelsup, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * agglevelsup.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's a PlaceHolderVar, Aggref or GroupingFunc, its arguments<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might contain SubLinks, which have not yet been processed (see the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * comments for <a href="#L1868" title="optimizer/plan/subselect.c:1868">SS_replace_correlation_vars</a>).&nbsp; Do that <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(arg, PlaceHolderVar) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IsA(arg, Aggref) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IsA(arg, GroupingFunc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arg = <a href="#L1919" title="optimizer/plan/subselect.c:1919">SS_process_sublinks</a>(root, arg, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;parParam = <a href="../../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(splan-&gt;parParam, pitem-&gt;paramId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;args = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(splan-&gt;args, arg);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Un-correlated or undirect correlated plans of EXISTS, EXPR, ARRAY,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ROWCOMPARE, or MULTIEXPR types can be used as initPlans.&nbsp; For EXISTS,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * EXPR, or ARRAY, we return a Param referring to the result of evaluating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the initPlan.&nbsp; For ROWCOMPARE, we must modify the testexpr tree to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contain PARAM_EXEC Params instead of the PARAM_SUBLINK Params emitted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by the parser, and then return that tree.&nbsp; For MULTIEXPR, we return a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * null constant: the resjunk targetlist item containing the SubLink does<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not need to return anything useful, since the referencing Params are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * elsewhere.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (splan-&gt;parParam == NIL &amp;&amp; subLinkType == EXISTS_SUBLINK)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Param&nbsp; &nbsp; &nbsp;&nbsp; *prm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(testexpr == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prm = <a href="../util/paramassign.c.html#L637" title="optimizer/util/paramassign.c:637">generate_new_exec_param</a>(root, BOOLOID, -<span class="Constant">1</span>, InvalidOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;setParam = list_make1_int(prm-&gt;paramid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isInitPlan = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (Node *) prm;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (splan-&gt;parParam == NIL &amp;&amp; subLinkType == EXPR_SUBLINK)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *te = linitial(plan-&gt;targetlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Param&nbsp; &nbsp; &nbsp;&nbsp; *prm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!te-&gt;resjunk);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(testexpr == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prm = <a href="../util/paramassign.c.html#L637" title="optimizer/util/paramassign.c:637">generate_new_exec_param</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) te-&gt;expr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>((Node *) te-&gt;expr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) te-&gt;expr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;setParam = list_make1_int(prm-&gt;paramid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isInitPlan = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (Node *) prm;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (splan-&gt;parParam == NIL &amp;&amp; subLinkType == ARRAY_SUBLINK)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *te = linitial(plan-&gt;targetlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arraytype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Param&nbsp; &nbsp; &nbsp;&nbsp; *prm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!te-&gt;resjunk);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(testexpr == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arraytype = <a href="../../utils/cache/lsyscache.c.html#L2811" title="utils/cache/lsyscache.c:2811">get_promoted_array_type</a>(<a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) te-&gt;expr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(arraytype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> array type for datatype </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(<a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) te-&gt;expr)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prm = <a href="../util/paramassign.c.html#L637" title="optimizer/util/paramassign.c:637">generate_new_exec_param</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arraytype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>((Node *) te-&gt;expr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) te-&gt;expr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;setParam = list_make1_int(prm-&gt;paramid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isInitPlan = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (Node *) prm;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (splan-&gt;parParam == NIL &amp;&amp; subLinkType == ROWCOMPARE_SUBLINK)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Adjust the Params */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *params;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(testexpr != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; params = <a href="#L580" title="optimizer/plan/subselect.c:580">generate_subquery_params</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;splan-&gt;paramIds);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L642" title="optimizer/plan/subselect.c:642">convert_testexpr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; testexpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; params);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;setParam = <a href="../../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(splan-&gt;paramIds);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isInitPlan = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The executable expression is returned to become part of the outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * plan's expression tree; it is not kept in the initplan node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (subLinkType == MULTIEXPR_SUBLINK)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Whether it's an initplan or not, it needs to set a PARAM_EXEC Param<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for each output column.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *params;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(testexpr == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; params = <a href="#L580" title="optimizer/plan/subselect.c:580">generate_subquery_params</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;splan-&gt;setParam);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Save the list of replacement Params in the n'th cell of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * root-&gt;multiexpr_params; setrefs.c will use it to replace<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PARAM_MULTIEXPR Params.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (list_length(root-&gt;multiexpr_params) &lt; subLinkId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;multiexpr_params = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;multiexpr_params, NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lc = list_nth_cell(root-&gt;multiexpr_params, subLinkId - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(lfirst(lc) == NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lfirst(lc) = params;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It can be an initplan if there are no parParams. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (splan-&gt;parParam == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isInitPlan = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (Node *) <a href="../../nodes/makefuncs.c.html#L339" title="nodes/makefuncs.c:339">makeNullConst</a>(RECORDOID, -<span class="Constant">1</span>, InvalidOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isInitPlan = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (Node *) splan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Adjust the Params in the testexpr, unless caller already took care<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of it (as indicated by passing a list of Param IDs).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (testexpr &amp;&amp; testexpr_paramids == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *params;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; params = <a href="#L580" title="optimizer/plan/subselect.c:580">generate_subquery_params</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;splan-&gt;paramIds);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;testexpr = <a href="#L642" title="optimizer/plan/subselect.c:642">convert_testexpr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; testexpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; params);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;testexpr = testexpr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;paramIds = testexpr_paramids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can't convert subplans of ALL_SUBLINK or ANY_SUBLINK types to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * initPlans, even when they are uncorrelated or undirect correlated,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because we need to scan the output of the subplan for each outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple.&nbsp; But if it's a not-direct-correlated IN (= ANY) test, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might be able to use a hashtable to avoid comparing all the tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subLinkType == ANY_SUBLINK &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;parParam == NIL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L712" title="optimizer/plan/subselect.c:712">subplan_is_hashable</a>(plan) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L761" title="optimizer/plan/subselect.c:761">testexpr_is_hashable</a>(splan-&gt;testexpr, splan-&gt;paramIds))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;useHashTable = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, we have the option to tack a Material node onto the top<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the subplan, to reduce the cost of reading it repeatedly.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is pointless for a direct-correlated subplan, since we'd have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recompute its results each time anyway.&nbsp; For uncorrelated/undirect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * correlated subplans, we add Material unless the subplan's top plan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * node would materialize its output anyway.&nbsp; Also, if <a href="../path/costsize.c.html#L143" title="optimizer/path/costsize.c:143">enable_material</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is false, then the user does not want us to materialize anything<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unnecessarily, so we don't.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (splan-&gt;parParam == NIL &amp;&amp; <a href="../path/costsize.c.html#L143" title="optimizer/path/costsize.c:143">enable_material</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="../../executor/execAmi.c.html#L635" title="executor/execAmi.c:635">ExecMaterializesOutput</a>(nodeTag(plan)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = <a href="createplan.c.html#L6527" title="optimizer/plan/createplan.c:6527">materialize_finished_plan</a>(plan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (Node *) splan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isInitPlan = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add the subplan, its path, and its PlannerInfo to the global lists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;glob-&gt;subplans = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;glob-&gt;subplans, plan);<br/></li>
<li>&nbsp; &nbsp; root-&gt;glob-&gt;subpaths = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;glob-&gt;subpaths, path);<br/></li>
<li>&nbsp; &nbsp; root-&gt;glob-&gt;subroots = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;glob-&gt;subroots, subroot);<br/></li>
<li>&nbsp; &nbsp; splan-&gt;plan_id = list_length(root-&gt;glob-&gt;subplans);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isInitPlan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;init_plans = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;init_plans, splan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A parameterless subplan (not initplan) should be prepared to handle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * REWIND efficiently.&nbsp; If it has direct parameters then there's no point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since it'll be reset on each scan anyway; and if it's an initplan then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there's no point since it won't get re-run without parameter changes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anyway.&nbsp; The input of a hashed subplan doesn't need REWIND either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (splan-&gt;parParam == NIL &amp;&amp; !isInitPlan &amp;&amp; !splan-&gt;useHashTable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;glob-&gt;rewindPlanIDs = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(root-&gt;glob-&gt;rewindPlanIDs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; splan-&gt;plan_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Label the subplan for EXPLAIN purposes */<br/></li>
<li></span>&nbsp; &nbsp; splan-&gt;plan_name = psprintf(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isInitPlan ? <span class="Constant">&quot;<a href="../../executor/execMain.c.html#L833" title="executor/execMain.c:833">InitPlan</a>&quot;</span> : <span class="Constant">&quot;SubPlan&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;plan_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Lastly, fill in the cost estimates for use later */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../path/costsize.c.html#L4435" title="optimizer/path/costsize.c:4435">cost_subplan</a>(root, splan, plan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L580" title="optimizer/plan/subselect.c:580">generate_subquery_params</a>: build a list of Params representing the output<br/></li>
<li></span><span class="Comment"> * columns of a sublink's sub-<a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a>, given the sub-<a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a>'s targetlist.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also return an integer list of the paramids of the Params.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L580">&#x200c;</a><span class="linkable">generate_subquery_params</span>(PlannerInfo *root, List *tlist, List **paramIds)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *ids;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = ids = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, tlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tent = (TargetEntry *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Param&nbsp; &nbsp; &nbsp;&nbsp; *param;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tent-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; param = <a href="../util/paramassign.c.html#L637" title="optimizer/util/paramassign.c:637">generate_new_exec_param</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) tent-&gt;expr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>((Node *) tent-&gt;expr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) tent-&gt;expr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, param);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ids = <a href="../../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(ids, param-&gt;paramid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *paramIds = ids;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L613" title="optimizer/plan/subselect.c:613">generate_subquery_vars</a>: build a list of Vars representing the output<br/></li>
<li></span><span class="Comment"> * columns of a sublink's sub-<a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a>, given the sub-<a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a>'s targetlist.<br/></li>
<li></span><span class="Comment"> * The Vars have the specified varno (RTE index).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L613">&#x200c;</a><span class="linkable">generate_subquery_vars</span>(PlannerInfo *root, List *tlist, Index varno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, tlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tent = (TargetEntry *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tent-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var = <a href="../../nodes/makefuncs.c.html#L105" title="nodes/makefuncs.c:105">makeVarFromTargetEntry</a>(varno, tent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, var);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L642" title="optimizer/plan/subselect.c:642">convert_testexpr</a>: convert the testexpr given by the parser into<br/></li>
<li></span><span class="Comment"> * actually executable form.&nbsp; This entails replacing PARAM_SUBLINK Params<br/></li>
<li></span><span class="Comment"> * with Params or Vars representing the results of the sub-<a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a>.&nbsp; The<br/></li>
<li></span><span class="Comment"> * nodes to be substituted are passed in as the List result from<br/></li>
<li></span><span class="Comment"> * <a href="#L580" title="optimizer/plan/subselect.c:580">generate_subquery_params</a> or <a href="#L613" title="optimizer/plan/subselect.c:613">generate_subquery_vars</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Node *<br/></li>
<li><a id="L642">&#x200c;</a><span class="linkable">convert_testexpr</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *testexpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *subst_nodes)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L42" title="optimizer/plan/subselect.c:42">convert_testexpr_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.root = root;<br/></li>
<li>&nbsp; &nbsp; context.subst_nodes = subst_nodes;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L654" title="optimizer/plan/subselect.c:654">convert_testexpr_mutator</a>(testexpr, &amp;context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Node *<br/></li>
<li><a id="L654">&#x200c;</a><span class="linkable">convert_testexpr_mutator</span>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L42" title="optimizer/plan/subselect.c:42">convert_testexpr_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Param))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Param&nbsp; &nbsp; &nbsp;&nbsp; *param = (Param *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (param-&gt;paramkind == PARAM_SUBLINK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (param-&gt;paramid &lt;= <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; param-&gt;paramid &gt; list_length(context-&gt;subst_nodes))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected PARAM_SUBLINK ID: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, param-&gt;paramid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We copy the list item to avoid having doubly-linked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * substructure in the modified <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> tree.&nbsp; This is probably<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unnecessary when it's a Param, but be safe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) copyObject(list_nth(context-&gt;subst_nodes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; param-&gt;paramid - <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, SubLink))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we come across a nested SubLink, it is neither necessary nor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * correct to recurse into it: <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> PARAM_SUBLINKs we might <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> inside<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * belong to the inner SubLink not the outer. So just return it as-is.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This reasoning depends on the assumption that nothing will <a href="../../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subexpressions into or out of the testexpr field of a SubLink, at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * least not without replacing PARAM_SUBLINKs first.&nbsp; If we did want<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to do that we'd need to rethink the parser-output representation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * altogether, since currently PARAM_SUBLINKs are only unique per<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * SubLink not globally across the query.&nbsp; The whole point of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * replacing them with Vars or PARAM_EXEC nodes is to make them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * globally unique <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> they escape from the SubLink's testexpr.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: this can't happen when called during <a href="#L1919" title="optimizer/plan/subselect.c:1919">SS_process_sublinks</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because that recursively processes inner SubLinks first.&nbsp; It can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * happen when called from <a href="#L1254" title="optimizer/plan/subselect.c:1254">convert_ANY_sublink_to_join</a>, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_mutator(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L654" title="optimizer/plan/subselect.c:654">convert_testexpr_mutator</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L712" title="optimizer/plan/subselect.c:712">subplan_is_hashable</a>: can we implement an ANY subplan by hashing?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is not responsible for checking whether the combining testexpr<br/></li>
<li></span><span class="Comment"> * is suitable for hashing.&nbsp; We only look at the subquery itself.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L712">&#x200c;</a></span><span class="linkable">subplan_is_hashable</span>(Plan *plan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; subquery_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The estimated size of the subquery result must fit in hash_mem. (Note:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we use heap tuple overhead here even though the tuples will actually be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stored as MinimalTuples; this provides some fudge factor for hashtable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overhead.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; subquery_size = plan-&gt;plan_rows *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (MAXALIGN(plan-&gt;plan_width) + MAXALIGN(SizeofHeapTupleHeader));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (subquery_size &gt; <a href="../../executor/nodeHash.c.html#L3595" title="executor/nodeHash.c:3595">get_hash_memory_limit</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L736" title="optimizer/plan/subselect.c:736">subpath_is_hashable</a>: can we implement an ANY subplan by hashing?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Identical to <a href="#L712" title="optimizer/plan/subselect.c:712">subplan_is_hashable</a>, but work from a Path for the subplan.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L736">&#x200c;</a></span><span class="linkable">subpath_is_hashable</span>(Path *path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; subquery_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The estimated size of the subquery result must fit in hash_mem. (Note:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we use heap tuple overhead here even though the tuples will actually be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stored as MinimalTuples; this provides some fudge factor for hashtable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overhead.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; subquery_size = path-&gt;rows *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (MAXALIGN(path-&gt;pathtarget-&gt;width) + MAXALIGN(SizeofHeapTupleHeader));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (subquery_size &gt; <a href="../../executor/nodeHash.c.html#L3595" title="executor/nodeHash.c:3595">get_hash_memory_limit</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L761" title="optimizer/plan/subselect.c:761">testexpr_is_hashable</a>: is an ANY SubLink's test expression hashable?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To identify LHS vs RHS of the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> expression, we must be given the<br/></li>
<li></span><span class="Comment"> * list of output Param IDs of the SubLink's subquery.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L761">&#x200c;</a></span><span class="linkable">testexpr_is_hashable</span>(Node *testexpr, List *param_ids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The testexpr must be a single OpExpr, or an AND-clause containing only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OpExprs, each of which satisfy <a href="#L792" title="optimizer/plan/subselect.c:792">test_opexpr_is_hashable</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (testexpr &amp;&amp; IsA(testexpr, OpExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L792" title="optimizer/plan/subselect.c:792">test_opexpr_is_hashable</a>((OpExpr *) testexpr, param_ids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (is_andclause(testexpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, ((BoolExpr *) testexpr)-&gt;args)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *andarg = (Node *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsA(andarg, OpExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L792" title="optimizer/plan/subselect.c:792">test_opexpr_is_hashable</a>((OpExpr *) andarg, param_ids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L792">&#x200c;</a></span><span class="linkable">test_opexpr_is_hashable</span>(OpExpr *testexpr, List *param_ids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The combining operator must be hashable and strict.&nbsp; The need for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hashability is obvious, since we want to use hashing.&nbsp; Without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * strictness, behavior in the presence of nulls is too unpredictable.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * actually must assume even more than plain strictness: it can't yield<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NULL for non-null inputs, either (see nodeSubplan.c).&nbsp; However, <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indexes and <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> joins assume that too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L832" title="optimizer/plan/subselect.c:832">hash_ok_operator</a>(testexpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The left and right inputs must belong to the outer and inner queries<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * respectively; hence Params that will be supplied by the subquery must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not appear in the LHS, and Vars of the outer query must not appear in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the RHS.&nbsp; (Ordinarily, this must be true because of the way that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parser builds an ANY SubLink's testexpr ... but inlining of <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * could have changed the expression's structure, so we have to check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Such cases do not occur often enough to be worth trying to <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a>, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we don't worry about trying to commute the clause or anything like<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that; we just need to be sure not to build an invalid plan.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(testexpr-&gt;args) != <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/clauses.c.html#L1137" title="optimizer/util/clauses.c:1137">contain_exec_param</a>((Node *) linitial(testexpr-&gt;args), param_ids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/var.c.html#L403" title="optimizer/util/var.c:403">contain_var_clause</a>((Node *) lsecond(testexpr-&gt;args)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check expression is hashable + strict<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We could use <a href="../../utils/cache/lsyscache.c.html#L1437" title="utils/cache/lsyscache.c:1437">op_hashjoinable</a>() and <a href="../../utils/cache/lsyscache.c.html#L1477" title="utils/cache/lsyscache.c:1477">op_strict</a>(), but do it like this to<br/></li>
<li></span><span class="Comment"> * avoid a redundant cache lookup.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L832">&#x200c;</a></span><span class="linkable">hash_ok_operator</span>(OpExpr *expr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opid = expr-&gt;opno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* quick out if not a binary operator */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(expr-&gt;args) != <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (opid == ARRAY_EQ_OP ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opid == RECORD_EQ_OP)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* these are strict, but must check input type to ensure hashable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *leftarg = linitial(expr-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../utils/cache/lsyscache.c.html#L1437" title="utils/cache/lsyscache.c:1437">op_hashjoinable</a>(opid, <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(leftarg));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else must look up the operator properties */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_operator optup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tup = <a href="../../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(OPEROID, ObjectIdGetDatum(opid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for operator </span><span class="Special">%u</span><span class="Constant">&quot;</span>, opid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; optup = (Form_pg_operator) GETSTRUCT(tup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!optup-&gt;oprcanhash || !<a href="../../utils/cache/lsyscache.c.html#L1761" title="utils/cache/lsyscache.c:1761">func_strict</a>(optup-&gt;oprcode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L880" title="optimizer/plan/subselect.c:880">SS_process_ctes</a>: process a query's WITH list<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Consider each CTE in the WITH list and either ignore it (if it's an<br/></li>
<li></span><span class="Comment"> * unreferenced SELECT), &quot;inline&quot; it to create a regular sub-SELECT-in-FROM,<br/></li>
<li></span><span class="Comment"> * or convert it to an initplan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A side effect is to fill in root-&gt;cte_plan_ids with a list that<br/></li>
<li></span><span class="Comment"> * parallels root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;cteList and provides the subplan ID for<br/></li>
<li></span><span class="Comment"> * each CTE's initplan, or a dummy ID (-1) if we didn't make an initplan.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L880">&#x200c;</a></span><span class="linkable">SS_process_ctes</span>(PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(root-&gt;cte_plan_ids == NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;cteList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CommonTableExpr *cte = (CommonTableExpr *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CmdType&nbsp; &nbsp; &nbsp; &nbsp; cmdType = ((Query *) cte-&gt;ctequery)-&gt;commandType;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *subquery;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlannerInfo *subroot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *final_rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *best_path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SubPlan&nbsp; &nbsp; *splan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore SELECT CTEs that are not actually referenced anywhere.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;cterefcount == <span class="Constant">0</span> &amp;&amp; cmdType == CMD_SELECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make a dummy entry in cte_plan_ids */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;cte_plan_ids = <a href="../../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(root-&gt;cte_plan_ids, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Consider inlining the CTE (creating RTE_SUBQUERY RTE(s)) instead of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * implementing it as a separately-planned CTE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We cannot inline if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of these conditions hold:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 1. The user said not to (the CTEMaterializeAlways option).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 2. The CTE is recursive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 3. The CTE has side-effects; this includes either not being a plain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * SELECT, or containing volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; Inlining might change<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the side-effects, which would be bad.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 4. The CTE is multiply-referenced and contains a self-reference to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a recursive CTE outside itself.&nbsp; Inlining would result in multiple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recursive self-references, which we don't support.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, we have an option whether to inline or not.&nbsp; That should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * always be a win if there's just a single reference, but if the CTE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is multiply-referenced then it's unclear: inlining adds duplicate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * computations, but the ability to absorb restrictions from the outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * query level could outweigh that.&nbsp; We do not have nearly enough<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * information at this point to tell whether that's true, so we let<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the user express a preference.&nbsp; Our default behavior is to inline<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only singly-referenced CTEs, but a CTE marked CTEMaterializeNever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will be inlined even if multiply referenced.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: we check for volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> last, because that's more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expensive than the other tests needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((cte-&gt;ctematerialized == CTEMaterializeNever ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (cte-&gt;ctematerialized == CTEMaterializeDefault &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;cterefcount == <span class="Constant">1</span>)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !cte-&gt;cterecursive &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmdType == CMD_SELECT &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L1056" title="optimizer/plan/subselect.c:1056">contain_dml</a>(cte-&gt;ctequery) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cte-&gt;cterefcount &lt;= <span class="Constant">1</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="#L1083" title="optimizer/plan/subselect.c:1083">contain_outer_selfref</a>(cte-&gt;ctequery)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>(cte-&gt;ctequery))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1138" title="optimizer/plan/subselect.c:1138">inline_cte</a>(root, cte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make a dummy entry in cte_plan_ids */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;cte_plan_ids = <a href="../../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(root-&gt;cte_plan_ids, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy the source Query node.&nbsp; Probably not necessary, but let's keep<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this similar to <a href="#L162" title="optimizer/plan/subselect.c:162">make_subplan</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; subquery = (Query *) copyObject(cte-&gt;ctequery);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* plan_params should not be in use in current query level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(root-&gt;plan_params == NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Generate Paths for the CTE query.&nbsp; Always plan for full retrieval<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * --- we don't have enough info to predict otherwise.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; subroot = <a href="planner.c.html#L628" title="optimizer/plan/planner.c:628">subquery_planner</a>(root-&gt;glob, subquery, root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cte-&gt;cterecursive, <span class="Constant">0.0</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since the current query level doesn't yet contain <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> RTEs, it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should not be possible for the CTE to have requested parameters of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;plan_params)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected outer reference in CTE query&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Select best Path and turn it into a Plan.&nbsp; At least for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * seems no reason to postpone doing that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; final_rel = <a href="../util/relnode.c.html#L1470" title="optimizer/util/relnode.c:1470">fetch_upper_rel</a>(subroot, UPPERREL_FINAL, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; best_path = final_rel-&gt;cheapest_total_path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan = <a href="createplan.c.html#L337" title="optimizer/plan/createplan.c:337">create_plan</a>(subroot, best_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make a SubPlan node for it.&nbsp; This is just enough unlike<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L319" title="optimizer/plan/subselect.c:319">build_subplan</a> that we can't share code.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note plan_id, plan_name, and cost fields are set further down.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; splan = makeNode(SubPlan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;subLinkType = CTE_SUBLINK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;testexpr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;paramIds = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="optimizer/plan/subselect.c:118">get_first_col_type</a>(plan, &amp;splan-&gt;firstColType, &amp;splan-&gt;firstColTypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;splan-&gt;firstColCollation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;useHashTable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;unknownEqFalse = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * CTE scans are not considered for parallelism (cf<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../path/allpaths.c.html#L589" title="optimizer/path/allpaths.c:589">set_rel_consider_parallel</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;parallel_safe = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;setParam = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;parParam = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;args = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The node can't have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> inputs (since it's an initplan), so the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parParam and args lists remain empty.&nbsp; (It could contain references<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to earlier CTEs' output param IDs, but CTE outputs are not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * propagated via the args list.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Assign a param ID to represent the CTE's output.&nbsp; No ordinary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;evaluation&quot; of this param slot ever happens, but we use the param<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ID for setParam/chgParam signaling just as if the CTE plan were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * returning a simple scalar output.&nbsp; (Also, the executor abuses the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ParamExecData slot for this param ID for communication among<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multiple CteScan nodes that might be scanning this CTE.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; paramid = <a href="../util/paramassign.c.html#L664" title="optimizer/util/paramassign.c:664">assign_special_exec_param</a>(root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;setParam = list_make1_int(paramid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add the subplan, its path, and its PlannerInfo to the global lists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;glob-&gt;subplans = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;glob-&gt;subplans, plan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;glob-&gt;subpaths = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;glob-&gt;subpaths, best_path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;glob-&gt;subroots = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;glob-&gt;subroots, subroot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;plan_id = list_length(root-&gt;glob-&gt;subplans);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;init_plans = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;init_plans, splan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;cte_plan_ids = <a href="../../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(root-&gt;cte_plan_ids, splan-&gt;plan_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Label the subplan for EXPLAIN purposes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;plan_name = psprintf(<span class="Constant">&quot;CTE </span><span class="Special">%s</span><span class="Constant">&quot;</span>, cte-&gt;ctename);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Lastly, fill in the cost estimates for use later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L4435" title="optimizer/path/costsize.c:4435">cost_subplan</a>(root, splan, plan);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1056" title="optimizer/plan/subselect.c:1056">contain_dml</a>: is <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subquery not a plain SELECT?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We reject SELECT FOR UPDATE/SHARE as well as INSERT etc.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1056">&#x200c;</a></span><span class="linkable">contain_dml</span>(Node *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1062" title="optimizer/plan/subselect.c:1062">contain_dml_walker</a>(node, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1062">&#x200c;</a></span><span class="linkable">contain_dml_walker</span>(Node *node, <span class="Type">void</span> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Query))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query = (Query *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;commandType != CMD_SELECT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; query-&gt;rowMarks != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> query_tree_walker(query, <a href="#L1062" title="optimizer/plan/subselect.c:1062">contain_dml_walker</a>, context, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L1062" title="optimizer/plan/subselect.c:1062">contain_dml_walker</a>, context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1083" title="optimizer/plan/subselect.c:1083">contain_outer_selfref</a>: is there an external recursive self-reference?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1083">&#x200c;</a></span><span class="linkable">contain_outer_selfref</span>(Node *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; depth = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We should be starting with a Query, so that depth will be 1 while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * examining its immediate contents.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(IsA(node, Query));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1097" title="optimizer/plan/subselect.c:1097">contain_outer_selfref_walker</a>(node, &amp;depth);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1097">&#x200c;</a></span><span class="linkable">contain_outer_selfref_walker</span>(Node *node, Index *depth)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, RangeTblEntry))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = (RangeTblEntry *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for a self-reference to a CTE that's above the Query that our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * search started at.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind == RTE_CTE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;self_reference &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;ctelevelsup &gt;= *depth)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allow range_table_walker to continue */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Query))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse into subquery, tracking nesting depth properly */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query = (Query *) node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*depth)++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = query_tree_walker(query, <a href="#L1097" title="optimizer/plan/subselect.c:1097">contain_outer_selfref_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) depth, QTW_EXAMINE_RTES_BEFORE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*depth)--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L1097" title="optimizer/plan/subselect.c:1097">contain_outer_selfref_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) depth);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1138" title="optimizer/plan/subselect.c:1138">inline_cte</a>: convert RTE_CTE references to given CTE into RTE_SUBQUERYs<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1138">&#x200c;</a></span><span class="linkable">inline_cte</span>(PlannerInfo *root, CommonTableExpr *cte)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L60" title="optimizer/plan/subselect.c:60">inline_cte_walker_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.ctename = cte-&gt;ctename;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Start at levelsup = -1 because we'll immediately increment it */<br/></li>
<li></span>&nbsp; &nbsp; context.levelsup = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; context.ctequery = castNode(Query, cte-&gt;ctequery);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1151" title="optimizer/plan/subselect.c:1151">inline_cte_walker</a>((Node *) root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>, &amp;context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1151">&#x200c;</a></span><span class="linkable">inline_cte_walker</span>(Node *node, <a href="#L60" title="optimizer/plan/subselect.c:60">inline_cte_walker_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Query))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query = (Query *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;levelsup++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Visit the query's RTE nodes after their contents; otherwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * query_tree_walker would descend into the newly inlined CTE query,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which we don't want.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) query_tree_walker(query, <a href="#L1151" title="optimizer/plan/subselect.c:1151">inline_cte_walker</a>, context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; QTW_EXAMINE_RTES_AFTER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;levelsup--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, RangeTblEntry))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = (RangeTblEntry *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind == RTE_CTE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcmp(rte-&gt;ctename, context-&gt;ctename) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;ctelevelsup == context-&gt;levelsup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Found a reference to replace.&nbsp; Generate a copy of the CTE query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with appropriate level adjustment for outer references (e.g.,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to other CTEs).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *newquery = copyObject(context-&gt;ctequery);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;levelsup &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../rewrite/rewriteManip.c.html#L849" title="rewrite/rewriteManip.c:849">IncrementVarSublevelsUp</a>((Node *) newquery, context-&gt;levelsup, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Convert the RTE_CTE RTE into a RTE_SUBQUERY.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Historically, a FOR UPDATE clause has been treated as extending<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * into views and subqueries, but not into CTEs.&nbsp; We preserve this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * distinction by not trying to <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> rowmarks into the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subquery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;rtekind = RTE_SUBQUERY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;subquery = newquery;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;security_barrier = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Zero out CTE-specific fields */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;ctename = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;ctelevelsup = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;self_reference = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;coltypes = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;coltypmods = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;colcollations = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L1151" title="optimizer/plan/subselect.c:1151">inline_cte_walker</a>, context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1254" title="optimizer/plan/subselect.c:1254">convert_ANY_sublink_to_join</a>: try to convert an ANY SubLink to a join<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller has found an ANY SubLink at the top level of one of the query's<br/></li>
<li></span><span class="Comment"> * qual clauses, but has not checked the properties of the SubLink further.<br/></li>
<li></span><span class="Comment"> * Decide whether it is appropriate to process this SubLink in join style.<br/></li>
<li></span><span class="Comment"> * If so, form a JoinExpr and return it.&nbsp; Return NULL if the SubLink cannot<br/></li>
<li></span><span class="Comment"> * be converted to a join.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The only non-obvious input parameter is available_rels: this is the set<br/></li>
<li></span><span class="Comment"> * of query rels that can safely be referenced in the sublink expression.<br/></li>
<li></span><span class="Comment"> * (We must restrict this to avoid changing the semantics when a sublink<br/></li>
<li></span><span class="Comment"> * is present in an outer join's ON qual.)&nbsp; The conversion must fail if<br/></li>
<li></span><span class="Comment"> * the converted qual would reference <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> but these parent-query relids.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On success, the returned JoinExpr has larg = NULL and rarg = the jointree<br/></li>
<li></span><span class="Comment"> * item representing the pulled-up subquery.&nbsp; The caller must set larg to<br/></li>
<li></span><span class="Comment"> * represent the relation(s) on the lefthand side of the new join, and insert<br/></li>
<li></span><span class="Comment"> * the JoinExpr into the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> query's jointree at an appropriate place<br/></li>
<li></span><span class="Comment"> * (typically, where the lefthand relation(s) had been).&nbsp; Note that the<br/></li>
<li></span><span class="Comment"> * passed-in SubLink must also be removed from its original position in the<br/></li>
<li></span><span class="Comment"> * query quals, since the quals of the returned JoinExpr replace it.<br/></li>
<li></span><span class="Comment"> * (Notionally, we replace the SubLink with a constant TRUE, then elide the<br/></li>
<li></span><span class="Comment"> * redundant constant from the qual.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On success, the caller is also responsible for recursively applying<br/></li>
<li></span><span class="Comment"> * <a href="../prep/prepjointree.c.html#L342" title="optimizer/prep/prepjointree.c:342">pull_up_sublinks</a> processing to the rarg and quals of the returned JoinExpr.<br/></li>
<li></span><span class="Comment"> * (On failure, there is no need to do anything, since <a href="../prep/prepjointree.c.html#L342" title="optimizer/prep/prepjointree.c:342">pull_up_sublinks</a> will<br/></li>
<li></span><span class="Comment"> * be applied when we recursively plan the sub-<a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a>.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Side effects of a successful conversion include adding the SubLink's<br/></li>
<li></span><span class="Comment"> * subselect to the query's rangetable, so that it can be referenced in<br/></li>
<li></span><span class="Comment"> * the JoinExpr's rarg.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>JoinExpr *<br/></li>
<li><a id="L1254">&#x200c;</a><span class="linkable">convert_ANY_sublink_to_join</span>(PlannerInfo *root, SubLink *sublink,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids available_rels)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JoinExpr&nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *subselect = (Query *) sublink-&gt;subselect;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; upper_varnos;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtindex;<br/></li>
<li>&nbsp; &nbsp; ParseNamespaceItem *nsitem;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li>&nbsp; &nbsp; RangeTblRef *rtr;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *subquery_vars;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *quals;<br/></li>
<li>&nbsp; &nbsp; ParseState *pstate;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; sub_ref_outer_relids;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; use_lateral;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(sublink-&gt;subLinkType == ANY_SUBLINK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the sub-<a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> refers to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> Vars of the parent query, we so let's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * considering it as LATERAL.&nbsp; (Vars of higher levels don't matter here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sub_ref_outer_relids = <a href="../util/var.c.html#L134" title="optimizer/util/var.c:134">pull_varnos_of_level</a>(<span class="Constant">NULL</span>, (Node *) subselect, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; use_lateral = !bms_is_empty(sub_ref_outer_relids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that sub-<a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> refers nothing outside of available_rels of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(sub_ref_outer_relids, available_rels))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The test expression must contain some Vars of the parent query, else<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's not gonna be a join.&nbsp; (Note that it won't have Vars referring to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the subquery, rather Params.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; upper_varnos = <a href="../util/var.c.html#L108" title="optimizer/util/var.c:108">pull_varnos</a>(root, sublink-&gt;testexpr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bms_is_empty(upper_varnos))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, it can't refer to anything outside available_rels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(upper_varnos, available_rels))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The combining operators and left-hand expressions mustn't be volatile.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>(sublink-&gt;testexpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create a dummy ParseState for <a href="../../parser/parse_relation.c.html#L1638" title="parser/parse_relation.c:1638">addRangeTableEntryForSubquery</a> */<br/></li>
<li></span>&nbsp; &nbsp; pstate = <a href="../../parser/parse_node.c.html#L39" title="parser/parse_node.c:39">make_parsestate</a>(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Okay, <a href="../../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a> up the sub-<a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> into <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We rely here on the assumption that the outer query has no references<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the inner (necessarily true, other than the Vars that we build<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * below). Therefore this is a lot easier than what <a href="../prep/prepjointree.c.html#L817" title="optimizer/prep/prepjointree.c:817">pull_up_subqueries</a> has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to go through.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nsitem = <a href="../../parser/parse_relation.c.html#L1638" title="parser/parse_relation.c:1638">addRangeTableEntryForSubquery</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subselect,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/makefuncs.c.html#L389" title="nodes/makefuncs.c:389">makeAlias</a>(<span class="Constant">&quot;ANY_subquery&quot;</span>, NIL),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; use_lateral,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; rte = nsitem-&gt;p_rte;<br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rtable = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rtable, rte);<br/></li>
<li>&nbsp; &nbsp; rtindex = list_length(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rtable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Form a RangeTblRef for the pulled-up sub-<a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rtr = makeNode(RangeTblRef);<br/></li>
<li>&nbsp; &nbsp; rtr-&gt;rtindex = rtindex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build a list of Vars representing the subselect outputs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; subquery_vars = <a href="#L613" title="optimizer/plan/subselect.c:613">generate_subquery_vars</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subselect-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtindex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build the new join's qual expression, replacing Params with these Vars.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; quals = <a href="#L642" title="optimizer/plan/subselect.c:642">convert_testexpr</a>(root, sublink-&gt;testexpr, subquery_vars);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And finally, build the JoinExpr node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = makeNode(JoinExpr);<br/></li>
<li>&nbsp; &nbsp; result-&gt;jointype = JOIN_SEMI;<br/></li>
<li>&nbsp; &nbsp; result-&gt;isNatural = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;larg = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* caller must fill this in */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;rarg = (Node *) rtr;<br/></li>
<li>&nbsp; &nbsp; result-&gt;usingClause = NIL;<br/></li>
<li>&nbsp; &nbsp; result-&gt;join_using_alias = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;quals = quals;<br/></li>
<li>&nbsp; &nbsp; result-&gt;alias = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;rtindex = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we don't need an RTE for it */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1371" title="optimizer/plan/subselect.c:1371">convert_EXISTS_sublink_to_join</a>: try to convert an EXISTS SubLink to a join<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The API of this function is identical to <a href="#L1254" title="optimizer/plan/subselect.c:1254">convert_ANY_sublink_to_join</a>'s,<br/></li>
<li></span><span class="Comment"> * except that we also support the case where the caller has found NOT EXISTS,<br/></li>
<li></span><span class="Comment"> * so we need an additional input parameter &quot;under_not&quot;.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>JoinExpr *<br/></li>
<li><a id="L1371">&#x200c;</a><span class="linkable">convert_EXISTS_sublink_to_join</span>(PlannerInfo *root, SubLink *sublink,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> under_not, Relids available_rels)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JoinExpr&nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *subselect = (Query *) sublink-&gt;subselect;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *whereClause;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varno;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; clause_varnos;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; upper_varnos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(sublink-&gt;subLinkType == EXISTS_SUBLINK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Can't flatten if it contains WITH.&nbsp; (We could arrange to <a href="../../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a> up the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WITH into the parent query's cteList, but that risks changing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * semantics, since a WITH ought to be executed once per associated query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * call.)&nbsp; Note that <a href="#L1254" title="optimizer/plan/subselect.c:1254">convert_ANY_sublink_to_join</a> doesn't have to reject<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this case, since it just produces a subquery RTE that doesn't have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get flattened into the parent query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (subselect-&gt;cteList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy the subquery so we can modify it safely (see comments in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L162" title="optimizer/plan/subselect.c:162">make_subplan</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; subselect = copyObject(subselect);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See if the subquery can be simplified based on the knowledge that it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * being used in EXISTS().&nbsp; If we aren't able to get rid of its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * targetlist, we have to fail, because the pullup operation leaves us<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with noplace to evaluate the targetlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1540" title="optimizer/plan/subselect.c:1540">simplify_EXISTS_query</a>(root, subselect))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Separate out the WHERE clause.&nbsp; (We could theoretically also remove<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * top-level plain JOIN/ON clauses, but it's probably not worth the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trouble.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; whereClause = subselect-&gt;jointree-&gt;quals;<br/></li>
<li>&nbsp; &nbsp; subselect-&gt;jointree-&gt;quals = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The rest of the sub-<a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> must not refer to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> Vars of the parent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * query.&nbsp; (Vars of higher levels should be okay, though.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/var.c.html#L441" title="optimizer/util/var.c:441">contain_vars_of_level</a>((Node *) subselect, <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On the other hand, the WHERE clause must contain some Vars of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent query, else it's not gonna be a join.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../util/var.c.html#L441" title="optimizer/util/var.c:441">contain_vars_of_level</a>(whereClause, <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't risk optimizing if the WHERE clause is volatile, either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>(whereClause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The subquery must have a nonempty jointree, but we can make it so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../prep/prepjointree.c.html#L284" title="optimizer/prep/prepjointree.c:284">replace_empty_jointree</a>(subselect);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare to <a href="../../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a> up the sub-<a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> into top <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We rely here on the assumption that the outer query has no references<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the inner (necessarily true). Therefore this is a lot easier than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * what <a href="../prep/prepjointree.c.html#L817" title="optimizer/prep/prepjointree.c:817">pull_up_subqueries</a> has to go through.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In fact, it's even easier than what <a href="#L1254" title="optimizer/plan/subselect.c:1254">convert_ANY_sublink_to_join</a> has to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do.&nbsp; The machinations of <a href="#L1540" title="optimizer/plan/subselect.c:1540">simplify_EXISTS_query</a> ensured that there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nothing interesting in the subquery except an rtable and jointree, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * even the jointree FromExpr no longer has quals.&nbsp; So we can just append<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the rtable to our own and use the FromExpr in our jointree. But first,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * adjust all level-zero varnos in the subquery to account for the rtable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * merger.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rtoffset = list_length(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rtable);<br/></li>
<li>&nbsp; &nbsp; <a href="../../rewrite/rewriteManip.c.html#L480" title="rewrite/rewriteManip.c:480">OffsetVarNodes</a>((Node *) subselect, rtoffset, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../rewrite/rewriteManip.c.html#L480" title="rewrite/rewriteManip.c:480">OffsetVarNodes</a>(whereClause, rtoffset, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Upper-level <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> in subquery will <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> be one level closer to their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent than <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>; in particular, anything that had been level 1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * becomes level zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../rewrite/rewriteManip.c.html#L849" title="rewrite/rewriteManip.c:849">IncrementVarSublevelsUp</a>((Node *) subselect, -<span class="Constant">1</span>, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../rewrite/rewriteManip.c.html#L849" title="rewrite/rewriteManip.c:849">IncrementVarSublevelsUp</a>(whereClause, -<span class="Constant">1</span>, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that the WHERE clause is adjusted to match the parent query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * environment, we can easily identify all the level-zero rels it uses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The ones &lt;= rtoffset belong to the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> query; the ones &gt; rtoffset do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; clause_varnos = <a href="../util/var.c.html#L108" title="optimizer/util/var.c:108">pull_varnos</a>(root, whereClause);<br/></li>
<li>&nbsp; &nbsp; upper_varnos = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; varno = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((varno = <a href="../../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(clause_varnos, varno)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (varno &lt;= rtoffset)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper_varnos = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(upper_varnos, varno);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(clause_varnos);<br/></li>
<li>&nbsp; &nbsp; Assert(!bms_is_empty(upper_varnos));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we've got the set of <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level varnos, we can make the last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check: only available_rels can be referenced.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(upper_varnos, available_rels))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we can attach the modified subquery rtable to the parent. This also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * adds subquery's RTEPermissionInfos into the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../rewrite/rewriteManip.c.html#L350" title="rewrite/rewriteManip.c:350">CombineRangeTables</a>(&amp;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rtable, &amp;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rteperminfos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subselect-&gt;rtable, subselect-&gt;rteperminfos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And finally, build the JoinExpr node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = makeNode(JoinExpr);<br/></li>
<li>&nbsp; &nbsp; result-&gt;jointype = under_not ? JOIN_ANTI : JOIN_SEMI;<br/></li>
<li>&nbsp; &nbsp; result-&gt;isNatural = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;larg = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* caller must fill this in */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* flatten out the FromExpr node if it's useless */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(subselect-&gt;jointree-&gt;fromlist) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;rarg = (Node *) linitial(subselect-&gt;jointree-&gt;fromlist);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;rarg = (Node *) subselect-&gt;jointree;<br/></li>
<li>&nbsp; &nbsp; result-&gt;usingClause = NIL;<br/></li>
<li>&nbsp; &nbsp; result-&gt;join_using_alias = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;quals = whereClause;<br/></li>
<li>&nbsp; &nbsp; result-&gt;alias = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;rtindex = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we don't need an RTE for it */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1540" title="optimizer/plan/subselect.c:1540">simplify_EXISTS_query</a>: remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> useless stuff in an EXISTS's subquery<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The only thing that matters about an EXISTS query is whether it returns<br/></li>
<li></span><span class="Comment"> * zero or more than zero rows.&nbsp; Therefore, we can remove certain SQL features<br/></li>
<li></span><span class="Comment"> * that won't affect that.&nbsp; The only part that is really likely to matter in<br/></li>
<li></span><span class="Comment"> * typical usage is simplifying the targetlist: it's a common habit to write<br/></li>
<li></span><span class="Comment"> * &quot;SELECT * FROM&quot; even though there is no need to evaluate <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> columns.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: by suppressing the targetlist we could cause an observable behavioral<br/></li>
<li></span><span class="Comment"> * change, namely that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> errors that might occur in evaluating the tlist<br/></li>
<li></span><span class="Comment"> * won't occur, nor will other side-effects of volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; This seems<br/></li>
<li></span><span class="Comment"> * unlikely to bother anyone in practice.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if was able to discard the targetlist, else false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1540">&#x200c;</a></span><span class="linkable">simplify_EXISTS_query</span>(PlannerInfo *root, Query *query)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't try to simplify at all if the query uses set operations,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggregates, grouping sets, SRFs, modifying CTEs, HAVING, OFFSET, or FOR<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * UPDATE/SHARE; <a href="../util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of these seem likely in normal usage and their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possible effects are complex.&nbsp; (Note: we could ignore an &quot;OFFSET 0&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clause, but that traditionally is used as an optimization fence, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;commandType != CMD_SELECT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query-&gt;setOperations ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query-&gt;hasAggs ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query-&gt;groupingSets ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query-&gt;hasWindowFuncs ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query-&gt;hasTargetSRFs ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query-&gt;hasModifyingCTE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query-&gt;havingQual ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query-&gt;limitOffset ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query-&gt;rowMarks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LIMIT with a constant positive (or NULL) value doesn't affect the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * semantics of EXISTS, so let's ignore such clauses.&nbsp; This is worth doing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because people accustomed to certain other DBMSes may be in the habit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of writing EXISTS(SELECT ... LIMIT 1) as an optimization.&nbsp; If there's a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LIMIT with anything else as argument, though, we can't simplify.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;limitCount)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The LIMIT clause has not yet been through <a href="../util/clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so we have to apply that here.&nbsp; It might seem like this is a waste<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of cycles, since the only case plausibly worth worrying about is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;LIMIT 1&quot; ... but what we'll actually see is &quot;LIMIT int8(1::int4)&quot;,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so we have to fold constants or we're not going to recognize it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *node = <a href="../util/clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a>(root, query-&gt;limitCount);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Const&nbsp; &nbsp; &nbsp;&nbsp; *limit;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Might as well update the query if we simplified the clause. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; query-&gt;limitCount = node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsA(node, Const))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; limit = (Const *) node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(limit-&gt;consttype == INT8OID);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!limit-&gt;constisnull &amp;&amp; DatumGetInt64(limit-&gt;constvalue) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Whether or not the targetlist is safe, we can drop the LIMIT. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; query-&gt;limitCount = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, we can throw away the targetlist, as well as <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> GROUP,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WINDOW, DISTINCT, and ORDER BY clauses; <a href="../util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of those clauses will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * change a nonzero-rows result to zero rows or vice versa.&nbsp; (Furthermore,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since our parsetree representation of these clauses depends on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * targetlist, we'd better throw them away if we drop the targetlist.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; query-&gt;targetList = NIL;<br/></li>
<li>&nbsp; &nbsp; query-&gt;groupClause = NIL;<br/></li>
<li>&nbsp; &nbsp; query-&gt;windowClause = NIL;<br/></li>
<li>&nbsp; &nbsp; query-&gt;distinctClause = NIL;<br/></li>
<li>&nbsp; &nbsp; query-&gt;sortClause = NIL;<br/></li>
<li>&nbsp; &nbsp; query-&gt;hasDistinctOn = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1628" title="optimizer/plan/subselect.c:1628">convert_EXISTS_to_ANY</a>: try to convert EXISTS to a hashable ANY sublink<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The subselect is expected to be a fresh copy that we can munge up,<br/></li>
<li></span><span class="Comment"> * and to have been successfully passed through <a href="#L1540" title="optimizer/plan/subselect.c:1540">simplify_EXISTS_query</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On success, the modified subselect is returned, and we store a suitable<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level test expression at *testexpr, plus a list of the subselect's<br/></li>
<li></span><span class="Comment"> * output Params at *paramIds.&nbsp; (The test expression is already Param-ified<br/></li>
<li></span><span class="Comment"> * and hence need not go through <a href="#L642" title="optimizer/plan/subselect.c:642">convert_testexpr</a>, which is why we have to<br/></li>
<li></span><span class="Comment"> * deal with the Param IDs specially.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On failure, returns NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Query *<br/></li>
<li><a id="L1628">&#x200c;</a><span class="linkable">convert_EXISTS_to_ANY</span>(PlannerInfo *root, Query *subselect,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node **testexpr, List **paramIds)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *whereClause;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *leftargs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *rightargs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *opids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *opcollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *newWhere,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *testlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *paramids;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *rc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *oc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *cc;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; resno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Query must not require a targetlist, since we have to insert a new one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Caller should have dealt with the case already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(subselect-&gt;targetList == NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Separate out the WHERE clause.&nbsp; (We could theoretically also remove<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * top-level plain JOIN/ON clauses, but it's probably not worth the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trouble.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; whereClause = subselect-&gt;jointree-&gt;quals;<br/></li>
<li>&nbsp; &nbsp; subselect-&gt;jointree-&gt;quals = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The rest of the sub-<a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> must not refer to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> Vars of the parent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * query.&nbsp; (Vars of higher levels should be okay, though.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we need not check for Aggrefs separately because we know the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sub-<a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> is as yet unoptimized; <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> uplevel Aggref must therefore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contain an uplevel Var reference.&nbsp; This is not the case below ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/var.c.html#L441" title="optimizer/util/var.c:441">contain_vars_of_level</a>((Node *) subselect, <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't risk optimizing if the WHERE clause is volatile, either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>(whereClause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clean up the WHERE clause by doing const-simplification etc on it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Aside from simplifying the processing we're about to do, this is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * important for being able to <a href="../../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a> chunks of the WHERE clause up into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent query.&nbsp; Since we are invoked partway through the parent's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="planner.c.html#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>() work, earlier steps of <a href="planner.c.html#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wouldn't get applied to the pulled-up stuff unless we do them here. For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the parts of the WHERE clause that get put back into the child query,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this work is partially duplicative, but it shouldn't hurt.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we do not run <a href="../util/var.c.html#L744" title="optimizer/util/var.c:744">flatten_join_alias_vars</a>.&nbsp; This is OK because <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent aliases were flattened already, and we're not going to <a href="../../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * child Vars (of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> description) into the parent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: passing the parent's root to <a href="../util/clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a> is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * technically wrong, but we can get away with it since only the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * boundParams (if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) are used, and those would be the same in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subroot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; whereClause = <a href="../util/clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a>(root, whereClause);<br/></li>
<li>&nbsp; &nbsp; whereClause = (Node *) <a href="../prep/prepqual.c.html#L293" title="optimizer/prep/prepqual.c:293">canonicalize_qual</a>((Expr *) whereClause, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; whereClause = (Node *) <a href="../../nodes/makefuncs.c.html#L737" title="nodes/makefuncs.c:737">make_ands_implicit</a>((Expr *) whereClause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> have a flattened implicit-AND list of clauses, which we try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * break apart into &quot;outervar = innervar&quot; <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> clauses. Anything that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't be broken apart just goes back into the newWhere list.&nbsp; Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we aren't trying hard yet to ensure that we have only outer or only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inner on each side; we'll check that if we get to the end.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; leftargs = rightargs = opids = opcollations = newWhere = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, (List *) whereClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OpExpr&nbsp; &nbsp; &nbsp;&nbsp; *expr = (OpExpr *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(expr, OpExpr) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L832" title="optimizer/plan/subselect.c:832">hash_ok_operator</a>(expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *leftarg = (Node *) linitial(expr-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *rightarg = (Node *) lsecond(expr-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/var.c.html#L441" title="optimizer/util/var.c:441">contain_vars_of_level</a>(leftarg, <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftargs = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(leftargs, leftarg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightargs = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rightargs, rightarg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opids = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(opids, expr-&gt;opno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcollations = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(opcollations, expr-&gt;inputcollid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/var.c.html#L441" title="optimizer/util/var.c:441">contain_vars_of_level</a>(rightarg, <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must commute the clause to put the outer var on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * left, because the hashing code in nodeSubplan.c expects<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that.&nbsp; This probably shouldn't ever fail, since hashable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operators ought to have commutators, but be paranoid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr-&gt;opno = <a href="../../utils/cache/lsyscache.c.html#L1509" title="utils/cache/lsyscache.c:1509">get_commutator</a>(expr-&gt;opno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(expr-&gt;opno) &amp;&amp; <a href="#L832" title="optimizer/plan/subselect.c:832">hash_ok_operator</a>(expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftargs = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(leftargs, rightarg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightargs = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rightargs, leftarg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opids = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(opids, expr-&gt;opno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcollations = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(opcollations, expr-&gt;inputcollid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If no commutator, no chance to <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> the WHERE clause */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Couldn't handle it as a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> clause */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newWhere = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newWhere, expr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> anything we could convert, fail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (leftargs == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There mustn't be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> parent Vars or Aggs in the stuff that we intend to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * put back into the child query.&nbsp; Note: you might think we don't need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check for Aggs separately, because an uplevel Agg must contain an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * uplevel Var in its argument.&nbsp; But it is possible that the uplevel Var<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * got optimized away by <a href="../util/clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a>.&nbsp; Consider<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SUM(CASE WHEN false THEN uplevelvar ELSE 0 <a href="../../regex/regcomp.c.html#L336" title="regex/regcomp.c:336">END</a>)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/var.c.html#L441" title="optimizer/util/var.c:441">contain_vars_of_level</a>((Node *) newWhere, <span class="Constant">1</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/var.c.html#L441" title="optimizer/util/var.c:441">contain_vars_of_level</a>((Node *) rightargs, <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasAggs &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../rewrite/rewriteManip.c.html#L85" title="rewrite/rewriteManip.c:85">contain_aggs_of_level</a>((Node *) newWhere, <span class="Constant">1</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../rewrite/rewriteManip.c.html#L85" title="rewrite/rewriteManip.c:85">contain_aggs_of_level</a>((Node *) rightargs, <span class="Constant">1</span>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And there can't be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> child Vars in the stuff we intend to <a href="../../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a> up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Note: we'd need to check for child Aggs too, except we know the child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has no aggs at all because of <a href="#L1540" title="optimizer/plan/subselect.c:1540">simplify_EXISTS_query</a>'s check. The same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * goes for window <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/var.c.html#L441" title="optimizer/util/var.c:441">contain_vars_of_level</a>((Node *) leftargs, <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also reject sublinks in the stuff we intend to <a href="../../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a> up.&nbsp; (It might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possible to support this, but doesn't seem worth the complication.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/clauses.c.html#L330" title="optimizer/util/clauses.c:330">contain_subplans</a>((Node *) leftargs))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Okay, adjust the sublevelsup in the stuff we're pulling up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../rewrite/rewriteManip.c.html#L849" title="rewrite/rewriteManip.c:849">IncrementVarSublevelsUp</a>((Node *) leftargs, -<span class="Constant">1</span>, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Put back <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> child-level-only WHERE clauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newWhere)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subselect-&gt;jointree-&gt;quals = (Node *) <a href="../../nodes/makefuncs.c.html#L726" title="nodes/makefuncs.c:726">make_ands_explicit</a>(newWhere);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build a new targetlist for the child that emits the expressions we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need.&nbsp; Concurrently, build a testexpr for the parent using Params to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reference the child outputs.&nbsp; (Since we generate Params directly here,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there will be no need to convert the testexpr in <a href="#L319" title="optimizer/plan/subselect.c:319">build_subplan</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tlist = testlist = paramids = NIL;<br/></li>
<li>&nbsp; &nbsp; resno = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; forfour(lc, leftargs, rc, rightargs, oc, opids, cc, opcollations)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *leftarg = (Node *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *rightarg = (Node *) lfirst(rc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opid = lfirst_oid(oc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcollation = lfirst_oid(cc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Param&nbsp; &nbsp; &nbsp;&nbsp; *param;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; param = <a href="../util/paramassign.c.html#L637" title="optimizer/util/paramassign.c:637">generate_new_exec_param</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(rightarg),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>(rightarg),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>(rightarg));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>((Expr *) rightarg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resno++,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; testlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(testlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/makefuncs.c.html#L628" title="nodes/makefuncs.c:628">make_opclause</a>(opid, BOOLOID, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Expr *) leftarg, (Expr *) param,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, opcollation));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; paramids = <a href="../../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(paramids, param-&gt;paramid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Put everything where it should go, and we're done */<br/></li>
<li></span>&nbsp; &nbsp; subselect-&gt;targetList = tlist;<br/></li>
<li>&nbsp; &nbsp; *testexpr = (Node *) <a href="../../nodes/makefuncs.c.html#L726" title="nodes/makefuncs.c:726">make_ands_explicit</a>(testlist);<br/></li>
<li>&nbsp; &nbsp; *paramIds = paramids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> subselect;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Replace correlation <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> (uplevel <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>) with Params.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Uplevel PlaceHolderVars, aggregates, GROUPING() expressions, and<br/></li>
<li></span><span class="Comment"> * MergeSupportFuncs are replaced, too.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: it is critical that this runs immediately after <a href="#L1919" title="optimizer/plan/subselect.c:1919">SS_process_sublinks</a>.<br/></li>
<li></span><span class="Comment"> * Since we do not recurse into the arguments of uplevel PHVs and aggregates,<br/></li>
<li></span><span class="Comment"> * they will get copied to the appropriate subplan args list in the parent<br/></li>
<li></span><span class="Comment"> * query with uplevel <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> not replaced by Params, but only adjusted in level<br/></li>
<li></span><span class="Comment"> * (see <a href="../util/paramassign.c.html#L197" title="optimizer/util/paramassign.c:197">replace_outer_placeholdervar</a> and <a href="../util/paramassign.c.html#L224" title="optimizer/util/paramassign.c:224">replace_outer_agg</a>).&nbsp; That's exactly<br/></li>
<li></span><span class="Comment"> * what we want for the <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> of the parent level --- but if a PHV's or<br/></li>
<li></span><span class="Comment"> * aggregate's argument contains <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> further-up variables, they have to be<br/></li>
<li></span><span class="Comment"> * replaced with Params in their turn. That will happen when the parent level<br/></li>
<li></span><span class="Comment"> * runs <a href="#L1868" title="optimizer/plan/subselect.c:1868">SS_replace_correlation_vars</a>.&nbsp; Therefore it must do so after expanding<br/></li>
<li></span><span class="Comment"> * its sublinks to subplans.&nbsp; And we don't want <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> steps in between, else<br/></li>
<li></span><span class="Comment"> * those steps would never get applied to the argument expressions, either in<br/></li>
<li></span><span class="Comment"> * the parent or the child level.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Another fairly tricky thing going on here is the handling of SubLinks in<br/></li>
<li></span><span class="Comment"> * the arguments of uplevel PHVs/aggregates.&nbsp; Those are not touched inside the<br/></li>
<li></span><span class="Comment"> * intermediate query level, either.&nbsp; Instead, <a href="#L1919" title="optimizer/plan/subselect.c:1919">SS_process_sublinks</a> recurses on<br/></li>
<li></span><span class="Comment"> * them after copying the PHV or Aggref expression into the parent plan level<br/></li>
<li></span><span class="Comment"> * (this is actually taken care of in <a href="#L319" title="optimizer/plan/subselect.c:319">build_subplan</a>).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Node *<br/></li>
<li><a id="L1868">&#x200c;</a><span class="linkable">SS_replace_correlation_vars</span>(PlannerInfo *root, Node *expr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No setup needed for tree walk, so away we go */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1875" title="optimizer/plan/subselect.c:1875">replace_correlation_vars_mutator</a>(expr, root);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Node *<br/></li>
<li><a id="L1875">&#x200c;</a><span class="linkable">replace_correlation_vars_mutator</span>(Node *node, PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((Var *) node)-&gt;varlevelsup &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) <a href="../util/paramassign.c.html#L120" title="optimizer/util/paramassign.c:120">replace_outer_var</a>(root, (Var *) node);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((PlaceHolderVar *) node)-&gt;phlevelsup &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) <a href="../util/paramassign.c.html#L197" title="optimizer/util/paramassign.c:197">replace_outer_placeholdervar</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (PlaceHolderVar *) node);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Aggref))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((Aggref *) node)-&gt;agglevelsup &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) <a href="../util/paramassign.c.html#L224" title="optimizer/util/paramassign.c:224">replace_outer_agg</a>(root, (Aggref *) node);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, GroupingFunc))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((GroupingFunc *) node)-&gt;agglevelsup &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) <a href="../util/paramassign.c.html#L270" title="optimizer/util/paramassign.c:270">replace_outer_grouping</a>(root, (GroupingFunc *) node);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, MergeSupportFunc))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;commandType != CMD_MERGE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) <a href="../util/paramassign.c.html#L317" title="optimizer/util/paramassign.c:317">replace_outer_merge_support</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (MergeSupportFunc *) node);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_mutator(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1875" title="optimizer/plan/subselect.c:1875">replace_correlation_vars_mutator</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) root);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Expand SubLinks to SubPlans in the given expression.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The isQual argument tells whether or not this expression is a WHERE/HAVING<br/></li>
<li></span><span class="Comment"> * qualifier expression.&nbsp; If it is, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> sublinks appearing at top level need<br/></li>
<li></span><span class="Comment"> * not distinguish FALSE from UNKNOWN return <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Node *<br/></li>
<li><a id="L1919">&#x200c;</a><span class="linkable">SS_process_sublinks</span>(PlannerInfo *root, Node *expr, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isQual)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="optimizer/plan/subselect.c:48">process_sublinks_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.root = root;<br/></li>
<li>&nbsp; &nbsp; context.isTopQual = isQual;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1929" title="optimizer/plan/subselect.c:1929">process_sublinks_mutator</a>(expr, &amp;context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Node *<br/></li>
<li><a id="L1929">&#x200c;</a><span class="linkable">process_sublinks_mutator</span>(Node *node, <a href="#L48" title="optimizer/plan/subselect.c:48">process_sublinks_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="optimizer/plan/subselect.c:48">process_sublinks_context</a> locContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; locContext.root = context-&gt;root;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, SubLink))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SubLink&nbsp; &nbsp; *sublink = (SubLink *) node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *testexpr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First, recursively process the lefthand-side expressions, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * They're not top-level anymore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; locContext.isTopQual = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; testexpr = <a href="#L1929" title="optimizer/plan/subselect.c:1929">process_sublinks_mutator</a>(sublink-&gt;testexpr, &amp;locContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now build the SubPlan node and make the expr to return.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L162" title="optimizer/plan/subselect.c:162">make_subplan</a>(context-&gt;root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Query *) sublink-&gt;subselect,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublink-&gt;subLinkType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublink-&gt;subLinkId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; testexpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;isTopQual);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't recurse into the arguments of an outer PHV, Aggref or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * GroupingFunc here.&nbsp; Any SubLinks in the arguments have to be dealt with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * at the outer query level; they'll be handled when <a href="#L319" title="optimizer/plan/subselect.c:319">build_subplan</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * collects the PHV, Aggref or GroupingFunc into the arguments to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * passed down to the current subplan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((PlaceHolderVar *) node)-&gt;phlevelsup &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, Aggref))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((Aggref *) node)-&gt;agglevelsup &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, GroupingFunc))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((GroupingFunc *) node)-&gt;agglevelsup &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We should never see a SubPlan expression in the input (since this is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the very routine that creates 'em to begin with).&nbsp; We shouldn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ourselves invoked directly on a Query, either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!IsA(node, SubPlan));<br/></li>
<li>&nbsp; &nbsp; Assert(!IsA(node, AlternativeSubPlan));<br/></li>
<li>&nbsp; &nbsp; Assert(!IsA(node, Query));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Because <a href="#L162" title="optimizer/plan/subselect.c:162">make_subplan</a>() could return an AND or OR clause, we have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * take steps to preserve AND/OR flatness of a qual.&nbsp; We assume the input<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has been AND/OR flattened and so we need no recursion here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Due to the coding here, we will not get called on the List subnodes of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an AND; and the input is *not* yet in implicit-AND format.&nbsp; So no check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is needed for a bare List.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Anywhere within the top-level AND/OR clause structure, we can tell<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L162" title="optimizer/plan/subselect.c:162">make_subplan</a>() that NULL and FALSE are interchangeable.&nbsp; So isTopQual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * propagates down in both cases.&nbsp; (Note that this is unlike the meaning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of &quot;top level qual&quot; used in most other places in Postgres.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (is_andclause(node))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newargs = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Still at qual top-level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; locContext.isTopQual = context-&gt;isTopQual;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, ((BoolExpr *) node)-&gt;args)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *newarg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newarg = <a href="#L1929" title="optimizer/plan/subselect.c:1929">process_sublinks_mutator</a>(lfirst(l), &amp;locContext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_andclause(newarg))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newargs = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(newargs, ((BoolExpr *) newarg)-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newargs = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newargs, newarg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) <a href="../../nodes/makefuncs.c.html#L654" title="nodes/makefuncs.c:654">make_andclause</a>(newargs);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_orclause(node))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newargs = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Still at qual top-level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; locContext.isTopQual = context-&gt;isTopQual;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, ((BoolExpr *) node)-&gt;args)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *newarg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newarg = <a href="#L1929" title="optimizer/plan/subselect.c:1929">process_sublinks_mutator</a>(lfirst(l), &amp;locContext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_orclause(newarg))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newargs = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(newargs, ((BoolExpr *) newarg)-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newargs = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newargs, newarg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) <a href="../../nodes/makefuncs.c.html#L670" title="nodes/makefuncs.c:670">make_orclause</a>(newargs);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we recurse down through anything other than an AND or OR node, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are definitely not at top qual level anymore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; locContext.isTopQual = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_mutator(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1929" title="optimizer/plan/subselect.c:1929">process_sublinks_mutator</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) &amp;locContext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2072" title="optimizer/plan/subselect.c:2072">SS_identify_outer_params</a> - identify the Params available from outer levels<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This must be run after <a href="#L1868" title="optimizer/plan/subselect.c:1868">SS_replace_correlation_vars</a> and <a href="#L1919" title="optimizer/plan/subselect.c:1919">SS_process_sublinks</a><br/></li>
<li></span><span class="Comment"> * processing is complete in a given query level as well as all of its<br/></li>
<li></span><span class="Comment"> * descendant levels (which means it's most practical to do it at the end of<br/></li>
<li></span><span class="Comment"> * processing the query level).&nbsp; We compute the set of paramIds that outer<br/></li>
<li></span><span class="Comment"> * levels will make available to this level+descendants, and record it in<br/></li>
<li></span><span class="Comment"> * root-&gt;outer_params for use while computing extParam/allParam sets in final<br/></li>
<li></span><span class="Comment"> * plan <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>.&nbsp; (We can't just compute it then, because the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> levels'<br/></li>
<li></span><span class="Comment"> * plan_params lists are transient and will be gone by then.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2072">&#x200c;</a></span><span class="linkable">SS_identify_outer_params</span>(PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *outer_params;<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *proot;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If no parameters have been assigned anywhere in the tree, we certainly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't need to do anything here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;glob-&gt;paramExecTypes == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan all query levels above this one to see which parameters are due to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be available from them, either because <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> query levels have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * requested them (via plan_params) or because they will be available from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initPlans of those levels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; outer_params = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (proot = root-&gt;parent_root; proot != <span class="Constant">NULL</span>; proot = proot-&gt;parent_root)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Include ordinary Var/PHV/Aggref/GroupingFunc params */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, proot-&gt;plan_params)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlannerParamItem *pitem = (PlannerParamItem *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_params = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(outer_params, pitem-&gt;paramId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Include <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outputs of outer-level initPlans */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, proot-&gt;init_plans)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SubPlan&nbsp; &nbsp; *initsubplan = (SubPlan *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l2, initsubplan-&gt;setParam)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_params = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(outer_params, lfirst_int(l2));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Include worktable ID, if a recursive query is being planned */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proot-&gt;wt_param_id &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_params = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(outer_params, proot-&gt;wt_param_id);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; root-&gt;outer_params = outer_params;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2134" title="optimizer/plan/subselect.c:2134">SS_charge_for_initplans</a> - account for initplans in Path costs &amp; parallelism<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> initPlans have been created in the current query level, they will<br/></li>
<li></span><span class="Comment"> * get attached to the Plan tree created from whichever Path we <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> from<br/></li>
<li></span><span class="Comment"> * the given rel.&nbsp; Increment all that rel's Paths' costs to account for them,<br/></li>
<li></span><span class="Comment"> * and if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the initPlans are parallel-unsafe, mark all the rel's Paths<br/></li>
<li></span><span class="Comment"> * parallel-unsafe as well.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is separate from <a href="#L2239" title="optimizer/plan/subselect.c:2239">SS_attach_initplans</a> because we might conditionally<br/></li>
<li></span><span class="Comment"> * create more initPlans during <a href="createplan.c.html#L337" title="optimizer/plan/createplan.c:337">create_plan</a>(), depending on which Path we<br/></li>
<li></span><span class="Comment"> * <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a>.&nbsp; However, Paths that would generate such initPlans are expected<br/></li>
<li></span><span class="Comment"> * to have included their cost and parallel-safety effects already.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2134">&#x200c;</a></span><span class="linkable">SS_charge_for_initplans</span>(PlannerInfo *root, RelOptInfo *final_rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; initplan_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; unsafe_initplans;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do if no initPlans */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;init_plans == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute the cost increment just once, since it will be the same for all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Paths.&nbsp; Also check for parallel-unsafe initPlans.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2198" title="optimizer/plan/subselect.c:2198">SS_compute_initplan_cost</a>(root-&gt;init_plans,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;initplan_cost, &amp;unsafe_initplans);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now adjust the costs and parallel_safe flags.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, final_rel-&gt;pathlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path = (Path *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;startup_cost += initplan_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;total_cost += initplan_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unsafe_initplans)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path-&gt;parallel_safe = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Adjust partial paths' costs too, or forget them entirely if we must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consider the rel parallel-unsafe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unsafe_initplans)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; final_rel-&gt;partial_pathlist = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; final_rel-&gt;consider_parallel = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, final_rel-&gt;partial_pathlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path = (Path *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path-&gt;startup_cost += initplan_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path-&gt;total_cost += initplan_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We needn't do <a href="../util/pathnode.c.html#L242" title="optimizer/util/pathnode.c:242">set_cheapest</a>() here, caller will do it */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2198" title="optimizer/plan/subselect.c:2198">SS_compute_initplan_cost</a> - count up the cost delta for some initplans<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The total cost returned in *initplan_cost_p should be added to both the<br/></li>
<li></span><span class="Comment"> * startup and total costs of the plan node the initplans get attached to.<br/></li>
<li></span><span class="Comment"> * We also report whether <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the initplans are not parallel-safe.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The primary user of this is <a href="#L2134" title="optimizer/plan/subselect.c:2134">SS_charge_for_initplans</a>, but it's also<br/></li>
<li></span><span class="Comment"> * used in adjusting costs when we move initplans to another plan node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2198">&#x200c;</a></span><span class="linkable">SS_compute_initplan_cost</span>(List *init_plans,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Cost *initplan_cost_p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *unsafe_initplans_p)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; initplan_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; unsafe_initplans;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We assume each initPlan gets run once during top plan startup.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a conservative overestimate, since in fact an initPlan might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * executed later than plan startup, or even not at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; initplan_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; unsafe_initplans = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, init_plans)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SubPlan&nbsp; &nbsp; *initsubplan = lfirst_node(SubPlan, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initplan_cost += initsubplan-&gt;startup_cost + initsubplan-&gt;per_call_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!initsubplan-&gt;parallel_safe)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsafe_initplans = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *initplan_cost_p = initplan_cost;<br/></li>
<li>&nbsp; &nbsp; *unsafe_initplans_p = unsafe_initplans;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2239" title="optimizer/plan/subselect.c:2239">SS_attach_initplans</a> - attach initplans to topmost plan node<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Attach <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> initplans created in the current query level to the specified<br/></li>
<li></span><span class="Comment"> * plan node, which should normally be the topmost node for the query level.<br/></li>
<li></span><span class="Comment"> * (In principle the initPlans could go in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> node at or above where they're<br/></li>
<li></span><span class="Comment"> * referenced; but there seems no reason to put them <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> than the<br/></li>
<li></span><span class="Comment"> * topmost node, so we don't bother to track exactly where they came from.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We do not touch the plan node's cost or parallel_safe flag.&nbsp; The initplans<br/></li>
<li></span><span class="Comment"> * must have been accounted for in <a href="#L2134" title="optimizer/plan/subselect.c:2134">SS_charge_for_initplans</a>, or by <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> later<br/></li>
<li></span><span class="Comment"> * code that adds initplans via <a href="#L3017" title="optimizer/plan/subselect.c:3017">SS_make_initplan_from_plan</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2239">&#x200c;</a></span><span class="linkable">SS_attach_initplans</span>(PlannerInfo *root, Plan *plan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; plan-&gt;initPlan = root-&gt;init_plans;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2254" title="optimizer/plan/subselect.c:2254">SS_finalize_plan</a> - do final parameter processing for a completed Plan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This recursively computes the extParam and allParam sets for every Plan<br/></li>
<li></span><span class="Comment"> * node in the given plan tree.&nbsp; (Oh, and RangeTblFunction.funcparams too.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We assume that <a href="#L2254" title="optimizer/plan/subselect.c:2254">SS_finalize_plan</a> has already been run on <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> initplans or<br/></li>
<li></span><span class="Comment"> * subplans the plan tree could reference.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2254">&#x200c;</a></span><span class="linkable">SS_finalize_plan</span>(PlannerInfo *root, Plan *plan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No setup needed, just recurse through plan tree. */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L2292" title="optimizer/plan/subselect.c:2292">finalize_plan</a>(root, plan, -<span class="Constant">1</span>, root-&gt;outer_params, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Recursive processing of all nodes in the plan tree<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * gather_param is the rescan_param of an ancestral Gather/GatherMerge,<br/></li>
<li></span><span class="Comment"> * or -1 if there is <a href="../util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * valid_params is the set of param IDs supplied by outer plan levels<br/></li>
<li></span><span class="Comment"> * that are valid to reference in this plan node or its children.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * scan_params is a set of param IDs to force scan plan nodes to reference.<br/></li>
<li></span><span class="Comment"> * This is for <a href="../../executor/execMain.c.html#L2470" title="executor/execMain.c:2470">EvalPlanQual</a> support, and is always NULL at the top of the<br/></li>
<li></span><span class="Comment"> * recursion.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The return value is the computed allParam set for the given Plan node.<br/></li>
<li></span><span class="Comment"> * This is just an <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> notational convenience: we can add a child<br/></li>
<li></span><span class="Comment"> * plan's allParams to the set of param IDs of interest to this level<br/></li>
<li></span><span class="Comment"> * in the same statement that recurses to that child.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Do not scribble on caller's <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of valid_params or scan_params!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: although we attempt to deal with initPlans anywhere in the tree, the<br/></li>
<li></span><span class="Comment"> * logic is not really right.&nbsp; The problem is that a plan node might return an<br/></li>
<li></span><span class="Comment"> * output Param of its initPlan as a targetlist item, in which case it's valid<br/></li>
<li></span><span class="Comment"> * for the parent plan level to reference that same Param; the parent's usage<br/></li>
<li></span><span class="Comment"> * will be converted into a Var referencing the child plan node by setrefs.c.<br/></li>
<li></span><span class="Comment"> * But this function would see the parent's reference as out of scope and<br/></li>
<li></span><span class="Comment"> * complain about it.&nbsp; For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, this does not matter because the <a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> only<br/></li>
<li></span><span class="Comment"> * attaches initPlans to the topmost plan node in a query level, so the case<br/></li>
<li></span><span class="Comment"> * doesn't arise.&nbsp; If we ever <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> this processing into setrefs.c, maybe it<br/></li>
<li></span><span class="Comment"> * can be handled more cleanly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Bitmapset *<br/></li>
<li><a id="L2292">&#x200c;</a><span class="linkable">finalize_plan</span>(PlannerInfo *root, Plan *plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> gather_param,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bitmapset *valid_params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bitmapset *scan_params)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L54" title="optimizer/plan/subselect.c:54">finalize_primnode_context</a> context;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locally_added_param;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *nestloop_params;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *initExtParam;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *initSetParam;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *child_params;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plan == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.root = root;<br/></li>
<li>&nbsp; &nbsp; context.paramids = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> set to empty */<br/></li>
<li></span>&nbsp; &nbsp; locally_added_param = -<span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* there isn't one */<br/></li>
<li></span>&nbsp; &nbsp; nestloop_params = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there aren't <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Examine <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> initPlans to determine the set of external params they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reference and the set of output params they supply.&nbsp; (We assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L2254" title="optimizer/plan/subselect.c:2254">SS_finalize_plan</a> was run on them already.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; initExtParam = initSetParam = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(l, plan-&gt;initPlan)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SubPlan&nbsp; &nbsp; *initsubplan = (SubPlan *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *initplan = planner_subplan_get_plan(root, initsubplan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initExtParam = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(initExtParam, initplan-&gt;extParam);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l2, initsubplan-&gt;setParam)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initSetParam = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(initSetParam, lfirst_int(l2));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Any setParams are validly referenceable in this node and children */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (initSetParam)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; valid_params = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(valid_params, initSetParam);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When we call <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>, context.paramids sets are automatically<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * merged together.&nbsp; But when recursing to self, we have to do it the hard<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * way.&nbsp; We want the paramids set to include params in subplans as well as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * at this level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find params in targetlist and qual */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) plan-&gt;targetlist, &amp;context);<br/></li>
<li>&nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) plan-&gt;qual, &amp;context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's a parallel-aware scan node, mark it as dependent on the parent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Gather/GatherMerge's rescan Param.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (gather_param &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;parallel-aware plan node is not below a Gather&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context.paramids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(context.paramids, gather_param);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check additional node-type-specific fields */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (nodeTag(plan))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Result:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>(((Result *) plan)-&gt;resconstantqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SeqScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.paramids = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context.paramids, scan_params);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SampleScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) ((SampleScan *) plan)-&gt;tablesample,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.paramids = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context.paramids, scan_params);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IndexScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) ((IndexScan *) plan)-&gt;indexqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) ((IndexScan *) plan)-&gt;indexorderby,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we need not look at indexqualorig, since it will have the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * param references as indexqual.&nbsp; Likewise, we can ignore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indexorderbyorig.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.paramids = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context.paramids, scan_params);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IndexOnlyScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) ((IndexOnlyScan *) plan)-&gt;indexqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) ((IndexOnlyScan *) plan)-&gt;recheckqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) ((IndexOnlyScan *) plan)-&gt;indexorderby,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we need not look at indextlist, since it cannot contain Params.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.paramids = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context.paramids, scan_params);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_BitmapIndexScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) ((BitmapIndexScan *) plan)-&gt;indexqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we need not look at indexqualorig, since it will have the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * param references as indexqual.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_BitmapHeapScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) ((BitmapHeapScan *) plan)-&gt;bitmapqualorig,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.paramids = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context.paramids, scan_params);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_TidScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) ((TidScan *) plan)-&gt;tidquals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.paramids = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context.paramids, scan_params);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_TidRangeScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) ((TidRangeScan *) plan)-&gt;tidrangequals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.paramids = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context.paramids, scan_params);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SubqueryScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SubqueryScan *sscan = (SubqueryScan *) plan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *subquery_params;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We must run <a href="#L2292" title="optimizer/plan/subselect.c:2292">finalize_plan</a> on the subquery */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../util/relnode.c.html#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(root, sscan-&gt;scan.scanrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subquery_params = rel-&gt;subroot-&gt;outer_params;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (gather_param &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subquery_params = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(<a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(subquery_params),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gather_param);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2292" title="optimizer/plan/subselect.c:2292">finalize_plan</a>(rel-&gt;subroot, sscan-&gt;subplan, gather_param,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subquery_params, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now we can add its extParams to the parent's params */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.paramids = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context.paramids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sscan-&gt;subplan-&gt;extParam);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We need scan_params too, though */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.paramids = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context.paramids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scan_params);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_FunctionScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FunctionScan *fscan = (FunctionScan *) plan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Call <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a> independently on each function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expression, so that we can record which params are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * referenced in each, in order to decide which need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * re-evaluating during rescan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, fscan-&gt;<a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblFunction *rtfunc = (RangeTblFunction *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L54" title="optimizer/plan/subselect.c:54">finalize_primnode_context</a> funccontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; funccontext = context;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; funccontext.paramids = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>(rtfunc-&gt;funcexpr, &amp;funccontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remember results for execution */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtfunc-&gt;funcparams = funccontext.paramids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* add the function's params to the overall set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.paramids = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context.paramids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; funccontext.paramids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.paramids = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context.paramids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scan_params);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_TableFuncScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) ((TableFuncScan *) plan)-&gt;tablefunc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.paramids = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context.paramids, scan_params);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ValuesScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) ((ValuesScan *) plan)-&gt;values_lists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.paramids = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context.paramids, scan_params);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_CteScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * You might think we should add the node's cteParam to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * paramids, but we shouldn't because that param is just a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * linkage mechanism for multiple CteScan nodes for the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * CTE; it is never used for changed-param signaling.&nbsp; What we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have to do instead is to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the referenced CTE plan and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * incorporate its external paramids, so that the correct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * things will happen if the CTE references outer-level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * variables.&nbsp; See test cases for bug #4902.&nbsp; (We assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L2254" title="optimizer/plan/subselect.c:2254">SS_finalize_plan</a> was run on the CTE plan already.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan_id = ((CteScan *) plan)-&gt;ctePlanId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *cteplan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* so, do this ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plan_id &lt; <span class="Constant">1</span> || plan_id &gt; list_length(root-&gt;glob-&gt;subplans))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> plan for CteScan referencing plan ID </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plan_id);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cteplan = (Plan *) list_nth(root-&gt;glob-&gt;subplans, plan_id - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.paramids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context.paramids, cteplan-&gt;extParam);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... but not this */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.paramids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(context.paramids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((CteScan *) plan)-&gt;cteParam);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.paramids = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context.paramids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scan_params);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_WorkTableScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.paramids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(context.paramids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((WorkTableScan *) plan)-&gt;wtParam);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.paramids = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context.paramids, scan_params);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_NamedTuplestoreScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.paramids = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context.paramids, scan_params);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ForeignScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForeignScan *fscan = (ForeignScan *) plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) fscan-&gt;fdw_exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) fscan-&gt;fdw_recheck_quals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We assume fdw_scan_tlist cannot contain Params */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.paramids = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context.paramids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scan_params);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_CustomScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CustomScan *cscan = (CustomScan *) plan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) cscan-&gt;custom_exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We assume custom_scan_tlist cannot contain Params */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.paramids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context.paramids, scan_params);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* child nodes if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, cscan-&gt;custom_plans)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.paramids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context.paramids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2292" title="optimizer/plan/subselect.c:2292">finalize_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Plan *) lfirst(lc),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gather_param,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valid_params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan_params));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ModifyTable:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ModifyTable *mtplan = (ModifyTable *) plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Force descendant scan nodes to reference epqParam */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locally_added_param = mtplan-&gt;epqParam;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valid_params = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(<a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(valid_params),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locally_added_param);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan_params = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(<a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(scan_params),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; locally_added_param);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) mtplan-&gt;returningLists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) mtplan-&gt;onConflictSet,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) mtplan-&gt;onConflictWhere,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* exclRelTlist contains only Vars, doesn't need examination */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Append:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, ((Append *) plan)-&gt;appendplans)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.paramids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context.paramids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2292" title="optimizer/plan/subselect.c:2292">finalize_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Plan *) lfirst(l),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gather_param,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valid_params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan_params));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_MergeAppend:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, ((MergeAppend *) plan)-&gt;mergeplans)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.paramids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context.paramids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2292" title="optimizer/plan/subselect.c:2292">finalize_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Plan *) lfirst(l),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gather_param,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valid_params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan_params));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_BitmapAnd:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, ((BitmapAnd *) plan)-&gt;bitmapplans)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.paramids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context.paramids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2292" title="optimizer/plan/subselect.c:2292">finalize_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Plan *) lfirst(l),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gather_param,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valid_params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan_params));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_BitmapOr:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, ((BitmapOr *) plan)-&gt;bitmapplans)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.paramids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context.paramids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2292" title="optimizer/plan/subselect.c:2292">finalize_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Plan *) lfirst(l),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gather_param,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valid_params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan_params));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_NestLoop:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) ((Join *) plan)-&gt;joinqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* collect set of params that will be passed to right child */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, ((NestLoop *) plan)-&gt;nestParams)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NestLoopParam *nlp = (NestLoopParam *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nestloop_params = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(nestloop_params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nlp-&gt;paramno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_MergeJoin:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) ((Join *) plan)-&gt;joinqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) ((MergeJoin *) plan)-&gt;mergeclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_HashJoin:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) ((Join *) plan)-&gt;joinqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) ((HashJoin *) plan)-&gt;hashclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Hash:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) ((Hash *) plan)-&gt;hashkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Limit:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>(((Limit *) plan)-&gt;limitOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>(((Limit *) plan)-&gt;limitCount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_RecursiveUnion:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* child nodes are allowed to reference wtParam */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locally_added_param = ((RecursiveUnion *) plan)-&gt;wtParam;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valid_params = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(<a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(valid_params),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locally_added_param);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* wtParam does *not* get added to scan_params */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_LockRows:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Force descendant scan nodes to reference epqParam */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locally_added_param = ((LockRows *) plan)-&gt;epqParam;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valid_params = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(<a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(valid_params),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locally_added_param);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan_params = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(<a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(scan_params),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; locally_added_param);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Agg:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Agg&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *agg = (Agg *) plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * AGG_HASHED plans need to know which Params are referenced<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in aggregate calls.&nbsp; Do a separate scan to identify them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (agg-&gt;aggstrategy == AGG_HASHED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L54" title="optimizer/plan/subselect.c:54">finalize_primnode_context</a> aggcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggcontext.root = root;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggcontext.paramids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2974" title="optimizer/plan/subselect.c:2974">finalize_agg_primnode</a>((Node *) agg-&gt;plan.targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;aggcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2974" title="optimizer/plan/subselect.c:2974">finalize_agg_primnode</a>((Node *) agg-&gt;plan.qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;aggcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; agg-&gt;aggParams = aggcontext.paramids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_WindowAgg:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>(((WindowAgg *) plan)-&gt;startOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>(((WindowAgg *) plan)-&gt;endOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Gather:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* child nodes are allowed to reference rescan_param, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locally_added_param = ((Gather *) plan)-&gt;rescan_param;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locally_added_param &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valid_params = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(<a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(valid_params),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locally_added_param);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We currently don't support nested Gathers.&nbsp; The issue so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * far as this function is concerned would be how to identify<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which child nodes depend on which Gather.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(gather_param &lt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Pass down rescan_param to child parallel-aware nodes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gather_param = locally_added_param;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* rescan_param does *not* get added to scan_params */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_GatherMerge:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* child nodes are allowed to reference rescan_param, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locally_added_param = ((GatherMerge *) plan)-&gt;rescan_param;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locally_added_param &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valid_params = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(<a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(valid_params),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locally_added_param);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We currently don't support nested Gathers.&nbsp; The issue so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * far as this function is concerned would be how to identify<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which child nodes depend on which Gather.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(gather_param &lt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Pass down rescan_param to child parallel-aware nodes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gather_param = locally_added_param;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* rescan_param does *not* get added to scan_params */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Memoize:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) ((Memoize *) plan)-&gt;param_exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ProjectSet:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Material:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Sort:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IncrementalSort:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Unique:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SetOp:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Group:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no node-type-specific fields need fixing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) nodeTag(plan));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process left and right child plans, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; child_params = <a href="#L2292" title="optimizer/plan/subselect.c:2292">finalize_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plan-&gt;lefttree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gather_param,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; valid_params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scan_params);<br/></li>
<li>&nbsp; &nbsp; context.paramids = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context.paramids, child_params);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nestloop_params)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* right child can reference nestloop_params as well as valid_params */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; child_params = <a href="#L2292" title="optimizer/plan/subselect.c:2292">finalize_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plan-&gt;righttree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gather_param,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(nestloop_params, valid_params),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scan_params);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and they don't count as parameters used at my level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; child_params = <a href="../../nodes/bitmapset.c.html#L346" title="nodes/bitmapset.c:346">bms_difference</a>(child_params, nestloop_params);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(nestloop_params);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* easy case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; child_params = <a href="#L2292" title="optimizer/plan/subselect.c:2292">finalize_plan</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plan-&gt;righttree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gather_param,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; valid_params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scan_params);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; context.paramids = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context.paramids, child_params);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Any locally generated parameter doesn't count towards its generating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plan node's external dependencies.&nbsp; (Note: if we changed valid_params<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and/or scan_params, we leak those bitmapsets; not worth the notational<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trouble to clean them up.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (locally_added_param &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context.paramids = <a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(context.paramids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locally_added_param);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we have all the paramids referenced in this node and children */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(context.paramids, valid_params))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;plan should not reference subplan's variable&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The plan node's allParam and extParam fields should include all its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * referenced paramids, plus contributions from <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> child initPlans.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> setParams of the initPlans should not be present in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent node's extParams, only in its allParams.&nbsp; (It's possible that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some initPlans have extParams that are setParams of other initPlans.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* allParam must include initplans' extParams and setParams */<br/></li>
<li></span>&nbsp; &nbsp; plan-&gt;allParam = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(context.paramids, initExtParam);<br/></li>
<li>&nbsp; &nbsp; plan-&gt;allParam = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(plan-&gt;allParam, initSetParam);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* extParam must include <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> initplan extParams */<br/></li>
<li></span>&nbsp; &nbsp; plan-&gt;extParam = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(context.paramids, initExtParam);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* but not <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> initplan setParams */<br/></li>
<li></span>&nbsp; &nbsp; plan-&gt;extParam = <a href="../../nodes/bitmapset.c.html#L1161" title="nodes/bitmapset.c:1161">bms_del_members</a>(plan-&gt;extParam, initSetParam);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan-&gt;allParam;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>: add IDs of all PARAM_EXEC params that appear (or will<br/></li>
<li></span><span class="Comment"> * appear) in the given expression tree to the result set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2890">&#x200c;</a></span><span class="linkable">finalize_primnode</span>(Node *node, <a href="#L54" title="optimizer/plan/subselect.c:54">finalize_primnode_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Param))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((Param *) node)-&gt;paramkind == PARAM_EXEC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramid = ((Param *) node)-&gt;paramid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;paramids = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(context-&gt;paramids, paramid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no more to do here */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, Aggref))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check to see if the aggregate will be replaced by a Param<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * referencing a subquery output during setrefs.c.&nbsp; If so, we must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * account for that Param here.&nbsp; (For various reasons, it's not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * convenient to perform that substitution earlier than setrefs.c, nor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to perform this processing after setrefs.c.&nbsp; Thus we need a wart<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Aggref&nbsp; &nbsp; &nbsp;&nbsp; *aggref = (Aggref *) node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Param&nbsp; &nbsp; &nbsp;&nbsp; *aggparam;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggparam = <a href="setrefs.c.html#L3427" title="optimizer/plan/setrefs.c:3427">find_minmax_agg_replacement_param</a>(context-&gt;root, aggref);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggparam != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;paramids = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(context-&gt;paramids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggparam-&gt;paramid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fall through to examine the agg's arguments */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, SubPlan))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SubPlan&nbsp; &nbsp; *subplan = (SubPlan *) node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = planner_subplan_get_plan(context-&gt;root, subplan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *subparamids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse into the testexpr, but not into the Plan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>(subplan-&gt;testexpr, context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> param IDs of output parameters of the subplan that were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * referenced in the testexpr.&nbsp; These are not interesting for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parameter change signaling since we always re-evaluate the subplan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that this wouldn't work too well if there might be uses of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * same param IDs elsewhere in the plan, but that can't happen because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../util/paramassign.c.html#L637" title="optimizer/util/paramassign.c:637">generate_new_exec_param</a> never tries to <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> params.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, subplan-&gt;paramIds)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;paramids = <a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(context-&gt;paramids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lfirst_int(lc));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Also examine args list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) subplan-&gt;args, context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add params needed by the subplan to paramids, but excluding those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we will pass down to it.&nbsp; (We assume <a href="#L2254" title="optimizer/plan/subselect.c:2254">SS_finalize_plan</a> was run on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the subplan already.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; subparamids = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(plan-&gt;extParam);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, subplan-&gt;parParam)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subparamids = <a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(subparamids, lfirst_int(lc));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;paramids = <a href="../../nodes/bitmapset.c.html#L1230" title="nodes/bitmapset.c:1230">bms_join</a>(context-&gt;paramids, subparamids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no more to do here */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2974" title="optimizer/plan/subselect.c:2974">finalize_agg_primnode</a>: <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> all Aggref nodes in the given expression tree,<br/></li>
<li></span><span class="Comment"> * and add IDs of all PARAM_EXEC params appearing within their aggregated<br/></li>
<li></span><span class="Comment"> * arguments to the result set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2974">&#x200c;</a></span><span class="linkable">finalize_agg_primnode</span>(Node *node, <a href="#L54" title="optimizer/plan/subselect.c:54">finalize_primnode_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Aggref))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Aggref&nbsp; &nbsp; &nbsp;&nbsp; *agg = (Aggref *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we should not consider the direct arguments, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) agg-&gt;args, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2890" title="optimizer/plan/subselect.c:2890">finalize_primnode</a>((Node *) agg-&gt;aggfilter, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there can't be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> Aggrefs below here */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L2974" title="optimizer/plan/subselect.c:2974">finalize_agg_primnode</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3001" title="optimizer/plan/subselect.c:3001">SS_make_initplan_output_param</a> - make a Param for an initPlan's output<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The plan is expected to return a scalar value of the given type/collation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that in some cases the initplan may not ever appear in the finished<br/></li>
<li></span><span class="Comment"> * plan tree.&nbsp; If that happens, we'll have wasted a PARAM_EXEC slot, which<br/></li>
<li></span><span class="Comment"> * is no big deal.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Param *<br/></li>
<li><a id="L3001">&#x200c;</a><span class="linkable">SS_make_initplan_output_param</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid resulttype, int32 resulttypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid resultcollation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../util/paramassign.c.html#L637" title="optimizer/util/paramassign.c:637">generate_new_exec_param</a>(root, resulttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; resulttypmod, resultcollation);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3017" title="optimizer/plan/subselect.c:3017">SS_make_initplan_from_plan</a> - given a plan tree, make it an <a href="../../executor/execMain.c.html#L833" title="executor/execMain.c:833">InitPlan</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We build an EXPR_SUBLINK SubPlan node and put it into the initplan<br/></li>
<li></span><span class="Comment"> * list for the outer query level.&nbsp; A Param that represents the initplan's<br/></li>
<li></span><span class="Comment"> * output has already been assigned using <a href="#L3001" title="optimizer/plan/subselect.c:3001">SS_make_initplan_output_param</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3017">&#x200c;</a></span><span class="linkable">SS_make_initplan_from_plan</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PlannerInfo *subroot, Plan *plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Param *prm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SubPlan&nbsp; &nbsp; *node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add the subplan and its PlannerInfo, as well as a dummy path entry, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the global lists.&nbsp; Ideally we'd save a real path, but right <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sole caller doesn't build a path that exactly matches the plan.&nbsp; Since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're not currently going to need the path for an initplan, it's not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worth requiring construction of such a path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;glob-&gt;subplans = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;glob-&gt;subplans, plan);<br/></li>
<li>&nbsp; &nbsp; root-&gt;glob-&gt;subpaths = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;glob-&gt;subpaths, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; root-&gt;glob-&gt;subroots = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;glob-&gt;subroots, subroot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a SubPlan node and add it to the outer list of InitPlans. Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it has to appear after <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other InitPlans it might depend on (see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comments in <a href="../../executor/execAmi.c.html#L76" title="executor/execAmi.c:76">ExecReScan</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; node = makeNode(SubPlan);<br/></li>
<li>&nbsp; &nbsp; node-&gt;subLinkType = EXPR_SUBLINK;<br/></li>
<li>&nbsp; &nbsp; node-&gt;plan_id = list_length(root-&gt;glob-&gt;subplans);<br/></li>
<li>&nbsp; &nbsp; node-&gt;plan_name = psprintf(<span class="Constant">&quot;<a href="../../executor/execMain.c.html#L833" title="executor/execMain.c:833">InitPlan</a> </span><span class="Special">%d</span><span class="Constant">&quot;</span>, node-&gt;plan_id);<br/></li>
<li>&nbsp; &nbsp; <a href="#L118" title="optimizer/plan/subselect.c:118">get_first_col_type</a>(plan, &amp;node-&gt;firstColType, &amp;node-&gt;firstColTypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;node-&gt;firstColCollation);<br/></li>
<li>&nbsp; &nbsp; node-&gt;parallel_safe = plan-&gt;parallel_safe;<br/></li>
<li>&nbsp; &nbsp; node-&gt;setParam = list_make1_int(prm-&gt;paramid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; root-&gt;init_plans = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;init_plans, node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The node can't have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> inputs (since it's an initplan), so the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parParam and args lists remain empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set costs of SubPlan using info from the plan tree */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../path/costsize.c.html#L4435" title="optimizer/path/costsize.c:4435">cost_subplan</a>(subroot, node, plan);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
