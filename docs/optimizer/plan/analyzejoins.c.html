<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>optimizer/plan/analyzejoins.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>optimizer/plan/analyzejoins.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L44">enable_self_join_removal</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L1439">ReplaceVarnoContext</a></li>
<li><a href="#L42">SelfJoinCandidate</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L145">clause_sides_match_join</a></li>
<li><a href="#L1184">distinct_col_search</a></li>
<li><a href="#L1224">innerrel_is_unique</a></li>
<li><a href="#L1244">innerrel_is_unique_ext</a></li>
<li><a href="#L1374">is_innerrel_unique_for</a></li>
<li><a href="#L177">join_is_removable</a></li>
<li><a href="#L2041">match_unique_clauses</a></li>
<li><a href="#L1035">query_is_distinct_for</a></li>
<li><a href="#L998">query_supports_distinctness</a></li>
<li><a href="#L764">reduce_unique_semijoins</a></li>
<li><a href="#L899">rel_is_distinct_for</a></li>
<li><a href="#L840">rel_supports_distinctness</a></li>
<li><a href="#L483">remove_leftjoinrel_from_query</a></li>
<li><a href="#L656">remove_rel_from_eclass</a></li>
<li><a href="#L710">remove_rel_from_joinlist</a></li>
<li><a href="#L347">remove_rel_from_query</a></li>
<li><a href="#L599">remove_rel_from_restrictinfo</a></li>
<li><a href="#L1747">remove_self_join_rel</a></li>
<li><a href="#L2111">remove_self_joins_one_group</a></li>
<li><a href="#L2279">remove_self_joins_recurse</a></li>
<li><a href="#L81">remove_useless_joins</a></li>
<li><a href="#L2453">remove_useless_self_joins</a></li>
<li><a href="#L1575">replace_relid</a></li>
<li><a href="#L1547">replace_varno</a></li>
<li><a href="#L1442">replace_varno_walker</a></li>
<li><a href="#L1714">restrict_infos_logically_equal</a></li>
<li><a href="#L2406">self_join_candidates_cmp</a></li>
<li><a href="#L1976">split_selfjoin_quals</a></li>
<li><a href="#L1614">update_eclasses</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * analyzejoins.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Routines for simplifying joins after initial query analysis<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * While we do a great deal of join simplification in prep/prepjointree.c,<br/></li>
<li></span><span class="Comment"> * certain optimizations cannot be performed at that stage for lack of<br/></li>
<li></span><span class="Comment"> * detailed information about the query.&nbsp; The routines here are invoked<br/></li>
<li></span><span class="Comment"> * after initsplan.c has done its work, and can do additional join removal<br/></li>
<li></span><span class="Comment"> * and simplification steps based on the information extracted.&nbsp; The penalty<br/></li>
<li></span><span class="Comment"> * is that we have to work harder to clean up after ourselves when we modify<br/></li>
<li></span><span class="Comment"> * the query, since the derived data structures have to be updated too.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/optimizer/plan/analyzejoins.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_class.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/joininfo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/pathnode.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/paths.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/planmain.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/restrictinfo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The struct containing self-join candidate.&nbsp; Used to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> duplicate reloids.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reloid;<br/></li>
<li><a id="L42">&#x200c;</a>} <span class="linkable">SelfJoinCandidate</span>;<br/></li>
<li><br/></li>
<li><a id="L44">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">enable_self_join_removal</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* local <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L177" title="optimizer/plan/analyzejoins.c:177">join_is_removable</a>(PlannerInfo *root, SpecialJoinInfo *sjinfo);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L483" title="optimizer/plan/analyzejoins.c:483">remove_leftjoinrel_from_query</a>(PlannerInfo *root, <span class="Type">int</span> relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpecialJoinInfo *sjinfo);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L599" title="optimizer/plan/analyzejoins.c:599">remove_rel_from_restrictinfo</a>(RestrictInfo *rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> relid, <span class="Type">int</span> ojrelid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L656" title="optimizer/plan/analyzejoins.c:656">remove_rel_from_eclass</a>(EquivalenceClass *ec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> relid, <span class="Type">int</span> ojrelid);<br/></li>
<li><span class="Type">static</span> List *<a href="#L710" title="optimizer/plan/analyzejoins.c:710">remove_rel_from_joinlist</a>(List *joinlist, <span class="Type">int</span> relid, <span class="Type">int</span> *nremoved);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L840" title="optimizer/plan/analyzejoins.c:840">rel_supports_distinctness</a>(PlannerInfo *root, RelOptInfo *rel);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L899" title="optimizer/plan/analyzejoins.c:899">rel_is_distinct_for</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *clause_list, List **extra_clauses);<br/></li>
<li><span class="Type">static</span> Oid&nbsp; &nbsp; <a href="#L1184" title="optimizer/plan/analyzejoins.c:1184">distinct_col_search</a>(<span class="Type">int</span> colno, List *colnos, List *opids);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1374" title="optimizer/plan/analyzejoins.c:1374">is_innerrel_unique_for</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids joinrelids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids outerrelids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *innerrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JoinType jointype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *restrictlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **extra_clauses);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1547" title="optimizer/plan/analyzejoins.c:1547">replace_varno</a>(Node *node, <span class="Type">int</span> from, <span class="Type">int</span> to);<br/></li>
<li><span class="Type">static</span> Bitmapset *<a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(Relids relids, <span class="Type">int</span> oldId, <span class="Type">int</span> newId);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2406" title="optimizer/plan/analyzejoins.c:2406">self_join_candidates_cmp</a>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L81" title="optimizer/plan/analyzejoins.c:81">remove_useless_joins</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Check for relations that don't actually need to be joined at all,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and remove them from the query.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We are passed the current joinlist and return the updated list.&nbsp; Other<br/></li>
<li></span><span class="Comment"> * data structures that have to be updated are accessible via &quot;root&quot;.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L81">&#x200c;</a><span class="linkable">remove_useless_joins</span>(PlannerInfo *root, List *joinlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We are only interested in relations that are left-joined to, so we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan the join_info_list to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> them easily.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Statement">restart</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, root-&gt;join_info_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpecialJoinInfo *sjinfo = (SpecialJoinInfo *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; innerrelid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nremoved;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip if not removable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L177" title="optimizer/plan/analyzejoins.c:177">join_is_removable</a>(root, sjinfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Currently, <a href="#L177" title="optimizer/plan/analyzejoins.c:177">join_is_removable</a> can only succeed when the sjinfo's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * righthand is a single baserel.&nbsp; Remove that rel from the query and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * joinlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; innerrelid = <a href="../../nodes/bitmapset.c.html#L672" title="nodes/bitmapset.c:672">bms_singleton_member</a>(sjinfo-&gt;min_righthand);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L483" title="optimizer/plan/analyzejoins.c:483">remove_leftjoinrel_from_query</a>(root, innerrelid, sjinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We verify that exactly one reference gets removed from joinlist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nremoved = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; joinlist = <a href="#L710" title="optimizer/plan/analyzejoins.c:710">remove_rel_from_joinlist</a>(joinlist, innerrelid, &amp;nremoved);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nremoved != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> relation </span><span class="Special">%d</span><span class="Constant"> in joinlist&quot;</span>, innerrelid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can delete this SpecialJoinInfo from the list too, since it's no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * longer of interest.&nbsp; (Since we'll restart the foreach loop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * immediately, we don't bother with foreach_delete_current.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;join_info_list = <a href="../../nodes/list.c.html#L841" title="nodes/list.c:841">list_delete_cell</a>(root-&gt;join_info_list, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Restart the scan.&nbsp; This is necessary to ensure we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * removable joins independently of ordering of the join_info_list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (note that removal of attr_needed bits may make a join appear<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * removable that did not <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> restart;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> joinlist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L145" title="optimizer/plan/analyzejoins.c:145">clause_sides_match_join</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Determine whether a join clause is of the right form to use in this join.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We already know that the clause is a binary opclause referencing only the<br/></li>
<li></span><span class="Comment"> * rels in the current join.&nbsp; The point here is to check whether it has the<br/></li>
<li></span><span class="Comment"> * form &quot;outerrel_expr op innerrel_expr&quot; or &quot;innerrel_expr op outerrel_expr&quot;,<br/></li>
<li></span><span class="Comment"> * rather than mixing outer and inner <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> on either side.&nbsp; If it matches,<br/></li>
<li></span><span class="Comment"> * we set the transient flag outer_is_left to identify which side is which.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L145">&#x200c;</a></span><span class="linkable">clause_sides_match_join</span>(RestrictInfo *rinfo, Relids outerrelids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids innerrelids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(rinfo-&gt;left_relids, outerrelids) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(rinfo-&gt;right_relids, innerrelids))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* lefthand side is outer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rinfo-&gt;outer_is_left = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(rinfo-&gt;left_relids, innerrelids) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(rinfo-&gt;right_relids, outerrelids))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* righthand side is outer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rinfo-&gt;outer_is_left = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no good for these input relations */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L177" title="optimizer/plan/analyzejoins.c:177">join_is_removable</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Check whether we need not perform this special join at all, because<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; it will just duplicate its left input.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is true for a left join for which the join condition cannot match<br/></li>
<li></span><span class="Comment"> * more than one inner-side row.&nbsp; (There are other possibly interesting<br/></li>
<li></span><span class="Comment"> * cases, but we don't have the infrastructure to prove them.)&nbsp; We also<br/></li>
<li></span><span class="Comment"> * have to check that the inner side doesn't generate <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> variables needed<br/></li>
<li></span><span class="Comment"> * above the join.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L177">&#x200c;</a></span><span class="linkable">join_is_removable</span>(PlannerInfo *root, SpecialJoinInfo *sjinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; innerrelid;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *innerrel;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; inputrelids;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; joinrelids;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *clause_list = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attroff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must be a left join to a single baserel, else we aren't going to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * able to do anything with it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sjinfo-&gt;jointype != JOIN_LEFT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L715" title="nodes/bitmapset.c:715">bms_get_singleton_member</a>(sjinfo-&gt;min_righthand, &amp;innerrelid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Never try to eliminate a left join to the query result rel.&nbsp; Although<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the case is syntactically impossible in standard SQL, MERGE will build<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a join tree that looks exactly like that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (innerrelid == root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;resultRelation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; innerrel = <a href="../util/relnode.c.html#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(root, innerrelid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Before we go to the effort of checking whether <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> innerrel variables<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are needed above the join, make a quick check to eliminate cases in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which we will surely be unable to prove uniqueness of the innerrel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L840" title="optimizer/plan/analyzejoins.c:840">rel_supports_distinctness</a>(root, innerrel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute the relid set for the join we are considering */<br/></li>
<li></span>&nbsp; &nbsp; inputrelids = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(sjinfo-&gt;min_lefthand, sjinfo-&gt;min_righthand);<br/></li>
<li>&nbsp; &nbsp; Assert(sjinfo-&gt;ojrelid != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; joinrelids = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(inputrelids);<br/></li>
<li>&nbsp; &nbsp; joinrelids = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(joinrelids, sjinfo-&gt;ojrelid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can't remove the join if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> inner-rel attributes are used above the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * join.&nbsp; Here, &quot;above&quot; the join includes pushed-down conditions, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should reject if attr_needed includes the OJ's own relid; therefore,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> to inputrelids not joinrelids.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As a micro-optimization, it seems better to start with max_attr and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * count down rather than starting with min_attr and counting up, on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * theory that the system attributes are somewhat less likely to be wanted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and should be tested last.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (attroff = innerrel-&gt;max_attr - innerrel-&gt;min_attr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attroff &gt;= <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attroff--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(innerrel-&gt;attr_needed[attroff], inputrelids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Similarly check that the inner rel isn't needed by <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> PlaceHolderVars<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that will be used above the join.&nbsp; The PHV case is a little <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * complicated, because PHVs may have been assigned a ph_eval_at location<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that includes the innerrel, yet their contained expression might not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * actually reference the innerrel (it could be just a constant, for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * instance).&nbsp; If such a PHV is due to be evaluated above the join then it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needn't prevent join removal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, root-&gt;placeholder_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderInfo *phinfo = (PlaceHolderInfo *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(phinfo-&gt;ph_lateral, innerrel-&gt;relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* it references innerrel laterally */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(phinfo-&gt;ph_eval_at, innerrel-&gt;relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* it definitely doesn't reference innerrel */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(phinfo-&gt;ph_needed, inputrelids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* PHV is not used above the join */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(sjinfo-&gt;ojrelid, phinfo-&gt;ph_eval_at))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* it has to be evaluated below the join */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need to be sure there will still be a place to evaluate the PHV<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if we remove the join, ie that ph_eval_at wouldn't become empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(sjinfo-&gt;min_lefthand, phinfo-&gt;ph_eval_at))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there isn't <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other place to eval PHV */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check contained expression last, since this is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> expensive */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(<a href="../util/var.c.html#L108" title="optimizer/util/var.c:108">pull_varnos</a>(root, (Node *) phinfo-&gt;ph_var-&gt;phexpr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; innerrel-&gt;relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* contained expression references innerrel */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Search for mergejoinable clauses that constrain the inner rel against<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * either the outer rel or a pseudoconstant.&nbsp; If an operator is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mergejoinable then it behaves like equality for some btree opclass, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's what we want.&nbsp; The mergejoinability test also eliminates clauses<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * containing volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, which we couldn't depend on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, innerrel-&gt;joininfo)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *restrictinfo = (RestrictInfo *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the current join commutes with some other outer join(s) via<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * outer join identity 3, there will be multiple clones of its join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clauses in the joininfo list.&nbsp; We want to consider only the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * has_clone form of such clauses.&nbsp; Processing more than one form<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would be wasteful, and also some of the others would confuse the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * RINFO_IS_PUSHED_DOWN test below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (restrictinfo-&gt;is_clone)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore it */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's not a join clause for this outer join, we can't use it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that if the clause is pushed-down, then it is logically from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * above the outer join, even if it references no other rels (it might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be from WHERE, for example).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RINFO_IS_PUSHED_DOWN(restrictinfo, joinrelids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore; not useful here */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore if it's not a mergejoinable clause */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!restrictinfo-&gt;can_join ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restrictinfo-&gt;mergeopfamilies == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not mergejoinable */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if clause has the form &quot;outer op inner&quot; or &quot;inner op outer&quot;,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and if so mark which side is inner.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L145" title="optimizer/plan/analyzejoins.c:145">clause_sides_match_join</a>(restrictinfo, sjinfo-&gt;min_lefthand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; innerrel-&gt;relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no good for these input relations */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, add to list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; clause_list = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(clause_list, restrictinfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we have the relevant equality join clauses, try to prove the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * innerrel distinct.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L899" title="optimizer/plan/analyzejoins.c:899">rel_is_distinct_for</a>(root, innerrel, clause_list, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Some day it would be nice to check for other methods of establishing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * distinctness.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove the target rel-&gt;relid and references to the target join from the<br/></li>
<li></span><span class="Comment"> * <a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>'s data structures, having determined that there is no need<br/></li>
<li></span><span class="Comment"> * to include them in the query.&nbsp; Optionally replace them with subst if subst<br/></li>
<li></span><span class="Comment"> * is non-negative.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function updates only parts needed for both left-join removal and<br/></li>
<li></span><span class="Comment"> * self-join removal.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L347">&#x200c;</a></span><span class="linkable">remove_rel_from_query</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> subst, SpecialJoinInfo *sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids joinrelids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = rel-&gt;relid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ojrelid = (sjinfo != <span class="Constant">NULL</span>) ? sjinfo-&gt;ojrelid : -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; rti;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remove references to the rel from other baserels' attr_needed arrays<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and lateral_vars lists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (rti = <span class="Constant">1</span>; rti &lt; root-&gt;simple_rel_array_size; rti++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *otherrel = root-&gt;simple_rel_array[rti];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attroff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there may be empty slots corresponding to non-baserel RTEs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (otherrel == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(otherrel-&gt;relid == rti); <span class="Comment">/* sanity check on array */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no point in processing target rel itself */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (otherrel == rel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (attroff = otherrel-&gt;max_attr - otherrel-&gt;min_attr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attroff &gt;= <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attroff--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherrel-&gt;attr_needed[attroff] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(otherrel-&gt;attr_needed[attroff], relid, subst);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherrel-&gt;attr_needed[attroff] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(otherrel-&gt;attr_needed[attroff], ojrelid, subst);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update lateral_vars list. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1547" title="optimizer/plan/analyzejoins.c:1547">replace_varno</a>((Node *) otherrel-&gt;lateral_vars, relid, subst);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update all_baserels and related relid sets.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;all_baserels = <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(root-&gt;all_baserels, relid, subst);<br/></li>
<li>&nbsp; &nbsp; root-&gt;outer_join_rels = <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(root-&gt;outer_join_rels, ojrelid, subst);<br/></li>
<li>&nbsp; &nbsp; root-&gt;all_query_rels = <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(root-&gt;all_query_rels, relid, subst);<br/></li>
<li>&nbsp; &nbsp; root-&gt;all_query_rels = <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(root-&gt;all_query_rels, ojrelid, subst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Likewise remove references from SpecialJoinInfo data structures.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is relevant in case the outer join we're deleting is nested inside<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other outer joins: the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> joins' relid sets have to be adjusted. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * RHS of the target outer join will be made empty here, but that's OK<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since caller will delete that SpecialJoinInfo entirely.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, root-&gt;join_info_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpecialJoinInfo *sjinf = (SpecialJoinInfo *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sjinf-&gt;min_lefthand = <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(sjinf-&gt;min_lefthand, relid, subst);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sjinf-&gt;min_righthand = <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(sjinf-&gt;min_righthand, relid, subst);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sjinf-&gt;syn_lefthand = <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(sjinf-&gt;syn_lefthand, relid, subst);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sjinf-&gt;syn_righthand = <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(sjinf-&gt;syn_righthand, relid, subst);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sjinf-&gt;min_lefthand = <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(sjinf-&gt;min_lefthand, ojrelid, subst);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sjinf-&gt;min_righthand = <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(sjinf-&gt;min_righthand, ojrelid, subst);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sjinf-&gt;syn_lefthand = <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(sjinf-&gt;syn_lefthand, ojrelid, subst);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sjinf-&gt;syn_righthand = <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(sjinf-&gt;syn_righthand, ojrelid, subst);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* relid cannot appear in these fields, but ojrelid can: */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sjinf-&gt;commute_above_l = <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(sjinf-&gt;commute_above_l, ojrelid, subst);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sjinf-&gt;commute_above_r = <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(sjinf-&gt;commute_above_r, ojrelid, subst);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sjinf-&gt;commute_below_l = <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(sjinf-&gt;commute_below_l, ojrelid, subst);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sjinf-&gt;commute_below_r = <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(sjinf-&gt;commute_below_r, ojrelid, subst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1547" title="optimizer/plan/analyzejoins.c:1547">replace_varno</a>((Node *) sjinf-&gt;semi_rhs_exprs, relid, subst);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Likewise remove references from PlaceHolderVar data structures,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * removing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> no-longer-needed placeholders entirely.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Removal is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> trickier than it might seem: we can remove PHVs that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are used at the target rel and/or in the join qual, but not those that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are used at join partner rels or above the join.&nbsp; It's not that easy to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * distinguish PHVs used at partner rels from those used in the join qual,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since they will both have ph_needed sets that are subsets of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * joinrelids.&nbsp; However, a PHV used at a partner rel could not have the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * target rel in ph_eval_at, so we check that while deciding whether to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * remove or just update the PHV.&nbsp; There is no corresponding test in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L177" title="optimizer/plan/analyzejoins.c:177">join_is_removable</a> because it doesn't need to distinguish those cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, root-&gt;placeholder_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderInfo *phinfo = (PlaceHolderInfo *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(sjinfo == <span class="Constant">NULL</span> || !<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(relid, phinfo-&gt;ph_lateral));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(phinfo-&gt;ph_needed, joinrelids) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(relid, phinfo-&gt;ph_eval_at) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (sjinfo == <span class="Constant">NULL</span> || !<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(ojrelid, phinfo-&gt;ph_eval_at)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;placeholder_list = foreach_delete_current(root-&gt;placeholder_list,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;placeholder_array[phinfo-&gt;phid] = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *phv = phinfo-&gt;ph_var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phinfo-&gt;ph_eval_at = <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(phinfo-&gt;ph_eval_at, relid, subst);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phinfo-&gt;ph_eval_at = <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(phinfo-&gt;ph_eval_at, ojrelid, subst);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!bms_is_empty(phinfo-&gt;ph_eval_at));&nbsp; &nbsp; <span class="Comment">/* checked previously */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phinfo-&gt;ph_needed = <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(phinfo-&gt;ph_needed, relid, subst);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phinfo-&gt;ph_needed = <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(phinfo-&gt;ph_needed, ojrelid, subst);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ph_needed might or might not become empty */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phinfo-&gt;ph_lateral = <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(phinfo-&gt;ph_lateral, relid, subst);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ph_lateral might or might not be empty */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phv-&gt;phrels = <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(phv-&gt;phrels, relid, subst);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phv-&gt;phrels = <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(phv-&gt;phrels, ojrelid, subst);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!bms_is_empty(phv-&gt;phrels));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1547" title="optimizer/plan/analyzejoins.c:1547">replace_varno</a>((Node *) phv-&gt;phexpr, relid, subst);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(phv-&gt;phnullingrels == <span class="Constant">NULL</span>); <span class="Comment">/* no need to adjust */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove the target relid and references to the target join from the<br/></li>
<li></span><span class="Comment"> * <a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>'s data structures, having determined that there is no need<br/></li>
<li></span><span class="Comment"> * to include them in the query.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We are not terribly thorough here.&nbsp; We only bother to update parts of<br/></li>
<li></span><span class="Comment"> * the <a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>'s data structures that will actually be consulted later.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L483">&#x200c;</a></span><span class="linkable">remove_leftjoinrel_from_query</span>(PlannerInfo *root, <span class="Type">int</span> relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpecialJoinInfo *sjinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *joininfos;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ojrelid = sjinfo-&gt;ojrelid;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *rel = <a href="../util/relnode.c.html#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(root, relid);<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; join_plus_commute;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; joinrelids;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute the relid set for the join we are considering */<br/></li>
<li></span>&nbsp; &nbsp; joinrelids = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(sjinfo-&gt;min_lefthand, sjinfo-&gt;min_righthand);<br/></li>
<li>&nbsp; &nbsp; Assert(ojrelid != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; joinrelids = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(joinrelids, ojrelid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L347" title="optimizer/plan/analyzejoins.c:347">remove_rel_from_query</a>(root, rel, -<span class="Constant">1</span>, sjinfo, joinrelids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> joinquals referencing the rel from the joininfo lists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In some cases, a joinqual has to be put back after deleting its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reference to the target rel.&nbsp; This can occur for pseudoconstant and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * outerjoin-delayed quals, which can get marked as requiring the rel in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * order to force them to be evaluated at or above the join.&nbsp; We can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just discard them, though.&nbsp; Only quals that logically belonged to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * outer join being discarded should be removed from the query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We might encounter a qual that is a clone of a deletable qual with some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * outer-join relids added (see <a href="initsplan.c.html#L1878" title="optimizer/plan/initsplan.c:1878">deconstruct_distribute_oj_quals</a>).&nbsp; To<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensure we get rid of such clones as well, add the relids of all OJs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commutable with this one to the set we test against for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pushed-down-ness.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; join_plus_commute = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(joinrelids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sjinfo-&gt;commute_above_r);<br/></li>
<li>&nbsp; &nbsp; join_plus_commute = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(join_plus_commute,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sjinfo-&gt;commute_below_l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must make a copy of the rel's old joininfo list <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> starting the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * loop, because otherwise <a href="../util/joininfo.c.html#L153" title="optimizer/util/joininfo.c:153">remove_join_clause_from_rels</a> would destroy the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list while we're scanning it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; joininfos = <a href="../../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(rel-&gt;joininfo);<br/></li>
<li>&nbsp; &nbsp; foreach(l, joininfos)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/joininfo.c.html#L153" title="optimizer/util/joininfo.c:153">remove_join_clause_from_rels</a>(root, rinfo, rinfo-&gt;required_relids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RINFO_IS_PUSHED_DOWN(rinfo, join_plus_commute))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There might be references to relid or ojrelid in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * RestrictInfo's relid sets, as a consequence of PHVs having had<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ph_eval_at sets that include those.&nbsp; We already checked above<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such PHV is safe (and updated its ph_eval_at), so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can just drop those references.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L599" title="optimizer/plan/analyzejoins.c:599">remove_rel_from_restrictinfo</a>(rinfo, relid, ojrelid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Cross-check that the clause itself does not reference the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * target rel or join.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; clause_varnos = <a href="../util/var.c.html#L108" title="optimizer/util/var.c:108">pull_varnos</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Node *) rinfo-&gt;clause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(relid, clause_varnos));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(ojrelid, clause_varnos));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now throw it back into the joininfo lists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="initsplan.c.html#L2836" title="optimizer/plan/initsplan.c:2836">distribute_restrictinfo_to_rels</a>(root, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Likewise remove references from EquivalenceClasses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, root-&gt;eq_classes)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EquivalenceClass *ec = (EquivalenceClass *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(relid, ec-&gt;ec_relids) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(ojrelid, ec-&gt;ec_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L656" title="optimizer/plan/analyzejoins.c:656">remove_rel_from_eclass</a>(ec, relid, ojrelid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There may be references to the rel in root-&gt;fkey_list, but if so,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="initsplan.c.html#L3169" title="optimizer/plan/initsplan.c:3169">match_foreign_keys_to_quals</a>() will get rid of them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Finally, remove the rel from the baserel array to prevent it from being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * referenced again.&nbsp; (We can't do this earlier because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../util/joininfo.c.html#L153" title="optimizer/util/joininfo.c:153">remove_join_clause_from_rels</a> will touch it.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;simple_rel_array[relid] = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And nuke the RelOptInfo, just in case there's another access path */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> references to relid or ojrelid from the RestrictInfo.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We only bother to clean out bits in clause_relids and required_relids,<br/></li>
<li></span><span class="Comment"> * not nullingrel bits in contained Vars and PHVs.&nbsp; (This might have to be<br/></li>
<li></span><span class="Comment"> * improved sometime.)&nbsp; However, if the RestrictInfo contains an OR clause<br/></li>
<li></span><span class="Comment"> * we have to also clean up the sub-clauses.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L599">&#x200c;</a></span><span class="linkable">remove_rel_from_restrictinfo</span>(RestrictInfo *rinfo, <span class="Type">int</span> relid, <span class="Type">int</span> ojrelid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The clause_relids probably aren't shared with anything else, but let's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * copy them just to be sure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rinfo-&gt;clause_relids = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(rinfo-&gt;clause_relids);<br/></li>
<li>&nbsp; &nbsp; rinfo-&gt;clause_relids = <a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(rinfo-&gt;clause_relids, relid);<br/></li>
<li>&nbsp; &nbsp; rinfo-&gt;clause_relids = <a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(rinfo-&gt;clause_relids, ojrelid);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Likewise for required_relids */<br/></li>
<li></span>&nbsp; &nbsp; rinfo-&gt;required_relids = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(rinfo-&gt;required_relids);<br/></li>
<li>&nbsp; &nbsp; rinfo-&gt;required_relids = <a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(rinfo-&gt;required_relids, relid);<br/></li>
<li>&nbsp; &nbsp; rinfo-&gt;required_relids = <a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(rinfo-&gt;required_relids, ojrelid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If it's an OR, recurse to clean up sub-clauses */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/restrictinfo.c.html#L416" title="optimizer/util/restrictinfo.c:416">restriction_is_or_clause</a>(rinfo))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(is_orclause(rinfo-&gt;orclause));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, ((BoolExpr *) rinfo-&gt;orclause)-&gt;args)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *orarg = (Node *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OR arguments should be ANDs or sub-RestrictInfos */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_andclause(orarg))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *andargs = ((BoolExpr *) orarg)-&gt;args;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, andargs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo2 = lfirst_node(RestrictInfo, lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L599" title="optimizer/plan/analyzejoins.c:599">remove_rel_from_restrictinfo</a>(rinfo2, relid, ojrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo2 = castNode(RestrictInfo, orarg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L599" title="optimizer/plan/analyzejoins.c:599">remove_rel_from_restrictinfo</a>(rinfo2, relid, ojrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> references to relid or ojrelid from the EquivalenceClass.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Like <a href="#L599" title="optimizer/plan/analyzejoins.c:599">remove_rel_from_restrictinfo</a>, we don't worry about cleaning out<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> nullingrel bits in contained Vars and PHVs.&nbsp; (This might have to be<br/></li>
<li></span><span class="Comment"> * improved sometime.)&nbsp; We do need to fix the EC and EM relid sets to ensure<br/></li>
<li></span><span class="Comment"> * that implied join equalities will be generated at the appropriate join<br/></li>
<li></span><span class="Comment"> * level(s).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L656">&#x200c;</a></span><span class="linkable">remove_rel_from_eclass</span>(EquivalenceClass *ec, <span class="Type">int</span> relid, <span class="Type">int</span> ojrelid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fix up the EC's overall relids */<br/></li>
<li></span>&nbsp; &nbsp; ec-&gt;ec_relids = <a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(ec-&gt;ec_relids, relid);<br/></li>
<li>&nbsp; &nbsp; ec-&gt;ec_relids = <a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(ec-&gt;ec_relids, ojrelid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fix up the member expressions.&nbsp; Any non-const member that ends with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * empty em_relids must be a Var or PHV of the removed relation.&nbsp; We don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need it anymore, so we can drop it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, ec-&gt;ec_members)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EquivalenceMember *cur_em = (EquivalenceMember *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(relid, cur_em-&gt;em_relids) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(ojrelid, cur_em-&gt;em_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!cur_em-&gt;em_is_const);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_em-&gt;em_relids = <a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(cur_em-&gt;em_relids, relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_em-&gt;em_relids = <a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(cur_em-&gt;em_relids, ojrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bms_is_empty(cur_em-&gt;em_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ec-&gt;ec_members = foreach_delete_current(ec-&gt;ec_members, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fix up the source clauses, in case we can re-use them later */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, ec-&gt;ec_sources)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L599" title="optimizer/plan/analyzejoins.c:599">remove_rel_from_restrictinfo</a>(rinfo, relid, ojrelid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Rather than expend code on fixing up <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> already-derived clauses, just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * drop them.&nbsp; (At this point, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such clauses would be base restriction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clauses, which we'd not need anymore anyway.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ec-&gt;ec_derives = NIL;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> occurrences of the target relid from a joinlist structure.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It's easiest to build a whole new list structure, so we handle it that<br/></li>
<li></span><span class="Comment"> * way.&nbsp; Efficiency is not a big deal here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *nremoved is incremented by the number of occurrences removed (there<br/></li>
<li></span><span class="Comment"> * should be exactly one, but the caller checks that).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L710">&#x200c;</a><span class="linkable">remove_rel_from_joinlist</span>(List *joinlist, <span class="Type">int</span> relid, <span class="Type">int</span> *nremoved)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *jl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(jl, joinlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *jlnode = (Node *) lfirst(jl);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(jlnode, RangeTblRef))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varno = ((RangeTblRef *) jlnode)-&gt;rtindex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (varno == relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*nremoved)++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, jlnode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(jlnode, List))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse to handle subproblem */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sublist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublist = <a href="#L710" title="optimizer/plan/analyzejoins.c:710">remove_rel_from_joinlist</a>((List *) jlnode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relid, nremoved);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Avoid including empty sub-lists in the result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sublist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, sublist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized joinlist node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) nodeTag(jlnode));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L764" title="optimizer/plan/analyzejoins.c:764">reduce_unique_semijoins</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Check for semijoins that can be simplified to plain inner joins<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; because the inner relation is provably unique for the join clauses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Ideally this would happen during <a href="../prep/prepjointree.c.html#L2713" title="optimizer/prep/prepjointree.c:2713">reduce_outer_joins</a>, but we don't have<br/></li>
<li></span><span class="Comment"> * enough information at that point.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To perform the strength reduction when applicable, we need only delete<br/></li>
<li></span><span class="Comment"> * the semijoin's SpecialJoinInfo from root-&gt;join_info_list.&nbsp; (We don't<br/></li>
<li></span><span class="Comment"> * bother fixing the join type attributed to it in the query jointree,<br/></li>
<li></span><span class="Comment"> * since that won't be consulted again.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L764">&#x200c;</a></span><span class="linkable">reduce_unique_semijoins</span>(PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan the join_info_list to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> semijoins.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, root-&gt;join_info_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpecialJoinInfo *sjinfo = (SpecialJoinInfo *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; innerrelid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *innerrel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; joinrelids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *restrictlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Must be a semijoin to a single baserel, else we aren't going to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * able to do anything with it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sjinfo-&gt;jointype != JOIN_SEMI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L715" title="nodes/bitmapset.c:715">bms_get_singleton_member</a>(sjinfo-&gt;min_righthand, &amp;innerrelid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; innerrel = <a href="../util/relnode.c.html#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(root, innerrelid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Before we trouble to run <a href="../path/equivclass.c.html#L1392" title="optimizer/path/equivclass.c:1392">generate_join_implied_equalities</a>, make a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * quick check to eliminate cases in which we will surely be unable to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prove uniqueness of the innerrel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L840" title="optimizer/plan/analyzejoins.c:840">rel_supports_distinctness</a>(root, innerrel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute the relid set for the join we are considering */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; joinrelids = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(sjinfo-&gt;min_lefthand, sjinfo-&gt;min_righthand);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(sjinfo-&gt;ojrelid == <span class="Constant">0</span>);&nbsp; &nbsp; <span class="Comment">/* SEMI joins don't have RT indexes */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since we're only considering a single-rel RHS, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> join clauses it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * has must be clauses linking it to the semijoin's min_lefthand.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can also consider EC-derived join clauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; restrictlist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(<a href="../path/equivclass.c.html#L1392" title="optimizer/path/equivclass.c:1392">generate_join_implied_equalities</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; joinrelids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sjinfo-&gt;min_lefthand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; innerrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; innerrel-&gt;joininfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Test whether the innerrel is unique for those clauses. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1224" title="optimizer/plan/analyzejoins.c:1224">innerrel_is_unique</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrelids, sjinfo-&gt;min_lefthand, innerrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JOIN_SEMI, restrictlist, <span class="Constant">true</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, remove the SpecialJoinInfo from the list. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;join_info_list = foreach_delete_current(root-&gt;join_info_list, lc);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L840" title="optimizer/plan/analyzejoins.c:840">rel_supports_distinctness</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Could the relation possibly be proven distinct on some set of columns?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is effectively a pre-checking function for <a href="#L899" title="optimizer/plan/analyzejoins.c:899">rel_is_distinct_for</a>().<br/></li>
<li></span><span class="Comment"> * It must return true if <a href="#L899" title="optimizer/plan/analyzejoins.c:899">rel_is_distinct_for</a>() could possibly return true<br/></li>
<li></span><span class="Comment"> * with this rel, but it should not expend a lot of cycles.&nbsp; The idea is<br/></li>
<li></span><span class="Comment"> * that callers can avoid doing possibly-expensive processing to compute<br/></li>
<li></span><span class="Comment"> * <a href="#L899" title="optimizer/plan/analyzejoins.c:899">rel_is_distinct_for</a>()'s argument lists if the call could not possibly<br/></li>
<li></span><span class="Comment"> * succeed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L840">&#x200c;</a></span><span class="linkable">rel_supports_distinctness</span>(PlannerInfo *root, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We only know about baserels ... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;reloptkind != RELOPT_BASEREL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rtekind == RTE_RELATION)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For a plain relation, we only know how to prove uniqueness by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reference to unique indexes.&nbsp; Make sure there's at least one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * suitable unique index.&nbsp; It must be immediately enforced, and not a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partial index. (Keep these conditions in sync with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../path/indxpath.c.html#L3440" title="optimizer/path/indxpath.c:3440">relation_has_unique_index_for</a>!)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, rel-&gt;indexlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexOptInfo *ind = (IndexOptInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ind-&gt;unique &amp;&amp; ind-&gt;immediate &amp;&amp; ind-&gt;indpred == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rel-&gt;rtekind == RTE_SUBQUERY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *subquery = root-&gt;simple_rte_array[rel-&gt;relid]-&gt;subquery;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check if the subquery has <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> qualities that support distinctness */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L998" title="optimizer/plan/analyzejoins.c:998">query_supports_distinctness</a>(subquery))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We have no proof rules for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other rtekinds. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L899" title="optimizer/plan/analyzejoins.c:899">rel_is_distinct_for</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Does the relation return only distinct rows according to clause_list?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * clause_list is a list of join restriction clauses involving this rel and<br/></li>
<li></span><span class="Comment"> * some other one.&nbsp; Return true if no two rows emitted by this rel could<br/></li>
<li></span><span class="Comment"> * possibly join to the same row of the other rel.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must have already determined that each condition is a<br/></li>
<li></span><span class="Comment"> * mergejoinable equality with an expression in this relation on one side, and<br/></li>
<li></span><span class="Comment"> * an expression not involving this relation on the other.&nbsp; The transient<br/></li>
<li></span><span class="Comment"> * outer_is_left flag is used to identify which side references this relation:<br/></li>
<li></span><span class="Comment"> * left side if outer_is_left is false, right side if it is true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the passed-in clause_list may be destructively modified!&nbsp; This<br/></li>
<li></span><span class="Comment"> * is OK for current uses, because the clause_list is built by the caller for<br/></li>
<li></span><span class="Comment"> * the sole purpose of passing to this function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * outer_exprs contains the right sides of baserestrictinfo clauses looking<br/></li>
<li></span><span class="Comment"> * like x = const if distinctness is derived from such clauses, not joininfo<br/></li>
<li></span><span class="Comment"> * clause.&nbsp; Pass NULL to the outer_exprs, if its value is not needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L899">&#x200c;</a></span><span class="linkable">rel_is_distinct_for</span>(PlannerInfo *root, RelOptInfo *rel, List *clause_list,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **extra_clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We could <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> a couple of tests here if we assume all callers checked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L840" title="optimizer/plan/analyzejoins.c:840">rel_supports_distinctness</a> first, but it doesn't seem worth taking <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * risk for.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;reloptkind != RELOPT_BASEREL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rtekind == RTE_RELATION)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Examine the indexes to see if we have a matching unique index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../path/indxpath.c.html#L3455" title="optimizer/path/indxpath.c:3455">relation_has_unique_index_ext</a> automatically adds <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> usable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * restriction clauses for the rel, so we needn't do that here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../path/indxpath.c.html#L3455" title="optimizer/path/indxpath.c:3455">relation_has_unique_index_ext</a>(root, rel, clause_list, NIL, NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra_clauses))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rel-&gt;rtekind == RTE_SUBQUERY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; relid = rel-&gt;relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *subquery = root-&gt;simple_rte_array[relid]-&gt;subquery;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *colnos = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *opids = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Build the argument lists for <a href="#L1035" title="optimizer/plan/analyzejoins.c:1035">query_is_distinct_for</a>: a list of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * output column numbers that the query needs to be distinct over, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a list of equality operators that the output columns need to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * distinct according to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (</span><span class="Todo">XXX</span><span class="Comment"> we are not considering restriction clauses attached to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subquery; is that worth doing?)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, clause_list)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get the equality operator we need uniqueness according to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (This might be a cross-type operator and thus not exactly the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * same operator the subquery would consider; that's all right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since <a href="#L1035" title="optimizer/plan/analyzejoins.c:1035">query_is_distinct_for</a> can resolve such cases.)&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caller's mergejoinability test should have selected only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OpExprs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op = castNode(OpExpr, rinfo-&gt;clause)-&gt;opno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* caller identified the inner side for us */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rinfo-&gt;outer_is_left)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var = (Var *) get_rightop(rinfo-&gt;clause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var = (Var *) get_leftop(rinfo-&gt;clause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We may ignore <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> RelabelType node above the operand.&nbsp; (There<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * won't be more than one, since <a href="../util/clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a>() has been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * applied already.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var &amp;&amp; IsA(var, RelabelType))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var = (Var *) ((RelabelType *) var)-&gt;arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If inner side isn't a Var referencing a subquery output column,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this clause doesn't <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!var || !IsA(var, Var) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varno != relid || var-&gt;varlevelsup != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colnos = <a href="../../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(colnos, var-&gt;varattno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opids = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(opids, op);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1035" title="optimizer/plan/analyzejoins.c:1035">query_is_distinct_for</a>(subquery, colnos, opids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L998" title="optimizer/plan/analyzejoins.c:998">query_supports_distinctness</a> - could the query possibly be proven distinct<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; on some set of output columns?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is effectively a pre-checking function for <a href="#L1035" title="optimizer/plan/analyzejoins.c:1035">query_is_distinct_for</a>().<br/></li>
<li></span><span class="Comment"> * It must return true if <a href="#L1035" title="optimizer/plan/analyzejoins.c:1035">query_is_distinct_for</a>() could possibly return true<br/></li>
<li></span><span class="Comment"> * with this query, but it should not expend a lot of cycles.&nbsp; The idea is<br/></li>
<li></span><span class="Comment"> * that callers can avoid doing possibly-expensive processing to compute<br/></li>
<li></span><span class="Comment"> * <a href="#L1035" title="optimizer/plan/analyzejoins.c:1035">query_is_distinct_for</a>()'s argument lists if the call could not possibly<br/></li>
<li></span><span class="Comment"> * succeed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L998">&#x200c;</a></span><span class="linkable">query_supports_distinctness</span>(Query *query)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* SRFs break distinctness except with DISTINCT, see below */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;hasTargetSRFs &amp;&amp; query-&gt;distinctClause == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check for features we can prove distinctness with */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;distinctClause != NIL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query-&gt;groupClause != NIL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query-&gt;groupingSets != NIL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query-&gt;hasAggs ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query-&gt;havingQual ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query-&gt;setOperations)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1035" title="optimizer/plan/analyzejoins.c:1035">query_is_distinct_for</a> - does query never return duplicates of the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; specified columns?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * query is a not-yet-planned subquery (in current usage, it's always from<br/></li>
<li></span><span class="Comment"> * a subquery RTE, which the <a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> avoids scribbling on).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * colnos is an integer list of output column numbers (resno's).&nbsp; We are<br/></li>
<li></span><span class="Comment"> * interested in whether rows consisting of just these columns are certain<br/></li>
<li></span><span class="Comment"> * to be distinct.&nbsp; &quot;Distinctness&quot; is defined according to whether the<br/></li>
<li></span><span class="Comment"> * corresponding <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level equality operators listed in opids would think<br/></li>
<li></span><span class="Comment"> * the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are distinct.&nbsp; (Note: the opids entries could be cross-type<br/></li>
<li></span><span class="Comment"> * operators, and thus not exactly the equality operators that the subquery<br/></li>
<li></span><span class="Comment"> * would use itself.&nbsp; We use <a href="../../utils/cache/lsyscache.c.html#L698" title="utils/cache/lsyscache.c:698">equality_ops_are_compatible</a>() to check<br/></li>
<li></span><span class="Comment"> * compatibility.&nbsp; That looks at btree or <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> opfamily membership, and so<br/></li>
<li></span><span class="Comment"> * should give trustworthy answers for all operators that we might need<br/></li>
<li></span><span class="Comment"> * to deal with here.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1035">&#x200c;</a></span><span class="linkable">query_is_distinct_for</span>(Query *query, List *colnos, List *opids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(list_length(colnos) == list_length(opids));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * DISTINCT (including DISTINCT ON) guarantees uniqueness if all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * columns in the DISTINCT clause appear in colnos and operator semantics<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * match.&nbsp; This is true even if there are SRFs in the DISTINCT columns or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * elsewhere in the tlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;distinctClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, query-&gt;distinctClause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *sgc = (SortGroupClause *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = <a href="../util/tlist.c.html#L367" title="optimizer/util/tlist.c:367">get_sortgroupclause_tle</a>(sgc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; query-&gt;targetList);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opid = <a href="#L1184" title="optimizer/plan/analyzejoins.c:1184">distinct_col_search</a>(tle-&gt;resno, colnos, opids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(opid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../utils/cache/lsyscache.c.html#L698" title="utils/cache/lsyscache.c:698">equality_ops_are_compatible</a>(opid, sgc-&gt;eqop))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* exit early if no match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (l == <span class="Constant">NULL</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* had matches for all? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, a set-returning function in the query's targetlist can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * result in returning duplicate rows, despite <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> grouping that might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * occur <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> tlist evaluation.&nbsp; (If all tlist SRFs are within GROUP BY<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * columns, it would be safe because they'd be expanded <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> grouping.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * But it doesn't currently seem worth the effort to check for that.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;hasTargetSRFs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Similarly, GROUP BY without GROUPING SETS guarantees uniqueness if all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the grouped columns appear in colnos and operator semantics match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;groupClause &amp;&amp; !query-&gt;groupingSets)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, query-&gt;groupClause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *sgc = (SortGroupClause *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = <a href="../util/tlist.c.html#L367" title="optimizer/util/tlist.c:367">get_sortgroupclause_tle</a>(sgc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; query-&gt;targetList);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opid = <a href="#L1184" title="optimizer/plan/analyzejoins.c:1184">distinct_col_search</a>(tle-&gt;resno, colnos, opids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(opid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../utils/cache/lsyscache.c.html#L698" title="utils/cache/lsyscache.c:698">equality_ops_are_compatible</a>(opid, sgc-&gt;eqop))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* exit early if no match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (l == <span class="Constant">NULL</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* had matches for all? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (query-&gt;groupingSets)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have grouping sets with expressions, we probably don't have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * uniqueness and analysis would be hard. Punt.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;groupClause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have no groupClause (therefore no grouping expressions), we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might have one or many empty grouping sets. If there's just one,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then we're returning only one row and are certainly unique. But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise, we know we're certainly not unique.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(query-&gt;groupingSets) == <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((GroupingSet *) linitial(query-&gt;groupingSets))-&gt;kind == GROUPING_SET_EMPTY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have no GROUP BY, but do have aggregates or HAVING, then the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result is at most one row so it's surely unique, for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> operators.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;hasAggs || query-&gt;havingQual)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * UNION, INTERSECT, EXCEPT guarantee uniqueness of the whole output row,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * except with ALL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;setOperations)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SetOperationStmt *topop = castNode(SetOperationStmt, query-&gt;setOperations);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(topop-&gt;op != SETOP_NONE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!topop-&gt;all)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We're good if all the nonjunk output columns are in colnos */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lg = list_head(topop-&gt;groupClauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, query-&gt;targetList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *sgc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; <span class="Comment">/* ignore resjunk columns */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* non-resjunk columns should have grouping clauses */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(lg != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sgc = (SortGroupClause *) lfirst(lg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lg = lnext(topop-&gt;groupClauses, lg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opid = <a href="#L1184" title="optimizer/plan/analyzejoins.c:1184">distinct_col_search</a>(tle-&gt;resno, colnos, opids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(opid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../utils/cache/lsyscache.c.html#L698" title="utils/cache/lsyscache.c:698">equality_ops_are_compatible</a>(opid, sgc-&gt;eqop))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* exit early if no match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (l == <span class="Constant">NULL</span>)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* had matches for all? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> Are there <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other cases in which we can easily see the result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must be distinct?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If you do add more smarts to this function, be sure to update<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L998" title="optimizer/plan/analyzejoins.c:998">query_supports_distinctness</a>() to match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1184" title="optimizer/plan/analyzejoins.c:1184">distinct_col_search</a> - subroutine for <a href="#L1035" title="optimizer/plan/analyzejoins.c:1035">query_is_distinct_for</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If colno is in colnos, return the corresponding <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of opids,<br/></li>
<li></span><span class="Comment"> * else return InvalidOid.&nbsp; (Ordinarily colnos would not contain duplicates,<br/></li>
<li></span><span class="Comment"> * but if it does, we arbitrarily <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> the first match.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Oid<br/></li>
<li><a id="L1184">&#x200c;</a><span class="linkable">distinct_col_search</span>(<span class="Type">int</span> colno, List *colnos, List *opids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; forboth(lc1, colnos, lc2, opids)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (colno == lfirst_int(lc1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> lfirst_oid(lc2);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1224" title="optimizer/plan/analyzejoins.c:1224">innerrel_is_unique</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Check if the innerrel provably contains at most one tuple matching <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; tuple from the outerrel, based on join clauses in the 'restrictlist'.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We need an actual RelOptInfo for the innerrel, but it's sufficient to<br/></li>
<li></span><span class="Comment"> * identify the outerrel by its Relids.&nbsp; This asymmetry supports use of this<br/></li>
<li></span><span class="Comment"> * function <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> joinrels have been built.&nbsp; (The caller is expected to<br/></li>
<li></span><span class="Comment"> * also supply the joinrelids, just to save recalculating that.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The proof must be made based only on clauses that will be &quot;joinquals&quot;<br/></li>
<li></span><span class="Comment"> * rather than &quot;otherquals&quot; at execution.&nbsp; For an inner join there's no<br/></li>
<li></span><span class="Comment"> * difference; but if the join is outer, we must ignore pushed-down quals,<br/></li>
<li></span><span class="Comment"> * as those will become &quot;otherquals&quot;.&nbsp; Note that this means the answer might<br/></li>
<li></span><span class="Comment"> * vary depending on whether IS_OUTER_JOIN(jointype); since we cache the<br/></li>
<li></span><span class="Comment"> * answer without regard to that, callers must take care not to call this<br/></li>
<li></span><span class="Comment"> * with jointypes that would be classified differently by IS_OUTER_JOIN().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The actual proof is undertaken by <a href="#L1374" title="optimizer/plan/analyzejoins.c:1374">is_innerrel_unique_for</a>(); this function<br/></li>
<li></span><span class="Comment"> * is a frontend that is mainly concerned with caching the answers.<br/></li>
<li></span><span class="Comment"> * In particular, the force_cache argument allows overriding the <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a><br/></li>
<li></span><span class="Comment"> * heuristic about whether to cache negative answers; it should be &quot;true&quot;<br/></li>
<li></span><span class="Comment"> * if making an inquiry that is not part of the normal bottom-up join search<br/></li>
<li></span><span class="Comment"> * sequence.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1224">&#x200c;</a></span><span class="linkable">innerrel_is_unique</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids joinrelids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids outerrelids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *innerrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JoinType jointype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *restrictlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> force_cache)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1244" title="optimizer/plan/analyzejoins.c:1244">innerrel_is_unique_ext</a>(root, joinrelids, outerrelids, innerrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jointype, restrictlist, force_cache, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1244" title="optimizer/plan/analyzejoins.c:1244">innerrel_is_unique_ext</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Do the same as <a href="#L1224" title="optimizer/plan/analyzejoins.c:1224">innerrel_is_unique</a>(), but also set to '*extra_clauses'<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; additional clauses from a baserestrictinfo list that were used to prove<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; uniqueness.&nbsp; A non NULL 'extra_clauses' indicates that we're checking<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; for self-join and correspondingly dealing with filtered clauses.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1244">&#x200c;</a></span><span class="linkable">innerrel_is_unique_ext</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids joinrelids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids outerrelids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *innerrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JoinType jointype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *restrictlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> force_cache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **extra_clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext old_context;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; UniqueRelInfo *uniqueRelInfo;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *outer_exprs = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; self_join = (extra_clauses != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Certainly can't prove uniqueness when there are no joinclauses */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (restrictlist == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make a quick check to eliminate cases in which we will surely be unable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to prove uniqueness of the innerrel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L840" title="optimizer/plan/analyzejoins.c:840">rel_supports_distinctness</a>(root, innerrel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Query the cache to see if we've managed to prove that innerrel is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unique for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of this outerrel.&nbsp; For non self-join search, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't need an exact match, as extra outerrels can't make the innerrel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> less unique (or more formally, the restrictlist for a join to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * superset outerrel must be a superset of the conditions we successfully<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * used <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>). For self-join search, we require an exact match of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * outerrels, because we need extra clauses to be valid for our case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, for self-join checking we've filtered the clauses list.&nbsp; Thus,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for a self-join search, we can match only the result cached for another<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * self-join check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, innerrel-&gt;unique_for_rels)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uniqueRelInfo = (UniqueRelInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((!self_join &amp;&amp; <a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(uniqueRelInfo-&gt;outerrelids, outerrelids)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (self_join &amp;&amp; <a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(uniqueRelInfo-&gt;outerrelids, outerrelids) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uniqueRelInfo-&gt;self_join))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (extra_clauses)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *extra_clauses = uniqueRelInfo-&gt;extra_clauses;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Success! */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Conversely, we may have already determined that this outerrel, or some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * superset thereof, cannot prove this innerrel to be unique.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, innerrel-&gt;non_unique_for_rels)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; unique_for_rels = (Relids) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(outerrelids, unique_for_rels))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No cached information, so try to make the proof. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1374" title="optimizer/plan/analyzejoins.c:1374">is_innerrel_unique_for</a>(root, joinrelids, outerrelids, innerrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jointype, restrictlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; self_join ? &amp;outer_exprs : <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Cache the positive result for future probes, being sure to keep it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the planner_cxt even if we are working in GEQO.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: one might consider trying to isolate the minimal <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the outerrels that proved the innerrel unique.&nbsp; But it's not worth<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the trouble, because the <a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> builds up joinrels incrementally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and so we'll see the minimally sufficient outerrels <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * supersets of them anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; old_context = MemoryContextSwitchTo(root-&gt;planner_cxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uniqueRelInfo = makeNode(UniqueRelInfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uniqueRelInfo-&gt;outerrelids = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(outerrelids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uniqueRelInfo-&gt;self_join = self_join;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uniqueRelInfo-&gt;extra_clauses = outer_exprs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; innerrel-&gt;unique_for_rels = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(innerrel-&gt;unique_for_rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uniqueRelInfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(old_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (extra_clauses)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *extra_clauses = outer_exprs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Success! */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * None of the join conditions for outerrel proved innerrel unique, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we can safely reject this outerrel or <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of it in future<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, in normal planning mode, caching this knowledge is totally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pointless; it won't be queried again, because we build up joinrels<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from smaller to larger.&nbsp; It is useful in GEQO mode, where the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * knowledge can be carried across successive planning attempts; and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's likely to be useful when using join-search plugins, too. Hence<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cache when join_search_private is non-NULL.&nbsp; (Yeah, that's a hack,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but it seems reasonable.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also, allow callers to override that heuristic and force caching;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that's useful for <a href="#L764" title="optimizer/plan/analyzejoins.c:764">reduce_unique_semijoins</a>, which calls here <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the normal join search starts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (force_cache || root-&gt;join_search_private)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_context = MemoryContextSwitchTo(root-&gt;planner_cxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; innerrel-&gt;non_unique_for_rels =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(innerrel-&gt;non_unique_for_rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(outerrelids));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(old_context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1374" title="optimizer/plan/analyzejoins.c:1374">is_innerrel_unique_for</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Check if the innerrel provably contains at most one tuple matching <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; tuple from the outerrel, based on join clauses in the 'restrictlist'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1374">&#x200c;</a></span><span class="linkable">is_innerrel_unique_for</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids joinrelids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids outerrelids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *innerrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JoinType jointype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *restrictlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **extra_clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *clause_list = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Search for mergejoinable clauses that constrain the inner rel against<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the outer rel.&nbsp; If an operator is mergejoinable then it behaves like<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * equality for some btree opclass, so it's what we want.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mergejoinability test also eliminates clauses containing volatile<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, which we couldn't depend on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, restrictlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *restrictinfo = (RestrictInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As noted above, if it's a pushed-down clause and we're at an outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * join, we can't use it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IS_OUTER_JOIN(jointype) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RINFO_IS_PUSHED_DOWN(restrictinfo, joinrelids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore if it's not a mergejoinable clause */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!restrictinfo-&gt;can_join ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restrictinfo-&gt;mergeopfamilies == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not mergejoinable */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if the clause has the form &quot;outer op inner&quot; or &quot;inner op<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * outer&quot;, and if so mark which side is inner.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L145" title="optimizer/plan/analyzejoins.c:145">clause_sides_match_join</a>(restrictinfo, outerrelids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; innerrel-&gt;relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no good for these input relations */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, add to the list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; clause_list = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(clause_list, restrictinfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Let <a href="#L899" title="optimizer/plan/analyzejoins.c:899">rel_is_distinct_for</a>() do the hard work */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L899" title="optimizer/plan/analyzejoins.c:899">rel_is_distinct_for</a>(root, innerrel, clause_list, extra_clauses);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1547" title="optimizer/plan/analyzejoins.c:1547">replace_varno</a> - <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> in the given tree <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> Vars, PlaceHolderVar, and Relids<br/></li>
<li></span><span class="Comment"> * that reference the removing relid, and change them to the reference to<br/></li>
<li></span><span class="Comment"> * the replacement relid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: although this has the form of a walker, we cheat and modify the<br/></li>
<li></span><span class="Comment"> * nodes in-place.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; from;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublevels_up;<br/></li>
<li><a id="L1439">&#x200c;</a>} <span class="linkable">ReplaceVarnoContext</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1442">&#x200c;</a></span><span class="linkable">replace_varno_walker</span>(Node *node, <a href="#L1439" title="optimizer/plan/analyzejoins.c:1439">ReplaceVarnoContext</a> *ctx)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varno == ctx-&gt;from &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varlevelsup == ctx-&gt;sublevels_up)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varno = ctx-&gt;to;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varnosyn = ctx-&gt;to;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *phv = (PlaceHolderVar *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (phv-&gt;phlevelsup == ctx-&gt;sublevels_up)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phv-&gt;phrels =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(phv-&gt;phrels, ctx-&gt;from, ctx-&gt;to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phv-&gt;phnullingrels =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(phv-&gt;phnullingrels, ctx-&gt;from, ctx-&gt;to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through to recurse into the placeholder's expression */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, Query))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse into subselects */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctx-&gt;sublevels_up++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = query_tree_walker((Query *) node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1442" title="optimizer/plan/analyzejoins.c:1442">replace_varno_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; QTW_EXAMINE_SORTGROUP);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctx-&gt;sublevels_up--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, RestrictInfo))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_req_equal =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (rinfo-&gt;required_relids == rinfo-&gt;clause_relids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(ctx-&gt;from, rinfo-&gt;clause_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1547" title="optimizer/plan/analyzejoins.c:1547">replace_varno</a>((Node *) rinfo-&gt;clause, ctx-&gt;from, ctx-&gt;to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1547" title="optimizer/plan/analyzejoins.c:1547">replace_varno</a>((Node *) rinfo-&gt;orclause, ctx-&gt;from, ctx-&gt;to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rinfo-&gt;clause_relids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(rinfo-&gt;clause_relids, ctx-&gt;from, ctx-&gt;to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rinfo-&gt;left_relids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(rinfo-&gt;left_relids, ctx-&gt;from, ctx-&gt;to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rinfo-&gt;right_relids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(rinfo-&gt;right_relids, ctx-&gt;from, ctx-&gt;to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_req_equal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rinfo-&gt;required_relids = rinfo-&gt;clause_relids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rinfo-&gt;required_relids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(rinfo-&gt;required_relids, ctx-&gt;from, ctx-&gt;to);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rinfo-&gt;outer_relids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(rinfo-&gt;outer_relids, ctx-&gt;from, ctx-&gt;to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rinfo-&gt;incompatible_relids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(rinfo-&gt;incompatible_relids, ctx-&gt;from, ctx-&gt;to);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rinfo-&gt;mergeopfamilies &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L715" title="nodes/bitmapset.c:715">bms_get_singleton_member</a>(rinfo-&gt;clause_relids, &amp;relid) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid == ctx-&gt;to &amp;&amp; IsA(rinfo-&gt;clause, OpExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *leftOp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *rightOp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftOp = (Expr *) get_leftop(rinfo-&gt;clause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightOp = (Expr *) get_rightop(rinfo-&gt;clause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (leftOp != <span class="Constant">NULL</span> &amp;&amp; <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(leftOp, rightOp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NullTest&nbsp;&nbsp; *ntest = makeNode(NullTest);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntest-&gt;arg = leftOp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntest-&gt;nulltesttype = IS_NOT_NULL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntest-&gt;argisrow = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntest-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rinfo-&gt;clause = (Expr *) ntest;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rinfo-&gt;mergeopfamilies = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rinfo-&gt;orclause == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L1442" title="optimizer/plan/analyzejoins.c:1442">replace_varno_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) ctx);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1547">&#x200c;</a></span><span class="linkable">replace_varno</span>(Node *node, <span class="Type">int</span> from, <span class="Type">int</span> to)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1439" title="optimizer/plan/analyzejoins.c:1439">ReplaceVarnoContext</a> ctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (to &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx.from = from;<br/></li>
<li>&nbsp; &nbsp; ctx.to = to;<br/></li>
<li>&nbsp; &nbsp; ctx.sublevels_up = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must be prepared to start with a Query or a bare expression tree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; query_or_expression_tree_walker(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1442" title="optimizer/plan/analyzejoins.c:1442">replace_varno_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) &amp;ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QTW_EXAMINE_SORTGROUP);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Substitute newId by oldId in relids.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We must make a copy of the original Bitmapset <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> making <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * modifications, because the same pointer to it might be shared among<br/></li>
<li></span><span class="Comment"> * different places.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Bitmapset *<br/></li>
<li><a id="L1575">&#x200c;</a><span class="linkable">replace_relid</span>(Relids relids, <span class="Type">int</span> oldId, <span class="Type">int</span> newId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (oldId &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> relid without substitution. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newId &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(<a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(relids), oldId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Substitute newId for oldId. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(oldId, relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(<a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(<a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(relids), oldId), newId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> relids;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update EC members to point to the remaining relation instead of the removed<br/></li>
<li></span><span class="Comment"> * one, removing duplicates.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Restriction clauses for base relations are already distributed to<br/></li>
<li></span><span class="Comment"> * the respective baserestrictinfo lists (see<br/></li>
<li></span><span class="Comment"> * <a href="../path/equivclass.c.html#L2971" title="optimizer/path/equivclass.c:2971">generate_implied_equalities_for_column</a>). The above code has already processed<br/></li>
<li></span><span class="Comment"> * this list, and updated these clauses to reference the remaining<br/></li>
<li></span><span class="Comment"> * relation, so we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> them here based on their relids.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Likewise, we have already processed the join clauses that join the<br/></li>
<li></span><span class="Comment"> * removed relation to the remaining one.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Finally, there are join clauses that join the removed relation to<br/></li>
<li></span><span class="Comment"> * some third relation. We can't just delete the source clauses and<br/></li>
<li></span><span class="Comment"> * regenerate them from the EC because the corresponding equality<br/></li>
<li></span><span class="Comment"> * operators might be missing (see the handling of ec_broken).<br/></li>
<li></span><span class="Comment"> * Therefore, we will update the references in the source clauses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Derived clauses can be generated again, so it is simpler to just<br/></li>
<li></span><span class="Comment"> * delete them.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1614">&#x200c;</a></span><span class="linkable">update_eclasses</span>(EquivalenceClass *ec, <span class="Type">int</span> from, <span class="Type">int</span> to)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *new_members = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *new_sources = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, ec-&gt;ec_members)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EquivalenceMember *em = lfirst_node(EquivalenceMember, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_redundant = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(from, em-&gt;em_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_members = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(new_members, em);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; em-&gt;em_relids = <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(em-&gt;em_relids, from, to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; em-&gt;em_jdomain-&gt;jd_relids = <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(em-&gt;em_jdomain-&gt;jd_relids, from, to);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We only process inner joins */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1547" title="optimizer/plan/analyzejoins.c:1547">replace_varno</a>((Node *) em-&gt;em_expr, from, to);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc1, new_members)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EquivalenceMember *other = lfirst_node(EquivalenceMember, lc1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(em-&gt;em_relids, other-&gt;em_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(em-&gt;em_expr, other-&gt;em_expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_redundant = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!is_redundant)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_members = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(new_members, em);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(ec-&gt;ec_members);<br/></li>
<li>&nbsp; &nbsp; ec-&gt;ec_members = new_members;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(ec-&gt;ec_derives);<br/></li>
<li>&nbsp; &nbsp; ec-&gt;ec_derives = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update EC source expressions */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, ec-&gt;ec_sources)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_redundant = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(from, rinfo-&gt;required_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_sources = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(new_sources, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1547" title="optimizer/plan/analyzejoins.c:1547">replace_varno</a>((Node *) rinfo, from, to);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * After switching the clause to the remaining relation, check it for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * redundancy with existing ones. We don't have to check for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * redundancy with derived clauses, because we've just deleted them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc1, new_sources)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *other = lfirst_node(RestrictInfo, lc1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(rinfo-&gt;clause_relids, other-&gt;clause_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(rinfo-&gt;clause, other-&gt;clause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_redundant = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!is_redundant)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_sources = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(new_sources, rinfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(ec-&gt;ec_sources);<br/></li>
<li>&nbsp; &nbsp; ec-&gt;ec_sources = new_sources;<br/></li>
<li>&nbsp; &nbsp; ec-&gt;ec_relids = <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(ec-&gt;ec_relids, from, to);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * &quot;Logically&quot; compares two RestrictInfo's ignoring the 'rinfo_serial' field,<br/></li>
<li></span><span class="Comment"> * which makes almost every RestrictInfo unique.&nbsp; This type of comparison is<br/></li>
<li></span><span class="Comment"> * useful when removing duplicates while moving RestrictInfo's from removed<br/></li>
<li></span><span class="Comment"> * relation to remaining relation during self-join elimination.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment">: In the future, we might remove the 'rinfo_serial' field completely and<br/></li>
<li></span><span class="Comment"> * get rid of this function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1714">&#x200c;</a></span><span class="linkable">restrict_infos_logically_equal</span>(RestrictInfo *a, RestrictInfo *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saved_rinfo_serial = a-&gt;rinfo_serial;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; a-&gt;rinfo_serial = b-&gt;rinfo_serial;<br/></li>
<li>&nbsp; &nbsp; result = <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(a, b);<br/></li>
<li>&nbsp; &nbsp; a-&gt;rinfo_serial = saved_rinfo_serial;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove a relation after we have proven that it participates only in an<br/></li>
<li></span><span class="Comment"> * unneeded unique self join.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Replace <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> links in <a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> info structures.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Transfer join and restriction clauses from the removed relation to the<br/></li>
<li></span><span class="Comment"> * remaining one. We change the Vars of the clause to point to the<br/></li>
<li></span><span class="Comment"> * remaining relation instead of the removed one. The clauses that require<br/></li>
<li></span><span class="Comment"> * a <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of joinrelids become restriction clauses of the remaining<br/></li>
<li></span><span class="Comment"> * relation, and others remain join clauses. We append them to<br/></li>
<li></span><span class="Comment"> * baserestrictinfo and joininfo respectively, trying not to introduce<br/></li>
<li></span><span class="Comment"> * duplicates.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also have to process the 'joinclauses' list here, because it<br/></li>
<li></span><span class="Comment"> * contains EC-derived join clauses which must become filter clauses. It<br/></li>
<li></span><span class="Comment"> * is not enough to just correct the ECs because the EC-derived<br/></li>
<li></span><span class="Comment"> * restrictions are generated <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> join removal (see<br/></li>
<li></span><span class="Comment"> * <a href="../path/equivclass.c.html#L1044" title="optimizer/path/equivclass.c:1044">generate_base_implied_equalities</a>).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1747">&#x200c;</a></span><span class="linkable">remove_self_join_rel</span>(PlannerInfo *root, PlanRowMark *kmark, PlanRowMark *rmark,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *toKeep, RelOptInfo *toRemove,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *restrictlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *joininfos;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *jinfo_candidates = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *binfo_candidates = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(toKeep-&gt;relid != -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Replace the index of the removing table with the keeping one. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * technique of removing/distributing restrictinfo is used here to attach<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just appeared (for keeping relation) join clauses and avoid adding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * duplicates of those that already exist in the joininfo list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; joininfos = <a href="../../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(toRemove-&gt;joininfo);<br/></li>
<li>&nbsp; &nbsp; foreach(lc, joininfos)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/joininfo.c.html#L153" title="optimizer/util/joininfo.c:153">remove_join_clause_from_rels</a>(root, rinfo, rinfo-&gt;required_relids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1547" title="optimizer/plan/analyzejoins.c:1547">replace_varno</a>((Node *) rinfo, toRemove-&gt;relid, toKeep-&gt;relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L781" title="nodes/bitmapset.c:781">bms_membership</a>(rinfo-&gt;required_relids) == BMS_MULTIPLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jinfo_candidates = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(jinfo_candidates, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; binfo_candidates = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(binfo_candidates, rinfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Concatenate restrictlist to the list of base restrictions of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * removing table just to simplify the replacement procedure: all of them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * weren't connected to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> keeping relations and need to be added to some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; toRemove-&gt;baserestrictinfo = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(toRemove-&gt;baserestrictinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; restrictlist);<br/></li>
<li>&nbsp; &nbsp; foreach(lc, toRemove-&gt;baserestrictinfo)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1547" title="optimizer/plan/analyzejoins.c:1547">replace_varno</a>((Node *) rinfo, toRemove-&gt;relid, toKeep-&gt;relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L781" title="nodes/bitmapset.c:781">bms_membership</a>(rinfo-&gt;required_relids) == BMS_MULTIPLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jinfo_candidates = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(jinfo_candidates, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; binfo_candidates = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(binfo_candidates, rinfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now, add all non-redundant clauses to the keeping relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Contradictory operation. On the one side, we reduce the length of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restrict lists that can impact planning or executing time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Additionally, we improve the accuracy of cardinality estimation. On the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other side, it is one more place that can make planning time much<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * longer in specific cases. It would have been better to avoid calling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>() function here, but it's the only way to detect duplicated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inequality expressions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, binfo_candidates)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *olc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_redundant = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(toRemove-&gt;relid, rinfo-&gt;required_relids));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(olc, toKeep-&gt;baserestrictinfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *src = lfirst_node(RestrictInfo, olc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(src-&gt;clause_relids, rinfo-&gt;clause_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Const and non-const expressions can't be <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (src == rinfo ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (rinfo-&gt;parent_ec != <span class="Constant">NULL<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;&amp; src-&gt;parent_ec == rinfo-&gt;parent_ec)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || <a href="#L1714" title="optimizer/plan/analyzejoins.c:1714">restrict_infos_logically_equal</a>(rinfo, src))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_redundant = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!is_redundant)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="initsplan.c.html#L2836" title="optimizer/plan/initsplan.c:2836">distribute_restrictinfo_to_rels</a>(root, rinfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; foreach(lc, jinfo_candidates)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *olc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_redundant = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(toRemove-&gt;relid, rinfo-&gt;required_relids));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(olc, toKeep-&gt;joininfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *src = lfirst_node(RestrictInfo, olc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(src-&gt;clause_relids, rinfo-&gt;clause_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can't <a href="../geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> trivially different clauses */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (src == rinfo ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (rinfo-&gt;parent_ec != <span class="Constant">NULL<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;&amp; src-&gt;parent_ec == rinfo-&gt;parent_ec)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || <a href="#L1714" title="optimizer/plan/analyzejoins.c:1714">restrict_infos_logically_equal</a>(rinfo, src))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_redundant = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!is_redundant)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="initsplan.c.html#L2836" title="optimizer/plan/initsplan.c:2836">distribute_restrictinfo_to_rels</a>(root, rinfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(binfo_candidates);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(jinfo_candidates);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Arrange equivalence classes, mentioned removing a table, with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * keeping one: varno of removing table should be replaced in members and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sources lists. Also, remove duplicated elements if this replacement<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * procedure created them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; i = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((i = <a href="../../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(toRemove-&gt;eclass_indexes, i)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EquivalenceClass *ec = (EquivalenceClass *) list_nth(root-&gt;eq_classes, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1614" title="optimizer/plan/analyzejoins.c:1614">update_eclasses</a>(ec, toRemove-&gt;relid, toKeep-&gt;relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; toKeep-&gt;eclass_indexes = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(toKeep-&gt;eclass_indexes, i);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Transfer the targetlist and attr_needed flags.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; foreach(lc, toRemove-&gt;reltarget-&gt;exprs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *node = lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1547" title="optimizer/plan/analyzejoins.c:1547">replace_varno</a>(node, toRemove-&gt;relid, toKeep-&gt;relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/list.c.html#L661" title="nodes/list.c:661">list_member</a>(toKeep-&gt;reltarget-&gt;exprs, node))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toKeep-&gt;reltarget-&gt;exprs = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(toKeep-&gt;reltarget-&gt;exprs, node);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = toKeep-&gt;min_attr; i &lt;= toKeep-&gt;max_attr; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attno = i - toKeep-&gt;min_attr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; toRemove-&gt;attr_needed[attno] = <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(toRemove-&gt;attr_needed[attno],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; toRemove-&gt;relid, toKeep-&gt;relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; toKeep-&gt;attr_needed[attno] = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(toKeep-&gt;attr_needed[attno],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; toRemove-&gt;attr_needed[attno]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the removed relation has a row mark, transfer it to the remaining<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If both rels have row marks, just keep the one corresponding to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * remaining relation, because we verified earlier that they have the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * strength.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rmark)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (kmark)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(kmark-&gt;markType == rmark-&gt;markType);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;rowMarks = <a href="../../nodes/list.c.html#L872" title="nodes/list.c:872">list_delete_ptr</a>(root-&gt;rowMarks, rmark);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Shouldn't have inheritance children here. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rmark-&gt;rti == rmark-&gt;prti);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rmark-&gt;rti = rmark-&gt;prti = toKeep-&gt;relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Replace varno in all the query structures */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1547" title="optimizer/plan/analyzejoins.c:1547">replace_varno</a>((Node *) root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>, toRemove-&gt;relid, toKeep-&gt;relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* See <a href="#L2111" title="optimizer/plan/analyzejoins.c:2111">remove_self_joins_one_group</a>() */<br/></li>
<li></span>&nbsp; &nbsp; Assert(root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;resultRelation != toRemove-&gt;relid);<br/></li>
<li>&nbsp; &nbsp; Assert(root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;resultRelation != toKeep-&gt;relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Replace links in the <a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> info */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L347" title="optimizer/plan/analyzejoins.c:347">remove_rel_from_query</a>(root, toRemove, toKeep-&gt;relid, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* At last, replace varno in root targetlist and HAVING clause */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1547" title="optimizer/plan/analyzejoins.c:1547">replace_varno</a>((Node *) root-&gt;processed_tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toRemove-&gt;relid, toKeep-&gt;relid);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1547" title="optimizer/plan/analyzejoins.c:1547">replace_varno</a>((Node *) root-&gt;processed_groupClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toRemove-&gt;relid, toKeep-&gt;relid);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(root-&gt;all_result_relids, toRemove-&gt;relid, toKeep-&gt;relid);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1575" title="optimizer/plan/analyzejoins.c:1575">replace_relid</a>(root-&gt;leaf_result_relids, toRemove-&gt;relid, toKeep-&gt;relid);<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There may be references to the rel in root-&gt;fkey_list, but if so,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="initsplan.c.html#L3169" title="optimizer/plan/initsplan.c:3169">match_foreign_keys_to_quals</a>() will get rid of them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Finally, remove the rel from the baserel array to prevent it from being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * referenced again.&nbsp; (We can't do this earlier because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../util/joininfo.c.html#L153" title="optimizer/util/joininfo.c:153">remove_join_clause_from_rels</a> will touch it.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;simple_rel_array[toRemove-&gt;relid] = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And nuke the RelOptInfo, just in case there's another access path */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(toRemove);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1976" title="optimizer/plan/analyzejoins.c:1976">split_selfjoin_quals</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Processes 'joinquals' by building two lists: one containing the quals<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; where the columns/exprs are on either side of the join match, and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; another one containing the remaining quals.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'joinquals' must only contain quals for a RTE_RELATION being joined to<br/></li>
<li></span><span class="Comment"> * itself.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1976">&#x200c;</a></span><span class="linkable">split_selfjoin_quals</span>(PlannerInfo *root, List *joinquals, List **selfjoinquals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **otherjoinquals, <span class="Type">int</span> from, <span class="Type">int</span> to)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sjoinquals = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *ojoinquals = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, joinquals)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OpExpr&nbsp; &nbsp; &nbsp;&nbsp; *expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *leftexpr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *rightexpr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In general, clause looks like F(arg1) = G(arg2) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rinfo-&gt;mergeopfamilies ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L751" title="nodes/bitmapset.c:751">bms_num_members</a>(rinfo-&gt;clause_relids) != <span class="Constant">2</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L781" title="nodes/bitmapset.c:781">bms_membership</a>(rinfo-&gt;left_relids) != BMS_SINGLETON ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L781" title="nodes/bitmapset.c:781">bms_membership</a>(rinfo-&gt;right_relids) != BMS_SINGLETON)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ojoinquals = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(ojoinquals, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; expr = (OpExpr *) rinfo-&gt;clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsA(expr, OpExpr) || list_length(expr-&gt;args) != <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ojoinquals = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(ojoinquals, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; leftexpr = get_leftop(rinfo-&gt;clause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rightexpr = copyObject(get_rightop(rinfo-&gt;clause));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (leftexpr &amp;&amp; IsA(leftexpr, RelabelType))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftexpr = (Node *) ((RelabelType *) leftexpr)-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rightexpr &amp;&amp; IsA(rightexpr, RelabelType))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightexpr = (Node *) ((RelabelType *) rightexpr)-&gt;arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Quite an expensive operation, narrowing the use case. For example,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when we have cast of the same var to different (but compatible)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * types.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1547" title="optimizer/plan/analyzejoins.c:1547">replace_varno</a>(rightexpr, <a href="../../nodes/bitmapset.c.html#L672" title="nodes/bitmapset.c:672">bms_singleton_member</a>(rinfo-&gt;right_relids),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L672" title="nodes/bitmapset.c:672">bms_singleton_member</a>(rinfo-&gt;left_relids));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(leftexpr, rightexpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sjoinquals = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(sjoinquals, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ojoinquals = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(ojoinquals, rinfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *selfjoinquals = sjoinquals;<br/></li>
<li>&nbsp; &nbsp; *otherjoinquals = ojoinquals;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check for a case when uniqueness is at least partly derived from a<br/></li>
<li></span><span class="Comment"> * baserestrictinfo clause. In this case, we have a chance to return only<br/></li>
<li></span><span class="Comment"> * one row (if such clauses on both sides of SJ are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>) or nothing (if they<br/></li>
<li></span><span class="Comment"> * are different).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2041">&#x200c;</a></span><span class="linkable">match_unique_clauses</span>(PlannerInfo *root, RelOptInfo *outer, List *uclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, uclauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *clause;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *iclause;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *c1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; matched = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *olc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(outer-&gt;relid &gt; <span class="Constant">0</span> &amp;&amp; relid &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Only filters like f(R.x1,...,R.xN) == expr we should consider. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(bms_is_empty(rinfo-&gt;left_relids) ^<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bms_is_empty(rinfo-&gt;right_relids));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; clause = (Expr *) copyObject(rinfo-&gt;clause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1547" title="optimizer/plan/analyzejoins.c:1547">replace_varno</a>((Node *) clause, relid, outer-&gt;relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iclause = bms_is_empty(rinfo-&gt;left_relids) ? get_rightop(clause) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; get_leftop(clause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; c1 = bms_is_empty(rinfo-&gt;left_relids) ? get_leftop(clause) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; get_rightop(clause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compare these left and right sides with the corresponding sides of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the outer's filters. If no one is detected - return immediately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(olc, outer-&gt;baserestrictinfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *orinfo = lfirst_node(RestrictInfo, olc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *oclause;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *c2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (orinfo-&gt;mergeopfamilies == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't consider clauses which aren't similar to 'F(X)=G(Y)' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(is_opclause(orinfo-&gt;clause));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oclause = bms_is_empty(orinfo-&gt;left_relids) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; get_rightop(orinfo-&gt;clause) : get_leftop(orinfo-&gt;clause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c2 = (bms_is_empty(orinfo-&gt;left_relids) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; get_leftop(orinfo-&gt;clause) : get_rightop(orinfo-&gt;clause));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(iclause, oclause) &amp;&amp; <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(c1, c2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matched = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!matched)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find and remove unique self joins in a group of base relations that have<br/></li>
<li></span><span class="Comment"> * the same Oid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a set of relids that were removed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Relids<br/></li>
<li><a id="L2111">&#x200c;</a><span class="linkable">remove_self_joins_one_group</span>(PlannerInfo *root, Relids relids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Index of kept relation */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = -<span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Index of removed relation */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((r = <a href="../../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(relids, r)) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *inner = root-&gt;simple_rel_array[r];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> result relation as either source or target relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of SJE, because result relation has different behavior in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../executor/execMain.c.html#L2470" title="executor/execMain.c:2470">EvalPlanQual</a>() and RETURNING clause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;resultRelation == r)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; k = r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((k = <a href="../../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(relids, k)) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; joinrelids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *outer = root-&gt;simple_rel_array[k];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *restrictlist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *selfjoinquals;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *otherjoinquals;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; jinfo_check = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlanRowMark *omark = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlanRowMark *imark = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *uclauses = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;resultRelation == k)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* A sanity check: the relations have the same Oid. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(root-&gt;simple_rte_array[k]-&gt;relid ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;simple_rte_array[r]-&gt;relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It is impossible to eliminate join of two relations if they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * belong to different rules of order. Otherwise <a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> can't be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * able to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> variants of correct query plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, root-&gt;join_info_list)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpecialJoinInfo *info = (SpecialJoinInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(k, info-&gt;syn_lefthand) ^<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(r, info-&gt;syn_lefthand)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(k, info-&gt;syn_righthand) ^<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(r, info-&gt;syn_righthand)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jinfo_check = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!jinfo_check)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check Row Marks equivalence.&nbsp; We can't remove the join if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relations have row marks of different strength (e.g. one is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * locked FOR UPDATE and another just has ROW_MARK_REFERENCE for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../executor/execMain.c.html#L2470" title="executor/execMain.c:2470">EvalPlanQual</a> rechecking).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, root-&gt;rowMarks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlanRowMark *rowMark = (PlanRowMark *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rowMark-&gt;rti == k)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(imark == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; imark = rowMark;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rowMark-&gt;rti == r)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(omark == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; omark = rowMark;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (omark &amp;&amp; imark)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (omark &amp;&amp; imark &amp;&amp; omark-&gt;markType != imark-&gt;markType)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We only deal with base rels here, so their relids bitset<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contains only one member -- their relid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrelids = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(joinrelids, r);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrelids = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(joinrelids, k);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PHVs should not impose <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> constraints on removing self joins.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At this stage, joininfo lists of inner and outer can contain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only clauses, required for a superior outer join that can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * influence this optimization. So, we can avoid to call the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../util/relnode.c.html#L1297" title="optimizer/util/relnode.c:1297">build_joinrel_restrictlist</a>() routine.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restrictlist = <a href="../path/equivclass.c.html#L1392" title="optimizer/path/equivclass.c:1392">generate_join_implied_equalities</a>(root, joinrelids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inner-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Process restrictlist to separate the self join quals out of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other quals. e.g x = x goes to selfjoinquals and a = b to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherjoinquals.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1976" title="optimizer/plan/analyzejoins.c:1976">split_selfjoin_quals</a>(root, restrictlist, &amp;selfjoinquals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;otherjoinquals, inner-&gt;relid, outer-&gt;relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To enable SJE for the only degenerate case without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> self<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * join clauses at all, add baserestrictinfo to this list. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * degenerate case works only if both sides have the same clause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * So doesn't matter which side to add.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selfjoinquals = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(selfjoinquals, outer-&gt;baserestrictinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Determine if the inner table can duplicate outer rows.&nbsp; We must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bypass the unique rel cache here since we're possibly using a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of join quals. We can use 'force_cache' == true when all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * join quals are self-join quals.&nbsp; Otherwise, we could end up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * putting false negatives in the cache.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1244" title="optimizer/plan/analyzejoins.c:1244">innerrel_is_unique_ext</a>(root, joinrelids, inner-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer, JOIN_INNER, selfjoinquals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(otherjoinquals) == <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;uclauses))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have proven that for both relations, the same unique index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * guarantees that there is at most one row where columns <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * given <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. These <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> must be the same for both relations,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or else we won't match the same row on each side of the join.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2041" title="optimizer/plan/analyzejoins.c:2041">match_unique_clauses</a>(root, inner, uclauses, outer-&gt;relid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can remove either relation, so remove the inner one in order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to simplify this loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1747" title="optimizer/plan/analyzejoins.c:1747">remove_self_join_rel</a>(root, omark, imark, outer, inner, restrictlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(result, r);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We have removed the outer relation, try the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Gather indexes of base relations from the joinlist and try to eliminate self<br/></li>
<li></span><span class="Comment"> * joins.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Relids<br/></li>
<li><a id="L2279">&#x200c;</a><span class="linkable">remove_self_joins_recurse</span>(PlannerInfo *root, List *joinlist, Relids toRemove)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *jl;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; relids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L42" title="optimizer/plan/analyzejoins.c:42">SelfJoinCandidate</a> *candidates = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numRels;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Collect indexes of base relations of the join tree */<br/></li>
<li></span>&nbsp; &nbsp; foreach(jl, joinlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *jlnode = (Node *) lfirst(jl);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(jlnode, RangeTblRef))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblRef *ref = (RangeTblRef *) jlnode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = root-&gt;simple_rte_array[ref-&gt;rtindex];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We only care about base relations from which we <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * something.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind == RTE_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;relkind == RELKIND_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;simple_rel_array[ref-&gt;rtindex] != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(ref-&gt;rtindex, relids));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relids = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(relids, ref-&gt;rtindex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(jlnode, List))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recursively go inside the sub-joinlist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toRemove = <a href="#L2279" title="optimizer/plan/analyzejoins.c:2279">remove_self_joins_recurse</a>(root, (List *) jlnode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; toRemove);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized joinlist node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) nodeTag(jlnode));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; numRels = <a href="../../nodes/bitmapset.c.html#L751" title="nodes/bitmapset.c:751">bms_num_members</a>(relids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Need at least two relations for the join */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (numRels &lt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> toRemove;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In order to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> relations with the same oid we first build an array of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * candidates and then sort it by oid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; candidates = (<a href="#L42" title="optimizer/plan/analyzejoins.c:42">SelfJoinCandidate</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L42" title="optimizer/plan/analyzejoins.c:42">SelfJoinCandidate</a>) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numRels);<br/></li>
<li>&nbsp; &nbsp; i = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; j = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((i = <a href="../../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(relids, i)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; candidates[j].relid = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; candidates[j].reloid = root-&gt;simple_rte_array[i]-&gt;relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; j++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qsort(candidates, numRels, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L42" title="optimizer/plan/analyzejoins.c:42">SelfJoinCandidate</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2406" title="optimizer/plan/analyzejoins.c:2406">self_join_candidates_cmp</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Iteratively form a group of relation indexes with the same oid and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * launch the routine that detects self-joins in this group and removes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * excessive <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> table entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At the end of the iteration, exclude the group from the overall relids<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list. So each <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> iteration of the cycle will involve less and less<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value of relids.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">1</span>; j &lt; numRels + <span class="Constant">1</span>; j++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j == numRels || candidates[j].reloid != candidates[i].reloid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j - i &gt;= <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create a group of relation indexes with the same oid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; group = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; removed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (i &lt; j)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; group = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(group, candidates[i].relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relids = <a href="../../nodes/bitmapset.c.html#L1161" title="nodes/bitmapset.c:1161">bms_del_members</a>(relids, group);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to remove self-joins from a group of identical entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> attempt iteratively - if something is deleted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from a group, changes in clauses and equivalence classes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can give us a chance to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> more candidates.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(group, toRemove));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; removed = <a href="#L2111" title="optimizer/plan/analyzejoins.c:2111">remove_self_joins_one_group</a>(root, group);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toRemove = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(toRemove, removed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; group = <a href="../../nodes/bitmapset.c.html#L1161" title="nodes/bitmapset.c:1161">bms_del_members</a>(group, removed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (!bms_is_empty(removed) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/bitmapset.c.html#L781" title="nodes/bitmapset.c:781">bms_membership</a>(group) == BMS_MULTIPLE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(removed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(group);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Single relation, just remove it from the set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relids = <a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(relids, candidates[i].relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = j;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(bms_is_empty(relids));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> toRemove;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compare self-join candidates by their oids.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2406">&#x200c;</a></span><span class="linkable">self_join_candidates_cmp</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L42" title="optimizer/plan/analyzejoins.c:42">SelfJoinCandidate</a> *ca = (<span class="Type">const</span> <a href="#L42" title="optimizer/plan/analyzejoins.c:42">SelfJoinCandidate</a> *) a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L42" title="optimizer/plan/analyzejoins.c:42">SelfJoinCandidate</a> *cb = (<span class="Type">const</span> <a href="#L42" title="optimizer/plan/analyzejoins.c:42">SelfJoinCandidate</a> *) b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ca-&gt;reloid != cb-&gt;reloid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (ca-&gt;reloid &lt; cb-&gt;reloid ? -<span class="Constant">1</span> : <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find and remove useless self joins.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Search for joins where a relation is joined to itself. If the join clause<br/></li>
<li></span><span class="Comment"> * for each tuple from one side of the join is proven to match the same<br/></li>
<li></span><span class="Comment"> * physical row (or nothing) on the other side, that self-join can be<br/></li>
<li></span><span class="Comment"> * eliminated from the query.&nbsp; Suitable join clauses are assumed to be in the<br/></li>
<li></span><span class="Comment"> * form of X = X, and can be replaced with NOT NULL clauses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For the sake of simplicity, we don't apply this optimization to special<br/></li>
<li></span><span class="Comment"> * joins. Here is a list of what we could do in some particular cases:<br/></li>
<li></span><span class="Comment"> * 'a <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> semi join a <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>': is reduced to inner by <a href="#L764" title="optimizer/plan/analyzejoins.c:764">reduce_unique_semijoins</a>,<br/></li>
<li></span><span class="Comment"> * and then removed normally.<br/></li>
<li></span><span class="Comment"> * 'a <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> anti join a <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>': could simplify to a scan with 'outer quals AND<br/></li>
<li></span><span class="Comment"> * (IS NULL on join columns OR NOT inner quals)'.<br/></li>
<li></span><span class="Comment"> * 'a <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> left join a <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>': could simplify to a scan like inner but without<br/></li>
<li></span><span class="Comment"> * NOT NULL conditions on join columns.<br/></li>
<li></span><span class="Comment"> * 'a <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> left join (a <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> join b)': can't simplify this, because join to b<br/></li>
<li></span><span class="Comment"> * can both remove rows and introduce duplicates.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To search for removable joins, we order all the relations on their Oid,<br/></li>
<li></span><span class="Comment"> * go over each set with the same Oid, and consider each pair of relations<br/></li>
<li></span><span class="Comment"> * in this set.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To remove the join, we mark one of the participating relations as dead<br/></li>
<li></span><span class="Comment"> * and rewrite all references to it to point to the remaining relation.<br/></li>
<li></span><span class="Comment"> * This includes modifying RestrictInfos, EquivalenceClasses, and<br/></li>
<li></span><span class="Comment"> * EquivalenceMembers. We also have to modify the row marks. The join clauses<br/></li>
<li></span><span class="Comment"> * of the removed relation become either restriction or join clauses, based on<br/></li>
<li></span><span class="Comment"> * whether they reference <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> relations not participating in the removed join.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'targetlist' is the top-level targetlist of the query. If it has <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * references to the removed relations, we update them to point to the<br/></li>
<li></span><span class="Comment"> * remaining ones.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L2453">&#x200c;</a><span class="linkable">remove_useless_self_joins</span>(PlannerInfo *root, List *joinlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; toRemove = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L44" title="optimizer/plan/analyzejoins.c:44">enable_self_join_removal</a> || joinlist == NIL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (list_length(joinlist) == <span class="Constant">1</span> &amp;&amp; !IsA(linitial(joinlist), List)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> joinlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Merge pairs of relations participated in self-join. Remove unnecessary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> table entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; toRemove = <a href="#L2279" title="optimizer/plan/analyzejoins.c:2279">remove_self_joins_recurse</a>(root, joinlist, toRemove);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(toRemove != <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nremoved = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* At the end, remove orphaned relation links */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((relid = <a href="../../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(toRemove, relid)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinlist = <a href="#L710" title="optimizer/plan/analyzejoins.c:710">remove_rel_from_joinlist</a>(joinlist, relid, &amp;nremoved);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> joinlist;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
