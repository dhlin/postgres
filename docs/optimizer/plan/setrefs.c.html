<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>optimizer/plan/setrefs.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>optimizer/plan/setrefs.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L38">NullingRelsMatch</a></li>
<li><a href="#L73">fix_join_expr_context</a></li>
<li><a href="#L62">fix_scan_expr_context</a></li>
<li><a href="#L83">fix_upper_expr_context</a></li>
<li><a href="#L90">fix_windowagg_cond_context</a></li>
<li><a href="#L97">flatten_rtes_walker_context</a></li>
<li><a href="#L55">indexed_tlist</a></li>
<li><a href="#L46">tlist_vinfo</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L538">add_rte_to_flat_rtable</a></li>
<li><a href="#L391">add_rtes_to_flat_rtable</a></li>
<li><a href="#L2676">build_tlist_index</a></li>
<li><a href="#L2727">build_tlist_index_other_vars</a></li>
<li><a href="#L1534">clean_up_removed_plan_level</a></li>
<li><a href="#L2540">convert_combining_aggrefs</a></li>
<li><a href="#L1944">copyVar</a></li>
<li><a href="#L3541">extract_query_dependencies</a></li>
<li><a href="#L3577">extract_query_dependencies_walker</a></li>
<li><a href="#L3427">find_minmax_agg_replacement_param</a></li>
<li><a href="#L2092">fix_alternative_subplan</a></li>
<li><a href="#L1966">fix_expr_common</a></li>
<li><a href="#L3021">fix_join_expr</a></li>
<li><a href="#L3043">fix_join_expr_mutator</a></li>
<li><a href="#L2061">fix_param_node</a></li>
<li><a href="#L2148">fix_scan_expr</a></li>
<li><a href="#L2183">fix_scan_expr_mutator</a></li>
<li><a href="#L2249">fix_scan_expr_walker</a></li>
<li><a href="#L3182">fix_upper_expr</a></li>
<li><a href="#L3202">fix_upper_expr_mutator</a></li>
<li><a href="#L3379">fix_windowagg_condition_expr</a></li>
<li><a href="#L3349">fix_windowagg_condition_expr_mutator</a></li>
<li><a href="#L492">flatten_rtes_walker</a></li>
<li><a href="#L480">flatten_unplanned_rtes</a></li>
<li><a href="#L1922">offset_relid_set</a></li>
<li><a href="#L3460">record_plan_function_dependency</a></li>
<li><a href="#L3500">record_plan_type_dependency</a></li>
<li><a href="#L2903">search_indexed_tlist_for_non_var</a></li>
<li><a href="#L2850">search_indexed_tlist_for_phv</a></li>
<li><a href="#L2943">search_indexed_tlist_for_sortgroupref</a></li>
<li><a href="#L2785">search_indexed_tlist_for_var</a></li>
<li><a href="#L1741">set_append_references</a></li>
<li><a href="#L1665">set_customscan_references</a></li>
<li><a href="#L2609">set_dummy_tlist_references</a></li>
<li><a href="#L1578">set_foreignscan_references</a></li>
<li><a href="#L1889">set_hash_references</a></li>
<li><a href="#L1321">set_indexonlyscan_references</a></li>
<li><a href="#L2270">set_join_references</a></li>
<li><a href="#L1816">set_mergeappend_references</a></li>
<li><a href="#L2485">set_param_references</a></li>
<li><a href="#L287">set_plan_references</a></li>
<li><a href="#L608">set_plan_refs</a></li>
<li><a href="#L3305">set_returning_clause_references</a></li>
<li><a href="#L1395">set_subqueryscan_references</a></li>
<li><a href="#L2419">set_upper_references</a></li>
<li><a href="#L3400">set_windowagg_runcondition_references</a></li>
<li><a href="#L1464">trivial_subqueryscan</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L125">ISREGCLASSCONST</a></li>
<li><a href="#L116">NUM_EXEC_QUAL</a></li>
<li><a href="#L115">NUM_EXEC_TLIST</a></li>
<li><a href="#L129">fix_scan_list</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * setrefs.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Post-processing of a completed plan tree: fix references to subplan<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>, compute regproc <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for operators, etc<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/optimizer/plan/setrefs.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/pathnode.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/planmain.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/<a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/subselect.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/tlist.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_relation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/utility.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; NRM_EQUAL,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* expect exact match of nullingrels */<br/></li>
<li></span>&nbsp; &nbsp; NRM_SUBSET,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* actual Var may have a <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of input */<br/></li>
<li></span>&nbsp; &nbsp; NRM_SUPERSET,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* actual Var may have a superset of input */<br/></li>
<li><a id="L38">&#x200c;</a></span>} <span class="linkable">NullingRelsMatch</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varno;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* RT index of Var */<br/></li>
<li></span>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; varattno;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* attr number of Var */<br/></li>
<li></span>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; resno;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* TLE position of Var */<br/></li>
<li></span>&nbsp; &nbsp; Bitmapset&nbsp; *varnullingrels; <span class="Comment">/* Var's varnullingrels */<br/></li>
<li><a id="L46">&#x200c;</a></span>} <span class="linkable">tlist_vinfo</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* underlying target list */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_vars;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of plain Var tlist entries */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_ph_vars;&nbsp; &nbsp; <span class="Comment">/* are there PlaceHolderVar entries? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_non_vars;&nbsp; &nbsp; <span class="Comment">/* are there other entries? */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L46" title="optimizer/plan/setrefs.c:46">tlist_vinfo</a> <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>[FLEXIBLE_ARRAY_MEMBER];&nbsp; &nbsp; <span class="Comment">/* has num_vars entries */<br/></li>
<li><a id="L55">&#x200c;</a></span>} <span class="linkable">indexed_tlist</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *root;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; num_exec;<br/></li>
<li><a id="L62">&#x200c;</a>} <span class="linkable">fix_scan_expr_context</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *root;<br/></li>
<li>&nbsp; &nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *outer_itlist;<br/></li>
<li>&nbsp; &nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *inner_itlist;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; acceptable_rel;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset;<br/></li>
<li>&nbsp; &nbsp; <a href="#L38" title="optimizer/plan/setrefs.c:38">NullingRelsMatch</a> nrm_match;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; num_exec;<br/></li>
<li><a id="L73">&#x200c;</a>} <span class="linkable">fix_join_expr_context</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *root;<br/></li>
<li>&nbsp; &nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *subplan_itlist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvarno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset;<br/></li>
<li>&nbsp; &nbsp; <a href="#L38" title="optimizer/plan/setrefs.c:38">NullingRelsMatch</a> nrm_match;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; num_exec;<br/></li>
<li><a id="L83">&#x200c;</a>} <span class="linkable">fix_upper_expr_context</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *root;<br/></li>
<li>&nbsp; &nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *subplan_itlist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvarno;<br/></li>
<li><a id="L90">&#x200c;</a>} <span class="linkable">fix_windowagg_cond_context</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Context info for <a href="#L492" title="optimizer/plan/setrefs.c:492">flatten_rtes_walker</a>() */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; PlannerGlobal *glob;<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query;<br/></li>
<li><a id="L97">&#x200c;</a>} <span class="linkable">flatten_rtes_walker_context</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Selecting the best alternative in an AlternativeSubPlan expression requires<br/></li>
<li></span><span class="Comment"> * estimating how many times that expression will be evaluated.&nbsp; For an<br/></li>
<li></span><span class="Comment"> * expression in a plan node's targetlist, the plan's estimated number of<br/></li>
<li></span><span class="Comment"> * output rows is clearly what to use, but for an expression in a qual it's<br/></li>
<li></span><span class="Comment"> * far less clear.&nbsp; Since AlternativeSubPlans aren't heavily used, we don't<br/></li>
<li></span><span class="Comment"> * want to expend a lot of cycles making such estimates.&nbsp; What we use is twice<br/></li>
<li></span><span class="Comment"> * the number of output rows.&nbsp; That's not entirely unfounded: we know that<br/></li>
<li></span><span class="Comment"> * <a href="../path/clausesel.c.html#L667" title="optimizer/path/clausesel.c:667">clause_selectivity</a>() would fall back to a default selectivity estimate<br/></li>
<li></span><span class="Comment"> * of 0.5 for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SubPlan, so if the qual containing the SubPlan is the last<br/></li>
<li></span><span class="Comment"> * to be applied (which it likely would be, thanks to <a href="createplan.c.html#L5315" title="optimizer/plan/createplan.c:5315">order_qual_clauses</a>()),<br/></li>
<li></span><span class="Comment"> * this matches what we could have estimated in a far more laborious fashion.<br/></li>
<li></span><span class="Comment"> * Obviously there are many other scenarios, but it's probably not worth the<br/></li>
<li></span><span class="Comment"> * trouble to try to improve on this estimate, especially not when we don't<br/></li>
<li></span><span class="Comment"> * have a better estimate for the selectivity of the SubPlan qual itself.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L115">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUM_EXEC_TLIST</span>(parentplan)&nbsp; ((parentplan)-&gt;plan_rows)<br/></li>
<li><a id="L116">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUM_EXEC_QUAL</span>(parentplan)&nbsp;&nbsp; ((parentplan)-&gt;plan_rows * </span><span class="Constant">2.0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check if a Const node is a regclass value.&nbsp; We <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> plain OID too,<br/></li>
<li></span><span class="Comment"> * since a regclass Const will get folded to that type if it's an argument<br/></li>
<li></span><span class="Comment"> * to <a href="../../utils/adt/oid.c.html#L272" title="utils/adt/oid.c:272">oideq</a> or similar operators.&nbsp; (This might result in some extraneous<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in a plan's list of relation dependencies, but the worst result<br/></li>
<li></span><span class="Comment"> * would be occasional useless replans.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L125">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ISREGCLASSCONST</span>(con) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (((con)-&gt;consttype == REGCLASSOID || (con)-&gt;consttype == OIDOID) &amp;&amp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; !(con)-&gt;constisnull)<br/></li>
<li></span><br/></li>
<li><a id="L129">&#x200c;</a><span class="PreProc">#define <span class="linkable">fix_scan_list</span>(root, lst, rtoffset, num_exec) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((List *) <a href="#L2148" title="optimizer/plan/setrefs.c:2148">fix_scan_expr</a>(root, (Node *) (lst), rtoffset, num_exec))<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L391" title="optimizer/plan/setrefs.c:391">add_rtes_to_flat_rtable</a>(PlannerInfo *root, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L480" title="optimizer/plan/setrefs.c:480">flatten_unplanned_rtes</a>(PlannerGlobal *glob, RangeTblEntry *rte);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L492" title="optimizer/plan/setrefs.c:492">flatten_rtes_walker</a>(Node *node, <a href="#L97" title="optimizer/plan/setrefs.c:97">flatten_rtes_walker_context</a> *cxt);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L538" title="optimizer/plan/setrefs.c:538">add_rte_to_flat_rtable</a>(PlannerGlobal *glob, List *rteperminfos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RangeTblEntry *rte);<br/></li>
<li><span class="Type">static</span> Plan *<a href="#L608" title="optimizer/plan/setrefs.c:608">set_plan_refs</a>(PlannerInfo *root, Plan *plan, <span class="Type">int</span> rtoffset);<br/></li>
<li><span class="Type">static</span> Plan *<a href="#L1321" title="optimizer/plan/setrefs.c:1321">set_indexonlyscan_references</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexOnlyScan *plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> rtoffset);<br/></li>
<li><span class="Type">static</span> Plan *<a href="#L1395" title="optimizer/plan/setrefs.c:1395">set_subqueryscan_references</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SubqueryScan *plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> rtoffset);<br/></li>
<li><span class="Type">static</span> Plan *<a href="#L1534" title="optimizer/plan/setrefs.c:1534">clean_up_removed_plan_level</a>(Plan *parent, Plan *child);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1578" title="optimizer/plan/setrefs.c:1578">set_foreignscan_references</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ForeignScan *fscan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> rtoffset);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1665" title="optimizer/plan/setrefs.c:1665">set_customscan_references</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CustomScan *cscan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> rtoffset);<br/></li>
<li><span class="Type">static</span> Plan *<a href="#L1741" title="optimizer/plan/setrefs.c:1741">set_append_references</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Append *aplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> rtoffset);<br/></li>
<li><span class="Type">static</span> Plan *<a href="#L1816" title="optimizer/plan/setrefs.c:1816">set_mergeappend_references</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MergeAppend *mplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> rtoffset);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1889" title="optimizer/plan/setrefs.c:1889">set_hash_references</a>(PlannerInfo *root, Plan *plan, <span class="Type">int</span> rtoffset);<br/></li>
<li><span class="Type">static</span> Relids <a href="../../rewrite/rewriteManip.c.html#L532" title="rewrite/rewriteManip.c:532">offset_relid_set</a>(Relids relids, <span class="Type">int</span> rtoffset);<br/></li>
<li><span class="Type">static</span> Node *<a href="#L2148" title="optimizer/plan/setrefs.c:2148">fix_scan_expr</a>(PlannerInfo *root, Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> rtoffset, <span class="Type">double</span> num_exec);<br/></li>
<li><span class="Type">static</span> Node *<a href="#L2183" title="optimizer/plan/setrefs.c:2183">fix_scan_expr_mutator</a>(Node *node, <a href="#L62" title="optimizer/plan/setrefs.c:62">fix_scan_expr_context</a> *context);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2249" title="optimizer/plan/setrefs.c:2249">fix_scan_expr_walker</a>(Node *node, <a href="#L62" title="optimizer/plan/setrefs.c:62">fix_scan_expr_context</a> *context);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2270" title="optimizer/plan/setrefs.c:2270">set_join_references</a>(PlannerInfo *root, Join *join, <span class="Type">int</span> rtoffset);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2419" title="optimizer/plan/setrefs.c:2419">set_upper_references</a>(PlannerInfo *root, Plan *plan, <span class="Type">int</span> rtoffset);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2485" title="optimizer/plan/setrefs.c:2485">set_param_references</a>(PlannerInfo *root, Plan *plan);<br/></li>
<li><span class="Type">static</span> Node *<a href="#L2540" title="optimizer/plan/setrefs.c:2540">convert_combining_aggrefs</a>(Node *node, <span class="Type">void</span> *context);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2609" title="optimizer/plan/setrefs.c:2609">set_dummy_tlist_references</a>(Plan *plan, <span class="Type">int</span> rtoffset);<br/></li>
<li><span class="Type">static</span> <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *<a href="#L2676" title="optimizer/plan/setrefs.c:2676">build_tlist_index</a>(List *tlist);<br/></li>
<li><span class="Type">static</span> Var *<a href="#L2785" title="optimizer/plan/setrefs.c:2785">search_indexed_tlist_for_var</a>(Var *var,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> newvarno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L38" title="optimizer/plan/setrefs.c:38">NullingRelsMatch</a> nrm_match);<br/></li>
<li><span class="Type">static</span> Var *<a href="#L2850" title="optimizer/plan/setrefs.c:2850">search_indexed_tlist_for_phv</a>(PlaceHolderVar *phv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> newvarno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L38" title="optimizer/plan/setrefs.c:38">NullingRelsMatch</a> nrm_match);<br/></li>
<li><span class="Type">static</span> Var *<a href="#L2903" title="optimizer/plan/setrefs.c:2903">search_indexed_tlist_for_non_var</a>(Expr *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> newvarno);<br/></li>
<li><span class="Type">static</span> Var *<a href="#L2943" title="optimizer/plan/setrefs.c:2943">search_indexed_tlist_for_sortgroupref</a>(Expr *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index sortgroupref,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> newvarno);<br/></li>
<li><span class="Type">static</span> List *<a href="#L3021" title="optimizer/plan/setrefs.c:3021">fix_join_expr</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *outer_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *inner_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index acceptable_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L38" title="optimizer/plan/setrefs.c:38">NullingRelsMatch</a> nrm_match,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> num_exec);<br/></li>
<li><span class="Type">static</span> Node *<a href="#L3043" title="optimizer/plan/setrefs.c:3043">fix_join_expr_mutator</a>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L73" title="optimizer/plan/setrefs.c:73">fix_join_expr_context</a> *context);<br/></li>
<li><span class="Type">static</span> Node *<a href="#L3182" title="optimizer/plan/setrefs.c:3182">fix_upper_expr</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *subplan_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> newvarno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L38" title="optimizer/plan/setrefs.c:38">NullingRelsMatch</a> nrm_match,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> num_exec);<br/></li>
<li><span class="Type">static</span> Node *<a href="#L3202" title="optimizer/plan/setrefs.c:3202">fix_upper_expr_mutator</a>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L83" title="optimizer/plan/setrefs.c:83">fix_upper_expr_context</a> *context);<br/></li>
<li><span class="Type">static</span> List *<a href="#L3305" title="optimizer/plan/setrefs.c:3305">set_returning_clause_references</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *rlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Plan *topplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index resultRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> rtoffset);<br/></li>
<li><span class="Type">static</span> List *<a href="#L3400" title="optimizer/plan/setrefs.c:3400">set_windowagg_runcondition_references</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *runcondition,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Plan *plan);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; SUBPLAN REFERENCES<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L287" title="optimizer/plan/setrefs.c:287">set_plan_references</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is the final processing pass of the <a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>/optimizer.&nbsp; The plan<br/></li>
<li></span><span class="Comment"> * tree is complete; we just have to adjust some representational details<br/></li>
<li></span><span class="Comment"> * for the convenience of the executor:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 1. We flatten the various subquery rangetables into a single list, and<br/></li>
<li></span><span class="Comment"> * zero out RangeTblEntry fields that are not useful to the executor.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 2. We adjust Vars in scan nodes to be consistent with the flat rangetable.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 3. We adjust Vars in <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> plan nodes to refer to the outputs of their<br/></li>
<li></span><span class="Comment"> * subplans.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 4. Aggrefs in Agg plan nodes need to be adjusted in some cases involving<br/></li>
<li></span><span class="Comment"> * partial aggregation or minmax aggregate optimization.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 5. PARAM_MULTIEXPR Params are replaced by regular PARAM_EXEC Params,<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that we have finished planning all MULTIEXPR subplans.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 6. AlternativeSubPlan expressions are replaced by just one of their<br/></li>
<li></span><span class="Comment"> * alternatives, using an estimate of how many times they'll be executed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 7. We compute regproc OIDs for operators (ie, we look up the function<br/></li>
<li></span><span class="Comment"> * that implements each op).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 8. We create lists of specific objects that the plan depends on.<br/></li>
<li></span><span class="Comment"> * This will be used by plancache.c to drive invalidation of cached plans.<br/></li>
<li></span><span class="Comment"> * Relation dependencies are represented by OIDs, and everything else by<br/></li>
<li></span><span class="Comment"> * PlanInvalItems (this distinction is motivated by the shared-inval APIs).<br/></li>
<li></span><span class="Comment"> * Currently, relations, user-defined <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, and domains are the only<br/></li>
<li></span><span class="Comment"> * types of objects that are explicitly tracked this way.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 9. We assign every plan node in the tree a unique ID.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also perform one final optimization step, which is to delete<br/></li>
<li></span><span class="Comment"> * SubqueryScan, Append, and MergeAppend plan nodes that aren't doing<br/></li>
<li></span><span class="Comment"> * anything useful.&nbsp; The reason for doing this last is that<br/></li>
<li></span><span class="Comment"> * it can't readily be done <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="#L287" title="optimizer/plan/setrefs.c:287">set_plan_references</a>, because it would<br/></li>
<li></span><span class="Comment"> * break <a href="#L2419" title="optimizer/plan/setrefs.c:2419">set_upper_references</a>: the Vars in the child plan's top tlist<br/></li>
<li></span><span class="Comment"> * wouldn't match up with the Vars in the outer plan tree.&nbsp; A SubqueryScan<br/></li>
<li></span><span class="Comment"> * serves a necessary function as a buffer between outer query and subquery<br/></li>
<li></span><span class="Comment"> * variable numbering ... but after we've flattened the rangetable this is<br/></li>
<li></span><span class="Comment"> * no longer a problem, since then there's only one rtindex namespace.<br/></li>
<li></span><span class="Comment"> * Likewise, Append and MergeAppend buffer between the parent and child <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a><br/></li>
<li></span><span class="Comment"> * of an appendrel, but we don't need to worry about that once we've done<br/></li>
<li></span><span class="Comment"> * <a href="#L287" title="optimizer/plan/setrefs.c:287">set_plan_references</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L287" title="optimizer/plan/setrefs.c:287">set_plan_references</a> recursively traverses the whole plan tree.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The return value is normally the same Plan node passed in, but can be<br/></li>
<li></span><span class="Comment"> * different when the passed-in Plan is a node we decide isn't needed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The flattened rangetable entries are appended to root-&gt;glob-&gt;finalrtable.<br/></li>
<li></span><span class="Comment"> * Also, rowmarks entries are appended to root-&gt;glob-&gt;finalrowmarks, and the<br/></li>
<li></span><span class="Comment"> * RT indexes of ModifyTable result relations to root-&gt;glob-&gt;resultRelations,<br/></li>
<li></span><span class="Comment"> * and flattened AppendRelInfos are appended to root-&gt;glob-&gt;appendRelations.<br/></li>
<li></span><span class="Comment"> * Plan dependencies are appended to root-&gt;glob-&gt;relationOids (for relations)<br/></li>
<li></span><span class="Comment"> * and root-&gt;glob-&gt;invalItems (for everything else).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Notice that we modify Plan nodes in-place, but use expression_tree_mutator<br/></li>
<li></span><span class="Comment"> * to process targetlist and qual expressions.&nbsp; We can assume that the Plan<br/></li>
<li></span><span class="Comment"> * nodes were just built by the <a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> and are not multiply referenced, but<br/></li>
<li></span><span class="Comment"> * it's not so safe to assume that for expression tree nodes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Plan *<br/></li>
<li><a id="L287">&#x200c;</a><span class="linkable">set_plan_references</span>(PlannerInfo *root, Plan *plan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; PlannerGlobal *glob = root-&gt;glob;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset = list_length(glob-&gt;finalrtable);<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add all the query's RTEs to the flattened rangetable.&nbsp; The live ones<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will have their rangetable indexes increased by rtoffset.&nbsp; (Additional<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * RTEs, not referenced by the Plan tree, might get added after those.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L391" title="optimizer/plan/setrefs.c:391">add_rtes_to_flat_rtable</a>(root, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Adjust RT indexes of PlanRowMarks and add to final rowmarks list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, root-&gt;rowMarks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlanRowMark *rc = lfirst_node(PlanRowMark, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlanRowMark *newrc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* flat copy is enough since all fields are scalars */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newrc = (PlanRowMark *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PlanRowMark));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(newrc, rc, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PlanRowMark));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* adjust indexes ... but *not* the rowmarkId */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newrc-&gt;rti += rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newrc-&gt;prti += rtoffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; glob-&gt;finalrowmarks = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(glob-&gt;finalrowmarks, newrc);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Adjust RT indexes of AppendRelInfos and add to final appendrels list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We assume the AppendRelInfos were built during planning and don't need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to be copied.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, root-&gt;append_rel_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AppendRelInfo *appinfo = lfirst_node(AppendRelInfo, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* adjust RT indexes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; appinfo-&gt;parent_relid += rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appinfo-&gt;child_relid += rtoffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Rather than adjust the translated_vars entries, just drop 'em.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Neither the executor nor EXPLAIN currently need that data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; appinfo-&gt;translated_vars = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; glob-&gt;appendRelations = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(glob-&gt;appendRelations, appinfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If needed, create workspace for processing AlternativeSubPlans */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;hasAlternativeSubPlans)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;isAltSubplan = (<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(list_length(glob-&gt;subplans) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;isUsedSubplan = (<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(list_length(glob-&gt;subplans) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now fix the Plan tree */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="#L608" title="optimizer/plan/setrefs.c:608">set_plan_refs</a>(root, plan, rtoffset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have AlternativeSubPlans, it is likely that we <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> have some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unreferenced subplans in glob-&gt;subplans.&nbsp; To avoid expending cycles on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those subplans later, get rid of them by setting those list entries to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NULL.&nbsp; (Note: we can't do this immediately upon processing an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * AlternativeSubPlan, because there may be multiple copies of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * AlternativeSubPlan, and they can get resolved differently.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;hasAlternativeSubPlans)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, glob-&gt;subplans)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndx = foreach_current_index(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it was used by some AlternativeSubPlan in this query level,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but wasn't selected as best by <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> AlternativeSubPlan, then we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't need it.&nbsp; Do not touch subplans that aren't parts of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * AlternativeSubPlans.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;isAltSubplan[ndx] &amp;&amp; !root-&gt;isUsedSubplan[ndx])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lfirst(lc) = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extract RangeTblEntries from the plan's rangetable, and add to flat rtable<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This can recurse into subquery plans; &quot;recursing&quot; is true if so.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This also seems like a good place to add the query's RTEPermissionInfos to<br/></li>
<li></span><span class="Comment"> * the flat rteperminfos.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L391">&#x200c;</a></span><span class="linkable">add_rtes_to_flat_rtable</span>(PlannerInfo *root, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlannerGlobal *glob = root-&gt;glob;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; rti;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add the query's own RTEs to the flattened rangetable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At top level, we must add all RTEs so that their indexes in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * flattened rangetable match up with their original indexes.&nbsp; When<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recursing, we only care about extracting relation RTEs (and subquery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * RTEs that were once relation RTEs).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rtable)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = (RangeTblEntry *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!recursing || rte-&gt;rtekind == RTE_RELATION ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (rte-&gt;rtekind == RTE_SUBQUERY &amp;&amp; OidIsValid(rte-&gt;relid)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L538" title="optimizer/plan/setrefs.c:538">add_rte_to_flat_rtable</a>(glob, root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rteperminfos, rte);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> dead subqueries, they are not referenced in the Plan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tree, so we must add RTEs contained in them to the flattened rtable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * separately.&nbsp; (If we failed to do this, the executor would not perform<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expected permission checks for tables mentioned in such subqueries.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: this pass over the rangetable can't be combined with the previous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one, because that would mess up the numbering of the live RTEs in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * flattened rangetable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rti = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rtable)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = (RangeTblEntry *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We should ignore inheritance-parent RTEs: their contents have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pulled up into our rangetable already.&nbsp; Also ignore <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subquery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * RTEs without matching RelOptInfos, as they likewise have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pulled up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind == RTE_SUBQUERY &amp;&amp; !rte-&gt;inh &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rti &lt; root-&gt;simple_rel_array_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel = root-&gt;simple_rel_array[rti];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rel-&gt;relid == rti);&nbsp; &nbsp; <span class="Comment">/* sanity check on array */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The subquery might never have been planned at all, if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * was excluded on the basis of self-contradictory constraints<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in our query level.&nbsp; In this case apply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L480" title="optimizer/plan/setrefs.c:480">flatten_unplanned_rtes</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it was planned but the result rel is dummy, we assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that it has been omitted from our plan tree (see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../path/allpaths.c.html#L2494" title="optimizer/path/allpaths.c:2494">set_subquery_pathlist</a>), and recurse to <a href="../../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a> up its RTEs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, it should be represented by a SubqueryScan node<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * somewhere in our plan tree, and we'll <a href="../../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a> up its RTEs when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we process that plan node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, if we're recursing, then we should <a href="../../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a> up RTEs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whether the subquery is dummy or not, because we've found<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that some <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> query level is treating this one as dummy,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and so we won't scan this level's plan tree at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;subroot == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L480" title="optimizer/plan/setrefs.c:480">flatten_unplanned_rtes</a>(glob, rte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (recursing ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IS_DUMMY_REL(<a href="../util/relnode.c.html#L1470" title="optimizer/util/relnode.c:1470">fetch_upper_rel</a>(rel-&gt;subroot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UPPERREL_FINAL, <span class="Constant">NULL</span>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L391" title="optimizer/plan/setrefs.c:391">add_rtes_to_flat_rtable</a>(rel-&gt;subroot, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rti++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extract RangeTblEntries from a subquery that was never planned at all<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L480">&#x200c;</a></span><span class="linkable">flatten_unplanned_rtes</span>(PlannerGlobal *glob, RangeTblEntry *rte)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="optimizer/plan/setrefs.c:97">flatten_rtes_walker_context</a> cxt = {glob, rte-&gt;subquery};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use query_tree_walker to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> all RTEs in the <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> tree */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) query_tree_walker(rte-&gt;subquery,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L492" title="optimizer/plan/setrefs.c:492">flatten_rtes_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) &amp;cxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; QTW_EXAMINE_RTES_BEFORE);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L492">&#x200c;</a></span><span class="linkable">flatten_rtes_walker</span>(Node *node, <a href="#L97" title="optimizer/plan/setrefs.c:97">flatten_rtes_walker_context</a> *cxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, RangeTblEntry))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = (RangeTblEntry *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* As above, we need only save relation RTEs and former relations */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind == RTE_RELATION ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (rte-&gt;rtekind == RTE_SUBQUERY &amp;&amp; OidIsValid(rte-&gt;relid)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L538" title="optimizer/plan/setrefs.c:538">add_rte_to_flat_rtable</a>(cxt-&gt;glob, cxt-&gt;query-&gt;rteperminfos, rte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Query))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Recurse into subselects.&nbsp; Must update cxt-&gt;query to this query so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that the rtable and rteperminfos correspond with each other.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *save_query = cxt-&gt;query;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;query = (Query *) node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = query_tree_walker((Query *) node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L492" title="optimizer/plan/setrefs.c:492">flatten_rtes_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) cxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; QTW_EXAMINE_RTES_BEFORE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;query = save_query;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L492" title="optimizer/plan/setrefs.c:492">flatten_rtes_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) cxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add (a copy of) the given RTE to the final rangetable and also the<br/></li>
<li></span><span class="Comment"> * corresponding RTEPermissionInfo, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, to final rteperminfos.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the flat rangetable, we zero out substructure pointers that are not<br/></li>
<li></span><span class="Comment"> * needed by the executor; this reduces the storage space and copying cost<br/></li>
<li></span><span class="Comment"> * for cached plans.&nbsp; We keep only the ctename, alias, eref Alias fields,<br/></li>
<li></span><span class="Comment"> * which are needed by EXPLAIN, and perminfoindex which is needed by the<br/></li>
<li></span><span class="Comment"> * executor to fetch the RTE's RTEPermissionInfo.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L538">&#x200c;</a></span><span class="linkable">add_rte_to_flat_rtable</span>(PlannerGlobal *glob, List *rteperminfos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RangeTblEntry *rte)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *newrte;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* flat copy to duplicate all the scalar fields */<br/></li>
<li></span>&nbsp; &nbsp; newrte = (RangeTblEntry *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RangeTblEntry));<br/></li>
<li>&nbsp; &nbsp; memcpy(newrte, rte, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RangeTblEntry));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* zap unneeded sub-structure */<br/></li>
<li></span>&nbsp; &nbsp; newrte-&gt;tablesample = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; newrte-&gt;subquery = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; newrte-&gt;joinaliasvars = NIL;<br/></li>
<li>&nbsp; &nbsp; newrte-&gt;joinleftcols = NIL;<br/></li>
<li>&nbsp; &nbsp; newrte-&gt;joinrightcols = NIL;<br/></li>
<li>&nbsp; &nbsp; newrte-&gt;join_using_alias = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; newrte-&gt;<a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> = NIL;<br/></li>
<li>&nbsp; &nbsp; newrte-&gt;tablefunc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; newrte-&gt;values_lists = NIL;<br/></li>
<li>&nbsp; &nbsp; newrte-&gt;coltypes = NIL;<br/></li>
<li>&nbsp; &nbsp; newrte-&gt;coltypmods = NIL;<br/></li>
<li>&nbsp; &nbsp; newrte-&gt;colcollations = NIL;<br/></li>
<li>&nbsp; &nbsp; newrte-&gt;securityQuals = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; glob-&gt;finalrtable = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(glob-&gt;finalrtable, newrte);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's a plain relation RTE (or a subquery that was once a view<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reference), add the relation OID to relationOids.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do this even though the RTE might be unreferenced in the plan tree;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this would correspond to cases such as views that were expanded, child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tables that were eliminated by constraint exclusion, etc. Schema<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * invalidation on such a rel must still force rebuilding of the plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note we don't bother to avoid making duplicate list entries.&nbsp; We could,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but it would probably cost more cycles than it would save.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newrte-&gt;rtekind == RTE_RELATION ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (newrte-&gt;rtekind == RTE_SUBQUERY &amp;&amp; OidIsValid(newrte-&gt;relid)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; glob-&gt;relationOids = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(glob-&gt;relationOids, newrte-&gt;relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add a copy of the RTEPermissionInfo, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, corresponding to this RTE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the flattened global list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;perminfoindex &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RTEPermissionInfo *perminfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RTEPermissionInfo *newperminfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the existing one from this query's rteperminfos. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; perminfo = <a href="../../parser/parse_relation.c.html#L3903" title="parser/parse_relation.c:3903">getRTEPermissionInfo</a>(rteperminfos, newrte);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add a new one to finalrteperminfos and copy the contents of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * existing one into it.&nbsp; Note that <a href="../../parser/parse_relation.c.html#L3874" title="parser/parse_relation.c:3874">addRTEPermissionInfo</a>() also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * updates newrte-&gt;perminfoindex to point to newperminfo in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * finalrteperminfos.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newrte-&gt;perminfoindex = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* expected by <a href="../../parser/parse_relation.c.html#L3874" title="parser/parse_relation.c:3874">addRTEPermissionInfo</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newperminfo = <a href="../../parser/parse_relation.c.html#L3874" title="parser/parse_relation.c:3874">addRTEPermissionInfo</a>(&amp;glob-&gt;finalrteperminfos, newrte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(newperminfo, perminfo, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RTEPermissionInfo));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L608" title="optimizer/plan/setrefs.c:608">set_plan_refs</a>: recurse through the Plan nodes of a single subquery level<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Plan *<br/></li>
<li><a id="L608">&#x200c;</a><span class="linkable">set_plan_refs</span>(PlannerInfo *root, Plan *plan, <span class="Type">int</span> rtoffset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plan == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assign this node a unique ID. */<br/></li>
<li></span>&nbsp; &nbsp; plan-&gt;plan_node_id = root-&gt;glob-&gt;lastPlanNodeId++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Plan-type-specific fixes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (nodeTag(plan))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SeqScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SeqScan&nbsp; &nbsp; *splan = (SeqScan *) plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.scanrelid += rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.plan.targetlist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;scan.plan.targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.plan.qual =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;scan.plan.qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SampleScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SampleScan *splan = (SampleScan *) plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.scanrelid += rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.plan.targetlist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;scan.plan.targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.plan.qual =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;scan.plan.qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;tablesample = (TableSampleClause *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2148" title="optimizer/plan/setrefs.c:2148">fix_scan_expr</a>(root, (Node *) splan-&gt;tablesample,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IndexScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexScan&nbsp; *splan = (IndexScan *) plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.scanrelid += rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.plan.targetlist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;scan.plan.targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.plan.qual =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;scan.plan.qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;indexqual =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;indexqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;indexqualorig =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;indexqualorig,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;indexorderby =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;indexorderby,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;indexorderbyorig =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;indexorderbyorig,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IndexOnlyScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexOnlyScan *splan = (IndexOnlyScan *) plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1321" title="optimizer/plan/setrefs.c:1321">set_indexonlyscan_references</a>(root, splan, rtoffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_BitmapIndexScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BitmapIndexScan *splan = (BitmapIndexScan *) plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.scanrelid += rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no need to fix targetlist and qual */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(splan-&gt;scan.plan.targetlist == NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(splan-&gt;scan.plan.qual == NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;indexqual =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;indexqual, rtoffset, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;indexqualorig =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;indexqualorig,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_BitmapHeapScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BitmapHeapScan *splan = (BitmapHeapScan *) plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.scanrelid += rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.plan.targetlist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;scan.plan.targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.plan.qual =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;scan.plan.qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;bitmapqualorig =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;bitmapqualorig,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_TidScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TidScan&nbsp; &nbsp; *splan = (TidScan *) plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.scanrelid += rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.plan.targetlist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;scan.plan.targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.plan.qual =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;scan.plan.qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;tidquals =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;tidquals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_TidRangeScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TidRangeScan *splan = (TidRangeScan *) plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.scanrelid += rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.plan.targetlist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;scan.plan.targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.plan.qual =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;scan.plan.qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;tidrangequals =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;tidrangequals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SubqueryScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Needs special treatment, see comments below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1395" title="optimizer/plan/setrefs.c:1395">set_subqueryscan_references</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (SubqueryScan *) plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtoffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_FunctionScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FunctionScan *splan = (FunctionScan *) plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.scanrelid += rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.plan.targetlist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;scan.plan.targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.plan.qual =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;scan.plan.qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;<a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;<a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, rtoffset, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_TableFuncScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TableFuncScan *splan = (TableFuncScan *) plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.scanrelid += rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.plan.targetlist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;scan.plan.targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.plan.qual =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;scan.plan.qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;tablefunc = (TableFunc *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2148" title="optimizer/plan/setrefs.c:2148">fix_scan_expr</a>(root, (Node *) splan-&gt;tablefunc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ValuesScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ValuesScan *splan = (ValuesScan *) plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.scanrelid += rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.plan.targetlist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;scan.plan.targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.plan.qual =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;scan.plan.qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;values_lists =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;values_lists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_CteScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CteScan&nbsp; &nbsp; *splan = (CteScan *) plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.scanrelid += rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.plan.targetlist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;scan.plan.targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.plan.qual =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;scan.plan.qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_NamedTuplestoreScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NamedTuplestoreScan *splan = (NamedTuplestoreScan *) plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.scanrelid += rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.plan.targetlist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;scan.plan.targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.plan.qual =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;scan.plan.qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_WorkTableScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WorkTableScan *splan = (WorkTableScan *) plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.scanrelid += rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.plan.targetlist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;scan.plan.targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;scan.plan.qual =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;scan.plan.qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ForeignScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1578" title="optimizer/plan/setrefs.c:1578">set_foreignscan_references</a>(root, (ForeignScan *) plan, rtoffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_CustomScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1665" title="optimizer/plan/setrefs.c:1665">set_customscan_references</a>(root, (CustomScan *) plan, rtoffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_NestLoop:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_MergeJoin:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_HashJoin:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2270" title="optimizer/plan/setrefs.c:2270">set_join_references</a>(root, (Join *) plan, rtoffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Gather:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_GatherMerge:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2419" title="optimizer/plan/setrefs.c:2419">set_upper_references</a>(root, plan, rtoffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2485" title="optimizer/plan/setrefs.c:2485">set_param_references</a>(root, plan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Hash:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1889" title="optimizer/plan/setrefs.c:1889">set_hash_references</a>(root, plan, rtoffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Memoize:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Memoize&nbsp; &nbsp; *mplan = (Memoize *) plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Memoize does not evaluate its targetlist.&nbsp; It just uses the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * same targetlist from its outer subnode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2609" title="optimizer/plan/setrefs.c:2609">set_dummy_tlist_references</a>(plan, rtoffset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mplan-&gt;param_exprs = <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, mplan-&gt;param_exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Material:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Sort:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IncrementalSort:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Unique:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SetOp:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * These plan types don't actually bother to evaluate their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * targetlists, because they just return their unmodified input<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples.&nbsp; Even though the targetlist won't be used by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * executor, we fix it up for possible use by EXPLAIN (not to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mention ease of debugging --- wrong varnos are very confusing).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2609" title="optimizer/plan/setrefs.c:2609">set_dummy_tlist_references</a>(plan, rtoffset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since these plan types don't check quals either, we should not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> qual expression attached to them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(plan-&gt;qual == NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_LockRows:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LockRows&nbsp;&nbsp; *splan = (LockRows *) plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Like the plan types above, LockRows doesn't evaluate its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tlist or quals.&nbsp; But we have to fix up the RT indexes in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * its rowmarks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2609" title="optimizer/plan/setrefs.c:2609">set_dummy_tlist_references</a>(plan, rtoffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(splan-&gt;plan.qual == NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, splan-&gt;rowMarks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlanRowMark *rc = (PlanRowMark *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc-&gt;rti += rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc-&gt;prti += rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Limit:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Limit&nbsp; &nbsp; &nbsp;&nbsp; *splan = (Limit *) plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Like the plan types above, Limit doesn't evaluate its tlist<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or quals.&nbsp; It does have live expressions for limit/offset,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * however; and those cannot contain subplan variable refs, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L2148" title="optimizer/plan/setrefs.c:2148">fix_scan_expr</a> works for them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2609" title="optimizer/plan/setrefs.c:2609">set_dummy_tlist_references</a>(plan, rtoffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(splan-&gt;plan.qual == NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;limitOffset =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2148" title="optimizer/plan/setrefs.c:2148">fix_scan_expr</a>(root, splan-&gt;limitOffset, rtoffset, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;limitCount =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2148" title="optimizer/plan/setrefs.c:2148">fix_scan_expr</a>(root, splan-&gt;limitCount, rtoffset, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Agg:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Agg&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *agg = (Agg *) plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this node is combining partial-aggregation results, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must convert its Aggrefs to contain references to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partial-aggregate subexpressions that will be available<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from the child plan node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DO_AGGSPLIT_COMBINE(agg-&gt;aggsplit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;targetlist = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2540" title="optimizer/plan/setrefs.c:2540">convert_combining_aggrefs</a>((Node *) plan-&gt;targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;qual = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2540" title="optimizer/plan/setrefs.c:2540">convert_combining_aggrefs</a>((Node *) plan-&gt;qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2419" title="optimizer/plan/setrefs.c:2419">set_upper_references</a>(root, plan, rtoffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Group:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2419" title="optimizer/plan/setrefs.c:2419">set_upper_references</a>(root, plan, rtoffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_WindowAgg:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WindowAgg&nbsp; *wplan = (WindowAgg *) plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Adjust the WindowAgg's run conditions by swapping the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WindowFuncs references out to instead reference the Var in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the scan slot so that when the executor evaluates the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * runCondition, it receives the WindowFunc's value from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * slot that the result has just been stored into rather than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * evaluating the WindowFunc all over again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wplan-&gt;runCondition = <a href="#L3400" title="optimizer/plan/setrefs.c:3400">set_windowagg_runcondition_references</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wplan-&gt;runCondition,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Plan *) wplan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2419" title="optimizer/plan/setrefs.c:2419">set_upper_references</a>(root, plan, rtoffset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Like Limit node limit/offset expressions, WindowAgg has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * frame offset expressions, which cannot contain subplan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * variable refs, so <a href="#L2148" title="optimizer/plan/setrefs.c:2148">fix_scan_expr</a> works for them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wplan-&gt;startOffset =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2148" title="optimizer/plan/setrefs.c:2148">fix_scan_expr</a>(root, wplan-&gt;startOffset, rtoffset, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wplan-&gt;endOffset =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2148" title="optimizer/plan/setrefs.c:2148">fix_scan_expr</a>(root, wplan-&gt;endOffset, rtoffset, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wplan-&gt;runCondition = <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wplan-&gt;runCondition,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wplan-&gt;runConditionOrig = <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wplan-&gt;runConditionOrig,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Result:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Result&nbsp; &nbsp; &nbsp;&nbsp; *splan = (Result *) plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Result may or may not have a subplan; if not, it's more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * like a scan node than an <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (splan-&gt;plan.lefttree != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2419" title="optimizer/plan/setrefs.c:2419">set_upper_references</a>(root, plan, rtoffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The tlist of a childless Result could contain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unresolved ROWID_VAR Vars, in case it's representing a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * target relation which is completely empty because of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraint exclusion.&nbsp; Replace <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such Vars by null<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constants, as though they'd been resolved for a leaf<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan node that doesn't support them.&nbsp; We could have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L2148" title="optimizer/plan/setrefs.c:2148">fix_scan_expr</a> do this, but since the case is only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expected to occur here, it seems safer to special-case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it here and keep the assertions that ROWID_VARs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shouldn't be seen by <a href="#L2148" title="optimizer/plan/setrefs.c:2148">fix_scan_expr</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, splan-&gt;plan.targetlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) tle-&gt;expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var &amp;&amp; IsA(var, Var) &amp;&amp; var-&gt;varno == ROWID_VAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle-&gt;expr = (Expr *) <a href="../../nodes/makefuncs.c.html#L339" title="nodes/makefuncs.c:339">makeNullConst</a>(var-&gt;vartype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var-&gt;vartypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var-&gt;varcollid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;plan.targetlist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;plan.targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;plan.qual =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;plan.qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* resconstantqual can't contain <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subplan variable refs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;resconstantqual =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2148" title="optimizer/plan/setrefs.c:2148">fix_scan_expr</a>(root, splan-&gt;resconstantqual, rtoffset, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ProjectSet:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2419" title="optimizer/plan/setrefs.c:2419">set_upper_references</a>(root, plan, rtoffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ModifyTable:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ModifyTable *splan = (ModifyTable *) plan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan = outerPlan(splan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(splan-&gt;plan.targetlist == NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(splan-&gt;plan.qual == NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;withCheckOptionLists =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;withCheckOptionLists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (splan-&gt;returningLists)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newRL = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lcrl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lcrr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pass each per-resultrel returningList through<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L3305" title="optimizer/plan/setrefs.c:3305">set_returning_clause_references</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(splan-&gt;returningLists) == list_length(splan-&gt;resultRelations));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; forboth(lcrl, splan-&gt;returningLists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lcrr, splan-&gt;resultRelations)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *rlist = (List *) lfirst(lcrl);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; resultrel = lfirst_int(lcrr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlist = <a href="#L3305" title="optimizer/plan/setrefs.c:3305">set_returning_clause_references</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newRL = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newRL, rlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;returningLists = newRL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set up the visible plan targetlist as being the same as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the first RETURNING list. This is for the use of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * EXPLAIN; the executor won't pay <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> attention to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * targetlist.&nbsp; We postpone this step until here so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we don't have to do <a href="#L3305" title="optimizer/plan/setrefs.c:3305">set_returning_clause_references</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * twice on identical targetlists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;plan.targetlist = copyObject(linitial(newRL));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We treat ModifyTable with ON CONFLICT as a form of 'pseudo<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * join', where the inner side is the EXCLUDED tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Therefore use <a href="#L3021" title="optimizer/plan/setrefs.c:3021">fix_join_expr</a> to setup the relevant variables<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to INNER_VAR. We explicitly don't create <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> OUTER_VARs as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * those are already used by RETURNING and it seems better to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be non-conflicting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (splan-&gt;onConflictSet)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *itlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itlist = <a href="#L2676" title="optimizer/plan/setrefs.c:2676">build_tlist_index</a>(splan-&gt;exclRelTlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;onConflictSet =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3021" title="optimizer/plan/setrefs.c:3021">fix_join_expr</a>(root, splan-&gt;onConflictSet,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; linitial_int(splan-&gt;resultRelations),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, NRM_EQUAL, <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>(plan));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;onConflictWhere = (Node *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3021" title="optimizer/plan/setrefs.c:3021">fix_join_expr</a>(root, (List *) splan-&gt;onConflictWhere,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; linitial_int(splan-&gt;resultRelations),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, NRM_EQUAL, <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>(plan));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(itlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;exclRelTlist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, splan-&gt;exclRelTlist, rtoffset, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The MERGE statement produces the target rows by performing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a right join between the target relation and the source<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation (which could be a plain relation or a subquery).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The INSERT and UPDATE actions of the MERGE statement<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * require access to the columns from the source relation. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * arrange things so that the source relation attributes are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * available as INNER_VAR and the target relation attributes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are available from the scan tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (splan-&gt;mergeActionLists != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newMJC = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lca,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lcj,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lcr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fix the targetList of individual action nodes so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the so-called &quot;source relation&quot; Vars are referenced as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * INNER_VAR.&nbsp; Note that for this to work correctly during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * execution, the ecxt_innertuple must be set to the tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * obtained by executing the subplan, which is what<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constitutes the &quot;source relation&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We leave the Vars from the result relation (i.e. the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * target relation) unchanged i.e. those Vars would be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * picked from the scan slot. So during execution, we must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ensure that ecxt_scantuple is setup correctly to refer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the tuple from the target relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *itlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itlist = <a href="#L2676" title="optimizer/plan/setrefs.c:2676">build_tlist_index</a>(subplan-&gt;targetlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; forthree(lca, splan-&gt;mergeActionLists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lcj, splan-&gt;mergeJoinConditions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lcr, splan-&gt;resultRelations)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *mergeActionList = lfirst(lca);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *mergeJoinCondition = lfirst(lcj);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; resultrel = lfirst_int(lcr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, mergeActionList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MergeAction *action = (MergeAction *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fix targetList of each action. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; action-&gt;targetList = <a href="#L3021" title="optimizer/plan/setrefs.c:3021">fix_join_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; action-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; resultrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NRM_EQUAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>(plan));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fix quals too. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; action-&gt;qual = (Node *) <a href="#L3021" title="optimizer/plan/setrefs.c:3021">fix_join_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (List *) action-&gt;qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NRM_EQUAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fix join condition too. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mergeJoinCondition = (Node *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3021" title="optimizer/plan/setrefs.c:3021">fix_join_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (List *) mergeJoinCondition,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NRM_EQUAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newMJC = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newMJC, mergeJoinCondition);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;mergeJoinConditions = newMJC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;nominalRelation += rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (splan-&gt;rootRelation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;rootRelation += rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;exclRelRTI += rtoffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, splan-&gt;resultRelations)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lfirst_int(l) += rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, splan-&gt;rowMarks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlanRowMark *rc = (PlanRowMark *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc-&gt;rti += rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc-&gt;prti += rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Append this ModifyTable node's final result relation RT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index(es) to the global list for the plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;glob-&gt;resultRelations =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(root-&gt;glob-&gt;resultRelations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;resultRelations);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (splan-&gt;rootRelation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;glob-&gt;resultRelations =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(root-&gt;glob-&gt;resultRelations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splan-&gt;rootRelation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Append:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Needs special treatment, see comments below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1741" title="optimizer/plan/setrefs.c:1741">set_append_references</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Append *) plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtoffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_MergeAppend:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Needs special treatment, see comments below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1816" title="optimizer/plan/setrefs.c:1816">set_mergeappend_references</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (MergeAppend *) plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_RecursiveUnion:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This doesn't evaluate targetlist or check quals either */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2609" title="optimizer/plan/setrefs.c:2609">set_dummy_tlist_references</a>(plan, rtoffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(plan-&gt;qual == NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_BitmapAnd:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BitmapAnd&nbsp; *splan = (BitmapAnd *) plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* BitmapAnd works like Append, but has no tlist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(splan-&gt;plan.targetlist == NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(splan-&gt;plan.qual == NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, splan-&gt;bitmapplans)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lfirst(l) = <a href="#L608" title="optimizer/plan/setrefs.c:608">set_plan_refs</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Plan *) lfirst(l),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_BitmapOr:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BitmapOr&nbsp;&nbsp; *splan = (BitmapOr *) plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* BitmapOr works like Append, but has no tlist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(splan-&gt;plan.targetlist == NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(splan-&gt;plan.qual == NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, splan-&gt;bitmapplans)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lfirst(l) = <a href="#L608" title="optimizer/plan/setrefs.c:608">set_plan_refs</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Plan *) lfirst(l),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) nodeTag(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now recurse into child plans, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: it is essential that we recurse into child plans AFTER we set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subplan references in this plan's tlist and quals.&nbsp; If we did the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reference-adjustments bottom-up, then we would fail to match this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plan's var nodes against the already-modified nodes of the children.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; plan-&gt;lefttree = <a href="#L608" title="optimizer/plan/setrefs.c:608">set_plan_refs</a>(root, plan-&gt;lefttree, rtoffset);<br/></li>
<li>&nbsp; &nbsp; plan-&gt;righttree = <a href="#L608" title="optimizer/plan/setrefs.c:608">set_plan_refs</a>(root, plan-&gt;righttree, rtoffset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1321" title="optimizer/plan/setrefs.c:1321">set_indexonlyscan_references</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Do <a href="#L287" title="optimizer/plan/setrefs.c:287">set_plan_references</a> processing on an IndexOnlyScan<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is unlike the handling of a plain IndexScan because we have to<br/></li>
<li></span><span class="Comment"> * convert Vars referencing the heap into Vars referencing the index.<br/></li>
<li></span><span class="Comment"> * We can use the <a href="#L3182" title="optimizer/plan/setrefs.c:3182">fix_upper_expr</a> machinery for that, by working from a<br/></li>
<li></span><span class="Comment"> * targetlist describing the index columns.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Plan *<br/></li>
<li><a id="L1321">&#x200c;</a><span class="linkable">set_indexonlyscan_references</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexOnlyScan *plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> rtoffset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *index_itlist;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *stripped_indextlist;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Vars in the plan node's targetlist, qual, and recheckqual must only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reference columns that the index AM can actually return.&nbsp; To ensure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this, remove non-returnable columns (which are marked as resjunk) from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the indexed tlist.&nbsp; We can just drop them because the <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * machinery pays attention to TLE resnos, not physical list position.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; stripped_indextlist = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, plan-&gt;indextlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *indextle = (TargetEntry *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!indextle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stripped_indextlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(stripped_indextlist, indextle);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; index_itlist = <a href="#L2676" title="optimizer/plan/setrefs.c:2676">build_tlist_index</a>(stripped_indextlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;scan.scanrelid += rtoffset;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;scan.plan.targetlist = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3182" title="optimizer/plan/setrefs.c:3182">fix_upper_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) plan-&gt;scan.plan.targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INDEX_VAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NRM_EQUAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>((Plan *) plan));<br/></li>
<li>&nbsp; &nbsp; plan-&gt;scan.plan.qual = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3182" title="optimizer/plan/setrefs.c:3182">fix_upper_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) plan-&gt;scan.plan.qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INDEX_VAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NRM_EQUAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>((Plan *) plan));<br/></li>
<li>&nbsp; &nbsp; plan-&gt;recheckqual = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3182" title="optimizer/plan/setrefs.c:3182">fix_upper_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) plan-&gt;recheckqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INDEX_VAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NRM_EQUAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>((Plan *) plan));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* indexqual is already transformed to reference index columns */<br/></li>
<li></span>&nbsp; &nbsp; plan-&gt;indexqual = <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, plan-&gt;indexqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* indexorderby is already transformed to reference index columns */<br/></li>
<li></span>&nbsp; &nbsp; plan-&gt;indexorderby = <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, plan-&gt;indexorderby,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtoffset, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* indextlist must NOT be transformed to reference index columns */<br/></li>
<li></span>&nbsp; &nbsp; plan-&gt;indextlist = <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, plan-&gt;indextlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtoffset, <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>((Plan *) plan));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(index_itlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Plan *) plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1395" title="optimizer/plan/setrefs.c:1395">set_subqueryscan_references</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Do <a href="#L287" title="optimizer/plan/setrefs.c:287">set_plan_references</a> processing on a SubqueryScan<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We try to strip out the SubqueryScan entirely; if we can't, we have<br/></li>
<li></span><span class="Comment"> * to do the normal processing on it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Plan *<br/></li>
<li><a id="L1395">&#x200c;</a><span class="linkable">set_subqueryscan_references</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SubqueryScan *plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> rtoffset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *rel;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Need to look up the subquery's RelOptInfo, since we need its subroot */<br/></li>
<li></span>&nbsp; &nbsp; rel = <a href="../util/relnode.c.html#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(root, plan-&gt;scan.scanrelid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Recursively process the subplan */<br/></li>
<li></span>&nbsp; &nbsp; plan-&gt;subplan = <a href="#L287" title="optimizer/plan/setrefs.c:287">set_plan_references</a>(rel-&gt;subroot, plan-&gt;subplan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1464" title="optimizer/plan/setrefs.c:1464">trivial_subqueryscan</a>(plan))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can omit the SubqueryScan node and just <a href="../../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a> up the subplan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1534" title="optimizer/plan/setrefs.c:1534">clean_up_removed_plan_level</a>((Plan *) plan, plan-&gt;subplan);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Keep the SubqueryScan node.&nbsp; We have to do the processing that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L287" title="optimizer/plan/setrefs.c:287">set_plan_references</a> would otherwise have done on it.&nbsp; Notice we do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not do <a href="#L2419" title="optimizer/plan/setrefs.c:2419">set_upper_references</a>() here, because a SubqueryScan will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * always have been created with correct references to its subplan's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * outputs to begin with.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;scan.scanrelid += rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;scan.plan.targetlist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, plan-&gt;scan.plan.targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>((Plan *) plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;scan.plan.qual =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, plan-&gt;scan.plan.qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>((Plan *) plan));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (Plan *) plan;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1464" title="optimizer/plan/setrefs.c:1464">trivial_subqueryscan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Detect whether a SubqueryScan can be deleted from the plan tree.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We can delete it if it has no qual to check and the targetlist just<br/></li>
<li></span><span class="Comment"> * regurgitates the output of the child plan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This can be called from <a href="createplan.c.html#L1140" title="optimizer/plan/createplan.c:1140">mark_async_capable_plan</a>(), a helper function for<br/></li>
<li></span><span class="Comment"> * <a href="createplan.c.html#L1216" title="optimizer/plan/createplan.c:1216">create_append_plan</a>(), <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="#L1395" title="optimizer/plan/setrefs.c:1395">set_subqueryscan_references</a>(), to determine<br/></li>
<li></span><span class="Comment"> * triviality of a SubqueryScan that is a child of an Append node.&nbsp; So we<br/></li>
<li></span><span class="Comment"> * cache the result in the SubqueryScan node to avoid repeated computation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: when called from <a href="createplan.c.html#L1140" title="optimizer/plan/createplan.c:1140">mark_async_capable_plan</a>(), we determine the result<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> running <a href="subselect.c.html#L2292" title="optimizer/plan/subselect.c:2292">finalize_plan</a>() on the SubqueryScan node (if needed) and<br/></li>
<li></span><span class="Comment"> * <a href="#L287" title="optimizer/plan/setrefs.c:287">set_plan_references</a>() on the subplan tree, but this would be safe, because<br/></li>
<li></span><span class="Comment"> * 1) <a href="subselect.c.html#L2292" title="optimizer/plan/subselect.c:2292">finalize_plan</a>() doesn't modify the tlist or quals for the SubqueryScan<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; node (or that for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> plan node in the subplan tree), and<br/></li>
<li></span><span class="Comment"> * 2) <a href="#L287" title="optimizer/plan/setrefs.c:287">set_plan_references</a>() modifies the tlist for every plan node in the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; subplan tree, but keeps const/resjunk columns as const/resjunk ones and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; preserves the length and order of the tlist, and<br/></li>
<li></span><span class="Comment"> * 3) <a href="#L287" title="optimizer/plan/setrefs.c:287">set_plan_references</a>() might delete the topmost plan node like an Append<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; or MergeAppend from the subplan tree and <a href="../../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a> up the child plan node,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; but in that case, the tlist for the child plan node exactly matches the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; parent.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1464">&#x200c;</a></span><span class="linkable">trivial_subqueryscan</span>(SubqueryScan *plan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrno;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We might have detected this already; in which case reuse the result */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plan-&gt;scanstatus == SUBQUERY_SCAN_TRIVIAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plan-&gt;scanstatus == SUBQUERY_SCAN_NONTRIVIAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; Assert(plan-&gt;scanstatus == SUBQUERY_SCAN_UNKNOWN);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initially, mark the SubqueryScan as non-deletable from the plan tree */<br/></li>
<li></span>&nbsp; &nbsp; plan-&gt;scanstatus = SUBQUERY_SCAN_NONTRIVIAL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plan-&gt;scan.plan.qual != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(plan-&gt;scan.plan.targetlist) !=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; list_length(plan-&gt;subplan-&gt;targetlist))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tlists not same length */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; attrno = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; forboth(lp, plan-&gt;scan.plan.targetlist, lc, plan-&gt;subplan-&gt;targetlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *ptle = (TargetEntry *) lfirst(lp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *ctle = (TargetEntry *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptle-&gt;resjunk != ctle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tlist doesn't match junk status */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> either a Var referencing the corresponding <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subplan tlist, or a Const equaling the subplan <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>. See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../prep/prepunion.c.html#L1397" title="optimizer/prep/prepunion.c:1397">generate_setop_tlist</a>() for motivation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptle-&gt;expr &amp;&amp; IsA(ptle-&gt;expr, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) ptle-&gt;expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(var-&gt;varno == plan-&gt;scan.scanrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(var-&gt;varlevelsup == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varattno != attrno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* out of order */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ptle-&gt;expr &amp;&amp; IsA(ptle-&gt;expr, Const))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(ptle-&gt;expr, ctle-&gt;expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attrno++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Re-mark the SubqueryScan as deletable from the plan tree */<br/></li>
<li></span>&nbsp; &nbsp; plan-&gt;scanstatus = SUBQUERY_SCAN_TRIVIAL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1534" title="optimizer/plan/setrefs.c:1534">clean_up_removed_plan_level</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Do necessary <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> when we strip out a SubqueryScan, Append, etc<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We are dropping the &quot;parent&quot; plan in favor of returning just its &quot;child&quot;.<br/></li>
<li></span><span class="Comment"> * A few small tweaks are needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Plan *<br/></li>
<li><a id="L1534">&#x200c;</a><span class="linkable">clean_up_removed_plan_level</span>(Plan *parent, Plan *child)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have to be sure we don't lose <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> initplans, so move <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> that were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attached to the parent plan to the child.&nbsp; If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> are parallel-unsafe,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the child is no longer parallel-safe.&nbsp; As a cosmetic matter, also add<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the initplans' run costs to the child's costs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parent-&gt;initPlan)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; initplan_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; unsafe_initplans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="subselect.c.html#L2198" title="optimizer/plan/subselect.c:2198">SS_compute_initplan_cost</a>(parent-&gt;initPlan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;initplan_cost, &amp;unsafe_initplans);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; child-&gt;startup_cost += initplan_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; child-&gt;total_cost += initplan_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unsafe_initplans)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child-&gt;parallel_safe = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Attach plans this way so that parent's initplans are processed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pre-existing initplans of the child.&nbsp; Probably doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matter, but let's preserve the ordering just in case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; child-&gt;initPlan = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(parent-&gt;initPlan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child-&gt;initPlan);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We also have to transfer the parent's column labeling info into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * child, else columns sent to client will be improperly labeled if this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is the topmost plan level.&nbsp; resjunk and so on may be important too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/tlist.c.html#L318" title="optimizer/util/tlist.c:318">apply_tlist_labeling</a>(child-&gt;targetlist, parent-&gt;targetlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> child;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1578" title="optimizer/plan/setrefs.c:1578">set_foreignscan_references</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; Do <a href="#L287" title="optimizer/plan/setrefs.c:287">set_plan_references</a> processing on a ForeignScan<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1578">&#x200c;</a></span><span class="linkable">set_foreignscan_references</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ForeignScan *fscan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> rtoffset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Adjust scanrelid if it's valid */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fscan-&gt;scan.scanrelid &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fscan-&gt;scan.scanrelid += rtoffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fscan-&gt;fdw_scan_tlist != NIL || fscan-&gt;scan.scanrelid == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Adjust tlist, qual, fdw_exprs, fdw_recheck_quals to reference<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * foreign scan tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *itlist = <a href="#L2676" title="optimizer/plan/setrefs.c:2676">build_tlist_index</a>(fscan-&gt;fdw_scan_tlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fscan-&gt;scan.plan.targetlist = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3182" title="optimizer/plan/setrefs.c:3182">fix_upper_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) fscan-&gt;scan.plan.targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INDEX_VAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NRM_EQUAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>((Plan *) fscan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fscan-&gt;scan.plan.qual = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3182" title="optimizer/plan/setrefs.c:3182">fix_upper_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) fscan-&gt;scan.plan.qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INDEX_VAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NRM_EQUAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>((Plan *) fscan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fscan-&gt;fdw_exprs = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3182" title="optimizer/plan/setrefs.c:3182">fix_upper_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) fscan-&gt;fdw_exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INDEX_VAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NRM_EQUAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>((Plan *) fscan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fscan-&gt;fdw_recheck_quals = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3182" title="optimizer/plan/setrefs.c:3182">fix_upper_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) fscan-&gt;fdw_recheck_quals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INDEX_VAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NRM_EQUAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>((Plan *) fscan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(itlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fdw_scan_tlist itself just needs <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>() adjustments */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fscan-&gt;fdw_scan_tlist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, fscan-&gt;fdw_scan_tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>((Plan *) fscan));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Adjust tlist, qual, fdw_exprs, fdw_recheck_quals in the standard<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * way<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fscan-&gt;scan.plan.targetlist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, fscan-&gt;scan.plan.targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>((Plan *) fscan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fscan-&gt;scan.plan.qual =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, fscan-&gt;scan.plan.qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>((Plan *) fscan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fscan-&gt;fdw_exprs =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, fscan-&gt;fdw_exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>((Plan *) fscan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fscan-&gt;fdw_recheck_quals =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, fscan-&gt;fdw_recheck_quals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>((Plan *) fscan));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fscan-&gt;fs_relids = <a href="../../rewrite/rewriteManip.c.html#L532" title="rewrite/rewriteManip.c:532">offset_relid_set</a>(fscan-&gt;fs_relids, rtoffset);<br/></li>
<li>&nbsp; &nbsp; fscan-&gt;fs_base_relids = <a href="../../rewrite/rewriteManip.c.html#L532" title="rewrite/rewriteManip.c:532">offset_relid_set</a>(fscan-&gt;fs_base_relids, rtoffset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Adjust resultRelation if it's valid */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fscan-&gt;resultRelation &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fscan-&gt;resultRelation += rtoffset;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1665" title="optimizer/plan/setrefs.c:1665">set_customscan_references</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; Do <a href="#L287" title="optimizer/plan/setrefs.c:287">set_plan_references</a> processing on a CustomScan<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1665">&#x200c;</a></span><span class="linkable">set_customscan_references</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CustomScan *cscan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> rtoffset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Adjust scanrelid if it's valid */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cscan-&gt;scan.scanrelid &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cscan-&gt;scan.scanrelid += rtoffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cscan-&gt;custom_scan_tlist != NIL || cscan-&gt;scan.scanrelid == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Adjust tlist, qual, custom_exprs to reference custom scan tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *itlist = <a href="#L2676" title="optimizer/plan/setrefs.c:2676">build_tlist_index</a>(cscan-&gt;custom_scan_tlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cscan-&gt;scan.plan.targetlist = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3182" title="optimizer/plan/setrefs.c:3182">fix_upper_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) cscan-&gt;scan.plan.targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INDEX_VAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NRM_EQUAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>((Plan *) cscan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cscan-&gt;scan.plan.qual = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3182" title="optimizer/plan/setrefs.c:3182">fix_upper_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) cscan-&gt;scan.plan.qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INDEX_VAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NRM_EQUAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>((Plan *) cscan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cscan-&gt;custom_exprs = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3182" title="optimizer/plan/setrefs.c:3182">fix_upper_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) cscan-&gt;custom_exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INDEX_VAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NRM_EQUAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>((Plan *) cscan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(itlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* custom_scan_tlist itself just needs <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>() adjustments */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cscan-&gt;custom_scan_tlist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, cscan-&gt;custom_scan_tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>((Plan *) cscan));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Adjust tlist, qual, custom_exprs in the standard way */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cscan-&gt;scan.plan.targetlist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, cscan-&gt;scan.plan.targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>((Plan *) cscan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cscan-&gt;scan.plan.qual =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, cscan-&gt;scan.plan.qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>((Plan *) cscan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cscan-&gt;custom_exprs =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="optimizer/plan/setrefs.c:129">fix_scan_list</a>(root, cscan-&gt;custom_exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset, <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>((Plan *) cscan));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Adjust child plan-nodes recursively, if needed */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, cscan-&gt;custom_plans)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lfirst(lc) = <a href="#L608" title="optimizer/plan/setrefs.c:608">set_plan_refs</a>(root, (Plan *) lfirst(lc), rtoffset);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cscan-&gt;custom_relids = <a href="../../rewrite/rewriteManip.c.html#L532" title="rewrite/rewriteManip.c:532">offset_relid_set</a>(cscan-&gt;custom_relids, rtoffset);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1741" title="optimizer/plan/setrefs.c:1741">set_append_references</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Do <a href="#L287" title="optimizer/plan/setrefs.c:287">set_plan_references</a> processing on an Append<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We try to strip out the Append entirely; if we can't, we have<br/></li>
<li></span><span class="Comment"> * to do the normal processing on it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Plan *<br/></li>
<li><a id="L1741">&#x200c;</a><span class="linkable">set_append_references</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Append *aplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> rtoffset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Append, like Sort et al, doesn't actually evaluate its targetlist or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check quals.&nbsp; If it's got exactly one child plan, then it's not doing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anything useful at all, and we can strip it out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(aplan-&gt;plan.qual == NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First, we gotta recurse on the children */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, aplan-&gt;appendplans)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lfirst(l) = <a href="#L608" title="optimizer/plan/setrefs.c:608">set_plan_refs</a>(root, (Plan *) lfirst(l), rtoffset);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See if it's safe to get rid of the Append entirely.&nbsp; For this to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * safe, there must be only one child plan and that child plan's parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * awareness must match the Append's.&nbsp; The reason for the latter is that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if the Append is parallel aware and the child is not, then the calling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plan may execute the non-parallel aware child multiple times.&nbsp; (If you<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * change these rules, update <a href="../util/pathnode.c.html#L1244" title="optimizer/util/pathnode.c:1244">create_append_path</a> to match.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(aplan-&gt;appendplans) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *p = (Plan *) linitial(aplan-&gt;appendplans);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (p-&gt;parallel_aware == aplan-&gt;plan.parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1534" title="optimizer/plan/setrefs.c:1534">clean_up_removed_plan_level</a>((Plan *) aplan, p);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, clean up the Append as needed.&nbsp; It's okay to do this after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recursing to the children, because <a href="#L2609" title="optimizer/plan/setrefs.c:2609">set_dummy_tlist_references</a> doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * look at those.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2609" title="optimizer/plan/setrefs.c:2609">set_dummy_tlist_references</a>((Plan *) aplan, rtoffset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; aplan-&gt;apprelids = <a href="../../rewrite/rewriteManip.c.html#L532" title="rewrite/rewriteManip.c:532">offset_relid_set</a>(aplan-&gt;apprelids, rtoffset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aplan-&gt;part_prune_info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, aplan-&gt;part_prune_info-&gt;prune_infos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *prune_infos = lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l2, prune_infos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PartitionedRelPruneInfo *pinfo = lfirst(l2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pinfo-&gt;rtindex += rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We don't need to recurse to lefttree or righttree ... */<br/></li>
<li></span>&nbsp; &nbsp; Assert(aplan-&gt;plan.lefttree == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(aplan-&gt;plan.righttree == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Plan *) aplan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1816" title="optimizer/plan/setrefs.c:1816">set_mergeappend_references</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Do <a href="#L287" title="optimizer/plan/setrefs.c:287">set_plan_references</a> processing on a MergeAppend<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We try to strip out the MergeAppend entirely; if we can't, we have<br/></li>
<li></span><span class="Comment"> * to do the normal processing on it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Plan *<br/></li>
<li><a id="L1816">&#x200c;</a><span class="linkable">set_mergeappend_references</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MergeAppend *mplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> rtoffset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * MergeAppend, like Sort et al, doesn't actually evaluate its targetlist<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or check quals.&nbsp; If it's got exactly one child plan, then it's not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doing anything useful at all, and we can strip it out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(mplan-&gt;plan.qual == NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First, we gotta recurse on the children */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, mplan-&gt;mergeplans)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lfirst(l) = <a href="#L608" title="optimizer/plan/setrefs.c:608">set_plan_refs</a>(root, (Plan *) lfirst(l), rtoffset);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See if it's safe to get rid of the MergeAppend entirely.&nbsp; For this to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be safe, there must be only one child plan and that child plan's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parallel awareness must match the MergeAppend's.&nbsp; The reason for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * latter is that if the MergeAppend is parallel aware and the child is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not, then the calling plan may execute the non-parallel aware child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multiple times.&nbsp; (If you change these rules, update<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../util/pathnode.c.html#L1415" title="optimizer/util/pathnode.c:1415">create_merge_append_path</a> to match.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(mplan-&gt;mergeplans) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *p = (Plan *) linitial(mplan-&gt;mergeplans);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (p-&gt;parallel_aware == mplan-&gt;plan.parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1534" title="optimizer/plan/setrefs.c:1534">clean_up_removed_plan_level</a>((Plan *) mplan, p);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, clean up the MergeAppend as needed.&nbsp; It's okay to do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after recursing to the children, because <a href="#L2609" title="optimizer/plan/setrefs.c:2609">set_dummy_tlist_references</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't look at those.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2609" title="optimizer/plan/setrefs.c:2609">set_dummy_tlist_references</a>((Plan *) mplan, rtoffset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mplan-&gt;apprelids = <a href="../../rewrite/rewriteManip.c.html#L532" title="rewrite/rewriteManip.c:532">offset_relid_set</a>(mplan-&gt;apprelids, rtoffset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mplan-&gt;part_prune_info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, mplan-&gt;part_prune_info-&gt;prune_infos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *prune_infos = lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l2, prune_infos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PartitionedRelPruneInfo *pinfo = lfirst(l2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pinfo-&gt;rtindex += rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We don't need to recurse to lefttree or righttree ... */<br/></li>
<li></span>&nbsp; &nbsp; Assert(mplan-&gt;plan.lefttree == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(mplan-&gt;plan.righttree == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Plan *) mplan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1889" title="optimizer/plan/setrefs.c:1889">set_hash_references</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; Do <a href="#L287" title="optimizer/plan/setrefs.c:287">set_plan_references</a> processing on a Hash node<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1889">&#x200c;</a></span><span class="linkable">set_hash_references</span>(PlannerInfo *root, Plan *plan, <span class="Type">int</span> rtoffset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Hash&nbsp; &nbsp; &nbsp;&nbsp; *hplan = (Hash *) plan;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *outer_plan = plan-&gt;lefttree;<br/></li>
<li>&nbsp; &nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *outer_itlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Hash's hashkeys are used when feeding tuples into the hashtable,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * therefore have them reference Hash's outer plan (which itself is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inner plan of the HashJoin).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; outer_itlist = <a href="#L2676" title="optimizer/plan/setrefs.c:2676">build_tlist_index</a>(outer_plan-&gt;targetlist);<br/></li>
<li>&nbsp; &nbsp; hplan-&gt;hashkeys = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3182" title="optimizer/plan/setrefs.c:3182">fix_upper_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) hplan-&gt;hashkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outer_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OUTER_VAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NRM_EQUAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>(plan));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Hash doesn't project */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2609" title="optimizer/plan/setrefs.c:2609">set_dummy_tlist_references</a>(plan, rtoffset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Hash nodes don't have their own quals */<br/></li>
<li></span>&nbsp; &nbsp; Assert(plan-&gt;qual == NIL);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../rewrite/rewriteManip.c.html#L532" title="rewrite/rewriteManip.c:532">offset_relid_set</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Apply rtoffset to the members of a Relids set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Relids<br/></li>
<li><a id="L1922">&#x200c;</a><span class="linkable">offset_relid_set</span>(Relids relids, <span class="Type">int</span> rtoffset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtindex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there's no offset to apply, we needn't recompute the value */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rtoffset == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> relids;<br/></li>
<li>&nbsp; &nbsp; rtindex = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((rtindex = <a href="../../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(relids, rtindex)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(result, rtindex + rtoffset);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1944" title="optimizer/plan/setrefs.c:1944">copyVar</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Copy a Var node.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L2148" title="optimizer/plan/setrefs.c:2148">fix_scan_expr</a> and friends do this enough times that it's worth having<br/></li>
<li></span><span class="Comment"> * a bespoke routine instead of using the generic copyObject() function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> Var *<br/></li>
<li><a id="L1944">&#x200c;</a><span class="linkable">copyVar</span>(Var *var)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *newvar = (Var *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Var));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *newvar = *var;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newvar;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1966" title="optimizer/plan/setrefs.c:1966">fix_expr_common</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Do generic <a href="#L287" title="optimizer/plan/setrefs.c:287">set_plan_references</a> processing on an expression node<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is code that is common to all variants of expression-fixing.<br/></li>
<li></span><span class="Comment"> * We must look up operator opcode info for OpExpr and related nodes,<br/></li>
<li></span><span class="Comment"> * add OIDs from regclass Const nodes into root-&gt;glob-&gt;relationOids, and<br/></li>
<li></span><span class="Comment"> * add PlanInvalItems for user-defined <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> into root-&gt;glob-&gt;invalItems.<br/></li>
<li></span><span class="Comment"> * We also fill in column index lists for GROUPING() expressions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We assume it's okay to update opcode info in-place.&nbsp; So this could possibly<br/></li>
<li></span><span class="Comment"> * scribble on the <a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>'s input data structures, but it's OK.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1966">&#x200c;</a></span><span class="linkable">fix_expr_common</span>(PlannerInfo *root, Node *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We assume callers won't call us on a NULL pointer */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Aggref))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3460" title="optimizer/plan/setrefs.c:3460">record_plan_function_dependency</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((Aggref *) node)-&gt;aggfnoid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, WindowFunc))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3460" title="optimizer/plan/setrefs.c:3460">record_plan_function_dependency</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((WindowFunc *) node)-&gt;winfnoid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, FuncExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3460" title="optimizer/plan/setrefs.c:3460">record_plan_function_dependency</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((FuncExpr *) node)-&gt;funcid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, OpExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L1868" title="nodes/nodeFuncs.c:1868">set_opfuncid</a>((OpExpr *) node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3460" title="optimizer/plan/setrefs.c:3460">record_plan_function_dependency</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((OpExpr *) node)-&gt;opfuncid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, DistinctExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L1868" title="nodes/nodeFuncs.c:1868">set_opfuncid</a>((OpExpr *) node);&nbsp; &nbsp; <span class="Comment">/* rely on struct equivalence */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3460" title="optimizer/plan/setrefs.c:3460">record_plan_function_dependency</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((DistinctExpr *) node)-&gt;opfuncid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, NullIfExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L1868" title="nodes/nodeFuncs.c:1868">set_opfuncid</a>((OpExpr *) node);&nbsp; &nbsp; <span class="Comment">/* rely on struct equivalence */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3460" title="optimizer/plan/setrefs.c:3460">record_plan_function_dependency</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((NullIfExpr *) node)-&gt;opfuncid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, ScalarArrayOpExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L1879" title="nodes/nodeFuncs.c:1879">set_sa_opfuncid</a>(saop);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3460" title="optimizer/plan/setrefs.c:3460">record_plan_function_dependency</a>(root, saop-&gt;opfuncid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(saop-&gt;hashfuncid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3460" title="optimizer/plan/setrefs.c:3460">record_plan_function_dependency</a>(root, saop-&gt;hashfuncid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(saop-&gt;negfuncid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3460" title="optimizer/plan/setrefs.c:3460">record_plan_function_dependency</a>(root, saop-&gt;negfuncid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, Const))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Const&nbsp; &nbsp; &nbsp;&nbsp; *con = (Const *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for regclass reference */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L125" title="optimizer/plan/setrefs.c:125">ISREGCLASSCONST</a>(con))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;glob-&gt;relationOids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(root-&gt;glob-&gt;relationOids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetObjectId(con-&gt;constvalue));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, GroupingFunc))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GroupingFunc *g = (GroupingFunc *) node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber *grouping_map = root-&gt;grouping_map;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If there are no grouping sets, we don't need this. */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(grouping_map || g-&gt;cols == NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (grouping_map)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *cols = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, g-&gt;refs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cols = <a href="../../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(cols, grouping_map[lfirst_int(lc)]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!g-&gt;cols || <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(cols, g-&gt;cols));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!g-&gt;cols)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; g-&gt;cols = cols;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2061" title="optimizer/plan/setrefs.c:2061">fix_param_node</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Do <a href="#L287" title="optimizer/plan/setrefs.c:287">set_plan_references</a> processing on a Param<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If it's a PARAM_MULTIEXPR, replace it with the appropriate Param from<br/></li>
<li></span><span class="Comment"> * root-&gt;multiexpr_params; otherwise no change is needed.<br/></li>
<li></span><span class="Comment"> * Just for paranoia's sake, we make a copy of the node in either case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Node *<br/></li>
<li><a id="L2061">&#x200c;</a><span class="linkable">fix_param_node</span>(PlannerInfo *root, Param *p)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (p-&gt;paramkind == PARAM_MULTIEXPR)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subqueryid = p-&gt;paramid &gt;&gt; <span class="Constant">16</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colno = p-&gt;paramid &amp; <span class="Constant">0xFFFF</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *params;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subqueryid &lt;= <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subqueryid &gt; list_length(root-&gt;multiexpr_params))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected PARAM_MULTIEXPR ID: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, p-&gt;paramid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; params = (List *) list_nth(root-&gt;multiexpr_params, subqueryid - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (colno &lt;= <span class="Constant">0</span> || colno &gt; list_length(params))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected PARAM_MULTIEXPR ID: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, p-&gt;paramid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> copyObject(list_nth(params, colno - <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Node *) copyObject(p);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2092" title="optimizer/plan/setrefs.c:2092">fix_alternative_subplan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Do <a href="#L287" title="optimizer/plan/setrefs.c:287">set_plan_references</a> processing on an AlternativeSubPlan<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Choose one of the alternative implementations and return just that one,<br/></li>
<li></span><span class="Comment"> * discarding the rest of the AlternativeSubPlan structure.<br/></li>
<li></span><span class="Comment"> * Note: caller must still recurse into the result!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We don't make <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> attempt to fix up cost estimates in the parent plan<br/></li>
<li></span><span class="Comment"> * node or higher-level nodes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Node *<br/></li>
<li><a id="L2092">&#x200c;</a><span class="linkable">fix_alternative_subplan</span>(PlannerInfo *root, AlternativeSubPlan *asplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> num_exec)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SubPlan&nbsp; &nbsp; *bestplan = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; bestcost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute the estimated cost of each subplan assuming num_exec<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * executions, and keep the cheapest one.&nbsp; In event of exact equality of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimates, we prefer the later plan; this is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> arbitrary, but in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current usage it biases us to break ties against fast-start subplans.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(asplan-&gt;subplans != NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, asplan-&gt;subplans)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SubPlan&nbsp; &nbsp; *curplan = (SubPlan *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; curcost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; curcost = curplan-&gt;startup_cost + num_exec * curplan-&gt;per_call_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bestplan == <span class="Constant">NULL</span> || curcost &lt;= bestcost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bestplan = curplan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bestcost = curcost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Also mark all subplans that are in AlternativeSubPlans */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;isAltSubplan[curplan-&gt;plan_id - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark the subplan we selected */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;isUsedSubplan[bestplan-&gt;plan_id - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Node *) bestplan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2148" title="optimizer/plan/setrefs.c:2148">fix_scan_expr</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Do <a href="#L287" title="optimizer/plan/setrefs.c:287">set_plan_references</a> processing on a scan-level expression<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This consists of incrementing all Vars' varnos by rtoffset,<br/></li>
<li></span><span class="Comment"> * replacing PARAM_MULTIEXPR Params, expanding PlaceHolderVars,<br/></li>
<li></span><span class="Comment"> * replacing Aggref nodes that should be replaced by initplan output Params,<br/></li>
<li></span><span class="Comment"> * choosing the best implementation for AlternativeSubPlans,<br/></li>
<li></span><span class="Comment"> * looking up operator opcode info for OpExpr and related nodes,<br/></li>
<li></span><span class="Comment"> * and adding OIDs from regclass Const nodes into root-&gt;glob-&gt;relationOids.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'node': the expression to be modified<br/></li>
<li></span><span class="Comment"> * 'rtoffset': how much to increment varnos by<br/></li>
<li></span><span class="Comment"> * 'num_exec': estimated number of executions of expression<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The expression tree is either copied-and-modified, or modified in-place<br/></li>
<li></span><span class="Comment"> * if that seems safe.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Node *<br/></li>
<li><a id="L2148">&#x200c;</a><span class="linkable">fix_scan_expr</span>(PlannerInfo *root, Node *node, <span class="Type">int</span> rtoffset, <span class="Type">double</span> num_exec)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L62" title="optimizer/plan/setrefs.c:62">fix_scan_expr_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.root = root;<br/></li>
<li>&nbsp; &nbsp; context.rtoffset = rtoffset;<br/></li>
<li>&nbsp; &nbsp; context.num_exec = num_exec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rtoffset != <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;multiexpr_params != NIL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;glob-&gt;lastPHId != <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;minmax_aggs != NIL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;hasAlternativeSubPlans)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2183" title="optimizer/plan/setrefs.c:2183">fix_scan_expr_mutator</a>(node, &amp;context);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If rtoffset == 0, we don't need to change <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> Vars, and if there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are no MULTIEXPR subqueries then we don't need to replace<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PARAM_MULTIEXPR Params, and if there are no placeholders anywhere<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we won't need to remove them, and if there are no minmax Aggrefs we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * won't need to replace them, and if there are no AlternativeSubPlans<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we won't need to remove them.&nbsp; Then it's OK to just scribble on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * input node tree instead of copying (since the only change, filling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unset opfuncid fields, is harmless).&nbsp; This saves just enough<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cycles to be noticeable on trivial queries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L2249" title="optimizer/plan/setrefs.c:2249">fix_scan_expr_walker</a>(node, &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Node *<br/></li>
<li><a id="L2183">&#x200c;</a><span class="linkable">fix_scan_expr_mutator</span>(Node *node, <a href="#L62" title="optimizer/plan/setrefs.c:62">fix_scan_expr_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = <a href="#L1944" title="optimizer/plan/setrefs.c:1944">copyVar</a>((Var *) node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(var-&gt;varlevelsup == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We should not see Vars marked INNER_VAR, OUTER_VAR, or ROWID_VAR.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * But an indexqual expression could contain INDEX_VAR Vars.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(var-&gt;varno != INNER_VAR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(var-&gt;varno != OUTER_VAR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(var-&gt;varno != ROWID_VAR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IS_SPECIAL_VARNO(var-&gt;varno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varno += context-&gt;rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varnosyn &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varnosyn += context-&gt;rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) var;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Param))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2061" title="optimizer/plan/setrefs.c:2061">fix_param_node</a>(context-&gt;root, (Param *) node);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Aggref))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Aggref&nbsp; &nbsp; &nbsp;&nbsp; *aggref = (Aggref *) node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Param&nbsp; &nbsp; &nbsp;&nbsp; *aggparam;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See if the Aggref should be replaced by a Param */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; aggparam = <a href="#L3427" title="optimizer/plan/setrefs.c:3427">find_minmax_agg_replacement_param</a>(context-&gt;root, aggref);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggparam != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make a copy of the Param for paranoia's sake */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) copyObject(aggparam);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If no match, just fall through to process it normally */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, CurrentOfExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CurrentOfExpr *cexpr = (CurrentOfExpr *) copyObject(node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!IS_SPECIAL_VARNO(cexpr-&gt;cvarno));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cexpr-&gt;cvarno += context-&gt;rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) cexpr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* At scan level, we should always just evaluate the contained expr */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *phv = (PlaceHolderVar *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> can we assert something about phnullingrels? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2183" title="optimizer/plan/setrefs.c:2183">fix_scan_expr_mutator</a>((Node *) phv-&gt;phexpr, context);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, AlternativeSubPlan))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2183" title="optimizer/plan/setrefs.c:2183">fix_scan_expr_mutator</a>(<a href="#L2092" title="optimizer/plan/setrefs.c:2092">fix_alternative_subplan</a>(context-&gt;root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (AlternativeSubPlan *) node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context-&gt;num_exec),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1966" title="optimizer/plan/setrefs.c:1966">fix_expr_common</a>(context-&gt;root, node);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_mutator(node, <a href="#L2183" title="optimizer/plan/setrefs.c:2183">fix_scan_expr_mutator</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2249">&#x200c;</a></span><span class="linkable">fix_scan_expr_walker</span>(Node *node, <a href="#L62" title="optimizer/plan/setrefs.c:62">fix_scan_expr_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; Assert(!(IsA(node, Var) &amp;&amp; ((Var *) node)-&gt;varno == ROWID_VAR));<br/></li>
<li>&nbsp; &nbsp; Assert(!IsA(node, PlaceHolderVar));<br/></li>
<li>&nbsp; &nbsp; Assert(!IsA(node, AlternativeSubPlan));<br/></li>
<li>&nbsp; &nbsp; <a href="#L1966" title="optimizer/plan/setrefs.c:1966">fix_expr_common</a>(context-&gt;root, node);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L2249" title="optimizer/plan/setrefs.c:2249">fix_scan_expr_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2270" title="optimizer/plan/setrefs.c:2270">set_join_references</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Modify the target list and quals of a join node to reference its<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; subplans, by setting the varnos to OUTER_VAR or INNER_VAR and setting<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; attno <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to the result domain number of either the corresponding<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; outer or inner join tuple item.&nbsp; Also perform opcode lookup for these<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; expressions, and add regclass OIDs to root-&gt;glob-&gt;relationOids.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2270">&#x200c;</a></span><span class="linkable">set_join_references</span>(PlannerInfo *root, Join *join, <span class="Type">int</span> rtoffset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *outer_plan = join-&gt;plan.lefttree;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *inner_plan = join-&gt;plan.righttree;<br/></li>
<li>&nbsp; &nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *outer_itlist;<br/></li>
<li>&nbsp; &nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *inner_itlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; outer_itlist = <a href="#L2676" title="optimizer/plan/setrefs.c:2676">build_tlist_index</a>(outer_plan-&gt;targetlist);<br/></li>
<li>&nbsp; &nbsp; inner_itlist = <a href="#L2676" title="optimizer/plan/setrefs.c:2676">build_tlist_index</a>(inner_plan-&gt;targetlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First process the joinquals (including <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> or <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> clauses).&nbsp; These<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are logically below the join so they can always use all <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * available from the input tlists.&nbsp; It's okay to also handle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NestLoopParams <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, because those couldn't refer to nullable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subexpressions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; join-&gt;joinqual = <a href="#L3021" title="optimizer/plan/setrefs.c:3021">fix_join_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; join-&gt;joinqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outer_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inner_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Index) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NRM_EQUAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>((Plan *) join));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now do join-type-specific stuff */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(join, NestLoop))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; NestLoop&nbsp;&nbsp; *nl = (NestLoop *) join;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, nl-&gt;nestParams)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NestLoopParam *nlp = (NestLoopParam *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Because we don't reparameterize parameterized paths to match<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the outer-join level at which they are used, Vars seen in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NestLoopParam expression may have nullingrels that are just a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of those in the Vars actually available from the outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * side.&nbsp; (Lateral references can also cause this, as explained in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the comments for <a href="../util/paramassign.c.html#L582" title="optimizer/util/paramassign.c:582">identify_current_nestloop_params</a>.)&nbsp; Not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checking this exactly is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> grotty, but the work needed to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * make things match up perfectly seems well out of proportion to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nlp-&gt;paramval = (Var *) <a href="#L3182" title="optimizer/plan/setrefs.c:3182">fix_upper_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) nlp-&gt;paramval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outer_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OUTER_VAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NRM_SUBSET,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>(outer_plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check we replaced <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> PlaceHolderVar with simple Var */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(IsA(nlp-&gt;paramval, Var) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nlp-&gt;paramval-&gt;varno == OUTER_VAR))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;NestLoopParam was not reduced to a simple Var&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(join, MergeJoin))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MergeJoin&nbsp; *mj = (MergeJoin *) join;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mj-&gt;mergeclauses = <a href="#L3021" title="optimizer/plan/setrefs.c:3021">fix_join_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mj-&gt;mergeclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outer_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inner_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Index) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NRM_EQUAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>((Plan *) join));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(join, HashJoin))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HashJoin&nbsp;&nbsp; *hj = (HashJoin *) join;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hj-&gt;hashclauses = <a href="#L3021" title="optimizer/plan/setrefs.c:3021">fix_join_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hj-&gt;hashclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inner_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Index) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NRM_EQUAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>((Plan *) join));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * HashJoin's hashkeys are used to look for matching tuples from its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * outer plan (not the Hash node!) in the hashtable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hj-&gt;hashkeys = (List *) <a href="#L3182" title="optimizer/plan/setrefs.c:3182">fix_upper_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) hj-&gt;hashkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outer_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OUTER_VAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NRM_EQUAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>((Plan *) join));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we need to fix up the targetlist and qpqual, which are logically<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * above the join.&nbsp; This means that, if it's not an inner join, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> Vars<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and PHVs appearing here should have nullingrels that include the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * effects of the outer join, ie they will have nullingrels <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * input Vars' nullingrels plus the <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> added by the outer join.&nbsp; We don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * currently have enough info available here to identify what that should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be, so we just tell <a href="#L3021" title="optimizer/plan/setrefs.c:3021">fix_join_expr</a> to <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> superset nullingrels<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * matches instead of exact ones.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; join-&gt;plan.targetlist = <a href="#L3021" title="optimizer/plan/setrefs.c:3021">fix_join_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; join-&gt;plan.targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inner_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Index) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (join-&gt;jointype == JOIN_INNER ? NRM_EQUAL : NRM_SUPERSET),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>((Plan *) join));<br/></li>
<li>&nbsp; &nbsp; join-&gt;plan.qual = <a href="#L3021" title="optimizer/plan/setrefs.c:3021">fix_join_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; join-&gt;plan.qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inner_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Index) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (join-&gt;jointype == JOIN_INNER ? NRM_EQUAL : NRM_SUPERSET),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>((Plan *) join));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(outer_itlist);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(inner_itlist);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2419" title="optimizer/plan/setrefs.c:2419">set_upper_references</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Update the targetlist and quals of an <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level plan node<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; to refer to the tuples returned by its lefttree subplan.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Also perform opcode lookup for these expressions, and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; add regclass OIDs to root-&gt;glob-&gt;relationOids.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used for single-input plan types like Agg, Group, Result.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In most cases, we have to match up individual Vars in the tlist and<br/></li>
<li></span><span class="Comment"> * qual expressions with elements of the subplan's tlist (which was<br/></li>
<li></span><span class="Comment"> * generated by flattening these selfsame expressions, so it should have all<br/></li>
<li></span><span class="Comment"> * the required variables).&nbsp; There is an important exception, however:<br/></li>
<li></span><span class="Comment"> * depending on where we are in the plan tree, sort/group columns may have<br/></li>
<li></span><span class="Comment"> * been pushed into the subplan tlist unflattened.&nbsp; If these <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are also<br/></li>
<li></span><span class="Comment"> * needed in the output then we want to reference the subplan tlist <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment"> * rather than recomputing the expression.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2419">&#x200c;</a></span><span class="linkable">set_upper_references</span>(PlannerInfo *root, Plan *plan, <span class="Type">int</span> rtoffset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan = plan-&gt;lefttree;<br/></li>
<li>&nbsp; &nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *subplan_itlist;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *output_targetlist;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; subplan_itlist = <a href="#L2676" title="optimizer/plan/setrefs.c:2676">build_tlist_index</a>(subplan-&gt;targetlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; output_targetlist = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(l, plan-&gt;targetlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *newexpr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's a sort/group item, first try to match by sortref */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;ressortgroupref != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newexpr = (Node *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2943" title="optimizer/plan/setrefs.c:2943">search_indexed_tlist_for_sortgroupref</a>(tle-&gt;expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle-&gt;ressortgroupref,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subplan_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OUTER_VAR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!newexpr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newexpr = <a href="#L3182" title="optimizer/plan/setrefs.c:3182">fix_upper_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) tle-&gt;expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subplan_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OUTER_VAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NRM_EQUAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newexpr = <a href="#L3182" title="optimizer/plan/setrefs.c:3182">fix_upper_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) tle-&gt;expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subplan_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OUTER_VAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NRM_EQUAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>(plan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../../nodes/makefuncs.c.html#L273" title="nodes/makefuncs.c:273">flatCopyTargetEntry</a>(tle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle-&gt;expr = (Expr *) newexpr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; output_targetlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(output_targetlist, tle);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = output_targetlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;qual = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3182" title="optimizer/plan/setrefs.c:3182">fix_upper_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) plan-&gt;qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subplan_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OUTER_VAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NRM_EQUAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L116" title="optimizer/plan/setrefs.c:116">NUM_EXEC_QUAL</a>(plan));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(subplan_itlist);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2485" title="optimizer/plan/setrefs.c:2485">set_param_references</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Initialize the initParam list in Gather or Gather <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> node such that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; it contains reference of all the params that needs to be evaluated<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> execution of the node.&nbsp; It contains the initplan params that are<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; being passed to the plan nodes below it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2485">&#x200c;</a></span><span class="linkable">set_param_references</span>(PlannerInfo *root, Plan *plan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(IsA(plan, Gather) || IsA(plan, GatherMerge));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plan-&gt;lefttree-&gt;extParam)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlannerInfo *proot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *initSetParam = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (proot = root; proot != <span class="Constant">NULL</span>; proot = proot-&gt;parent_root)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, proot-&gt;init_plans)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SubPlan&nbsp; &nbsp; *initsubplan = (SubPlan *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l2, initsubplan-&gt;setParam)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initSetParam = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(initSetParam, lfirst_int(l2));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remember the list of all external initplan params that are used by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the children of Gather or Gather <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(plan, Gather))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((Gather *) plan)-&gt;initParam =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L292" title="nodes/bitmapset.c:292">bms_intersect</a>(plan-&gt;lefttree-&gt;extParam, initSetParam);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((GatherMerge *) plan)-&gt;initParam =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L292" title="nodes/bitmapset.c:292">bms_intersect</a>(plan-&gt;lefttree-&gt;extParam, initSetParam);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Recursively scan an expression tree and convert Aggrefs to the proper<br/></li>
<li></span><span class="Comment"> * intermediate form for combining aggregates.&nbsp; This means (1) replacing each<br/></li>
<li></span><span class="Comment"> * one's argument list with a single argument that is the original Aggref<br/></li>
<li></span><span class="Comment"> * modified to show partial aggregation and (2) changing the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> Aggref to<br/></li>
<li></span><span class="Comment"> * show combining aggregation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * After this step, <a href="#L2419" title="optimizer/plan/setrefs.c:2419">set_upper_references</a> will replace the partial Aggrefs<br/></li>
<li></span><span class="Comment"> * with Vars referencing the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> Agg plan node's outputs, so that the final<br/></li>
<li></span><span class="Comment"> * form seen by the executor is a combining Aggref with a Var as input.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It's rather messy to postpone this step until setrefs.c; ideally it'd be<br/></li>
<li></span><span class="Comment"> * done in createplan.c.&nbsp; The difficulty is that once we modify the Aggref<br/></li>
<li></span><span class="Comment"> * expressions, they will no longer be <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>() to their original form and<br/></li>
<li></span><span class="Comment"> * so cross-plan-node-level matches will fail.&nbsp; So this has to happen after<br/></li>
<li></span><span class="Comment"> * the plan node above the Agg has resolved its subplan references.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Node *<br/></li>
<li><a id="L2540">&#x200c;</a><span class="linkable">convert_combining_aggrefs</span>(Node *node, <span class="Type">void</span> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Aggref))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Aggref&nbsp; &nbsp; &nbsp;&nbsp; *orig_agg = (Aggref *) node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Aggref&nbsp; &nbsp; &nbsp;&nbsp; *child_agg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Aggref&nbsp; &nbsp; &nbsp;&nbsp; *parent_agg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Assert we've not chosen to partial-ize <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unsupported cases */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(orig_agg-&gt;aggorder == NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(orig_agg-&gt;aggdistinct == NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since aggregate calls can't be nested, we needn't recurse into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * arguments.&nbsp; But for safety, flat-copy the Aggref node itself rather<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * than modifying it in-place.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; child_agg = makeNode(Aggref);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(child_agg, orig_agg, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Aggref));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For the parent Aggref, we want to copy all the fields of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * original aggregate *except* the args list, which we'll replace<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * below, and the aggfilter expression, which should be applied only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by the child not the parent.&nbsp; Rather than explicitly knowing about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all the other fields here, we can momentarily modify child_agg to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * provide a suitable source for copyObject.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; child_agg-&gt;args = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; child_agg-&gt;aggfilter = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent_agg = copyObject(child_agg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; child_agg-&gt;args = orig_agg-&gt;args;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; child_agg-&gt;aggfilter = orig_agg-&gt;aggfilter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now, set up child_agg to represent the first phase of partial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aggregation.&nbsp; For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, assume serialization is required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="planner.c.html#L5512" title="optimizer/plan/planner.c:5512">mark_partial_aggref</a>(child_agg, AGGSPLIT_INITIAL_SERIAL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * And set up parent_agg to represent the second phase.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; parent_agg-&gt;args = list_make1(<a href="../../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>((Expr *) child_agg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span>, <span class="Constant">NULL</span>, <span class="Constant">false</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="planner.c.html#L5512" title="optimizer/plan/planner.c:5512">mark_partial_aggref</a>(parent_agg, AGGSPLIT_FINAL_DESERIAL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) parent_agg;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_mutator(node, <a href="#L2540" title="optimizer/plan/setrefs.c:2540">convert_combining_aggrefs</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2609" title="optimizer/plan/setrefs.c:2609">set_dummy_tlist_references</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Replace the targetlist of an <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level plan node with a simple<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; list of OUTER_VAR references to its child.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used for plan types like Sort and Append that don't evaluate<br/></li>
<li></span><span class="Comment"> * their targetlists.&nbsp; Although the executor doesn't care at all what's in<br/></li>
<li></span><span class="Comment"> * the tlist, EXPLAIN needs it to be realistic.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we could almost use <a href="#L2419" title="optimizer/plan/setrefs.c:2419">set_upper_references</a>() here, but it fails for<br/></li>
<li></span><span class="Comment"> * Append for lack of a lefttree subplan.&nbsp; Single-purpose code is faster<br/></li>
<li></span><span class="Comment"> * anyway.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2609">&#x200c;</a></span><span class="linkable">set_dummy_tlist_references</span>(Plan *plan, <span class="Type">int</span> rtoffset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *output_targetlist;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; output_targetlist = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(l, plan-&gt;targetlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *oldvar = (Var *) tle-&gt;expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *newvar;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As in <a href="#L2903" title="optimizer/plan/setrefs.c:2903">search_indexed_tlist_for_non_var</a>(), we prefer to keep Consts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as Consts, not Vars referencing Consts.&nbsp; Here, there's no speed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * advantage to be had, but it makes EXPLAIN output look cleaner, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * again it avoids confusing the executor.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(oldvar, Const))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just reuse the existing TLE node */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; output_targetlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(output_targetlist, tle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newvar = <a href="../../nodes/makefuncs.c.html#L66" title="nodes/makefuncs.c:66">makeVar</a>(OUTER_VAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tle-&gt;resno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) oldvar),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>((Node *) oldvar),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) oldvar),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(oldvar, Var) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldvar-&gt;varnosyn &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvar-&gt;varnosyn = oldvar-&gt;varnosyn + rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvar-&gt;varattnosyn = oldvar-&gt;varattnosyn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvar-&gt;varnosyn = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* wasn't ever a plain Var */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvar-&gt;varattnosyn = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../../nodes/makefuncs.c.html#L273" title="nodes/makefuncs.c:273">flatCopyTargetEntry</a>(tle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle-&gt;expr = (Expr *) newvar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; output_targetlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(output_targetlist, tle);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; plan-&gt;targetlist = output_targetlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We don't touch plan-&gt;qual here */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2676" title="optimizer/plan/setrefs.c:2676">build_tlist_index</a> --- build an index data structure for a child tlist<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In most cases, subplan tlists will be &quot;flat&quot; tlists with only Vars,<br/></li>
<li></span><span class="Comment"> * so we try to <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> that case by extracting information about Vars<br/></li>
<li></span><span class="Comment"> * in advance.&nbsp; Matching a parent tlist to a child is still an O(N^2)<br/></li>
<li></span><span class="Comment"> * operation, but at least with a much smaller constant factor than plain<br/></li>
<li></span><span class="Comment"> * <a href="../util/tlist.c.html#L79" title="optimizer/util/tlist.c:79">tlist_member</a>() searches.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result of this function is an <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> struct to pass to<br/></li>
<li></span><span class="Comment"> * <a href="#L2785" title="optimizer/plan/setrefs.c:2785">search_indexed_tlist_for_var</a>() and siblings.<br/></li>
<li></span><span class="Comment"> * When done, the <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> may be freed with a single <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *<br/></li>
<li><a id="L2676">&#x200c;</a><span class="linkable">build_tlist_index</span>(List *tlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *itlist;<br/></li>
<li>&nbsp; &nbsp; <a href="#L46" title="optimizer/plan/setrefs.c:46">tlist_vinfo</a> *vinfo;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create data structure with enough slots for all tlist entries */<br/></li>
<li></span>&nbsp; &nbsp; itlist = (<a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(offsetof(<a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a>, <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_length(tlist) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L46" title="optimizer/plan/setrefs.c:46">tlist_vinfo</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; itlist-&gt;tlist = tlist;<br/></li>
<li>&nbsp; &nbsp; itlist-&gt;has_ph_vars = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; itlist-&gt;has_non_vars = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find the Vars and fill in the index array */<br/></li>
<li></span>&nbsp; &nbsp; vinfo = itlist-&gt;<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>;<br/></li>
<li>&nbsp; &nbsp; foreach(l, tlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;expr &amp;&amp; IsA(tle-&gt;expr, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) tle-&gt;expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vinfo-&gt;varno = var-&gt;varno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vinfo-&gt;varattno = var-&gt;varattno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vinfo-&gt;resno = tle-&gt;resno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vinfo-&gt;varnullingrels = var-&gt;varnullingrels;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vinfo++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (tle-&gt;expr &amp;&amp; IsA(tle-&gt;expr, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itlist-&gt;has_ph_vars = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itlist-&gt;has_non_vars = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; itlist-&gt;num_vars = (vinfo - itlist-&gt;<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> itlist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2727" title="optimizer/plan/setrefs.c:2727">build_tlist_index_other_vars</a> --- build a restricted tlist index<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is like <a href="#L2676" title="optimizer/plan/setrefs.c:2676">build_tlist_index</a>, but we only index tlist entries that<br/></li>
<li></span><span class="Comment"> * are Vars belonging to some rel other than the one specified.&nbsp; We will set<br/></li>
<li></span><span class="Comment"> * has_ph_vars (allowing PlaceHolderVars to be matched), but not has_non_vars<br/></li>
<li></span><span class="Comment"> * (so nothing other than Vars and PlaceHolderVars can be matched).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *<br/></li>
<li><a id="L2727">&#x200c;</a><span class="linkable">build_tlist_index_other_vars</span>(List *tlist, <span class="Type">int</span> ignore_rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *itlist;<br/></li>
<li>&nbsp; &nbsp; <a href="#L46" title="optimizer/plan/setrefs.c:46">tlist_vinfo</a> *vinfo;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create data structure with enough slots for all tlist entries */<br/></li>
<li></span>&nbsp; &nbsp; itlist = (<a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(offsetof(<a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a>, <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_length(tlist) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L46" title="optimizer/plan/setrefs.c:46">tlist_vinfo</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; itlist-&gt;tlist = tlist;<br/></li>
<li>&nbsp; &nbsp; itlist-&gt;has_ph_vars = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; itlist-&gt;has_non_vars = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find the desired Vars and fill in the index array */<br/></li>
<li></span>&nbsp; &nbsp; vinfo = itlist-&gt;<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>;<br/></li>
<li>&nbsp; &nbsp; foreach(l, tlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;expr &amp;&amp; IsA(tle-&gt;expr, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) tle-&gt;expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varno != ignore_rel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vinfo-&gt;varno = var-&gt;varno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vinfo-&gt;varattno = var-&gt;varattno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vinfo-&gt;resno = tle-&gt;resno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vinfo-&gt;varnullingrels = var-&gt;varnullingrels;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vinfo++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (tle-&gt;expr &amp;&amp; IsA(tle-&gt;expr, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itlist-&gt;has_ph_vars = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; itlist-&gt;num_vars = (vinfo - itlist-&gt;<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> itlist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2785" title="optimizer/plan/setrefs.c:2785">search_indexed_tlist_for_var</a> --- <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a Var in an indexed tlist<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If a match is found, return a copy of the given Var with suitably<br/></li>
<li></span><span class="Comment"> * modified varno/varattno (to wit, newvarno and the resno of the TLE entry).<br/></li>
<li></span><span class="Comment"> * Also ensure that varnosyn is incremented by rtoffset.<br/></li>
<li></span><span class="Comment"> * If no match, return NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In debugging builds, we cross-check the varnullingrels of the subplan<br/></li>
<li></span><span class="Comment"> * output Var based on nrm_match.&nbsp; Most call sites should pass NRM_EQUAL<br/></li>
<li></span><span class="Comment"> * indicating we expect an exact match.&nbsp; However, there are places where<br/></li>
<li></span><span class="Comment"> * we haven't cleaned things up completely, and we have to settle for<br/></li>
<li></span><span class="Comment"> * allowing <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> or superset matches.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Var *<br/></li>
<li><a id="L2785">&#x200c;</a><span class="linkable">search_indexed_tlist_for_var</span>(Var *var, <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> newvarno, <span class="Type">int</span> rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L38" title="optimizer/plan/setrefs.c:38">NullingRelsMatch</a> nrm_match)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varno = var-&gt;varno;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; varattno = var-&gt;varattno;<br/></li>
<li>&nbsp; &nbsp; <a href="#L46" title="optimizer/plan/setrefs.c:46">tlist_vinfo</a> *vinfo;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; vinfo = itlist-&gt;<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>;<br/></li>
<li>&nbsp; &nbsp; i = itlist-&gt;num_vars;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (i-- &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vinfo-&gt;varno == varno &amp;&amp; vinfo-&gt;varattno == varattno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found a match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *newvar = <a href="#L1944" title="optimizer/plan/setrefs.c:1944">copyVar</a>(var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Verify that we kept all the nullingrels machinations straight.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> we <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the check for system columns and whole-row Vars.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * That's because such Vars might be row identity Vars, which are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * generated without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> varnullingrels.&nbsp; It'd be hard to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise, since they're normally made very early in planning,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when we haven't looked at the jointree yet and don't know which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * joins might null such Vars.&nbsp; Doesn't seem worth the expense to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * make them fully valid.&nbsp; (While it's slightly annoying that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * thereby lose checking for user-written references to such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * columns, it seems unlikely that a bug in nullingrels logic<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would affect only system columns.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(varattno &lt;= <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (nrm_match == NRM_SUBSET ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(var-&gt;varnullingrels, vinfo-&gt;varnullingrels) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nrm_match == NRM_SUPERSET ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(vinfo-&gt;varnullingrels, var-&gt;varnullingrels) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(vinfo-&gt;varnullingrels, var-&gt;varnullingrels))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;wrong varnullingrels </span><span class="Special">%s</span><span class="Constant"> (expected </span><span class="Special">%s</span><span class="Constant">) for Var </span><span class="Special">%d</span><span class="Constant">/</span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/outfuncs.c.html#L808" title="nodes/outfuncs.c:808">bmsToString</a>(var-&gt;varnullingrels),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/outfuncs.c.html#L808" title="nodes/outfuncs.c:808">bmsToString</a>(vinfo-&gt;varnullingrels),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; varno, varattno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvar-&gt;varno = newvarno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvar-&gt;varattno = vinfo-&gt;resno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newvar-&gt;varnosyn &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvar-&gt;varnosyn += rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> newvar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vinfo++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no match */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2850" title="optimizer/plan/setrefs.c:2850">search_indexed_tlist_for_phv</a> --- <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a PlaceHolderVar in an indexed tlist<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If a match is found, return a Var constructed to reference the tlist item.<br/></li>
<li></span><span class="Comment"> * If no match, return NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Cross-check phnullingrels as in <a href="#L2785" title="optimizer/plan/setrefs.c:2785">search_indexed_tlist_for_var</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: it is a waste of time to call this unless itlist-&gt;has_ph_vars.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Var *<br/></li>
<li><a id="L2850">&#x200c;</a><span class="linkable">search_indexed_tlist_for_phv</span>(PlaceHolderVar *phv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *itlist, <span class="Type">int</span> newvarno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L38" title="optimizer/plan/setrefs.c:38">NullingRelsMatch</a> nrm_match)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, itlist-&gt;tlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;expr &amp;&amp; IsA(tle-&gt;expr, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *subphv = (PlaceHolderVar *) tle-&gt;expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *newvar;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Analogously to <a href="#L2785" title="optimizer/plan/setrefs.c:2785">search_indexed_tlist_for_var</a>, we match on phid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only.&nbsp; We don't use <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(), partially for speed but mostly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because phnullingrels might not be exactly <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (phv-&gt;phid != subphv-&gt;phid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Verify that we kept all the nullingrels machinations straight */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(nrm_match == NRM_SUBSET ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(phv-&gt;phnullingrels, subphv-&gt;phnullingrels) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrm_match == NRM_SUPERSET ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(subphv-&gt;phnullingrels, phv-&gt;phnullingrels) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(subphv-&gt;phnullingrels, phv-&gt;phnullingrels)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;wrong phnullingrels </span><span class="Special">%s</span><span class="Constant"> (expected </span><span class="Special">%s</span><span class="Constant">) for PlaceHolderVar </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/outfuncs.c.html#L808" title="nodes/outfuncs.c:808">bmsToString</a>(phv-&gt;phnullingrels),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/outfuncs.c.html#L808" title="nodes/outfuncs.c:808">bmsToString</a>(subphv-&gt;phnullingrels),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; phv-&gt;phid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found a matching subplan output expression */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvar = <a href="../../nodes/makefuncs.c.html#L105" title="nodes/makefuncs.c:105">makeVarFromTargetEntry</a>(newvarno, tle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvar-&gt;varnosyn = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* wasn't ever a plain Var */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvar-&gt;varattnosyn = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> newvar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no match */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2903" title="optimizer/plan/setrefs.c:2903">search_indexed_tlist_for_non_var</a> --- <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a non-Var/PHV in an indexed tlist<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If a match is found, return a Var constructed to reference the tlist item.<br/></li>
<li></span><span class="Comment"> * If no match, return NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: it is a waste of time to call this unless itlist-&gt;has_non_vars.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Var *<br/></li>
<li><a id="L2903">&#x200c;</a><span class="linkable">search_indexed_tlist_for_non_var</span>(Expr *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *itlist, <span class="Type">int</span> newvarno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TargetEntry *tle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's a simple Const, replacing it with a Var is silly, even if there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happens to be an identical Const below; a Var is more expensive to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * execute than a Const.&nbsp; What's more, replacing it could confuse some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * places in the executor that expect to see simple Consts for, eg,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dropped columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Const))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tle = <a href="../util/tlist.c.html#L79" title="optimizer/util/tlist.c:79">tlist_member</a>(node, itlist-&gt;tlist);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tle)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found a matching subplan output expression */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *newvar;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newvar = <a href="../../nodes/makefuncs.c.html#L105" title="nodes/makefuncs.c:105">makeVarFromTargetEntry</a>(newvarno, tle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newvar-&gt;varnosyn = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* wasn't ever a plain Var */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newvar-&gt;varattnosyn = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> newvar;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no match */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2943" title="optimizer/plan/setrefs.c:2943">search_indexed_tlist_for_sortgroupref</a> --- <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a sort/group expression<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If a match is found, return a Var constructed to reference the tlist item.<br/></li>
<li></span><span class="Comment"> * If no match, return NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is needed to ensure that we <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> the right subplan TLE in cases<br/></li>
<li></span><span class="Comment"> * where there are multiple textually-<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>()-but-volatile sort expressions.<br/></li>
<li></span><span class="Comment"> * And it's also faster than <a href="#L2903" title="optimizer/plan/setrefs.c:2903">search_indexed_tlist_for_non_var</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Var *<br/></li>
<li><a id="L2943">&#x200c;</a><span class="linkable">search_indexed_tlist_for_sortgroupref</span>(Expr *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index sortgroupref,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> newvarno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, itlist-&gt;tlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Usually the <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>() check is redundant, but in setop plans it may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not be, since prepunion.c assigns ressortgroupref <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column resno without regard to whether that matches the topmost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * level's sortgrouprefs and without regard to whether <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> implicit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * coercions are added in the setop tree.&nbsp; We might have to clean that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * up someday; but for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, just ignore <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> false matches.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;ressortgroupref == sortgroupref &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(node, tle-&gt;expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found a matching subplan output expression */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *newvar;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvar = <a href="../../nodes/makefuncs.c.html#L105" title="nodes/makefuncs.c:105">makeVarFromTargetEntry</a>(newvarno, tle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvar-&gt;varnosyn = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* wasn't ever a plain Var */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvar-&gt;varattnosyn = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> newvar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no match */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3021" title="optimizer/plan/setrefs.c:3021">fix_join_expr</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; Create a new set of targetlist entries or join qual clauses by<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; changing the varno/varattno <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of variables in the clauses<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; to reference target list <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> from the outer and inner join<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; relation target lists.&nbsp; Also perform opcode lookup and add<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; regclass OIDs to root-&gt;glob-&gt;relationOids.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used in four different scenarios:<br/></li>
<li></span><span class="Comment"> * 1) a normal join clause, where all the Vars in the clause *must* be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; replaced by OUTER_VAR or INNER_VAR references.&nbsp; In this case<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; acceptable_rel should be zero so that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> failure to match a Var will be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; reported as an error.<br/></li>
<li></span><span class="Comment"> * 2) RETURNING clauses, which may contain both Vars of the target relation<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; and Vars of other relations. In this case we want to replace the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; other-relation Vars by OUTER_VAR references, while leaving target Vars<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; alone. Thus inner_itlist = NULL and acceptable_rel = the ID of the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; target relation should be passed.<br/></li>
<li></span><span class="Comment"> * 3) ON CONFLICT UPDATE <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a>/WHERE clauses.&nbsp; Here references to EXCLUDED are<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; to be replaced with INNER_VAR references, while leaving target Vars (the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; to-be-updated relation) alone. Correspondingly inner_itlist is to be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; EXCLUDED elements, outer_itlist = NULL and acceptable_rel the target<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; relation.<br/></li>
<li></span><span class="Comment"> * 4) MERGE.&nbsp; In this case, references to the source relation are to be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; replaced with INNER_VAR references, leaving Vars of the target<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; relation (the to-be-modified relation) alone.&nbsp; So inner_itlist is to be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the source relation elements, outer_itlist = NULL and acceptable_rel<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the target relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'clauses' is the targetlist or list of join clauses<br/></li>
<li></span><span class="Comment"> * 'outer_itlist' is the indexed target list of the outer join relation,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; or NULL<br/></li>
<li></span><span class="Comment"> * 'inner_itlist' is the indexed target list of the inner join relation,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; or NULL<br/></li>
<li></span><span class="Comment"> * 'acceptable_rel' is either zero or the rangetable index of a relation<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; whose Vars may appear in the clause without provoking an error<br/></li>
<li></span><span class="Comment"> * 'rtoffset': how much to increment varnos by<br/></li>
<li></span><span class="Comment"> * 'nrm_match': as for <a href="#L2785" title="optimizer/plan/setrefs.c:2785">search_indexed_tlist_for_var</a>()<br/></li>
<li></span><span class="Comment"> * 'num_exec': estimated number of executions of expression<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the new expression tree.&nbsp; The original clause structure is<br/></li>
<li></span><span class="Comment"> * not modified.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L3021">&#x200c;</a><span class="linkable">fix_join_expr</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *outer_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *inner_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index acceptable_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L38" title="optimizer/plan/setrefs.c:38">NullingRelsMatch</a> nrm_match,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> num_exec)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L73" title="optimizer/plan/setrefs.c:73">fix_join_expr_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.root = root;<br/></li>
<li>&nbsp; &nbsp; context.outer_itlist = outer_itlist;<br/></li>
<li>&nbsp; &nbsp; context.inner_itlist = inner_itlist;<br/></li>
<li>&nbsp; &nbsp; context.acceptable_rel = acceptable_rel;<br/></li>
<li>&nbsp; &nbsp; context.rtoffset = rtoffset;<br/></li>
<li>&nbsp; &nbsp; context.nrm_match = nrm_match;<br/></li>
<li>&nbsp; &nbsp; context.num_exec = num_exec;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (List *) <a href="#L3043" title="optimizer/plan/setrefs.c:3043">fix_join_expr_mutator</a>((Node *) clauses, &amp;context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Node *<br/></li>
<li><a id="L3043">&#x200c;</a><span class="linkable">fix_join_expr_mutator</span>(Node *node, <a href="#L73" title="optimizer/plan/setrefs.c:73">fix_join_expr_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *newvar;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Look for the var in the input tlists, first in the outer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;outer_itlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvar = <a href="#L2785" title="optimizer/plan/setrefs.c:2785">search_indexed_tlist_for_var</a>(var,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;outer_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OUTER_VAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;nrm_match);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newvar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) newvar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* then in the inner. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;inner_itlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvar = <a href="#L2785" title="optimizer/plan/setrefs.c:2785">search_indexed_tlist_for_var</a>(var,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;inner_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INNER_VAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;nrm_match);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newvar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) newvar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's for acceptable_rel, adjust and return it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varno == context-&gt;acceptable_rel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var = <a href="#L1944" title="optimizer/plan/setrefs.c:1944">copyVar</a>(var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varno += context-&gt;rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varnosyn &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varnosyn += context-&gt;rtoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) var;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No referent found for Var */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;variable not found in subplan target lists&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *phv = (PlaceHolderVar *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See if the PlaceHolderVar has bubbled up from a <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> plan node */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;outer_itlist &amp;&amp; context-&gt;outer_itlist-&gt;has_ph_vars)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvar = <a href="#L2850" title="optimizer/plan/setrefs.c:2850">search_indexed_tlist_for_phv</a>(phv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;outer_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OUTER_VAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;nrm_match);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newvar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) newvar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;inner_itlist &amp;&amp; context-&gt;inner_itlist-&gt;has_ph_vars)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvar = <a href="#L2850" title="optimizer/plan/setrefs.c:2850">search_indexed_tlist_for_phv</a>(phv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;inner_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INNER_VAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;nrm_match);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newvar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) newvar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If not supplied by input plans, evaluate the contained expr */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> can we assert something about phnullingrels? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3043" title="optimizer/plan/setrefs.c:3043">fix_join_expr_mutator</a>((Node *) phv-&gt;phexpr, context);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try matching more complex expressions too, if tlists have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;outer_itlist &amp;&amp; context-&gt;outer_itlist-&gt;has_non_vars)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newvar = <a href="#L2903" title="optimizer/plan/setrefs.c:2903">search_indexed_tlist_for_non_var</a>((Expr *) node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;outer_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OUTER_VAR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newvar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) newvar;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;inner_itlist &amp;&amp; context-&gt;inner_itlist-&gt;has_non_vars)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newvar = <a href="#L2903" title="optimizer/plan/setrefs.c:2903">search_indexed_tlist_for_non_var</a>((Expr *) node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;inner_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INNER_VAR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newvar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) newvar;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Special cases (apply only AFTER failing to match to <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> tlist) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Param))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2061" title="optimizer/plan/setrefs.c:2061">fix_param_node</a>(context-&gt;root, (Param *) node);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, AlternativeSubPlan))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3043" title="optimizer/plan/setrefs.c:3043">fix_join_expr_mutator</a>(<a href="#L2092" title="optimizer/plan/setrefs.c:2092">fix_alternative_subplan</a>(context-&gt;root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (AlternativeSubPlan *) node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context-&gt;num_exec),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1966" title="optimizer/plan/setrefs.c:1966">fix_expr_common</a>(context-&gt;root, node);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_mutator(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L3043" title="optimizer/plan/setrefs.c:3043">fix_join_expr_mutator</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3182" title="optimizer/plan/setrefs.c:3182">fix_upper_expr</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Modifies an expression tree so that all Var nodes reference outputs<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; of a subplan.&nbsp; Also looks for Aggref nodes that should be replaced<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; by initplan output Params.&nbsp; Also performs opcode lookup, and adds<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; regclass OIDs to root-&gt;glob-&gt;relationOids.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used to fix up target and qual expressions of non-join <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level<br/></li>
<li></span><span class="Comment"> * plan nodes, as well as index-only scan nodes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * An error is raised if no matching var can be found in the subplan tlist<br/></li>
<li></span><span class="Comment"> * --- so this routine should only be applied to nodes whose subplans'<br/></li>
<li></span><span class="Comment"> * targetlists were generated by flattening the expressions used in the<br/></li>
<li></span><span class="Comment"> * parent node.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If itlist-&gt;has_non_vars is true, then we try to match whole subexpressions<br/></li>
<li></span><span class="Comment"> * against elements of the subplan tlist, so that we can avoid recomputing<br/></li>
<li></span><span class="Comment"> * expressions that were already computed by the subplan.&nbsp; (This is relatively<br/></li>
<li></span><span class="Comment"> * expensive, so we don't want to try it in the common case where the<br/></li>
<li></span><span class="Comment"> * subplan tlist is just a flattened list of Vars.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'node': the tree to be fixed (a target item or qual)<br/></li>
<li></span><span class="Comment"> * 'subplan_itlist': indexed target list for subplan (or index)<br/></li>
<li></span><span class="Comment"> * 'newvarno': varno to use for Vars referencing tlist elements<br/></li>
<li></span><span class="Comment"> * 'rtoffset': how much to increment varnos by<br/></li>
<li></span><span class="Comment"> * 'nrm_match': as for <a href="#L2785" title="optimizer/plan/setrefs.c:2785">search_indexed_tlist_for_var</a>()<br/></li>
<li></span><span class="Comment"> * 'num_exec': estimated number of executions of expression<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The resulting tree is a copy of the original in which all Var nodes have<br/></li>
<li></span><span class="Comment"> * varno = newvarno, varattno = resno of corresponding targetlist <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.<br/></li>
<li></span><span class="Comment"> * The original tree is not modified.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Node *<br/></li>
<li><a id="L3182">&#x200c;</a><span class="linkable">fix_upper_expr</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *subplan_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> newvarno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L38" title="optimizer/plan/setrefs.c:38">NullingRelsMatch</a> nrm_match,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> num_exec)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L83" title="optimizer/plan/setrefs.c:83">fix_upper_expr_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.root = root;<br/></li>
<li>&nbsp; &nbsp; context.subplan_itlist = subplan_itlist;<br/></li>
<li>&nbsp; &nbsp; context.newvarno = newvarno;<br/></li>
<li>&nbsp; &nbsp; context.rtoffset = rtoffset;<br/></li>
<li>&nbsp; &nbsp; context.nrm_match = nrm_match;<br/></li>
<li>&nbsp; &nbsp; context.num_exec = num_exec;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3202" title="optimizer/plan/setrefs.c:3202">fix_upper_expr_mutator</a>(node, &amp;context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Node *<br/></li>
<li><a id="L3202">&#x200c;</a><span class="linkable">fix_upper_expr_mutator</span>(Node *node, <a href="#L83" title="optimizer/plan/setrefs.c:83">fix_upper_expr_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *newvar;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newvar = <a href="#L2785" title="optimizer/plan/setrefs.c:2785">search_indexed_tlist_for_var</a>(var,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;subplan_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;newvarno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;nrm_match);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!newvar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;variable not found in subplan target list&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) newvar;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *phv = (PlaceHolderVar *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See if the PlaceHolderVar has bubbled up from a <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> plan node */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;subplan_itlist-&gt;has_ph_vars)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvar = <a href="#L2850" title="optimizer/plan/setrefs.c:2850">search_indexed_tlist_for_phv</a>(phv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;subplan_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;newvarno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;nrm_match);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newvar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) newvar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If not supplied by input plan, evaluate the contained expr */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> can we assert something about phnullingrels? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3202" title="optimizer/plan/setrefs.c:3202">fix_upper_expr_mutator</a>((Node *) phv-&gt;phexpr, context);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try matching more complex expressions too, if tlist has <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;subplan_itlist-&gt;has_non_vars)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newvar = <a href="#L2903" title="optimizer/plan/setrefs.c:2903">search_indexed_tlist_for_non_var</a>((Expr *) node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;subplan_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;newvarno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newvar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) newvar;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Special cases (apply only AFTER failing to match to <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> tlist) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Param))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2061" title="optimizer/plan/setrefs.c:2061">fix_param_node</a>(context-&gt;root, (Param *) node);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Aggref))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Aggref&nbsp; &nbsp; &nbsp;&nbsp; *aggref = (Aggref *) node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Param&nbsp; &nbsp; &nbsp;&nbsp; *aggparam;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See if the Aggref should be replaced by a Param */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; aggparam = <a href="#L3427" title="optimizer/plan/setrefs.c:3427">find_minmax_agg_replacement_param</a>(context-&gt;root, aggref);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggparam != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make a copy of the Param for paranoia's sake */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) copyObject(aggparam);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If no match, just fall through to process it normally */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, AlternativeSubPlan))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3202" title="optimizer/plan/setrefs.c:3202">fix_upper_expr_mutator</a>(<a href="#L2092" title="optimizer/plan/setrefs.c:2092">fix_alternative_subplan</a>(context-&gt;root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (AlternativeSubPlan *) node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;num_exec),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1966" title="optimizer/plan/setrefs.c:1966">fix_expr_common</a>(context-&gt;root, node);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_mutator(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L3202" title="optimizer/plan/setrefs.c:3202">fix_upper_expr_mutator</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3305" title="optimizer/plan/setrefs.c:3305">set_returning_clause_references</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Perform setrefs.c's work on a RETURNING targetlist<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the query involves more than just the result table, we have to<br/></li>
<li></span><span class="Comment"> * adjust <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> Vars that refer to other tables to reference junk tlist<br/></li>
<li></span><span class="Comment"> * entries in the top subplan's targetlist.&nbsp; Vars referencing the result<br/></li>
<li></span><span class="Comment"> * table should be left alone, however (the executor will evaluate them<br/></li>
<li></span><span class="Comment"> * using the actual heap tuple, after firing triggers if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>).&nbsp; In the<br/></li>
<li></span><span class="Comment"> * adjusted RETURNING list, result-table Vars will have their original<br/></li>
<li></span><span class="Comment"> * varno (plus rtoffset), but Vars for other rels will have varno OUTER_VAR.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also must perform opcode lookup and add regclass OIDs to<br/></li>
<li></span><span class="Comment"> * root-&gt;glob-&gt;relationOids.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rlist': the RETURNING targetlist to be fixed<br/></li>
<li></span><span class="Comment"> * 'topplan': the top subplan node that will be just below the ModifyTable<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; node (note it's not yet passed through <a href="#L608" title="optimizer/plan/setrefs.c:608">set_plan_refs</a>)<br/></li>
<li></span><span class="Comment"> * 'resultRelation': RT index of the associated result relation<br/></li>
<li></span><span class="Comment"> * 'rtoffset': how much to increment varnos by<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the given 'root' is for the parent query level, not the 'topplan'.<br/></li>
<li></span><span class="Comment"> * This does not matter currently since we only access the dependency-item<br/></li>
<li></span><span class="Comment"> * lists in root-&gt;glob, but it would need some hacking if we wanted a root<br/></li>
<li></span><span class="Comment"> * that actually matches the subplan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: resultRelation is not yet adjusted by rtoffset.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L3305">&#x200c;</a><span class="linkable">set_returning_clause_references</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *rlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Plan *topplan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index resultRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> rtoffset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *itlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can perform the desired Var fixup by abusing the <a href="#L3021" title="optimizer/plan/setrefs.c:3021">fix_join_expr</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * machinery that formerly handled inner indexscan fixup.&nbsp; We search the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * top plan's targetlist for Vars of non-result relations, and use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L3021" title="optimizer/plan/setrefs.c:3021">fix_join_expr</a> to convert RETURNING Vars into references to those tlist<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entries, while leaving result-rel Vars as-is.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PlaceHolderVars will also be sought in the targetlist, but no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more-complex expressions will be.&nbsp; Note that it is not possible for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PlaceHolderVar to refer to the result relation, since the result is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * never below an outer join.&nbsp; If that case could happen, we'd have to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prepared to pick apart the PlaceHolderVar and evaluate its contained<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expression instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; itlist = <a href="#L2727" title="optimizer/plan/setrefs.c:2727">build_tlist_index_other_vars</a>(topplan-&gt;targetlist, resultRelation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rlist = <a href="#L3021" title="optimizer/plan/setrefs.c:3021">fix_join_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NRM_EQUAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L115" title="optimizer/plan/setrefs.c:115">NUM_EXEC_TLIST</a>(topplan));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(itlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rlist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3349" title="optimizer/plan/setrefs.c:3349">fix_windowagg_condition_expr_mutator</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Mutator function for replacing WindowFuncs with the corresponding Var<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; in the targetlist which references that WindowFunc.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Node *<br/></li>
<li><a id="L3349">&#x200c;</a><span class="linkable">fix_windowagg_condition_expr_mutator</span>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L90" title="optimizer/plan/setrefs.c:90">fix_windowagg_cond_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, WindowFunc))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *newvar;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newvar = <a href="#L2903" title="optimizer/plan/setrefs.c:2903">search_indexed_tlist_for_non_var</a>((Expr *) node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;subplan_itlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;newvarno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newvar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) newvar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;WindowFunc not found in subplan target lists&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_mutator(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L3349" title="optimizer/plan/setrefs.c:3349">fix_windowagg_condition_expr_mutator</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3379" title="optimizer/plan/setrefs.c:3379">fix_windowagg_condition_expr</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Converts references in 'runcondition' so that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> WindowFunc<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; references are swapped out for a Var which references the matching<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; WindowFunc in 'subplan_itlist'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L3379">&#x200c;</a><span class="linkable">fix_windowagg_condition_expr</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *runcondition,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *subplan_itlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L90" title="optimizer/plan/setrefs.c:90">fix_windowagg_cond_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.root = root;<br/></li>
<li>&nbsp; &nbsp; context.subplan_itlist = subplan_itlist;<br/></li>
<li>&nbsp; &nbsp; context.newvarno = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (List *) <a href="#L3349" title="optimizer/plan/setrefs.c:3349">fix_windowagg_condition_expr_mutator</a>((Node *) runcondition,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3400" title="optimizer/plan/setrefs.c:3400">set_windowagg_runcondition_references</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Converts references in 'runcondition' so that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> WindowFunc<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; references are swapped out for a Var which references the matching<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; WindowFunc in 'plan' targetlist.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L3400">&#x200c;</a><span class="linkable">set_windowagg_runcondition_references</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *runcondition,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Plan *plan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newlist;<br/></li>
<li>&nbsp; &nbsp; <a href="#L55" title="optimizer/plan/setrefs.c:55">indexed_tlist</a> *itlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; itlist = <a href="#L2676" title="optimizer/plan/setrefs.c:2676">build_tlist_index</a>(plan-&gt;targetlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newlist = <a href="#L3379" title="optimizer/plan/setrefs.c:3379">fix_windowagg_condition_expr</a>(root, runcondition, itlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(itlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newlist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3427" title="optimizer/plan/setrefs.c:3427">find_minmax_agg_replacement_param</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If the given Aggref is one that we are optimizing into a subquery<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (cf. planagg.c), then return the Param that should replace it.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Else return NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is exported so that <a href="subselect.c.html#L2254" title="optimizer/plan/subselect.c:2254">SS_finalize_plan</a> can use it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> setrefs.c runs.<br/></li>
<li></span><span class="Comment"> * Note that it will not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> anything until we have built a Plan from a<br/></li>
<li></span><span class="Comment"> * MinMaxAggPath, as root-&gt;minmax_aggs will never be filled otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Param *<br/></li>
<li><a id="L3427">&#x200c;</a><span class="linkable">find_minmax_agg_replacement_param</span>(PlannerInfo *root, Aggref *aggref)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;minmax_aggs != NIL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; list_length(aggref-&gt;args) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *curTarget = (TargetEntry *) linitial(aggref-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, root-&gt;minmax_aggs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MinMaxAggInfo *mminfo = (MinMaxAggInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mminfo-&gt;aggfnoid == aggref-&gt;aggfnoid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(mminfo-&gt;target, curTarget-&gt;expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> mminfo-&gt;param;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY DEPENDENCY MANAGEMENT<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3460" title="optimizer/plan/setrefs.c:3460">record_plan_function_dependency</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Mark the current plan as depending on a particular function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is exported so that the function-inlining code can record a<br/></li>
<li></span><span class="Comment"> * dependency on a function that it's removed from the plan tree.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3460">&#x200c;</a></span><span class="linkable">record_plan_function_dependency</span>(PlannerInfo *root, Oid funcid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For performance reasons, we don't bother to track built-in <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we just assume they'll never change (or at least not in ways that'd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * invalidate plans using them).&nbsp; For this purpose we can consider a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * built-in function to be one with OID less than FirstUnpinnedObjectId.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that the OID generator guarantees never to generate such an OID<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after startup, even at OID wraparound.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (funcid &gt;= (Oid) FirstUnpinnedObjectId)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlanInvalItem *inval_item = makeNode(PlanInvalItem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It would work to use <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> syscache on pg_proc, but the easiest is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PROCOID since we already have the function's OID at hand.&nbsp; Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that plancache.c knows we use PROCOID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; inval_item-&gt;cacheId = PROCOID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inval_item-&gt;hashValue = GetSysCacheHashValue1(PROCOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(funcid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;glob-&gt;invalItems = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;glob-&gt;invalItems, inval_item);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3500" title="optimizer/plan/setrefs.c:3500">record_plan_type_dependency</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Mark the current plan as depending on a particular type.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is exported so that <a href="../util/clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a> can record a<br/></li>
<li></span><span class="Comment"> * dependency on a domain that it's removed a CoerceToDomain node for.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We don't currently need to record dependencies on domains that the<br/></li>
<li></span><span class="Comment"> * plan contains CoerceToDomain nodes for, though that might change in<br/></li>
<li></span><span class="Comment"> * future.&nbsp; Hence, this isn't actually called in this module, though<br/></li>
<li></span><span class="Comment"> * someday <a href="#L1966" title="optimizer/plan/setrefs.c:1966">fix_expr_common</a> might call it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3500">&#x200c;</a></span><span class="linkable">record_plan_type_dependency</span>(PlannerInfo *root, Oid typid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As in <a href="#L3460" title="optimizer/plan/setrefs.c:3460">record_plan_function_dependency</a>, ignore the possibility that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * someone would change a built-in domain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (typid &gt;= (Oid) FirstUnpinnedObjectId)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlanInvalItem *inval_item = makeNode(PlanInvalItem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It would work to use <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> syscache on pg_type, but the easiest is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * TYPEOID since we already have the type's OID at hand.&nbsp; Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * plancache.c knows we use TYPEOID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; inval_item-&gt;cacheId = TYPEOID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inval_item-&gt;hashValue = GetSysCacheHashValue1(TYPEOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(typid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;glob-&gt;invalItems = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;glob-&gt;invalItems, inval_item);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3541" title="optimizer/plan/setrefs.c:3541">extract_query_dependencies</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given a rewritten, but not yet planned, query or queries<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (i.e. a Query node or list of Query nodes), extract dependencies<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; just as <a href="#L287" title="optimizer/plan/setrefs.c:287">set_plan_references</a> would do.&nbsp; Also detect whether <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; rewrite steps were affected by RLS.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is needed by plancache.c to handle invalidation of cached unplanned<br/></li>
<li></span><span class="Comment"> * queries.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this does not go through <a href="../util/clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a>, and hence doesn't<br/></li>
<li></span><span class="Comment"> * reflect its additions of inlined <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> and elided CoerceToDomain nodes<br/></li>
<li></span><span class="Comment"> * to the invalItems list.&nbsp; This is obviously OK for <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, since we'll<br/></li>
<li></span><span class="Comment"> * see them in the original query tree anyway.&nbsp; For domains, it's OK because<br/></li>
<li></span><span class="Comment"> * we don't care about domains unless they get elided.&nbsp; That is, a plan might<br/></li>
<li></span><span class="Comment"> * have domain dependencies that the query tree doesn't.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3541">&#x200c;</a></span><span class="linkable">extract_query_dependencies</span>(Node *query,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **relationOids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **invalItems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *hasRowSecurity)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlannerGlobal glob;<br/></li>
<li>&nbsp; &nbsp; PlannerInfo root;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make up dummy <a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> state so we can use this module's machinery */<br/></li>
<li></span>&nbsp; &nbsp; MemSet(&amp;glob, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(glob));<br/></li>
<li>&nbsp; &nbsp; glob.type = T_PlannerGlobal;<br/></li>
<li>&nbsp; &nbsp; glob.relationOids = NIL;<br/></li>
<li>&nbsp; &nbsp; glob.invalItems = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Hack: we use glob.dependsOnRole to collect hasRowSecurity flags */<br/></li>
<li></span>&nbsp; &nbsp; glob.dependsOnRole = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemSet(&amp;root, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(root));<br/></li>
<li>&nbsp; &nbsp; root.type = T_PlannerInfo;<br/></li>
<li>&nbsp; &nbsp; root.glob = &amp;glob;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L3577" title="optimizer/plan/setrefs.c:3577">extract_query_dependencies_walker</a>(query, &amp;root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *relationOids = glob.relationOids;<br/></li>
<li>&nbsp; &nbsp; *invalItems = glob.invalItems;<br/></li>
<li>&nbsp; &nbsp; *hasRowSecurity = glob.dependsOnRole;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Tree walker for <a href="#L3541" title="optimizer/plan/setrefs.c:3541">extract_query_dependencies</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is exported so that <a href="planner.c.html#L6484" title="optimizer/plan/planner.c:6484">expression_planner_with_deps</a> can call it on<br/></li>
<li></span><span class="Comment"> * simple expressions (post-planning, not <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> planning, in that case).<br/></li>
<li></span><span class="Comment"> * In that usage, glob.dependsOnRole isn't meaningful, but the relationOids<br/></li>
<li></span><span class="Comment"> * and invalItems lists are added to as needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3577">&#x200c;</a></span><span class="linkable">extract_query_dependencies_walker</span>(Node *node, PlannerInfo *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; Assert(!IsA(node, PlaceHolderVar));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Query))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query = (Query *) node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;commandType == CMD_UTILITY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This logic must handle <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> utility command for which <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * analysis was nontrivial (cf. <a href="../../parser/analyze.c.html#L441" title="parser/analyze.c:441">stmt_requires_parse_analysis</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Notably, CALL requires its own processing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(query-&gt;utilityStmt, CallStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CallStmt&nbsp;&nbsp; *callstmt = (CallStmt *) query-&gt;utilityStmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We need not examine funccall, just the transformed exprs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L3577" title="optimizer/plan/setrefs.c:3577">extract_query_dependencies_walker</a>((Node *) callstmt-&gt;funcexpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L3577" title="optimizer/plan/setrefs.c:3577">extract_query_dependencies_walker</a>((Node *) callstmt-&gt;outargs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore other utility statements, except those (such as EXPLAIN)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that contain a parsed-but-not-planned query.&nbsp; For those, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just need to transfer our attention to the contained query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; query = <a href="../../tcop/utility.c.html#L2176" title="tcop/utility.c:2176">UtilityContainsQuery</a>(query-&gt;utilityStmt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (query == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remember if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> Query has RLS quals applied by rewriter */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;hasRowSecurity)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;glob-&gt;dependsOnRole = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Collect relation OIDs in this Query's rtable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, query-&gt;rtable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = (RangeTblEntry *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind == RTE_RELATION ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (rte-&gt;rtekind == RTE_SUBQUERY &amp;&amp; OidIsValid(rte-&gt;relid)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (rte-&gt;rtekind == RTE_NAMEDTUPLESTORE &amp;&amp; OidIsValid(rte-&gt;relid)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;glob-&gt;relationOids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(context-&gt;glob-&gt;relationOids, rte-&gt;relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And recurse into the query's subexpressions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> query_tree_walker(query, <a href="#L3577" title="optimizer/plan/setrefs.c:3577">extract_query_dependencies_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Extract function dependencies and check for regclass Consts */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1966" title="optimizer/plan/setrefs.c:1966">fix_expr_common</a>(context, node);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L3577" title="optimizer/plan/setrefs.c:3577">extract_query_dependencies_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
