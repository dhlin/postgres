<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>optimizer/plan/planagg.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>optimizer/plan/planagg.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L316">build_minmax_path</a></li>
<li><a href="#L236">can_minmax_aggs</a></li>
<li><a href="#L497">fetch_agg_sort_op</a></li>
<li><a href="#L478">minmax_qp_callback</a></li>
<li><a href="#L72">preprocess_minmax_aggregates</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * planagg.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Special planning for aggregate queries.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This module tries to replace MIN/MAX aggregate <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> by subqueries<br/></li>
<li></span><span class="Comment"> * of the form<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (SELECT col FROM tab<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WHERE col IS NOT NULL AND existing-quals<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ORDER BY col ASC/DESC<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LIMIT 1)<br/></li>
<li></span><span class="Comment"> * Given a suitable index on tab.col, this can be much faster than the<br/></li>
<li></span><span class="Comment"> * generic scan-all-the-rows aggregation plan.&nbsp; We can handle multiple<br/></li>
<li></span><span class="Comment"> * MIN/MAX aggregates by generating multiple subqueries, and their<br/></li>
<li></span><span class="Comment"> * orderings can be different.&nbsp; However, if the query contains <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * non-optimizable aggregates, there's no point since we'll have to<br/></li>
<li></span><span class="Comment"> * scan all the rows anyway.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/optimizer/plan/planagg.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_aggregate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/cost.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/pathnode.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/paths.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/planmain.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/subselect.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/tlist.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_clause.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parsetree.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;rewrite/rewriteManip.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L236" title="optimizer/plan/planagg.c:236">can_minmax_aggs</a>(PlannerInfo *root, List **context);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L316" title="optimizer/plan/planagg.c:316">build_minmax_path</a>(PlannerInfo *root, MinMaxAggInfo *mminfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid eqop, Oid sortop, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nulls_first);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L478" title="optimizer/plan/planagg.c:478">minmax_qp_callback</a>(PlannerInfo *root, <span class="Type">void</span> *extra);<br/></li>
<li><span class="Type">static</span> Oid&nbsp; &nbsp; <a href="#L497" title="optimizer/plan/planagg.c:497">fetch_agg_sort_op</a>(Oid aggfnoid);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L72" title="optimizer/plan/planagg.c:72">preprocess_minmax_aggregates</a> - preprocess MIN/MAX aggregates<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check to see whether the query contains MIN/MAX aggregate <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that<br/></li>
<li></span><span class="Comment"> * might be optimizable via indexscans.&nbsp; If it does, and all the aggregates<br/></li>
<li></span><span class="Comment"> * are potentially optimizable, then create a MinMaxAggPath and add it to<br/></li>
<li></span><span class="Comment"> * the (UPPERREL_GROUP_AGG, NULL) upperrel.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be called by <a href="planner.c.html#L1305" title="optimizer/plan/planner.c:1305">grouping_planner</a>() just <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it's ready to call<br/></li>
<li></span><span class="Comment"> * <a href="planmain.c.html#L54" title="optimizer/plan/planmain.c:54">query_planner</a>(), because we generate indexscan paths by cloning the<br/></li>
<li></span><span class="Comment"> * <a href="planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>'s state and invoking <a href="planmain.c.html#L54" title="optimizer/plan/planmain.c:54">query_planner</a>() on a modified version of<br/></li>
<li></span><span class="Comment"> * the query parsetree.&nbsp; Thus, all preprocessing needed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="planmain.c.html#L54" title="optimizer/plan/planmain.c:54">query_planner</a>()<br/></li>
<li></span><span class="Comment"> * must already be done.&nbsp; This relies on the list of aggregates in<br/></li>
<li></span><span class="Comment"> * root-&gt;agginfos, so <a href="../prep/prepagg.c.html#L110" title="optimizer/prep/prepagg.c:110">preprocess_aggrefs</a>() must have been called already, too.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L72">&#x200c;</a></span><span class="linkable">preprocess_minmax_aggregates</span>(PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; FromExpr&nbsp;&nbsp; *jtnode;<br/></li>
<li>&nbsp; &nbsp; RangeTblRef *rtr;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *aggs_list;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *grouped_rel;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* minmax_aggs list should be empty at this point */<br/></li>
<li></span>&nbsp; &nbsp; Assert(root-&gt;minmax_aggs == NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do if query has no aggregates */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasAggs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;setOperations);&nbsp; &nbsp; <span class="Comment">/* shouldn't get here if a setop */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rowMarks == NIL); <span class="Comment">/* nor if FOR UPDATE */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reject unoptimizable cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't handle GROUP BY or windowing, because our current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * implementations of grouping require looking at all the rows anyway, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so there's not much point in optimizing MIN/MAX.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause || list_length(<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupingSets) &gt; <span class="Constant">1</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasWindowFuncs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reject if query contains <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> CTEs; there's no way to build an indexscan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on one so we couldn't succeed here.&nbsp; (If the CTEs are unreferenced,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that's not true, but it doesn't seem worth expending cycles to check.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;cteList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We also restrict the query to reference exactly one table, since join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conditions can't be handled reasonably.&nbsp; (We could perhaps handle a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * query containing cartesian-product joins, but it hardly seems worth the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trouble.)&nbsp; However, the single table could be buried in several levels<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of FromExpr due to subqueries.&nbsp; Note the &quot;single&quot; table could be an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inheritance parent, too, including the case of a UNION ALL subquery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that's been flattened to an appendrel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; jtnode = <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;jointree;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (IsA(jtnode, FromExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(jtnode-&gt;fromlist) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jtnode = linitial(jtnode-&gt;fromlist);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!IsA(jtnode, RangeTblRef))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; rtr = (RangeTblRef *) jtnode;<br/></li>
<li>&nbsp; &nbsp; rte = planner_rt_fetch(rtr-&gt;rtindex, root);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind == RTE_RELATION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* ordinary relation, ok */</span> ;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rte-&gt;rtekind == RTE_SUBQUERY &amp;&amp; rte-&gt;inh)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* flattened UNION ALL subquery, ok */</span> ;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Examine all the aggregates and verify all are MIN/MAX aggregates.&nbsp; Stop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as soon as we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one that isn't.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; aggs_list = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L236" title="optimizer/plan/planagg.c:236">can_minmax_aggs</a>(root, &amp;aggs_list))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK, there is at least the possibility of performing the optimization.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build an access path for each aggregate.&nbsp; If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the aggregates<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prove to be non-indexable, give up; there is no point in optimizing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just some of them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, aggs_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MinMaxAggInfo *mminfo = (MinMaxAggInfo *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eqop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; reverse;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We'll need the equality operator that goes with the aggregate's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ordering operator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; eqop = <a href="../../utils/cache/lsyscache.c.html#L267" title="utils/cache/lsyscache.c:267">get_equality_op_for_ordering_op</a>(mminfo-&gt;aggsortop, &amp;reverse);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(eqop))&nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> equality operator for ordering operator </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mminfo-&gt;aggsortop);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can use either an ordering that gives NULLS FIRST or one that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * gives NULLS LAST; furthermore there's unlikely to be much<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * performance difference between them, so it doesn't seem worth<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * costing out both ways if we get a hit on the first one.&nbsp; NULLS<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * FIRST is more likely to be available if the operator is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reverse-sort operator, so try that first if reverse.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L316" title="optimizer/plan/planagg.c:316">build_minmax_path</a>(root, mminfo, eqop, mminfo-&gt;aggsortop, reverse))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L316" title="optimizer/plan/planagg.c:316">build_minmax_path</a>(root, mminfo, eqop, mminfo-&gt;aggsortop, !reverse))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No indexable path for this aggregate, so fail */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK, we can do the query this way.&nbsp; Prepare to create a MinMaxAggPath<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, create an output Param node for each agg.&nbsp; (If we end up not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * using the MinMaxAggPath, we'll waste a PARAM_EXEC slot for each agg,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which is not worth worrying about.&nbsp; We can't wait till <a href="createplan.c.html#L337" title="optimizer/plan/createplan.c:337">create_plan</a> time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to decide whether to make the Param, unfortunately.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, aggs_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MinMaxAggInfo *mminfo = (MinMaxAggInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mminfo-&gt;param =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="subselect.c.html#L3001" title="optimizer/plan/subselect.c:3001">SS_make_initplan_output_param</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) mminfo-&gt;target),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) mminfo-&gt;target));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a MinMaxAggPath node with the appropriate estimated costs and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other needed data, and add it to the UPPERREL_GROUP_AGG upperrel, where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it will compete against the standard aggregate implementation.&nbsp; (It<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will likely always win, but we need not assume that here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: <a href="planner.c.html#L1305" title="optimizer/plan/planner.c:1305">grouping_planner</a> won't have created this upperrel yet, but it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fine for us to create it first.&nbsp; We will not have inserted the correct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consider_parallel value in it, but MinMaxAggPath paths are currently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * never parallel-safe anyway, so that doesn't matter.&nbsp; Likewise, it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't matter that we haven't filled FDW-related fields in the rel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, because there are no rowmarks, we know that the processed_tlist<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't need to change anymore, so making the pathtarget <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> is safe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; grouped_rel = <a href="../util/relnode.c.html#L1470" title="optimizer/util/relnode.c:1470">fetch_upper_rel</a>(root, UPPERREL_GROUP_AGG, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(grouped_rel, (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/pathnode.c.html#L3397" title="optimizer/util/pathnode.c:3397">create_minmaxagg_path</a>(root, grouped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; create_pathtarget(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;processed_tlist),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggs_list,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (List *) <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;havingQual));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L236" title="optimizer/plan/planagg.c:236">can_minmax_aggs</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Examine all the aggregates in the query, and check if they are<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; all MIN/MAX aggregates.&nbsp; If so, build a list of MinMaxAggInfo<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; nodes for them.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns false if a non-MIN/MAX aggregate is found, true otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L236">&#x200c;</a></span><span class="linkable">can_minmax_aggs</span>(PlannerInfo *root, List **context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This function used to have to scan the query for itself, but <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just thumb through the AggInfo list made by <a href="../prep/prepagg.c.html#L110" title="optimizer/prep/prepagg.c:110">preprocess_aggrefs</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, root-&gt;agginfos)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AggInfo&nbsp; &nbsp; *agginfo = lfirst_node(AggInfo, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Aggref&nbsp; &nbsp; &nbsp;&nbsp; *aggref = linitial_node(Aggref, agginfo-&gt;aggrefs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggsortop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *curTarget;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MinMaxAggInfo *mminfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(aggref-&gt;agglevelsup == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(aggref-&gt;args) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* it couldn't be MIN/MAX */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ORDER BY is usually irrelevant for MIN/MAX, but it can change the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * outcome if the aggsortop's operator class recognizes non-identical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> as <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>.&nbsp; For example, 4.0 and 4.00 are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> according to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * numeric_ops, yet distinguishable.&nbsp; If MIN() receives more than one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * value <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to 4.0 and no value less than 4.0, it is unspecified<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which of those <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> MIN() returns.&nbsp; An ORDER BY expression<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that differs for each of those <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of the argument<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expression makes the result predictable once again.&nbsp; This is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * niche requirement, and we do not implement it with subquery paths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, this test lets us reject ordered-set aggregates<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * quickly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggref-&gt;aggorder != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* note: we do not care if DISTINCT is mentioned ... */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We might implement the optimization when a FILTER clause is present<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by adding the filter to the quals of the generated subquery.&nbsp; For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, just punt.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggref-&gt;aggfilter != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggsortop = <a href="#L497" title="optimizer/plan/planagg.c:497">fetch_agg_sort_op</a>(aggref-&gt;aggfnoid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(aggsortop))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not a MIN/MAX aggregate */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; curTarget = (TargetEntry *) linitial(aggref-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/clauses.c.html#L370" title="optimizer/util/clauses.c:370">contain_mutable_functions</a>((Node *) curTarget-&gt;expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not potentially indexable */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/cache/lsyscache.c.html#L2655" title="utils/cache/lsyscache.c:2655">type_is_rowtype</a>(<a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) curTarget-&gt;expr)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* IS NOT NULL would have weird semantics */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mminfo = makeNode(MinMaxAggInfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mminfo-&gt;aggfnoid = aggref-&gt;aggfnoid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mminfo-&gt;aggsortop = aggsortop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mminfo-&gt;target = curTarget-&gt;expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mminfo-&gt;subroot = <span class="Constant">NULL</span>; <span class="Comment">/* don't compute path yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mminfo-&gt;path = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mminfo-&gt;pathcost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mminfo-&gt;param = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *context = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(*context, mminfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L316" title="optimizer/plan/planagg.c:316">build_minmax_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given a MIN/MAX aggregate, try to build an indexscan Path it can be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; optimized with.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If successful, stash the best path in *mminfo and return true.<br/></li>
<li></span><span class="Comment"> * Otherwise, return false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L316">&#x200c;</a></span><span class="linkable">build_minmax_path</span>(PlannerInfo *root, MinMaxAggInfo *mminfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid eqop, Oid sortop, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nulls_first)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *subroot;<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; TargetEntry *tle;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist;<br/></li>
<li>&nbsp; &nbsp; NullTest&nbsp;&nbsp; *ntest;<br/></li>
<li>&nbsp; &nbsp; SortGroupClause *sortcl;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *final_rel;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *sorted_path;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; path_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; path_fraction;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We are going to construct what is effectively a sub-SELECT query, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clone the current query level's state and adjust it to make it look<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * like a subquery.&nbsp; Any outer references will <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> be one level higher<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>.&nbsp; (This means that when we are done, there will be no Vars<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of level 1, which is why the subquery can become an initplan.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; subroot = (PlannerInfo *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PlannerInfo));<br/></li>
<li>&nbsp; &nbsp; memcpy(subroot, root, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PlannerInfo));<br/></li>
<li>&nbsp; &nbsp; subroot-&gt;query_level++;<br/></li>
<li>&nbsp; &nbsp; subroot-&gt;parent_root = root;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* reset subplan-related stuff */<br/></li>
<li></span>&nbsp; &nbsp; subroot-&gt;plan_params = NIL;<br/></li>
<li>&nbsp; &nbsp; subroot-&gt;outer_params = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; subroot-&gt;init_plans = NIL;<br/></li>
<li>&nbsp; &nbsp; subroot-&gt;agginfos = NIL;<br/></li>
<li>&nbsp; &nbsp; subroot-&gt;aggtransinfos = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; subroot-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = copyObject(root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../rewrite/rewriteManip.c.html#L849" title="rewrite/rewriteManip.c:849">IncrementVarSublevelsUp</a>((Node *) <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>, <span class="Constant">1</span>, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* append_rel_list might contain outer Vars? */<br/></li>
<li></span>&nbsp; &nbsp; subroot-&gt;append_rel_list = copyObject(root-&gt;append_rel_list);<br/></li>
<li>&nbsp; &nbsp; <a href="../../rewrite/rewriteManip.c.html#L849" title="rewrite/rewriteManip.c:849">IncrementVarSublevelsUp</a>((Node *) subroot-&gt;append_rel_list, <span class="Constant">1</span>, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* There shouldn't be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> OJ info to <a href="../../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a>, as yet */<br/></li>
<li></span>&nbsp; &nbsp; Assert(subroot-&gt;join_info_list == NIL);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and we haven't made equivalence classes, either */<br/></li>
<li></span>&nbsp; &nbsp; Assert(subroot-&gt;eq_classes == NIL);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and we haven't created PlaceHolderInfos, either */<br/></li>
<li></span>&nbsp; &nbsp; Assert(subroot-&gt;placeholder_list == NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate modified query of the form<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; (SELECT col FROM tab<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WHERE col IS NOT NULL AND existing-quals<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ORDER BY col ASC/DESC<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LIMIT 1)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* single tlist entry that is the aggregate target */<br/></li>
<li></span>&nbsp; &nbsp; tle = <a href="../../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>(copyObject(mminfo-&gt;target),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (AttrNumber) <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;agg_target&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; tlist = list_make1(tle);<br/></li>
<li>&nbsp; &nbsp; subroot-&gt;processed_tlist = <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;targetList = tlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No HAVING, no DISTINCT, no aggregates anymore */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;havingQual = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; subroot-&gt;hasHavingQual = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;distinctClause = NIL;<br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasDistinctOn = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasAggs = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build &quot;target IS NOT NULL&quot; expression */<br/></li>
<li></span>&nbsp; &nbsp; ntest = makeNode(NullTest);<br/></li>
<li>&nbsp; &nbsp; ntest-&gt;nulltesttype = IS_NOT_NULL;<br/></li>
<li>&nbsp; &nbsp; ntest-&gt;arg = copyObject(mminfo-&gt;target);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we checked it wasn't a rowtype in <a href="#L236" title="optimizer/plan/planagg.c:236">can_minmax_aggs</a> */<br/></li>
<li></span>&nbsp; &nbsp; ntest-&gt;argisrow = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ntest-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* User might have had that in WHERE already */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/list.c.html#L661" title="nodes/list.c:661">list_member</a>((List *) <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;jointree-&gt;quals, ntest))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;jointree-&gt;quals = (Node *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(ntest, (List *) <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;jointree-&gt;quals);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build suitable ORDER BY clause */<br/></li>
<li></span>&nbsp; &nbsp; sortcl = makeNode(SortGroupClause);<br/></li>
<li>&nbsp; &nbsp; sortcl-&gt;tleSortGroupRef = <a href="../../parser/parse_clause.c.html#L3592" title="parser/parse_clause.c:3592">assignSortGroupRef</a>(tle, subroot-&gt;processed_tlist);<br/></li>
<li>&nbsp; &nbsp; sortcl-&gt;eqop = eqop;<br/></li>
<li>&nbsp; &nbsp; sortcl-&gt;sortop = sortop;<br/></li>
<li>&nbsp; &nbsp; sortcl-&gt;nulls_first = nulls_first;<br/></li>
<li>&nbsp; &nbsp; sortcl-&gt;hashable = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* no need to make this accurate */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;sortClause = list_make1(sortcl);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set up expressions for LIMIT 1 */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;limitOffset = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;limitCount = (Node *) <a href="../../nodes/makefuncs.c.html#L301" title="nodes/makefuncs.c:301">makeConst</a>(INT8OID, -<span class="Constant">1</span>, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(<span class="Constant">1</span>), <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FLOAT8PASSBYVAL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate the best paths for this query, telling <a href="planmain.c.html#L54" title="optimizer/plan/planmain.c:54">query_planner</a> that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have LIMIT 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; subroot-&gt;tuple_fraction = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; subroot-&gt;limit_tuples = <span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; final_rel = <a href="planmain.c.html#L54" title="optimizer/plan/planmain.c:54">query_planner</a>(subroot, <a href="#L478" title="optimizer/plan/planagg.c:478">minmax_qp_callback</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we didn't go through <a href="planner.c.html#L628" title="optimizer/plan/planner.c:628">subquery_planner</a>() to handle the subquery,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we have to do some of the same <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> it would do, in particular cope<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with params and initplans used within this subquery.&nbsp; (This won't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * matter if we end up not using the subplan.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="subselect.c.html#L2072" title="optimizer/plan/subselect.c:2072">SS_identify_outer_params</a>(subroot);<br/></li>
<li>&nbsp; &nbsp; <a href="subselect.c.html#L2134" title="optimizer/plan/subselect.c:2134">SS_charge_for_initplans</a>(subroot, final_rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the best presorted path, that being the one that's cheapest for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fetching just one row.&nbsp; If there's no such path, fail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (final_rel-&gt;rows &gt; <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path_fraction = <span class="Constant">1.0</span> / final_rel-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; path_fraction = <span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sorted_path =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/pathkeys.c.html#L681" title="optimizer/path/pathkeys.c:681">get_cheapest_fractional_path_for_pathkeys</a>(final_rel-&gt;pathlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subroot-&gt;query_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path_fraction);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!sorted_path)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The path might not return exactly what we want, so fix that.&nbsp; (We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assume that this won't change <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> conclusions about which was the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cheapest path.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sorted_path = <a href="../util/pathnode.c.html#L2793" title="optimizer/util/pathnode.c:2793">apply_projection_to_path</a>(subroot, final_rel, sorted_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; create_pathtarget(subroot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subroot-&gt;processed_tlist));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine cost to get just the first row of the presorted path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: cost calculation here should match<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../util/pathnode.c.html#L115" title="optimizer/util/pathnode.c:115">compare_fractional_path_costs</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; path_cost = sorted_path-&gt;startup_cost +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path_fraction * (sorted_path-&gt;total_cost - sorted_path-&gt;startup_cost);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save state for further processing */<br/></li>
<li></span>&nbsp; &nbsp; mminfo-&gt;subroot = subroot;<br/></li>
<li>&nbsp; &nbsp; mminfo-&gt;path = sorted_path;<br/></li>
<li>&nbsp; &nbsp; mminfo-&gt;pathcost = path_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute query_pathkeys and other pathkeys during <a href="planmain.c.html#L54" title="optimizer/plan/planmain.c:54">query_planner</a>()<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L478">&#x200c;</a></span><span class="linkable">minmax_qp_callback</span>(PlannerInfo *root, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; root-&gt;group_pathkeys = NIL;<br/></li>
<li>&nbsp; &nbsp; root-&gt;window_pathkeys = NIL;<br/></li>
<li>&nbsp; &nbsp; root-&gt;distinct_pathkeys = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; root-&gt;sort_pathkeys =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/pathkeys.c.html#L1347" title="optimizer/path/pathkeys.c:1347">make_pathkeys_for_sortclauses</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;sortClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;targetList);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; root-&gt;query_pathkeys = root-&gt;sort_pathkeys;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the OID of the sort operator, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, associated with an aggregate.<br/></li>
<li></span><span class="Comment"> * Returns InvalidOid if there is no such operator.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Oid<br/></li>
<li><a id="L497">&#x200c;</a><span class="linkable">fetch_agg_sort_op</span>(Oid aggfnoid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; aggTuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_aggregate aggform;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggsortop;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fetch aggregate entry from pg_aggregate */<br/></li>
<li></span>&nbsp; &nbsp; aggTuple = <a href="../../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(AGGFNOID, ObjectIdGetDatum(aggfnoid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(aggTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>&nbsp; &nbsp; aggform = (Form_pg_aggregate) GETSTRUCT(aggTuple);<br/></li>
<li>&nbsp; &nbsp; aggsortop = aggform-&gt;aggsortop;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(aggTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> aggsortop;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
