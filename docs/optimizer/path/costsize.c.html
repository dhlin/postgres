<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>optimizer/path/costsize.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>optimizer/path/costsize.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L122">cpu_index_tuple_cost</a></li>
<li><a href="#L123">cpu_operator_cost</a></li>
<li><a href="#L121">cpu_tuple_cost</a></li>
<li><a href="#L130">disable_cost</a></li>
<li><a href="#L128">effective_cache_size</a></li>
<li><a href="#L154">enable_async_append</a></li>
<li><a href="#L137">enable_bitmapscan</a></li>
<li><a href="#L147">enable_gathermerge</a></li>
<li><a href="#L141">enable_hashagg</a></li>
<li><a href="#L146">enable_hashjoin</a></li>
<li><a href="#L140">enable_incremental_sort</a></li>
<li><a href="#L136">enable_indexonlyscan</a></li>
<li><a href="#L135">enable_indexscan</a></li>
<li><a href="#L143">enable_material</a></li>
<li><a href="#L144">enable_memoize</a></li>
<li><a href="#L145">enable_mergejoin</a></li>
<li><a href="#L142">enable_nestloop</a></li>
<li><a href="#L150">enable_parallel_append</a></li>
<li><a href="#L151">enable_parallel_hash</a></li>
<li><a href="#L152">enable_partition_pruning</a></li>
<li><a href="#L149">enable_partitionwise_aggregate</a></li>
<li><a href="#L148">enable_partitionwise_join</a></li>
<li><a href="#L153">enable_presorted_aggregate</a></li>
<li><a href="#L134">enable_seqscan</a></li>
<li><a href="#L139">enable_sort</a></li>
<li><a href="#L138">enable_tidscan</a></li>
<li><a href="#L132">max_parallel_workers_per_gather</a></li>
<li><a href="#L125">parallel_setup_cost</a></li>
<li><a href="#L124">parallel_tuple_cost</a></li>
<li><a href="#L120">random_page_cost</a></li>
<li><a href="#L126">recursive_worktable_factor</a></li>
<li><a href="#L119">seq_page_cost</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L160">cost_qual_eval_context</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L2155">append_nonpartial_cost</a></li>
<li><a href="#L5194">approx_tuple_count</a></li>
<li><a href="#L3994">cached_scansel</a></li>
<li><a href="#L5391">calc_joinrel_size_estimate</a></li>
<li><a href="#L254">clamp_cardinality_to_long</a></li>
<li><a href="#L202">clamp_row_est</a></li>
<li><a href="#L231">clamp_width_est</a></li>
<li><a href="#L6403">compute_bitmap_pages</a></li>
<li><a href="#L5004">compute_semi_anti_join_factors</a></li>
<li><a href="#L2650">cost_agg</a></li>
<li><a href="#L2231">cost_append</a></li>
<li><a href="#L1157">cost_bitmap_and_node</a></li>
<li><a href="#L1013">cost_bitmap_heap_scan</a></li>
<li><a href="#L1201">cost_bitmap_or_node</a></li>
<li><a href="#L1114">cost_bitmap_tree_node</a></li>
<li><a href="#L1698">cost_ctescan</a></li>
<li><a href="#L1531">cost_functionscan</a></li>
<li><a href="#L436">cost_gather</a></li>
<li><a href="#L474">cost_gather_merge</a></li>
<li><a href="#L3163">cost_group</a></li>
<li><a href="#L1986">cost_incremental_sort</a></li>
<li><a href="#L549">cost_index</a></li>
<li><a href="#L2453">cost_material</a></li>
<li><a href="#L2509">cost_memoize_rescan</a></li>
<li><a href="#L2404">cost_merge_append</a></li>
<li><a href="#L1739">cost_namedtuplestorescan</a></li>
<li><a href="#L4640">cost_qual_eval</a></li>
<li><a href="#L4666">cost_qual_eval_node</a></li>
<li><a href="#L4680">cost_qual_eval_walker</a></li>
<li><a href="#L1813">cost_recursive_union</a></li>
<li><a href="#L4528">cost_rescan</a></li>
<li><a href="#L1776">cost_resultscan</a></li>
<li><a href="#L361">cost_samplescan</a></li>
<li><a href="#L284">cost_seqscan</a></li>
<li><a href="#L2124">cost_sort</a></li>
<li><a href="#L4435">cost_subplan</a></li>
<li><a href="#L1451">cost_subqueryscan</a></li>
<li><a href="#L1592">cost_tablefuncscan</a></li>
<li><a href="#L1357">cost_tidrangescan</a></li>
<li><a href="#L1249">cost_tidscan</a></li>
<li><a href="#L1884">cost_tuplesort</a></li>
<li><a href="#L1648">cost_valuesscan</a></li>
<li><a href="#L3068">cost_windowagg</a></li>
<li><a href="#L840">extract_nonindex_conditions</a></li>
<li><a href="#L4181">final_cost_hashjoin</a></li>
<li><a href="#L3745">final_cost_mergejoin</a></li>
<li><a href="#L3308">final_cost_nestloop</a></li>
<li><a href="#L6294">get_expr_width</a></li>
<li><a href="#L5541">get_foreign_key_join_selectivity</a></li>
<li><a href="#L963">get_indexpath_pages</a></li>
<li><a href="#L6363">get_parallel_divisor</a></li>
<li><a href="#L5269">get_parameterized_baserel_size</a></li>
<li><a href="#L5350">get_parameterized_joinrel_size</a></li>
<li><a href="#L4962">get_restriction_qual_cost</a></li>
<li><a href="#L2854">get_windowclause_startup_tuples</a></li>
<li><a href="#L5101">has_indexed_join_quals</a></li>
<li><a href="#L898">index_pages_fetched</a></li>
<li><a href="#L4073">initial_cost_hashjoin</a></li>
<li><a href="#L3514">initial_cost_mergejoin</a></li>
<li><a href="#L3233">initial_cost_nestloop</a></li>
<li><a href="#L6353">page_size</a></li>
<li><a href="#L6342">relation_byte_size</a></li>
<li><a href="#L5239">set_baserel_size_estimates</a></li>
<li><a href="#L5964">set_cte_size_estimates</a></li>
<li><a href="#L6064">set_foreign_size_estimates</a></li>
<li><a href="#L5872">set_function_size_estimates</a></li>
<li><a href="#L5318">set_joinrel_size_estimates</a></li>
<li><a href="#L6002">set_namedtuplestore_size_estimates</a></li>
<li><a href="#L6256">set_pathtarget_cost_width</a></li>
<li><a href="#L6099">set_rel_width</a></li>
<li><a href="#L6035">set_result_size_estimates</a></li>
<li><a href="#L5792">set_subquery_size_estimates</a></li>
<li><a href="#L5910">set_tablefunc_size_estimates</a></li>
<li><a href="#L5932">set_values_size_estimates</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L109">APPEND_CPU_COST_MULTIPLIER</a></li>
<li><a href="#L102">LOG2</a></li>
<li><a href="#L117">MAXIMUM_ROWCOUNT</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * costsize.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Routines to compute (and set) relation sizes and path costs<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Path costs are measured in arbitrary units established by these basic<br/></li>
<li></span><span class="Comment"> * parameters:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L119" title="optimizer/path/costsize.c:119">seq_page_cost</a>&nbsp; &nbsp; &nbsp; &nbsp; Cost of a sequential page fetch<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L120" title="optimizer/path/costsize.c:120">random_page_cost</a>&nbsp; &nbsp; Cost of a non-sequential page fetch<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a>&nbsp; &nbsp; &nbsp; &nbsp; Cost of typical CPU time to process a tuple<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L122" title="optimizer/path/costsize.c:122">cpu_index_tuple_cost</a>&nbsp; Cost of typical CPU time to process an index tuple<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>&nbsp; &nbsp; Cost of CPU time to execute an operator or function<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L124" title="optimizer/path/costsize.c:124">parallel_tuple_cost</a> Cost of CPU time to pass a tuple from worker to leader backend<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L125" title="optimizer/path/costsize.c:125">parallel_setup_cost</a> Cost of setting up shared memory for parallelism<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We expect that the kernel will typically do some amount of read-ahead<br/></li>
<li></span><span class="Comment"> * optimization; this in conjunction with seek costs means that <a href="#L119" title="optimizer/path/costsize.c:119">seq_page_cost</a><br/></li>
<li></span><span class="Comment"> * is normally considerably less than <a href="#L120" title="optimizer/path/costsize.c:120">random_page_cost</a>.&nbsp; (However, if the<br/></li>
<li></span><span class="Comment"> * database is fully cached in RAM, it is reasonable to set them <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also use a rough estimate &quot;<a href="#L128" title="optimizer/path/costsize.c:128">effective_cache_size</a>&quot; of the number of<br/></li>
<li></span><span class="Comment"> * disk pages in Postgres + OS-level disk cache.&nbsp; (We can't simply use<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a> for this purpose because that would ignore the effects of<br/></li>
<li></span><span class="Comment"> * the kernel's disk cache.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Obviously, taking constants for these <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> is an oversimplification,<br/></li>
<li></span><span class="Comment"> * but it's tough enough to get <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> useful estimates even at this level of<br/></li>
<li></span><span class="Comment"> * detail.&nbsp; Note that all of these parameters are user-settable, in case<br/></li>
<li></span><span class="Comment"> * the default <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are drastically off for a particular platform.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L119" title="optimizer/path/costsize.c:119">seq_page_cost</a> and <a href="#L120" title="optimizer/path/costsize.c:120">random_page_cost</a> can also be overridden for an individual<br/></li>
<li></span><span class="Comment"> * tablespace, in case some data is on a fast disk and other data is on a slow<br/></li>
<li></span><span class="Comment"> * disk.&nbsp; Per-tablespace overrides never apply to temporary work files such as<br/></li>
<li></span><span class="Comment"> * an external sort or a materialize node that overflows <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We compute two separate costs for each path:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; total_cost: total estimated cost to fetch all tuples<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; startup_cost: cost that is expended <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> first tuple is fetched<br/></li>
<li></span><span class="Comment"> * In some scenarios, such as when there is a LIMIT or we are implementing<br/></li>
<li></span><span class="Comment"> * an EXISTS(...) sub-<a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a>, it is not necessary to fetch all tuples of the<br/></li>
<li></span><span class="Comment"> * path's result.&nbsp; A caller can estimate the cost of fetching a partial<br/></li>
<li></span><span class="Comment"> * result by interpolating between startup_cost and total_cost.&nbsp; In detail:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; actual_cost = startup_cost +<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (total_cost - startup_cost) * tuples_to_fetch / path-&gt;rows;<br/></li>
<li></span><span class="Comment"> * Note that a base relation's rows count (and, by extension, plan_rows for<br/></li>
<li></span><span class="Comment"> * plan nodes below the LIMIT node) are set without regard to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> LIMIT, so<br/></li>
<li></span><span class="Comment"> * that this equation works properly.&nbsp; (Note: while path-&gt;rows is never zero<br/></li>
<li></span><span class="Comment"> * for ordinary relations, it is zero for paths for provably-empty relations,<br/></li>
<li></span><span class="Comment"> * so beware of division-by-zero.)&nbsp; &nbsp; The LIMIT is applied as a top-level<br/></li>
<li></span><span class="Comment"> * plan node.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For largely historical reasons, most of the routines in this module use<br/></li>
<li></span><span class="Comment"> * the passed result Path only to store their results (rows, startup_cost and<br/></li>
<li></span><span class="Comment"> * total_cost) into.&nbsp; All the input data they need is passed as separate<br/></li>
<li></span><span class="Comment"> * parameters, even though much of it could be extracted from the Path.<br/></li>
<li></span><span class="Comment"> * An exception is made for the cost_XXXjoin() routines, which expect all<br/></li>
<li></span><span class="Comment"> * the other fields of the passed XXXPath to be filled in, and similarly<br/></li>
<li></span><span class="Comment"> * <a href="#L549" title="optimizer/path/costsize.c:549">cost_index</a>() assumes the passed IndexPath is valid except for its output<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/optimizer/path/costsize.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/amapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tsmapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeAgg.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeHash.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeMemoize.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/clauses.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/cost.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/pathnode.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/paths.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/placeholder.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/plancat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/restrictinfo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parsetree.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/selfuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/spccache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/tuplesort.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L102">&#x200c;</a><span class="PreProc">#define <span class="linkable">LOG2</span>(x)&nbsp; (log(x) / </span><span class="Constant">0.693147180559945</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Append and MergeAppend nodes are less expensive than some other operations<br/></li>
<li></span><span class="Comment"> * which use <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a>; instead of adding a separate GUC, estimate the<br/></li>
<li></span><span class="Comment"> * per-tuple cost as <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> multiplied by this value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L109">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">APPEND_CPU_COST_MULTIPLIER</span> </span><span class="Constant">0.5<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Maximum value for row estimates.&nbsp; We cap row estimates to this to <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a><br/></li>
<li></span><span class="Comment"> * ensure that costs based on these estimates remain within the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of what<br/></li>
<li></span><span class="Comment"> * double can represent.&nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>() wouldn't act sanely given infinite or NaN<br/></li>
<li></span><span class="Comment"> * cost <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L117">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAXIMUM_ROWCOUNT</span> </span><span class="Constant">1e100<br/></li>
<li></span><br/></li>
<li><a id="L119">&#x200c;</a><span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">seq_page_cost</span> = DEFAULT_SEQ_PAGE_COST;<br/></li>
<li><a id="L120">&#x200c;</a><span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">random_page_cost</span> = DEFAULT_RANDOM_PAGE_COST;<br/></li>
<li><a id="L121">&#x200c;</a><span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">cpu_tuple_cost</span> = DEFAULT_CPU_TUPLE_COST;<br/></li>
<li><a id="L122">&#x200c;</a><span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">cpu_index_tuple_cost</span> = DEFAULT_CPU_INDEX_TUPLE_COST;<br/></li>
<li><a id="L123">&#x200c;</a><span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">cpu_operator_cost</span> = DEFAULT_CPU_OPERATOR_COST;<br/></li>
<li><a id="L124">&#x200c;</a><span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">parallel_tuple_cost</span> = DEFAULT_PARALLEL_TUPLE_COST;<br/></li>
<li><a id="L125">&#x200c;</a><span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">parallel_setup_cost</span> = DEFAULT_PARALLEL_SETUP_COST;<br/></li>
<li><a id="L126">&#x200c;</a><span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">recursive_worktable_factor</span> = DEFAULT_RECURSIVE_WORKTABLE_FACTOR;<br/></li>
<li><br/></li>
<li><a id="L128">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">effective_cache_size</span> = DEFAULT_EFFECTIVE_CACHE_SIZE;<br/></li>
<li><br/></li>
<li><a id="L130">&#x200c;</a>Cost&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">disable_cost</span> = <span class="Constant">1.0e10</span>;<br/></li>
<li><br/></li>
<li><a id="L132">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">max_parallel_workers_per_gather</span> = <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li><a id="L134">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">enable_seqscan</span> = <span class="Constant">true</span>;<br/></li>
<li><a id="L135">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">enable_indexscan</span> = <span class="Constant">true</span>;<br/></li>
<li><a id="L136">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">enable_indexonlyscan</span> = <span class="Constant">true</span>;<br/></li>
<li><a id="L137">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">enable_bitmapscan</span> = <span class="Constant">true</span>;<br/></li>
<li><a id="L138">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">enable_tidscan</span> = <span class="Constant">true</span>;<br/></li>
<li><a id="L139">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">enable_sort</span> = <span class="Constant">true</span>;<br/></li>
<li><a id="L140">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">enable_incremental_sort</span> = <span class="Constant">true</span>;<br/></li>
<li><a id="L141">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">enable_hashagg</span> = <span class="Constant">true</span>;<br/></li>
<li><a id="L142">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">enable_nestloop</span> = <span class="Constant">true</span>;<br/></li>
<li><a id="L143">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">enable_material</span> = <span class="Constant">true</span>;<br/></li>
<li><a id="L144">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">enable_memoize</span> = <span class="Constant">true</span>;<br/></li>
<li><a id="L145">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">enable_mergejoin</span> = <span class="Constant">true</span>;<br/></li>
<li><a id="L146">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">enable_hashjoin</span> = <span class="Constant">true</span>;<br/></li>
<li><a id="L147">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">enable_gathermerge</span> = <span class="Constant">true</span>;<br/></li>
<li><a id="L148">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">enable_partitionwise_join</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L149">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">enable_partitionwise_aggregate</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L150">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">enable_parallel_append</span> = <span class="Constant">true</span>;<br/></li>
<li><a id="L151">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">enable_parallel_hash</span> = <span class="Constant">true</span>;<br/></li>
<li><a id="L152">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">enable_partition_pruning</span> = <span class="Constant">true</span>;<br/></li>
<li><a id="L153">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">enable_presorted_aggregate</span> = <span class="Constant">true</span>;<br/></li>
<li><a id="L154">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">enable_async_append</span> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *root;<br/></li>
<li>&nbsp; &nbsp; QualCost&nbsp; &nbsp; total;<br/></li>
<li><a id="L160">&#x200c;</a>} <span class="linkable">cost_qual_eval_context</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> List *<a href="#L840" title="optimizer/path/costsize.c:840">extract_nonindex_conditions</a>(List *qual_clauses, List *indexclauses);<br/></li>
<li><span class="Type">static</span> MergeScanSelCache *<a href="#L3994" title="optimizer/path/costsize.c:3994">cached_scansel</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RestrictInfo *rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PathKey *pathkey);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4528" title="optimizer/path/costsize.c:4528">cost_rescan</a>(PlannerInfo *root, Path *path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cost *rescan_startup_cost, Cost *rescan_total_cost);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L4680" title="optimizer/path/costsize.c:4680">cost_qual_eval_walker</a>(Node *node, <a href="#L160" title="optimizer/path/costsize.c:160">cost_qual_eval_context</a> *context);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4962" title="optimizer/path/costsize.c:4962">get_restriction_qual_cost</a>(PlannerInfo *root, RelOptInfo *baserel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ParamPathInfo *param_info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QualCost *qpqual_cost);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L5101" title="optimizer/path/costsize.c:5101">has_indexed_join_quals</a>(NestPath *path);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L5194" title="optimizer/path/costsize.c:5194">approx_tuple_count</a>(PlannerInfo *root, JoinPath *path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *quals);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L5391" title="optimizer/path/costsize.c:5391">calc_joinrel_size_estimate</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *outer_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *inner_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> outer_rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> inner_rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SpecialJoinInfo *sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *restrictlist);<br/></li>
<li><span class="Type">static</span> Selectivity <a href="#L5541" title="optimizer/path/costsize.c:5541">get_foreign_key_join_selectivity</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids outer_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids inner_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpecialJoinInfo *sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **restrictlist);<br/></li>
<li><span class="Type">static</span> Cost <a href="#L2155" title="optimizer/path/costsize.c:2155">append_nonpartial_cost</a>(List *subpaths, <span class="Type">int</span> numpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> parallel_workers);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L6099" title="optimizer/path/costsize.c:6099">set_rel_width</a>(PlannerInfo *root, RelOptInfo *rel);<br/></li>
<li><span class="Type">static</span> int32 <a href="#L6294" title="optimizer/path/costsize.c:6294">get_expr_width</a>(PlannerInfo *root, <span class="Type">const</span> Node *expr);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L6342" title="optimizer/path/costsize.c:6342">relation_byte_size</a>(<span class="Type">double</span> tuples, <span class="Type">int</span> width);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L6353" title="optimizer/path/costsize.c:6353">page_size</a>(<span class="Type">double</span> tuples, <span class="Type">int</span> width);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L6363" title="optimizer/path/costsize.c:6363">get_parallel_divisor</a>(Path *path);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Force a row-count estimate to a sane value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">double<br/></li>
<li><a id="L202">&#x200c;</a></span><span class="linkable">clamp_row_est</span>(<span class="Type">double</span> nrows)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Avoid infinite and NaN row estimates.&nbsp; Costs derived from such <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are going to be useless.&nbsp; Also force the estimate to be at least one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * row, to make explain output look better and to avoid possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * divide-by-zero when interpolating costs.&nbsp; Make it an integer, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nrows &gt; <a href="#L117" title="optimizer/path/costsize.c:117">MAXIMUM_ROWCOUNT</a> || isnan(nrows))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nrows = <a href="#L117" title="optimizer/path/costsize.c:117">MAXIMUM_ROWCOUNT</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (nrows &lt;= <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nrows = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nrows = rint(nrows);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nrows;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L231" title="optimizer/path/costsize.c:231">clamp_width_est</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Force a tuple-width estimate to a sane value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="../plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> represents datatype width and tuple width estimates as int32.<br/></li>
<li></span><span class="Comment"> * When summing column width estimates to create a tuple width estimate,<br/></li>
<li></span><span class="Comment"> * it's possible to reach integer overflow in edge cases.&nbsp; To ensure sane<br/></li>
<li></span><span class="Comment"> * behavior, we form such sums in int64 arithmetic and then apply this routine<br/></li>
<li></span><span class="Comment"> * to clamp to int32 <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>int32<br/></li>
<li><a id="L231">&#x200c;</a><span class="linkable">clamp_width_est</span>(int64 tuple_width)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Anything more than MaxAllocSize is clearly bogus, since we could not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create a tuple that large.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tuple_width &gt; MaxAllocSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (int32) MaxAllocSize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unlike <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>, we just Assert that the value isn't negative,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rather than masking such errors.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(tuple_width &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (int32) tuple_width;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L254" title="optimizer/path/costsize.c:254">clamp_cardinality_to_long</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Cast a Cardinality value to a sane long value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">long<br/></li>
<li><a id="L254">&#x200c;</a></span><span class="linkable">clamp_cardinality_to_long</span>(Cardinality x)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Just for paranoia's sake, ensure we do something sane with negative or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NaN <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(x))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">LONG_MAX</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (x &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If &quot;long&quot; is 64 bits, then LONG_MAX cannot be represented exactly as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * double.&nbsp; Casting it to double and back may well result in overflow due<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to rounding, so avoid doing that.&nbsp; We trust that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> double value that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * compares strictly less than &quot;(double) LONG_MAX&quot; will cast to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * representable &quot;long&quot; value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (x &lt; (<span class="Type">double</span>) <span class="Constant">LONG_MAX</span>) ? (<span class="Type">long</span>) x : <span class="Constant">LONG_MAX</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L284" title="optimizer/path/costsize.c:284">cost_seqscan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Determines and returns the cost of scanning a relation sequentially.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'baserel' is the relation to be scanned<br/></li>
<li></span><span class="Comment"> * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L284">&#x200c;</a></span><span class="linkable">cost_seqscan</span>(Path *path, PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *baserel, ParamPathInfo *param_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; cpu_run_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; disk_run_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; spc_seq_page_cost;<br/></li>
<li>&nbsp; &nbsp; QualCost&nbsp; &nbsp; qpqual_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; cpu_per_tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should only be applied to base relations */<br/></li>
<li></span>&nbsp; &nbsp; Assert(baserel-&gt;relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(baserel-&gt;rtekind == RTE_RELATION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark the path with the correct row estimate */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (param_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;rows = param_info-&gt;ppi_rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;rows = baserel-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L134" title="optimizer/path/costsize.c:134">enable_seqscan</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += <a href="#L130" title="optimizer/path/costsize.c:130">disable_cost</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fetch estimated page cost for tablespace containing table */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/spccache.c.html#L182" title="utils/cache/spccache.c:182">get_tablespace_page_costs</a>(baserel-&gt;reltablespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;spc_seq_page_cost);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * disk costs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; disk_run_cost = spc_seq_page_cost * baserel-&gt;pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* CPU costs */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4962" title="optimizer/path/costsize.c:4962">get_restriction_qual_cost</a>(root, baserel, param_info, &amp;qpqual_cost);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; startup_cost += qpqual_cost.startup;<br/></li>
<li>&nbsp; &nbsp; cpu_per_tuple = <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> + qpqual_cost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; cpu_run_cost = cpu_per_tuple * baserel-&gt;tuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* tlist eval costs are paid per output row, not per tuple scanned */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += path-&gt;pathtarget-&gt;cost.startup;<br/></li>
<li>&nbsp; &nbsp; cpu_run_cost += path-&gt;pathtarget-&gt;cost.per_tuple * path-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Adjust costing for parallelism, if used. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (path-&gt;parallel_workers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; parallel_divisor = <a href="#L6363" title="optimizer/path/costsize.c:6363">get_parallel_divisor</a>(path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The CPU cost is divided among all the workers. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cpu_run_cost /= parallel_divisor;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It may be possible to amortize some of the I/O cost, but probably<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not very much, because most operating systems already do aggressive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prefetching.&nbsp; For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we assume that the disk run cost can't be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * amortized at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In the case of a parallel plan, the row count needs to represent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the number of tuples processed per worker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;rows = <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(path-&gt;rows / parallel_divisor);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;total_cost = startup_cost + cpu_run_cost + disk_run_cost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L361" title="optimizer/path/costsize.c:361">cost_samplescan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Determines and returns the cost of scanning a relation using sampling.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'baserel' is the relation to be scanned<br/></li>
<li></span><span class="Comment"> * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L361">&#x200c;</a></span><span class="linkable">cost_samplescan</span>(Path *path, PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *baserel, ParamPathInfo *param_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; run_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li>&nbsp; &nbsp; TableSampleClause *tsc;<br/></li>
<li>&nbsp; &nbsp; TsmRoutine *tsm;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; spc_seq_page_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spc_random_page_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spc_page_cost;<br/></li>
<li>&nbsp; &nbsp; QualCost&nbsp; &nbsp; qpqual_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; cpu_per_tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should only be applied to base relations with tablesample clauses */<br/></li>
<li></span>&nbsp; &nbsp; Assert(baserel-&gt;relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; rte = planner_rt_fetch(baserel-&gt;relid, root);<br/></li>
<li>&nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_RELATION);<br/></li>
<li>&nbsp; &nbsp; tsc = rte-&gt;tablesample;<br/></li>
<li>&nbsp; &nbsp; Assert(tsc != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; tsm = <a href="../../access/tablesample/tablesample.c.html#L27" title="access/tablesample/tablesample.c:27">GetTsmRoutine</a>(tsc-&gt;tsmhandler);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark the path with the correct row estimate */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (param_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;rows = param_info-&gt;ppi_rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;rows = baserel-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fetch estimated page cost for tablespace containing table */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/spccache.c.html#L182" title="utils/cache/spccache.c:182">get_tablespace_page_costs</a>(baserel-&gt;reltablespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;spc_random_page_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;spc_seq_page_cost);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if NextSampleBlock is used, assume random access, else sequential */<br/></li>
<li></span>&nbsp; &nbsp; spc_page_cost = (tsm-&gt;NextSampleBlock != <span class="Constant">NULL</span>) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; spc_random_page_cost : spc_seq_page_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * disk costs (recall that baserel-&gt;pages has already been set to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number of pages the sampling method will visit)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; run_cost += spc_page_cost * baserel-&gt;pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CPU costs (recall that baserel-&gt;tuples has already been set to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number of tuples the sampling method will <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a>).&nbsp; Note that we ignore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * execution cost of the TABLESAMPLE parameter expressions; they will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * evaluated only once per scan, and in most usages they'll likely be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * simple constants anyway.&nbsp; We also don't <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> anything for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calculations the sampling method might do internally.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4962" title="optimizer/path/costsize.c:4962">get_restriction_qual_cost</a>(root, baserel, param_info, &amp;qpqual_cost);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; startup_cost += qpqual_cost.startup;<br/></li>
<li>&nbsp; &nbsp; cpu_per_tuple = <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> + qpqual_cost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; run_cost += cpu_per_tuple * baserel-&gt;tuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* tlist eval costs are paid per output row, not per tuple scanned */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += path-&gt;pathtarget-&gt;cost.startup;<br/></li>
<li>&nbsp; &nbsp; run_cost += path-&gt;pathtarget-&gt;cost.per_tuple * path-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;total_cost = startup_cost + run_cost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L436" title="optimizer/path/costsize.c:436">cost_gather</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Determines and returns the cost of gather path.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rel' is the relation to be operated upon<br/></li>
<li></span><span class="Comment"> * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL<br/></li>
<li></span><span class="Comment"> * 'rows' may be used to point to a row estimate; if non-NULL, it overrides<br/></li>
<li></span><span class="Comment"> * both 'rel' and 'param_info'.&nbsp; This is useful when the path doesn't exactly<br/></li>
<li></span><span class="Comment"> * correspond to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> particular RelOptInfo.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L436">&#x200c;</a></span><span class="linkable">cost_gather</span>(GatherPath *path, PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel, ParamPathInfo *param_info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> *rows)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; run_cost = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark the path with the correct row estimate */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rows)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;path.rows = *rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (param_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;path.rows = param_info-&gt;ppi_rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;path.rows = rel-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; startup_cost = path-&gt;subpath-&gt;startup_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; run_cost = path-&gt;subpath-&gt;total_cost - path-&gt;subpath-&gt;startup_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Parallel setup and communication cost. */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += <a href="#L125" title="optimizer/path/costsize.c:125">parallel_setup_cost</a>;<br/></li>
<li>&nbsp; &nbsp; run_cost += <a href="#L124" title="optimizer/path/costsize.c:124">parallel_tuple_cost</a> * path-&gt;path.rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;path.startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;path.total_cost = (startup_cost + run_cost);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L474" title="optimizer/path/costsize.c:474">cost_gather_merge</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Determines and returns the cost of gather <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> path.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * GatherMerge merges several pre-sorted input streams, using a heap that at<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> given instant holds the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple from each stream. If there are N<br/></li>
<li></span><span class="Comment"> * streams, we need about N*log2(N) tuple comparisons to construct the heap at<br/></li>
<li></span><span class="Comment"> * startup, and then for each output tuple, about log2(N) comparisons to<br/></li>
<li></span><span class="Comment"> * replace the top heap entry with the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple from the same stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L474">&#x200c;</a></span><span class="linkable">cost_gather_merge</span>(GatherMergePath *path, PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel, ParamPathInfo *param_info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cost input_startup_cost, Cost input_total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> *rows)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; run_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; comparison_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; N;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; logN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark the path with the correct row estimate */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rows)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;path.rows = *rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (param_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;path.rows = param_info-&gt;ppi_rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;path.rows = rel-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L147" title="optimizer/path/costsize.c:147">enable_gathermerge</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += <a href="#L130" title="optimizer/path/costsize.c:130">disable_cost</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add one to the number of workers to account for the leader.&nbsp; This might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be overgenerous since the leader will do less work than other workers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in typical cases, but we'll go with it for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(path-&gt;num_workers &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; N = (<span class="Type">double</span>) path-&gt;num_workers + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; logN = <a href="#L102" title="optimizer/path/costsize.c:102">LOG2</a>(N);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assumed cost per tuple comparison */<br/></li>
<li></span>&nbsp; &nbsp; comparison_cost = <span class="Constant">2.0</span> * <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Heap creation cost */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += comparison_cost * N * logN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Per-tuple heap maintenance cost */<br/></li>
<li></span>&nbsp; &nbsp; run_cost += path-&gt;path.rows * comparison_cost * logN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* small cost for heap management, like <a href="#L2404" title="optimizer/path/costsize.c:2404">cost_merge_append</a> */<br/></li>
<li></span>&nbsp; &nbsp; run_cost += <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> * path-&gt;path.rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Parallel setup and communication cost.&nbsp; Since Gather Merge, unlike<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Gather, requires us to block until a tuple is available from every<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worker, we bump the IPC cost up a little <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> as compared with Gather.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For lack of a better idea, <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> an extra 5%.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += <a href="#L125" title="optimizer/path/costsize.c:125">parallel_setup_cost</a>;<br/></li>
<li>&nbsp; &nbsp; run_cost += <a href="#L124" title="optimizer/path/costsize.c:124">parallel_tuple_cost</a> * path-&gt;path.rows * <span class="Constant">1.05</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;path.startup_cost = startup_cost + input_startup_cost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;path.total_cost = (startup_cost + run_cost + input_total_cost);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L549" title="optimizer/path/costsize.c:549">cost_index</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Determines and returns the cost of scanning a relation using an index.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'path' describes the indexscan under consideration, and is complete<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; except for the fields to be set by this routine<br/></li>
<li></span><span class="Comment"> * 'loop_count' is the number of repetitions of the indexscan to factor into<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; estimates of caching behavior<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In addition to rows, startup_cost and total_cost, <a href="#L549" title="optimizer/path/costsize.c:549">cost_index</a>() sets the<br/></li>
<li></span><span class="Comment"> * path's indextotalcost and indexselectivity fields.&nbsp; These <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> will be<br/></li>
<li></span><span class="Comment"> * needed if the IndexPath is used in a BitmapIndexScan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: path-&gt;indexquals must contain only clauses usable as index<br/></li>
<li></span><span class="Comment"> * restrictions.&nbsp; Any additional quals evaluated as qpquals may reduce the<br/></li>
<li></span><span class="Comment"> * number of returned tuples, but they won't reduce the number of tuples<br/></li>
<li></span><span class="Comment"> * we have to fetch from the table, so they don't reduce the scan cost.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L549">&#x200c;</a></span><span class="linkable">cost_index</span>(IndexPath *path, PlannerInfo *root, <span class="Type">double</span> loop_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> partial_path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexOptInfo *index = path-&gt;indexinfo;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *baserel = index-&gt;rel;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; indexonly = (path-&gt;path.pathtype == T_IndexOnlyScan);<br/></li>
<li>&nbsp; &nbsp; amcostestimate_function amcostestimate;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *qpquals;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; run_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; cpu_run_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; indexStartupCost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; indexTotalCost;<br/></li>
<li>&nbsp; &nbsp; Selectivity indexSelectivity;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; indexCorrelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; csquared;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; spc_seq_page_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spc_random_page_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; min_IO_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_IO_cost;<br/></li>
<li>&nbsp; &nbsp; QualCost&nbsp; &nbsp; qpqual_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; cpu_per_tuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; tuples_fetched;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; pages_fetched;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; rand_heap_pages;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; index_pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should only be applied to base relations */<br/></li>
<li></span>&nbsp; &nbsp; Assert(IsA(baserel, RelOptInfo) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IsA(index, IndexOptInfo));<br/></li>
<li>&nbsp; &nbsp; Assert(baserel-&gt;relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(baserel-&gt;rtekind == RTE_RELATION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark the path with the correct row estimate, and identify which quals<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will need to be enforced as qpquals.&nbsp; We need not check <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> quals that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are implied by the index's predicate, so we can use indrestrictinfo not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * baserestrictinfo as the list of relevant restriction clauses for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (path-&gt;path.param_info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;path.rows = path-&gt;path.param_info-&gt;ppi_rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* qpquals come from the rel's restriction clauses and ppi_clauses */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qpquals = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(<a href="#L840" title="optimizer/path/costsize.c:840">extract_nonindex_conditions</a>(path-&gt;indexinfo-&gt;indrestrictinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path-&gt;indexclauses),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L840" title="optimizer/path/costsize.c:840">extract_nonindex_conditions</a>(path-&gt;path.param_info-&gt;ppi_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path-&gt;indexclauses));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;path.rows = baserel-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* qpquals come from just the rel's restriction clauses */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qpquals = <a href="#L840" title="optimizer/path/costsize.c:840">extract_nonindex_conditions</a>(path-&gt;indexinfo-&gt;indrestrictinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path-&gt;indexclauses);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L135" title="optimizer/path/costsize.c:135">enable_indexscan</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += <a href="#L130" title="optimizer/path/costsize.c:130">disable_cost</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we don't need to check <a href="#L136" title="optimizer/path/costsize.c:136">enable_indexonlyscan</a>; indxpath.c does that */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Call index-access-method-specific code to estimate the processing cost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for scanning the index, as well as the selectivity of the index (ie,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the fraction of <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a>-table tuples we will have to retrieve) and its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * correlation to the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a>-table tuple order.&nbsp; We need a cast here because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pathnodes.h uses a weak function type to avoid including amapi.h.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; amcostestimate = (amcostestimate_function) index-&gt;amcostestimate;<br/></li>
<li>&nbsp; &nbsp; amcostestimate(root, path, loop_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;indexStartupCost, &amp;indexTotalCost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;indexSelectivity, &amp;indexCorrelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;index_pages);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Save amcostestimate's results for possible use in bitmap scan planning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't bother to save indexStartupCost or indexCorrelation, because a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bitmap scan doesn't care about either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; path-&gt;indextotalcost = indexTotalCost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;indexselectivity = indexSelectivity;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* all costs for touching index itself included here */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += indexStartupCost;<br/></li>
<li>&nbsp; &nbsp; run_cost += indexTotalCost - indexStartupCost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* estimate number of <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a>-table tuples fetched */<br/></li>
<li></span>&nbsp; &nbsp; tuples_fetched = <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(indexSelectivity * baserel-&gt;tuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fetch estimated page costs for tablespace containing table */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/spccache.c.html#L182" title="utils/cache/spccache.c:182">get_tablespace_page_costs</a>(baserel-&gt;reltablespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;spc_random_page_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;spc_seq_page_cost);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate number of <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a>-table pages fetched, and compute I/O cost.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When the index ordering is uncorrelated with the table ordering,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we use an approximation proposed by Mackert and Lohman (see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L898" title="optimizer/path/costsize.c:898">index_pages_fetched</a>() for details) to compute the number of pages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fetched, and then <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> spc_random_page_cost per page fetched.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When the index ordering is exactly correlated with the table ordering<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (just after a CLUSTER, for example), the number of pages fetched should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be exactly selectivity * table_size.&nbsp; What's more, all but the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will be sequential fetches, not the random fetches that occur in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * uncorrelated case.&nbsp; So if the number of pages is more than 1, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ought to <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; spc_random_page_cost + (pages_fetched - 1) * spc_seq_page_cost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For partially-correlated indexes, we ought to <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> somewhere between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * these two estimates.&nbsp; We currently interpolate linearly between the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimates based on the correlation squared (</span><span class="Todo">XXX</span><span class="Comment"> is that appropriate?).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's an index-only scan, then we will not need to fetch <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pages for which the visibility map shows all tuples are visible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Hence, reduce the estimated number of heap fetches accordingly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use the measured fraction of the entire heap that is all-visible,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which might not be particularly relevant to the <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of the heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that this query will fetch; but it's not clear how to do better.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (loop_count &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For repeated indexscans, the appropriate estimate for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * uncorrelated case is to scale up the number of tuples fetched in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the Mackert and Lohman formula by the number of scans, so that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * estimate the number of pages fetched by all the scans; then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pro-rate the costs for one scan.&nbsp; In this case we assume all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fetches are random accesses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pages_fetched = <a href="#L898" title="optimizer/path/costsize.c:898">index_pages_fetched</a>(tuples_fetched * loop_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; baserel-&gt;pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">double</span>) index-&gt;pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexonly)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pages_fetched = ceil(pages_fetched * (<span class="Constant">1.0</span> - baserel-&gt;allvisfrac));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rand_heap_pages = pages_fetched;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; max_IO_cost = (pages_fetched * spc_random_page_cost) / loop_count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In the perfectly correlated case, the number of pages touched by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * each scan is selectivity * table_size, and we can use the Mackert<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and Lohman formula at the page level to estimate how much work is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * saved by caching across scans.&nbsp; We still assume all the fetches are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * random, though, which is an overestimate that's hard to correct for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * without double-counting the cache effects.&nbsp; (But in most cases<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * where such a plan is actually interesting, only one page would get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fetched per scan anyway, so it shouldn't matter much.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pages_fetched = ceil(indexSelectivity * (<span class="Type">double</span>) baserel-&gt;pages);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pages_fetched = <a href="#L898" title="optimizer/path/costsize.c:898">index_pages_fetched</a>(pages_fetched * loop_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; baserel-&gt;pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">double</span>) index-&gt;pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexonly)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pages_fetched = ceil(pages_fetched * (<span class="Constant">1.0</span> - baserel-&gt;allvisfrac));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; min_IO_cost = (pages_fetched * spc_random_page_cost) / loop_count;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Normal case: apply the Mackert and Lohman formula, and then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interpolate between that and the correlation-derived result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pages_fetched = <a href="#L898" title="optimizer/path/costsize.c:898">index_pages_fetched</a>(tuples_fetched,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; baserel-&gt;pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">double</span>) index-&gt;pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexonly)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pages_fetched = ceil(pages_fetched * (<span class="Constant">1.0</span> - baserel-&gt;allvisfrac));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rand_heap_pages = pages_fetched;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* max_IO_cost is for the perfectly uncorrelated case (csquared=0) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; max_IO_cost = pages_fetched * spc_random_page_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* min_IO_cost is for the perfectly correlated case (csquared=1) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pages_fetched = ceil(indexSelectivity * (<span class="Type">double</span>) baserel-&gt;pages);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexonly)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pages_fetched = ceil(pages_fetched * (<span class="Constant">1.0</span> - baserel-&gt;allvisfrac));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pages_fetched &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_IO_cost = spc_random_page_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pages_fetched &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_IO_cost += (pages_fetched - <span class="Constant">1</span>) * spc_seq_page_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_IO_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (partial_path)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For index only scans compute workers based on number of index pages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fetched; the number of heap pages we fetch might be so small as to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * effectively rule out parallelism, which we don't want to do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexonly)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rand_heap_pages = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Estimate the number of parallel workers required to scan index. Use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the number of heap pages computed considering heap fetches won't be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sequential as for parallel scans the pages are accessed in random<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;path.parallel_workers = <a href="allpaths.c.html#L4215" title="optimizer/path/allpaths.c:4215">compute_parallel_worker</a>(baserel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rand_heap_pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L132" title="optimizer/path/costsize.c:132">max_parallel_workers_per_gather</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fall out if workers can't be assigned for parallel scan, because in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * such a case this path will be rejected.&nbsp; So there is no benefit in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doing extra computation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path-&gt;path.parallel_workers &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;path.parallel_aware = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now interpolate based on estimated index order correlation to get total<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * disk I/O cost for <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> table accesses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; csquared = indexCorrelation * indexCorrelation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; run_cost += max_IO_cost + csquared * (min_IO_cost - max_IO_cost);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate CPU costs per tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * What we want here is <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> plus the evaluation costs of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * qual clauses that we have to evaluate as qpquals.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4640" title="optimizer/path/costsize.c:4640">cost_qual_eval</a>(&amp;qpqual_cost, qpquals, root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; startup_cost += qpqual_cost.startup;<br/></li>
<li>&nbsp; &nbsp; cpu_per_tuple = <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> + qpqual_cost.per_tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cpu_run_cost += cpu_per_tuple * tuples_fetched;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* tlist eval costs are paid per output row, not per tuple scanned */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += path-&gt;path.pathtarget-&gt;cost.startup;<br/></li>
<li>&nbsp; &nbsp; cpu_run_cost += path-&gt;path.pathtarget-&gt;cost.per_tuple * path-&gt;path.rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Adjust costing for parallelism, if used. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (path-&gt;path.parallel_workers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; parallel_divisor = <a href="#L6363" title="optimizer/path/costsize.c:6363">get_parallel_divisor</a>(&amp;path-&gt;path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;path.rows = <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(path-&gt;path.rows / parallel_divisor);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The CPU cost is divided among all the workers. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cpu_run_cost /= parallel_divisor;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; run_cost += cpu_run_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;path.startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;path.total_cost = startup_cost + run_cost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L840" title="optimizer/path/costsize.c:840">extract_nonindex_conditions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given a list of quals to be enforced in an indexscan, extract the ones that<br/></li>
<li></span><span class="Comment"> * will have to be applied as qpquals (ie, the index machinery won't handle<br/></li>
<li></span><span class="Comment"> * them).&nbsp; Here we detect only whether a qual clause is directly redundant<br/></li>
<li></span><span class="Comment"> * with some indexclause.&nbsp; If the index path is chosen for use, createplan.c<br/></li>
<li></span><span class="Comment"> * will try a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> harder to get rid of redundant qual conditions; specifically<br/></li>
<li></span><span class="Comment"> * it will see if quals can be proven to be implied by the indexquals.&nbsp; But<br/></li>
<li></span><span class="Comment"> * it does not seem worth the cycles to try to factor that in at this stage,<br/></li>
<li></span><span class="Comment"> * since we're only trying to estimate qual eval costs.&nbsp; Otherwise this must<br/></li>
<li></span><span class="Comment"> * match the logic in <a href="../plan/createplan.c.html#L3005" title="optimizer/plan/createplan.c:3005">create_indexscan_plan</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * qual_clauses, and the result, are lists of RestrictInfos.<br/></li>
<li></span><span class="Comment"> * indexclauses is a list of IndexClauses.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L840">&#x200c;</a><span class="linkable">extract_nonindex_conditions</span>(List *qual_clauses, List *indexclauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, qual_clauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rinfo-&gt;pseudoconstant)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we may drop pseudoconstants here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="equivclass.c.html#L3308" title="optimizer/path/equivclass.c:3308">is_redundant_with_indexclauses</a>(rinfo, indexclauses))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dup or derived from same EquivalenceClass */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the predicate proof attempt createplan.c will try ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, rinfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L898" title="optimizer/path/costsize.c:898">index_pages_fetched</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Estimate the number of pages actually fetched after accounting for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; cache effects.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use an approximation proposed by Mackert and Lohman, &quot;Index Scans<br/></li>
<li></span><span class="Comment"> * Using a Finite LRU Buffer: A Validated I/O Model&quot;, ACM Transactions<br/></li>
<li></span><span class="Comment"> * on Database Systems, Vol. 14, No. 3, September 1989, Pages 401-424.<br/></li>
<li></span><span class="Comment"> * The Mackert and Lohman approximation is that the number of pages<br/></li>
<li></span><span class="Comment"> * fetched is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; PF =<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; min(2TNs/(2T+Ns), T)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; when T &lt;= b<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; 2TNs/(2T+Ns)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; when T &gt; b and Ns &lt;= 2Tb/(2T-b)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; b + (Ns - 2Tb/(2T-b))*(T-b)/T&nbsp; &nbsp; when T &gt; b and Ns &gt; 2Tb/(2T-b)<br/></li>
<li></span><span class="Comment"> * where<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; T = # pages in table<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; N = # tuples in table<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; s = selectivity = fraction of table to be scanned<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; b = # buffer pages available (we include kernel space here)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We assume that <a href="#L128" title="optimizer/path/costsize.c:128">effective_cache_size</a> is the total number of buffer pages<br/></li>
<li></span><span class="Comment"> * available for the whole query, and pro-rate that space across all the<br/></li>
<li></span><span class="Comment"> * tables in the query and the index currently under consideration.&nbsp; (This<br/></li>
<li></span><span class="Comment"> * ignores space needed for other indexes used by the query, but since we<br/></li>
<li></span><span class="Comment"> * don't know which indexes will get used, we can't estimate that very well;<br/></li>
<li></span><span class="Comment"> * and in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case counting all the tables may well be an overestimate, since<br/></li>
<li></span><span class="Comment"> * depending on the join plan not all the tables may be scanned concurrently.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The product Ns is the number of tuples fetched; we pass in that<br/></li>
<li></span><span class="Comment"> * product rather than calculating it here.&nbsp; &quot;pages&quot; is the number of pages<br/></li>
<li></span><span class="Comment"> * in the object under consideration (either an index or a table).<br/></li>
<li></span><span class="Comment"> * &quot;index_pages&quot; is the amount to add to the total table space, which was<br/></li>
<li></span><span class="Comment"> * computed for us by <a href="allpaths.c.html#L171" title="optimizer/path/allpaths.c:171">make_one_rel</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller is expected to have ensured that tuples_fetched is greater than zero<br/></li>
<li></span><span class="Comment"> * and rounded to integer (see <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>).&nbsp; The result will likewise be<br/></li>
<li></span><span class="Comment"> * greater than zero and integral.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">double<br/></li>
<li><a id="L898">&#x200c;</a></span><span class="linkable">index_pages_fetched</span>(<span class="Type">double</span> tuples_fetched, BlockNumber pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> index_pages, PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; pages_fetched;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; total_pages;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; T,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* T is # pages in table, but don't allow it to be zero */<br/></li>
<li></span>&nbsp; &nbsp; T = (pages &gt; <span class="Constant">1</span>) ? (<span class="Type">double</span>) pages : <span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute number of pages assumed to be competing for cache space */<br/></li>
<li></span>&nbsp; &nbsp; total_pages = root-&gt;total_table_pages + index_pages;<br/></li>
<li>&nbsp; &nbsp; total_pages = Max(total_pages, <span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(T &lt;= total_pages);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* b is pro-rated share of <a href="#L128" title="optimizer/path/costsize.c:128">effective_cache_size</a> */<br/></li>
<li></span>&nbsp; &nbsp; b = (<span class="Type">double</span>) <a href="#L128" title="optimizer/path/costsize.c:128">effective_cache_size</a> * T / total_pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* force it positive and integral */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (b &lt;= <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; b = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; b = ceil(b);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This part is the Mackert and Lohman formula */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (T &lt;= b)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pages_fetched =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Constant">2.0</span> * T * tuples_fetched) / (<span class="Constant">2.0</span> * T + tuples_fetched);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pages_fetched &gt;= T)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pages_fetched = T;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pages_fetched = ceil(pages_fetched);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; lim;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lim = (<span class="Constant">2.0</span> * T * b) / (<span class="Constant">2.0</span> * T - b);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tuples_fetched &lt;= lim)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pages_fetched =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Constant">2.0</span> * T * tuples_fetched) / (<span class="Constant">2.0</span> * T + tuples_fetched);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pages_fetched =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b + (tuples_fetched - lim) * (T - b) / T;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pages_fetched = ceil(pages_fetched);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pages_fetched;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L963" title="optimizer/path/costsize.c:963">get_indexpath_pages</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Determine the total size of the indexes used in a bitmap index path.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: if the same index is used more than once in a bitmap tree, we will<br/></li>
<li></span><span class="Comment"> * count it multiple times, which perhaps is the wrong thing ... but it's<br/></li>
<li></span><span class="Comment"> * not completely clear, and detecting duplicates is difficult, so ignore it<br/></li>
<li></span><span class="Comment"> * for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L963">&#x200c;</a></span><span class="linkable">get_indexpath_pages</span>(Path *bitmapqual)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(bitmapqual, BitmapAndPath))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BitmapAndPath *apath = (BitmapAndPath *) bitmapqual;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, apath-&gt;bitmapquals)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result += <a href="#L963" title="optimizer/path/costsize.c:963">get_indexpath_pages</a>((Path *) lfirst(l));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(bitmapqual, BitmapOrPath))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BitmapOrPath *opath = (BitmapOrPath *) bitmapqual;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, opath-&gt;bitmapquals)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result += <a href="#L963" title="optimizer/path/costsize.c:963">get_indexpath_pages</a>((Path *) lfirst(l));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(bitmapqual, IndexPath))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexPath&nbsp; *ipath = (IndexPath *) bitmapqual;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (<span class="Type">double</span>) ipath-&gt;indexinfo-&gt;pages;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, nodeTag(bitmapqual));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1013" title="optimizer/path/costsize.c:1013">cost_bitmap_heap_scan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Determines and returns the cost of scanning a relation using a bitmap<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; index-then-heap plan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'baserel' is the relation to be scanned<br/></li>
<li></span><span class="Comment"> * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL<br/></li>
<li></span><span class="Comment"> * 'bitmapqual' is a tree of IndexPaths, BitmapAndPaths, and BitmapOrPaths<br/></li>
<li></span><span class="Comment"> * 'loop_count' is the number of repetitions of the indexscan to factor into<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; estimates of caching behavior<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the component IndexPaths in bitmapqual should have been costed<br/></li>
<li></span><span class="Comment"> * using the same loop_count.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1013">&#x200c;</a></span><span class="linkable">cost_bitmap_heap_scan</span>(Path *path, PlannerInfo *root, RelOptInfo *baserel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ParamPathInfo *param_info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path *bitmapqual, <span class="Type">double</span> loop_count)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; run_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; indexTotalCost;<br/></li>
<li>&nbsp; &nbsp; QualCost&nbsp; &nbsp; qpqual_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; cpu_per_tuple;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; cost_per_page;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; cpu_run_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; tuples_fetched;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; pages_fetched;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; spc_seq_page_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spc_random_page_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; T;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should only be applied to base relations */<br/></li>
<li></span>&nbsp; &nbsp; Assert(IsA(baserel, RelOptInfo));<br/></li>
<li>&nbsp; &nbsp; Assert(baserel-&gt;relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(baserel-&gt;rtekind == RTE_RELATION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark the path with the correct row estimate */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (param_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;rows = param_info-&gt;ppi_rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;rows = baserel-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L137" title="optimizer/path/costsize.c:137">enable_bitmapscan</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += <a href="#L130" title="optimizer/path/costsize.c:130">disable_cost</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pages_fetched = <a href="#L6403" title="optimizer/path/costsize.c:6403">compute_bitmap_pages</a>(root, baserel, bitmapqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; loop_count, &amp;indexTotalCost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;tuples_fetched);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; startup_cost += indexTotalCost;<br/></li>
<li>&nbsp; &nbsp; T = (baserel-&gt;pages &gt; <span class="Constant">1</span>) ? (<span class="Type">double</span>) baserel-&gt;pages : <span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch estimated page costs for tablespace containing table. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/spccache.c.html#L182" title="utils/cache/spccache.c:182">get_tablespace_page_costs</a>(baserel-&gt;reltablespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;spc_random_page_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;spc_seq_page_cost);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For small numbers of pages we should <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> spc_random_page_cost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * apiece, while if nearly all the table's pages are being read, it's more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * appropriate to <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> spc_seq_page_cost apiece.&nbsp; The effect is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nonlinear, too. For lack of a better idea, interpolate like this to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * determine the cost per page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pages_fetched &gt;= <span class="Constant">2.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cost_per_page = spc_random_page_cost -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (spc_random_page_cost - spc_seq_page_cost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * sqrt(pages_fetched / T);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cost_per_page = spc_random_page_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; run_cost += pages_fetched * cost_per_page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate CPU costs per tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Often the indexquals don't need to be rechecked at each tuple ... but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not always, especially not if there are enough tuples involved that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bitmaps become lossy.&nbsp; For the moment, just assume they will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rechecked always.&nbsp; This means we <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> the full freight for all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan clauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4962" title="optimizer/path/costsize.c:4962">get_restriction_qual_cost</a>(root, baserel, param_info, &amp;qpqual_cost);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; startup_cost += qpqual_cost.startup;<br/></li>
<li>&nbsp; &nbsp; cpu_per_tuple = <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> + qpqual_cost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; cpu_run_cost = cpu_per_tuple * tuples_fetched;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Adjust costing for parallelism, if used. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (path-&gt;parallel_workers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; parallel_divisor = <a href="#L6363" title="optimizer/path/costsize.c:6363">get_parallel_divisor</a>(path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The CPU cost is divided among all the workers. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cpu_run_cost /= parallel_divisor;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;rows = <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(path-&gt;rows / parallel_divisor);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; run_cost += cpu_run_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* tlist eval costs are paid per output row, not per tuple scanned */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += path-&gt;pathtarget-&gt;cost.startup;<br/></li>
<li>&nbsp; &nbsp; run_cost += path-&gt;pathtarget-&gt;cost.per_tuple * path-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;total_cost = startup_cost + run_cost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1114" title="optimizer/path/costsize.c:1114">cost_bitmap_tree_node</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Extract cost and selectivity from a bitmap tree node (index/and/or)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1114">&#x200c;</a></span><span class="linkable">cost_bitmap_tree_node</span>(Path *path, Cost *cost, Selectivity *selec)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(path, IndexPath))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *cost = ((IndexPath *) path)-&gt;indextotalcost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *selec = ((IndexPath *) path)-&gt;indexselectivity;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Charge a small amount per retrieved tuple to reflect the costs of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * manipulating the bitmap.&nbsp; This is mostly to make sure that a bitmap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan doesn't look to be the same cost as an indexscan to retrieve a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * single tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *cost += <span class="Constant">0.1</span> * <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> * path-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(path, BitmapAndPath))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *cost = path-&gt;total_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *selec = ((BitmapAndPath *) path)-&gt;bitmapselectivity;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(path, BitmapOrPath))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *cost = path-&gt;total_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *selec = ((BitmapOrPath *) path)-&gt;bitmapselectivity;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, nodeTag(path));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *cost = *selec = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1157" title="optimizer/path/costsize.c:1157">cost_bitmap_and_node</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Estimate the cost of a BitmapAnd node<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this considers only the costs of index scanning and bitmap<br/></li>
<li></span><span class="Comment"> * creation, not the eventual heap access.&nbsp; In that sense the object isn't<br/></li>
<li></span><span class="Comment"> * truly a Path, but it has enough path-like properties (costs in particular)<br/></li>
<li></span><span class="Comment"> * to warrant treating it as one.&nbsp; We don't bother to set the path rows field,<br/></li>
<li></span><span class="Comment"> * however.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1157">&#x200c;</a></span><span class="linkable">cost_bitmap_and_node</span>(BitmapAndPath *path, PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; totalCost;<br/></li>
<li>&nbsp; &nbsp; Selectivity selec;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We estimate AND selectivity on the assumption that the inputs are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * independent.&nbsp; This is probably often wrong, but we don't have the info<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to do better.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The runtime cost of the BitmapAnd itself is estimated at 100x<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> for each <a href="../../nodes/tidbitmap.c.html#L540" title="nodes/tidbitmap.c:540">tbm_intersect</a> needed.&nbsp; Probably too small,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * definitely too simplistic?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; totalCost = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; selec = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(l, path-&gt;bitmapquals)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *subpath = (Path *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; subCost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Selectivity subselec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1114" title="optimizer/path/costsize.c:1114">cost_bitmap_tree_node</a>(subpath, &amp;subCost, &amp;subselec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; selec *= subselec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; totalCost += subCost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (l != list_head(path-&gt;bitmapquals))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totalCost += <span class="Constant">100.0</span> * <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; path-&gt;bitmapselectivity = selec;<br/></li>
<li>&nbsp; &nbsp; path-&gt;path.rows = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* per above, not used */<br/></li>
<li></span>&nbsp; &nbsp; path-&gt;path.startup_cost = totalCost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;path.total_cost = totalCost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1201" title="optimizer/path/costsize.c:1201">cost_bitmap_or_node</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Estimate the cost of a BitmapOr node<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See comments for <a href="#L1157" title="optimizer/path/costsize.c:1157">cost_bitmap_and_node</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1201">&#x200c;</a></span><span class="linkable">cost_bitmap_or_node</span>(BitmapOrPath *path, PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; totalCost;<br/></li>
<li>&nbsp; &nbsp; Selectivity selec;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We estimate OR selectivity on the assumption that the inputs are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-overlapping, since that's often the case in &quot;x IN (list)&quot; type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * situations.&nbsp; Of course, we clamp to 1.0 at the end.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The runtime cost of the BitmapOr itself is estimated at 100x<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> for each <a href="../../nodes/tidbitmap.c.html#L458" title="nodes/tidbitmap.c:458">tbm_union</a> needed.&nbsp; Probably too small,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * definitely too simplistic?&nbsp; We are aware that the tbm_unions are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * optimized out when the inputs are BitmapIndexScans.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; totalCost = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; selec = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(l, path-&gt;bitmapquals)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *subpath = (Path *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; subCost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Selectivity subselec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1114" title="optimizer/path/costsize.c:1114">cost_bitmap_tree_node</a>(subpath, &amp;subCost, &amp;subselec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; selec += subselec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; totalCost += subCost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (l != list_head(path-&gt;bitmapquals) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !IsA(subpath, IndexPath))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totalCost += <span class="Constant">100.0</span> * <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; path-&gt;bitmapselectivity = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(selec, <span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; path-&gt;path.rows = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* per above, not used */<br/></li>
<li></span>&nbsp; &nbsp; path-&gt;path.startup_cost = totalCost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;path.total_cost = totalCost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1249" title="optimizer/path/costsize.c:1249">cost_tidscan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Determines and returns the cost of scanning a relation using TIDs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'baserel' is the relation to be scanned<br/></li>
<li></span><span class="Comment"> * 'tidquals' is the list of TID-checkable quals<br/></li>
<li></span><span class="Comment"> * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1249">&#x200c;</a></span><span class="linkable">cost_tidscan</span>(Path *path, PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *baserel, List *tidquals, ParamPathInfo *param_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; run_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isCurrentOf = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; QualCost&nbsp; &nbsp; qpqual_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; cpu_per_tuple;<br/></li>
<li>&nbsp; &nbsp; QualCost&nbsp; &nbsp; tid_qual_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; ntuples;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; spc_random_page_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should only be applied to base relations */<br/></li>
<li></span>&nbsp; &nbsp; Assert(baserel-&gt;relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(baserel-&gt;rtekind == RTE_RELATION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark the path with the correct row estimate */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (param_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;rows = param_info-&gt;ppi_rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;rows = baserel-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Count how many tuples we expect to retrieve */<br/></li>
<li></span>&nbsp; &nbsp; ntuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(l, tidquals)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *qual = rinfo-&gt;clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(qual, ScalarArrayOpExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Each <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of the array yields 1 tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) qual;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *arraynode = (Node *) lsecond(saop-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntuples += <a href="../../utils/adt/selfuncs.c.html#L2136" title="utils/adt/selfuncs.c:2136">estimate_array_length</a>(root, arraynode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(qual, CurrentOfExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* CURRENT OF yields 1 tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isCurrentOf = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntuples++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It's just CTID = something, count 1 tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntuples++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must force TID scan for WHERE CURRENT OF, because only nodeTidscan.c<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * understands how to do it correctly.&nbsp; Therefore, honor <a href="#L138" title="optimizer/path/costsize.c:138">enable_tidscan</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only when CURRENT OF isn't present.&nbsp; Also note that <a href="#L4640" title="optimizer/path/costsize.c:4640">cost_qual_eval</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * counts a CurrentOfExpr as having startup cost <a href="#L130" title="optimizer/path/costsize.c:130">disable_cost</a>, which we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subtract off here; that's to prevent other plan types such as seqscan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from winning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isCurrentOf)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(baserel-&gt;baserestrictcost.startup &gt;= <a href="#L130" title="optimizer/path/costsize.c:130">disable_cost</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost -= <a href="#L130" title="optimizer/path/costsize.c:130">disable_cost</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="#L138" title="optimizer/path/costsize.c:138">enable_tidscan</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += <a href="#L130" title="optimizer/path/costsize.c:130">disable_cost</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The TID qual expressions will be computed once, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other baserestrict<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * quals once per retrieved tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4640" title="optimizer/path/costsize.c:4640">cost_qual_eval</a>(&amp;tid_qual_cost, tidquals, root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fetch estimated page cost for tablespace containing table */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/spccache.c.html#L182" title="utils/cache/spccache.c:182">get_tablespace_page_costs</a>(baserel-&gt;reltablespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;spc_random_page_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* disk costs --- assume each tuple on a different page */<br/></li>
<li></span>&nbsp; &nbsp; run_cost += spc_random_page_cost * ntuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add scanning CPU costs */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4962" title="optimizer/path/costsize.c:4962">get_restriction_qual_cost</a>(root, baserel, param_info, &amp;qpqual_cost);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> currently we assume TID quals are a <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of qpquals */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += qpqual_cost.startup + tid_qual_cost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; cpu_per_tuple = <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> + qpqual_cost.per_tuple -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tid_qual_cost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; run_cost += cpu_per_tuple * ntuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* tlist eval costs are paid per output row, not per tuple scanned */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += path-&gt;pathtarget-&gt;cost.startup;<br/></li>
<li>&nbsp; &nbsp; run_cost += path-&gt;pathtarget-&gt;cost.per_tuple * path-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;total_cost = startup_cost + run_cost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1357" title="optimizer/path/costsize.c:1357">cost_tidrangescan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Determines and sets the costs of scanning a relation using a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; TIDs for 'path'<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'baserel' is the relation to be scanned<br/></li>
<li></span><span class="Comment"> * 'tidrangequals' is the list of TID-checkable <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> quals<br/></li>
<li></span><span class="Comment"> * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1357">&#x200c;</a></span><span class="linkable">cost_tidrangescan</span>(Path *path, PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *baserel, List *tidrangequals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ParamPathInfo *param_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Selectivity selectivity;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; pages;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; run_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; QualCost&nbsp; &nbsp; qpqual_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; cpu_per_tuple;<br/></li>
<li>&nbsp; &nbsp; QualCost&nbsp; &nbsp; tid_qual_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; ntuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nseqpages;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; spc_random_page_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; spc_seq_page_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should only be applied to base relations */<br/></li>
<li></span>&nbsp; &nbsp; Assert(baserel-&gt;relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(baserel-&gt;rtekind == RTE_RELATION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark the path with the correct row estimate */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (param_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;rows = param_info-&gt;ppi_rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;rows = baserel-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Count how many tuples and pages we expect to scan */<br/></li>
<li></span>&nbsp; &nbsp; selectivity = <a href="clausesel.c.html#L100" title="optimizer/path/clausesel.c:100">clauselist_selectivity</a>(root, tidrangequals, baserel-&gt;relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JOIN_INNER, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; pages = ceil(selectivity * baserel-&gt;pages);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pages &lt;= <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pages = <span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The first page in a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> requires a random seek, but each subsequent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page is just a normal sequential page read. <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: it's desirable for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * TID <a href="../../utils/adt/geo_spgist.c.html#L107" title="utils/adt/geo_spgist.c:107">Range</a> Scans to cost more than the equivalent Sequential Scans,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because Seq Scans have some performance advantages such as scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * synchronization and parallelizability, and we'd prefer one of them to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be picked unless a TID <a href="../../utils/adt/geo_spgist.c.html#L107" title="utils/adt/geo_spgist.c:107">Range</a> Scan really is better.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ntuples = selectivity * baserel-&gt;tuples;<br/></li>
<li>&nbsp; &nbsp; nseqpages = pages - <span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L138" title="optimizer/path/costsize.c:138">enable_tidscan</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += <a href="#L130" title="optimizer/path/costsize.c:130">disable_cost</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The TID qual expressions will be computed once, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other baserestrict<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * quals once per retrieved tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4640" title="optimizer/path/costsize.c:4640">cost_qual_eval</a>(&amp;tid_qual_cost, tidrangequals, root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fetch estimated page cost for tablespace containing table */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/spccache.c.html#L182" title="utils/cache/spccache.c:182">get_tablespace_page_costs</a>(baserel-&gt;reltablespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;spc_random_page_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;spc_seq_page_cost);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* disk costs; 1 random page and the remainder as seq pages */<br/></li>
<li></span>&nbsp; &nbsp; run_cost += spc_random_page_cost + spc_seq_page_cost * nseqpages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add scanning CPU costs */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4962" title="optimizer/path/costsize.c:4962">get_restriction_qual_cost</a>(root, baserel, param_info, &amp;qpqual_cost);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> currently we assume TID quals are a <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of qpquals at this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * point; they will be removed (if possible) when we create the plan, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we subtract their cost from the total qpqual cost.&nbsp; (If the TID quals<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't be removed, this is a mistake and we're going to underestimate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the CPU cost a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += qpqual_cost.startup + tid_qual_cost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; cpu_per_tuple = <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> + qpqual_cost.per_tuple -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tid_qual_cost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; run_cost += cpu_per_tuple * ntuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* tlist eval costs are paid per output row, not per tuple scanned */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += path-&gt;pathtarget-&gt;cost.startup;<br/></li>
<li>&nbsp; &nbsp; run_cost += path-&gt;pathtarget-&gt;cost.per_tuple * path-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;total_cost = startup_cost + run_cost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1451" title="optimizer/path/costsize.c:1451">cost_subqueryscan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Determines and returns the cost of scanning a subquery RTE.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'baserel' is the relation to be scanned<br/></li>
<li></span><span class="Comment"> * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL<br/></li>
<li></span><span class="Comment"> * 'trivial_pathtarget' is true if the pathtarget is believed to be trivial.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1451">&#x200c;</a></span><span class="linkable">cost_subqueryscan</span>(SubqueryScanPath *path, PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *baserel, ParamPathInfo *param_info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> trivial_pathtarget)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; run_cost;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *qpquals;<br/></li>
<li>&nbsp; &nbsp; QualCost&nbsp; &nbsp; qpqual_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; cpu_per_tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should only be applied to base relations that are subqueries */<br/></li>
<li></span>&nbsp; &nbsp; Assert(baserel-&gt;relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(baserel-&gt;rtekind == RTE_SUBQUERY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We compute the rowcount estimate as the subplan's estimate times the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * selectivity of relevant restriction clauses.&nbsp; In simple cases this will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * come out the same as baserel-&gt;rows; but when dealing with parallelized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * paths we must do it like this to get the right answer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (param_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qpquals = <a href="../../nodes/list.c.html#L598" title="nodes/list.c:598">list_concat_copy</a>(param_info-&gt;ppi_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; baserel-&gt;baserestrictinfo);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qpquals = baserel-&gt;baserestrictinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;path.rows = <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(path-&gt;subpath-&gt;rows *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="clausesel.c.html#L100" title="optimizer/path/clausesel.c:100">clauselist_selectivity</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; qpquals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JOIN_INNER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Cost of path is cost of evaluating the subplan, plus cost of evaluating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> restriction clauses and tlist that will be attached to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SubqueryScan node, plus <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> to account for selection and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * projection overhead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; path-&gt;path.startup_cost = path-&gt;subpath-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;path.total_cost = path-&gt;subpath-&gt;total_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, if there are no relevant restriction clauses and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pathtarget is trivial, then we expect that setrefs.c will <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> away<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the SubqueryScan plan node altogether, so we should just make its cost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and rowcount <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the input path's.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: there are some edge cases where createplan.c will apply a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * different targetlist to the SubqueryScan node, thus falsifying our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current estimate of whether the target is trivial, and making the cost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimate (though not the rowcount) wrong.&nbsp; It does not seem worth the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * extra complication to try to account for that exactly, especially since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that behavior falsifies other cost estimates as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (qpquals == NIL &amp;&amp; trivial_pathtarget)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4962" title="optimizer/path/costsize.c:4962">get_restriction_qual_cost</a>(root, baserel, param_info, &amp;qpqual_cost);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; startup_cost = qpqual_cost.startup;<br/></li>
<li>&nbsp; &nbsp; cpu_per_tuple = <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> + qpqual_cost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; run_cost = cpu_per_tuple * path-&gt;subpath-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* tlist eval costs are paid per output row, not per tuple scanned */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += path-&gt;path.pathtarget-&gt;cost.startup;<br/></li>
<li>&nbsp; &nbsp; run_cost += path-&gt;path.pathtarget-&gt;cost.per_tuple * path-&gt;path.rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;path.startup_cost += startup_cost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;path.total_cost += startup_cost + run_cost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1531" title="optimizer/path/costsize.c:1531">cost_functionscan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Determines and returns the cost of scanning a function RTE.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'baserel' is the relation to be scanned<br/></li>
<li></span><span class="Comment"> * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1531">&#x200c;</a></span><span class="linkable">cost_functionscan</span>(Path *path, PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *baserel, ParamPathInfo *param_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; run_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; QualCost&nbsp; &nbsp; qpqual_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; cpu_per_tuple;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li>&nbsp; &nbsp; QualCost&nbsp; &nbsp; exprcost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should only be applied to base relations that are <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span>&nbsp; &nbsp; Assert(baserel-&gt;relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; rte = planner_rt_fetch(baserel-&gt;relid, root);<br/></li>
<li>&nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_FUNCTION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark the path with the correct row estimate */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (param_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;rows = param_info-&gt;ppi_rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;rows = baserel-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate costs of executing the function expression(s).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Currently, nodeFunctionscan.c always executes the <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * completion <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> returning <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> rows, and caches the results in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuplestore.&nbsp; So the function eval cost is all startup cost, and per-row<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * costs are minimal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> in principle we ought to <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> tuplestore spill costs if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number of rows is large.&nbsp; However, given how phony our rowcount<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimates for <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> tend to be, there's not a lot of point in that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * refinement right <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4666" title="optimizer/path/costsize.c:4666">cost_qual_eval_node</a>(&amp;exprcost, (Node *) rte-&gt;<a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; startup_cost += exprcost.startup + exprcost.per_tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add scanning CPU costs */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4962" title="optimizer/path/costsize.c:4962">get_restriction_qual_cost</a>(root, baserel, param_info, &amp;qpqual_cost);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; startup_cost += qpqual_cost.startup;<br/></li>
<li>&nbsp; &nbsp; cpu_per_tuple = <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> + qpqual_cost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; run_cost += cpu_per_tuple * baserel-&gt;tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* tlist eval costs are paid per output row, not per tuple scanned */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += path-&gt;pathtarget-&gt;cost.startup;<br/></li>
<li>&nbsp; &nbsp; run_cost += path-&gt;pathtarget-&gt;cost.per_tuple * path-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;total_cost = startup_cost + run_cost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1592" title="optimizer/path/costsize.c:1592">cost_tablefuncscan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Determines and returns the cost of scanning a table function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'baserel' is the relation to be scanned<br/></li>
<li></span><span class="Comment"> * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1592">&#x200c;</a></span><span class="linkable">cost_tablefuncscan</span>(Path *path, PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *baserel, ParamPathInfo *param_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; run_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; QualCost&nbsp; &nbsp; qpqual_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; cpu_per_tuple;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li>&nbsp; &nbsp; QualCost&nbsp; &nbsp; exprcost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should only be applied to base relations that are <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span>&nbsp; &nbsp; Assert(baserel-&gt;relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; rte = planner_rt_fetch(baserel-&gt;relid, root);<br/></li>
<li>&nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_TABLEFUNC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark the path with the correct row estimate */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (param_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;rows = param_info-&gt;ppi_rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;rows = baserel-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate costs of executing the table func expression(s).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> in principle we ought to <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> tuplestore spill costs if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number of rows is large.&nbsp; However, given how phony our rowcount<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimates for tablefuncs tend to be, there's not a lot of point in that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * refinement right <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4666" title="optimizer/path/costsize.c:4666">cost_qual_eval_node</a>(&amp;exprcost, (Node *) rte-&gt;tablefunc, root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; startup_cost += exprcost.startup + exprcost.per_tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add scanning CPU costs */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4962" title="optimizer/path/costsize.c:4962">get_restriction_qual_cost</a>(root, baserel, param_info, &amp;qpqual_cost);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; startup_cost += qpqual_cost.startup;<br/></li>
<li>&nbsp; &nbsp; cpu_per_tuple = <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> + qpqual_cost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; run_cost += cpu_per_tuple * baserel-&gt;tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* tlist eval costs are paid per output row, not per tuple scanned */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += path-&gt;pathtarget-&gt;cost.startup;<br/></li>
<li>&nbsp; &nbsp; run_cost += path-&gt;pathtarget-&gt;cost.per_tuple * path-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;total_cost = startup_cost + run_cost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1648" title="optimizer/path/costsize.c:1648">cost_valuesscan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Determines and returns the cost of scanning a VALUES RTE.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'baserel' is the relation to be scanned<br/></li>
<li></span><span class="Comment"> * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1648">&#x200c;</a></span><span class="linkable">cost_valuesscan</span>(Path *path, PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *baserel, ParamPathInfo *param_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; run_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; QualCost&nbsp; &nbsp; qpqual_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; cpu_per_tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should only be applied to base relations that are <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> lists */<br/></li>
<li></span>&nbsp; &nbsp; Assert(baserel-&gt;relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(baserel-&gt;rtekind == RTE_VALUES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark the path with the correct row estimate */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (param_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;rows = param_info-&gt;ppi_rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;rows = baserel-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, estimate list evaluation cost at one operator eval per list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (probably pretty bogus, but is it worth being smarter?)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cpu_per_tuple = <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add scanning CPU costs */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4962" title="optimizer/path/costsize.c:4962">get_restriction_qual_cost</a>(root, baserel, param_info, &amp;qpqual_cost);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; startup_cost += qpqual_cost.startup;<br/></li>
<li>&nbsp; &nbsp; cpu_per_tuple += <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> + qpqual_cost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; run_cost += cpu_per_tuple * baserel-&gt;tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* tlist eval costs are paid per output row, not per tuple scanned */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += path-&gt;pathtarget-&gt;cost.startup;<br/></li>
<li>&nbsp; &nbsp; run_cost += path-&gt;pathtarget-&gt;cost.per_tuple * path-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;total_cost = startup_cost + run_cost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1698" title="optimizer/path/costsize.c:1698">cost_ctescan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Determines and returns the cost of scanning a CTE RTE.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this is used for both self-reference and regular CTEs; the<br/></li>
<li></span><span class="Comment"> * possible cost differences are below the threshold of what we could<br/></li>
<li></span><span class="Comment"> * estimate accurately anyway.&nbsp; Note that the costs of evaluating the<br/></li>
<li></span><span class="Comment"> * referenced CTE query are added into the final plan as initplan costs,<br/></li>
<li></span><span class="Comment"> * and should NOT be counted here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1698">&#x200c;</a></span><span class="linkable">cost_ctescan</span>(Path *path, PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *baserel, ParamPathInfo *param_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; run_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; QualCost&nbsp; &nbsp; qpqual_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; cpu_per_tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should only be applied to base relations that are CTEs */<br/></li>
<li></span>&nbsp; &nbsp; Assert(baserel-&gt;relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(baserel-&gt;rtekind == RTE_CTE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark the path with the correct row estimate */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (param_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;rows = param_info-&gt;ppi_rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;rows = baserel-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Charge one CPU tuple cost per row for tuplestore manipulation */<br/></li>
<li></span>&nbsp; &nbsp; cpu_per_tuple = <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add scanning CPU costs */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4962" title="optimizer/path/costsize.c:4962">get_restriction_qual_cost</a>(root, baserel, param_info, &amp;qpqual_cost);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; startup_cost += qpqual_cost.startup;<br/></li>
<li>&nbsp; &nbsp; cpu_per_tuple += <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> + qpqual_cost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; run_cost += cpu_per_tuple * baserel-&gt;tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* tlist eval costs are paid per output row, not per tuple scanned */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += path-&gt;pathtarget-&gt;cost.startup;<br/></li>
<li>&nbsp; &nbsp; run_cost += path-&gt;pathtarget-&gt;cost.per_tuple * path-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;total_cost = startup_cost + run_cost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1739" title="optimizer/path/costsize.c:1739">cost_namedtuplestorescan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Determines and returns the cost of scanning a named tuplestore.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1739">&#x200c;</a></span><span class="linkable">cost_namedtuplestorescan</span>(Path *path, PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *baserel, ParamPathInfo *param_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; run_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; QualCost&nbsp; &nbsp; qpqual_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; cpu_per_tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should only be applied to base relations that are Tuplestores */<br/></li>
<li></span>&nbsp; &nbsp; Assert(baserel-&gt;relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(baserel-&gt;rtekind == RTE_NAMEDTUPLESTORE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark the path with the correct row estimate */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (param_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;rows = param_info-&gt;ppi_rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;rows = baserel-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Charge one CPU tuple cost per row for tuplestore manipulation */<br/></li>
<li></span>&nbsp; &nbsp; cpu_per_tuple = <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add scanning CPU costs */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4962" title="optimizer/path/costsize.c:4962">get_restriction_qual_cost</a>(root, baserel, param_info, &amp;qpqual_cost);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; startup_cost += qpqual_cost.startup;<br/></li>
<li>&nbsp; &nbsp; cpu_per_tuple += <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> + qpqual_cost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; run_cost += cpu_per_tuple * baserel-&gt;tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;total_cost = startup_cost + run_cost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1776" title="optimizer/path/costsize.c:1776">cost_resultscan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Determines and returns the cost of scanning an RTE_RESULT relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1776">&#x200c;</a></span><span class="linkable">cost_resultscan</span>(Path *path, PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *baserel, ParamPathInfo *param_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; run_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; QualCost&nbsp; &nbsp; qpqual_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; cpu_per_tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should only be applied to RTE_RESULT base relations */<br/></li>
<li></span>&nbsp; &nbsp; Assert(baserel-&gt;relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(baserel-&gt;rtekind == RTE_RESULT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark the path with the correct row estimate */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (param_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;rows = param_info-&gt;ppi_rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;rows = baserel-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> qual cost plus <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4962" title="optimizer/path/costsize.c:4962">get_restriction_qual_cost</a>(root, baserel, param_info, &amp;qpqual_cost);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; startup_cost += qpqual_cost.startup;<br/></li>
<li>&nbsp; &nbsp; cpu_per_tuple = <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> + qpqual_cost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; run_cost += cpu_per_tuple * baserel-&gt;tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;total_cost = startup_cost + run_cost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1813" title="optimizer/path/costsize.c:1813">cost_recursive_union</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Determines and returns the cost of performing a recursive union,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; and also the estimated output size.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We are given Paths for the nonrecursive and recursive terms.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1813">&#x200c;</a></span><span class="linkable">cost_recursive_union</span>(Path *runion, Path *nrterm, Path *rterm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; total_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; total_rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We probably have decent estimates for the non-recursive term */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost = nrterm-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; total_cost = nrterm-&gt;total_cost;<br/></li>
<li>&nbsp; &nbsp; total_rows = nrterm-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We arbitrarily assume that about 10 recursive iterations will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needed, and that we've managed to get a good fix on the cost and output<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * size of each one of them.&nbsp; These are mighty shaky assumptions but it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hard to see how to do better.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; total_cost += <span class="Constant">10</span> * rterm-&gt;total_cost;<br/></li>
<li>&nbsp; &nbsp; total_rows += <span class="Constant">10</span> * rterm-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> per row to account for the costs of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * manipulating the tuplestores.&nbsp; (We don't worry about possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * spill-to-disk costs.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; total_cost += <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> * total_rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; runion-&gt;startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; runion-&gt;total_cost = total_cost;<br/></li>
<li>&nbsp; &nbsp; runion-&gt;rows = total_rows;<br/></li>
<li>&nbsp; &nbsp; runion-&gt;pathtarget-&gt;width = Max(nrterm-&gt;pathtarget-&gt;width,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rterm-&gt;pathtarget-&gt;width);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1884" title="optimizer/path/costsize.c:1884">cost_tuplesort</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Determines and returns the cost of sorting a relation using tuplesort,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; not including the cost of reading the input data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the total volume of data to sort is less than sort_mem, we will do<br/></li>
<li></span><span class="Comment"> * an in-memory sort, which requires no I/O and about t*log2(t) tuple<br/></li>
<li></span><span class="Comment"> * comparisons for t tuples.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the total volume exceeds sort_mem, we switch to a tape-style <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a><br/></li>
<li></span><span class="Comment"> * algorithm.&nbsp; There will still be about t*log2(t) tuple comparisons in<br/></li>
<li></span><span class="Comment"> * total, but we will also need to write and read each tuple once per<br/></li>
<li></span><span class="Comment"> * <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> pass.&nbsp; We expect about ceil(logM(r)) <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> passes where r is the<br/></li>
<li></span><span class="Comment"> * number of initial runs formed and M is the <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> order used by tuplesort.c.<br/></li>
<li></span><span class="Comment"> * Since the average initial run should be about sort_mem, we have<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; disk traffic = 2 * relsize * ceil(logM(p / sort_mem))<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; cpu = comparison_cost * t * log2(t)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the sort is bounded (i.e., only the first k result tuples are needed)<br/></li>
<li></span><span class="Comment"> * and k tuples can fit into sort_mem, we use a heap method that keeps only<br/></li>
<li></span><span class="Comment"> * k tuples in the heap; this will require about t*log2(k) tuple comparisons.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The disk traffic is assumed to be 3/4ths sequential and 1/4th random<br/></li>
<li></span><span class="Comment"> * accesses (</span><span class="Todo">XXX</span><span class="Comment"> can't we refine that guess?)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * By default, we <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> two operator evals per tuple comparison, which should<br/></li>
<li></span><span class="Comment"> * be in the right ballpark in most cases.&nbsp; The caller can tweak this by<br/></li>
<li></span><span class="Comment"> * specifying nonzero comparison_cost; typically that's used for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> extra<br/></li>
<li></span><span class="Comment"> * work that has to be done to prepare the inputs to the comparison operators.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'tuples' is the number of tuples in the relation<br/></li>
<li></span><span class="Comment"> * 'width' is the average tuple width in bytes<br/></li>
<li></span><span class="Comment"> * 'comparison_cost' is the extra cost per comparison, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * 'sort_mem' is the number of kilobytes of work memory allowed for the sort<br/></li>
<li></span><span class="Comment"> * 'limit_tuples' is the bound on the number of output tuples; -1 if no bound<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1884">&#x200c;</a></span><span class="linkable">cost_tuplesort</span>(Cost *startup_cost, Cost *run_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> tuples, <span class="Type">int</span> width,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Cost comparison_cost, <span class="Type">int</span> sort_mem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> limit_tuples)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; input_bytes = <a href="#L6342" title="optimizer/path/costsize.c:6342">relation_byte_size</a>(tuples, width);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; output_bytes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; output_tuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; sort_mem_bytes = sort_mem * <span class="Constant">1024L</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We want to be sure the cost of a sort is never estimated as zero, even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if passed-in tuple count is zero.&nbsp; Besides, mustn't do log(0)...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tuples &lt; <span class="Constant">2.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuples = <span class="Constant">2.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Include the default cost-per-comparison */<br/></li>
<li></span>&nbsp; &nbsp; comparison_cost += <span class="Constant">2.0</span> * <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do we have a useful LIMIT? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (limit_tuples &gt; <span class="Constant">0</span> &amp;&amp; limit_tuples &lt; tuples)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; output_tuples = limit_tuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; output_bytes = <a href="#L6342" title="optimizer/path/costsize.c:6342">relation_byte_size</a>(output_tuples, width);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; output_tuples = tuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; output_bytes = input_bytes;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (output_bytes &gt; sort_mem_bytes)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We'll have to use a disk-based sort of all the tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; npages = ceil(input_bytes / BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nruns = input_bytes / sort_mem_bytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; mergeorder = <a href="../../utils/sort/tuplesort.c.html#L1804" title="utils/sort/tuplesort.c:1804">tuplesort_merge_order</a>(sort_mem_bytes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; log_runs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; npageaccesses;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * CPU costs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Assume about N log2 N comparisons<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *startup_cost = comparison_cost * tuples * <a href="#L102" title="optimizer/path/costsize.c:102">LOG2</a>(tuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Disk costs */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute logM(r) as log(r) / log(M) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nruns &gt; mergeorder)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log_runs = ceil(log(nruns) / log(mergeorder));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log_runs = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; npageaccesses = <span class="Constant">2.0</span> * npages * log_runs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Assume 3/4ths of accesses are sequential, 1/4th are not */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *startup_cost += npageaccesses *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L119" title="optimizer/path/costsize.c:119">seq_page_cost</a> * <span class="Constant">0.75</span> + <a href="#L120" title="optimizer/path/costsize.c:120">random_page_cost</a> * <span class="Constant">0.25</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (tuples &gt; <span class="Constant">2</span> * output_tuples || input_bytes &gt; sort_mem_bytes)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We'll use a bounded heap-sort keeping just K tuples in memory, for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a total number of tuple comparisons of N log2 K; but the constant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * factor is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> higher than for quicksort.&nbsp; Tweak it so that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cost curve is continuous at the crossover point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *startup_cost = comparison_cost * tuples * <a href="#L102" title="optimizer/path/costsize.c:102">LOG2</a>(<span class="Constant">2.0</span> * output_tuples);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We'll use plain quicksort on all the input tuples */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *startup_cost = comparison_cost * tuples * <a href="#L102" title="optimizer/path/costsize.c:102">LOG2</a>(tuples);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> a small amount (arbitrarily set <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to operator cost) per<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * extracted tuple.&nbsp; We don't <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> because a Sort node<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't do qual-checking or projection, so it has less overhead than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * most plan nodes.&nbsp; Note it's correct to use tuples not output_tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here --- the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> LIMIT will pro-rate the run cost so we'd be double<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * counting the LIMIT otherwise.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *run_cost = <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> * tuples;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1986" title="optimizer/path/costsize.c:1986">cost_incremental_sort</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Determines and returns the cost of sorting a relation incrementally, when<br/></li>
<li></span><span class="Comment"> *&nbsp; the input path is presorted by a prefix of the pathkeys.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'presorted_keys' is the number of leading pathkeys by which the input path<br/></li>
<li></span><span class="Comment"> * is sorted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We estimate the number of groups into which the relation is divided by the<br/></li>
<li></span><span class="Comment"> * leading pathkeys, and then calculate the cost of sorting a single group<br/></li>
<li></span><span class="Comment"> * with tuplesort using <a href="#L1884" title="optimizer/path/costsize.c:1884">cost_tuplesort</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1986">&#x200c;</a></span><span class="linkable">cost_incremental_sort</span>(Path *path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlannerInfo *root, List *pathkeys, <span class="Type">int</span> presorted_keys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cost input_startup_cost, Cost input_total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> input_tuples, <span class="Type">int</span> width, Cost comparison_cost, <span class="Type">int</span> sort_mem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> limit_tuples)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; run_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_run_cost = input_total_cost - input_startup_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; group_tuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_groups;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; group_startup_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; group_run_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; group_input_run_cost;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *presortedExprs = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; unknown_varno = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(presorted_keys &gt; <span class="Constant">0</span> &amp;&amp; presorted_keys &lt; list_length(pathkeys));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We want to be sure the cost of a sort is never estimated as zero, even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if passed-in tuple count is zero.&nbsp; Besides, mustn't do log(0)...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (input_tuples &lt; <span class="Constant">2.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; input_tuples = <span class="Constant">2.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Default estimate of number of groups, capped to one group per row. */<br/></li>
<li></span>&nbsp; &nbsp; input_groups = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(input_tuples, DEFAULT_NUM_DISTINCT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Extract presorted keys as list of expressions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to be careful about Vars containing &quot;varno 0&quot; which might have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * been introduced by <a href="../prep/prepunion.c.html#L1546" title="optimizer/prep/prepunion.c:1546">generate_append_tlist</a>, which would confuse<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/selfuncs.c.html#L3416" title="utils/adt/selfuncs.c:3416">estimate_num_groups</a> (in fact it'd fail for such expressions). See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../prep/prepunion.c.html#L230" title="optimizer/prep/prepunion.c:230">recurse_set_operations</a> which has to deal with the same issue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unlike <a href="../prep/prepunion.c.html#L230" title="optimizer/prep/prepunion.c:230">recurse_set_operations</a> we can't access the original target list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here, and even if we could it's not very clear how useful would that be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for a set operation combining multiple tables. So we simply detect if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> expressions with &quot;varno 0&quot; and use the default<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * DEFAULT_NUM_DISTINCT in that case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We might also use either 1.0 (a single group) or input_tuples (each row<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * being a separate group), pretty much the worst and best case for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * incremental sort. But those are extreme cases and using something in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * between seems reasonable. Furthermore, <a href="../prep/prepunion.c.html#L1546" title="optimizer/prep/prepunion.c:1546">generate_append_tlist</a> is used<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for set operations, which are likely to produce mostly unique output<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anyway - from that standpoint the DEFAULT_NUM_DISTINCT is defensive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * while maintaining <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> startup cost.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, pathkeys)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *key = (PathKey *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EquivalenceMember *member = (EquivalenceMember *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; linitial(key-&gt;pk_eclass-&gt;ec_members);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if the expression contains Var with &quot;varno 0&quot; so that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't call <a href="../../utils/adt/selfuncs.c.html#L3416" title="utils/adt/selfuncs.c:3416">estimate_num_groups</a> in that case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(<span class="Constant">0</span>, <a href="../util/var.c.html#L108" title="optimizer/util/var.c:108">pull_varnos</a>(root, (Node *) member-&gt;em_expr)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unknown_varno = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* expression not containing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> Vars with &quot;varno 0&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; presortedExprs = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(presortedExprs, member-&gt;em_expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (foreach_current_index(l) + <span class="Constant">1</span> &gt;= presorted_keys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Estimate the number of groups with <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> presorted keys. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!unknown_varno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; input_groups = <a href="../../utils/adt/selfuncs.c.html#L3416" title="utils/adt/selfuncs.c:3416">estimate_num_groups</a>(root, presortedExprs, input_tuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; group_tuples = input_tuples / input_groups;<br/></li>
<li>&nbsp; &nbsp; group_input_run_cost = input_run_cost / input_groups;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate the average cost of sorting of one group where presorted keys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1884" title="optimizer/path/costsize.c:1884">cost_tuplesort</a>(&amp;group_startup_cost, &amp;group_run_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; group_tuples, width, comparison_cost, sort_mem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; limit_tuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Startup cost of incremental sort is the startup cost of its first group<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plus the cost of its input.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost = group_startup_cost + input_startup_cost +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; group_input_run_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * After we started producing tuples from the first group, the cost of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * producing all the tuples is given by the cost to finish processing this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * group, plus the total cost to process the remaining groups, plus the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * remaining cost of input.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; run_cost = group_run_cost + (group_run_cost + group_startup_cost) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (input_groups - <span class="Constant">1</span>) + group_input_run_cost * (input_groups - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Incremental sort adds some overhead by itself. Firstly, it has to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * detect the sort groups. This is roughly <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to one extra copy and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comparison per tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; run_cost += (<a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> + comparison_cost) * input_tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Additionally, we <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> double <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> for each input group to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * account for the <a href="../../utils/sort/tuplesort.c.html#L1039" title="utils/sort/tuplesort.c:1039">tuplesort_reset</a> that's performed after each group.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; run_cost += <span class="Constant">2.0</span> * <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> * input_groups;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;rows = input_tuples;<br/></li>
<li>&nbsp; &nbsp; path-&gt;startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;total_cost = startup_cost + run_cost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2124" title="optimizer/path/costsize.c:2124">cost_sort</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Determines and returns the cost of sorting a relation, including<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the cost of reading the input data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: some callers currently pass NIL for pathkeys because they<br/></li>
<li></span><span class="Comment"> * can't conveniently supply the sort keys.&nbsp; Since this routine doesn't<br/></li>
<li></span><span class="Comment"> * currently do anything with pathkeys anyway, that doesn't matter...<br/></li>
<li></span><span class="Comment"> * but if it ever does, it should react gracefully to lack of key data.<br/></li>
<li></span><span class="Comment"> * (Actually, the thing we'd most likely be interested in is just the number<br/></li>
<li></span><span class="Comment"> * of sort keys, which all callers *could* supply.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2124">&#x200c;</a></span><span class="linkable">cost_sort</span>(Path *path, PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *pathkeys, Cost input_cost, <span class="Type">double</span> tuples, <span class="Type">int</span> width,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cost comparison_cost, <span class="Type">int</span> sort_mem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> limit_tuples)<br/></li>
<li><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; run_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1884" title="optimizer/path/costsize.c:1884">cost_tuplesort</a>(&amp;startup_cost, &amp;run_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tuples, width,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; comparison_cost, sort_mem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; limit_tuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L139" title="optimizer/path/costsize.c:139">enable_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += <a href="#L130" title="optimizer/path/costsize.c:130">disable_cost</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; startup_cost += input_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;rows = tuples;<br/></li>
<li>&nbsp; &nbsp; path-&gt;startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;total_cost = startup_cost + run_cost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2155" title="optimizer/path/costsize.c:2155">append_nonpartial_cost</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Estimate the cost of the non-partial paths in a Parallel Append.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; The non-partial paths are assumed to be the first &quot;numpaths&quot; paths<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; from the subpaths list, and to be in order of decreasing cost.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Cost<br/></li>
<li><a id="L2155">&#x200c;</a><span class="linkable">append_nonpartial_cost</span>(List *subpaths, <span class="Type">int</span> numpaths, <span class="Type">int</span> parallel_workers)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp;&nbsp; *costarr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arrlen;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path_index;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_index;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numpaths == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Array length is number of workers or number of relevant paths,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whichever is less.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; arrlen = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(parallel_workers, numpaths);<br/></li>
<li>&nbsp; &nbsp; costarr = (Cost *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Cost) * arrlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The first few paths will each be claimed by a different worker. */<br/></li>
<li></span>&nbsp; &nbsp; path_index = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(cell, subpaths)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *subpath = (Path *) lfirst(cell);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path_index == arrlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; costarr[path_index++] = subpath-&gt;total_cost;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since subpaths are sorted by decreasing cost, the last one will have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the minimum cost.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; min_index = arrlen - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For each of the remaining subpaths, add its cost to the array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with minimum cost.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; for_each_cell(l, subpaths, cell)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *subpath = (Path *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Consider only the non-partial paths */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path_index++ == numpaths)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; costarr[min_index] += subpath-&gt;total_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update the new min cost array index */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; min_index = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; arrlen; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (costarr[i] &lt; costarr[min_index])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_index = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return the highest cost from the array */<br/></li>
<li></span>&nbsp; &nbsp; max_index = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; arrlen; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (costarr[i] &gt; costarr[max_index])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_index = i;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> costarr[max_index];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2231" title="optimizer/path/costsize.c:2231">cost_append</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Determines and returns the cost of an Append node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2231">&#x200c;</a></span><span class="linkable">cost_append</span>(AppendPath *apath)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; apath-&gt;path.startup_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; apath-&gt;path.total_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; apath-&gt;path.rows = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (apath-&gt;subpaths == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!apath-&gt;path.parallel_aware)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pathkeys = apath-&gt;path.pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pathkeys == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *firstsubpath = (Path *) linitial(apath-&gt;subpaths);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For an unordered, non-parallel-aware Append we take the startup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cost as the startup cost of the first subpath.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; apath-&gt;path.startup_cost = firstsubpath-&gt;startup_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute rows and costs as sums of subplan rows and costs. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, apath-&gt;subpaths)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *subpath = (Path *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; apath-&gt;path.rows += subpath-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; apath-&gt;path.total_cost += subpath-&gt;total_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For an ordered, non-parallel-aware Append we take the startup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cost as the sum of the subpath startup costs.&nbsp; This ensures<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that we don't underestimate the startup cost when a query's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * LIMIT is such that several of the children have to be run to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * satisfy it.&nbsp; This might be overkill --- another plausible hack<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would be to take the Append's startup cost as the maximum of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the child startup costs.&nbsp; But we don't want to risk believing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that an ORDER BY LIMIT query can be satisfied at small cost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when the first child has small startup cost but later ones<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't.&nbsp; (If we had the ability to deal with nonlinear cost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interpolation for partial retrievals, we would not need to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so conservative about this.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This case is also different from the above in that we have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * account for possibly injecting sorts into subpaths that aren't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * natively ordered.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, apath-&gt;subpaths)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *subpath = (Path *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp; &nbsp; sort_path;&nbsp; &nbsp; <span class="Comment">/* dummy for result of <a href="#L2124" title="optimizer/path/costsize.c:2124">cost_sort</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="pathkeys.c.html#L341" title="optimizer/path/pathkeys.c:341">pathkeys_contained_in</a>(pathkeys, subpath-&gt;pathkeys))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We'll need to insert a Sort node, so include costs for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that.&nbsp; We can use the parent's LIMIT if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, since we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * certainly won't <a href="../../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a> more than that many tuples from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> child.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2124" title="optimizer/path/costsize.c:2124">cost_sort</a>(&amp;sort_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Comment">/* doesn't currently need root */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;pathtarget-&gt;width,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0.0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; apath-&gt;limit_tuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath = &amp;sort_path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; apath-&gt;path.rows += subpath-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; apath-&gt;path.startup_cost += subpath-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; apath-&gt;path.total_cost += subpath-&gt;total_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* parallel-aware */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; parallel_divisor = <a href="#L6363" title="optimizer/path/costsize.c:6363">get_parallel_divisor</a>(&amp;apath-&gt;path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Parallel-aware Append never produces ordered output. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(apath-&gt;path.pathkeys == NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Calculate startup cost. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, apath-&gt;subpaths)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *subpath = (Path *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Append will start returning tuples when the child node having<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lowest startup cost is done setting up. We consider only the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first few subplans that immediately get a worker assigned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; apath-&gt;path.startup_cost = subpath-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (i &lt; apath-&gt;path.parallel_workers)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; apath-&gt;path.startup_cost = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(apath-&gt;path.startup_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subpath-&gt;startup_cost);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Apply parallel divisor to subpaths.&nbsp; Scale the number of rows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for each partial subpath based on the ratio of the parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * divisor originally used for the subpath to the one we adopted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also add the cost of partial paths to the total cost, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ignore non-partial paths for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; apath-&gt;first_partial_path)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; apath-&gt;path.rows += subpath-&gt;rows / parallel_divisor;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; subpath_parallel_divisor;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath_parallel_divisor = <a href="#L6363" title="optimizer/path/costsize.c:6363">get_parallel_divisor</a>(subpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; apath-&gt;path.rows += subpath-&gt;rows * (subpath_parallel_divisor /<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parallel_divisor);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; apath-&gt;path.total_cost += subpath-&gt;total_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; apath-&gt;path.rows = <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(apath-&gt;path.rows);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add cost for non-partial subpaths. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; apath-&gt;path.total_cost +=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2155" title="optimizer/path/costsize.c:2155">append_nonpartial_cost</a>(apath-&gt;subpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; apath-&gt;first_partial_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; apath-&gt;path.parallel_workers);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Although Append does not do <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> selection or projection, it's not free;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * add a small per-tuple overhead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; apath-&gt;path.total_cost +=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> * <a href="#L109" title="optimizer/path/costsize.c:109">APPEND_CPU_COST_MULTIPLIER</a> * apath-&gt;path.rows;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2404" title="optimizer/path/costsize.c:2404">cost_merge_append</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Determines and returns the cost of a MergeAppend node.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * MergeAppend merges several pre-sorted input streams, using a heap that<br/></li>
<li></span><span class="Comment"> * at <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> given instant holds the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple from each stream.&nbsp; If there<br/></li>
<li></span><span class="Comment"> * are N streams, we need about N*log2(N) tuple comparisons to construct<br/></li>
<li></span><span class="Comment"> * the heap at startup, and then for each output tuple, about log2(N)<br/></li>
<li></span><span class="Comment"> * comparisons to replace the top entry.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (The effective value of N will drop once some of the input streams are<br/></li>
<li></span><span class="Comment"> * exhausted, but it seems unlikely to be worth trying to account for that.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The heap is never spilled to disk, since we assume N is not very large.<br/></li>
<li></span><span class="Comment"> * So this is much simpler than <a href="#L2124" title="optimizer/path/costsize.c:2124">cost_sort</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As in <a href="#L2124" title="optimizer/path/costsize.c:2124">cost_sort</a>, we <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> two operator evals per tuple comparison.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'pathkeys' is a list of sort keys<br/></li>
<li></span><span class="Comment"> * 'n_streams' is the number of input streams<br/></li>
<li></span><span class="Comment"> * 'input_startup_cost' is the sum of the input streams' startup costs<br/></li>
<li></span><span class="Comment"> * 'input_total_cost' is the sum of the input streams' total costs<br/></li>
<li></span><span class="Comment"> * 'tuples' is the number of tuples in all the streams<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2404">&#x200c;</a></span><span class="linkable">cost_merge_append</span>(Path *path, PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *pathkeys, <span class="Type">int</span> n_streams,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cost input_startup_cost, Cost input_total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> tuples)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; run_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; comparison_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; N;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; logN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Avoid log(0)...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; N = (n_streams &lt; <span class="Constant">2</span>) ? <span class="Constant">2.0</span> : (<span class="Type">double</span>) n_streams;<br/></li>
<li>&nbsp; &nbsp; logN = <a href="#L102" title="optimizer/path/costsize.c:102">LOG2</a>(N);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assumed cost per tuple comparison */<br/></li>
<li></span>&nbsp; &nbsp; comparison_cost = <span class="Constant">2.0</span> * <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Heap creation cost */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += comparison_cost * N * logN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Per-tuple heap maintenance cost */<br/></li>
<li></span>&nbsp; &nbsp; run_cost += tuples * comparison_cost * logN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Although MergeAppend does not do <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> selection or projection, it's not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * free; add a small per-tuple overhead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; run_cost += <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> * <a href="#L109" title="optimizer/path/costsize.c:109">APPEND_CPU_COST_MULTIPLIER</a> * tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;startup_cost = startup_cost + input_startup_cost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;total_cost = startup_cost + run_cost + input_total_cost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2453" title="optimizer/path/costsize.c:2453">cost_material</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Determines and returns the cost of materializing a relation, including<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the cost of reading the input data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the total volume of data to materialize exceeds <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>, we will need<br/></li>
<li></span><span class="Comment"> * to write it to disk, so the cost is much higher in that case.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that here we are estimating the costs for the first scan of the<br/></li>
<li></span><span class="Comment"> * relation, so the materialization is all overhead --- <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> savings will<br/></li>
<li></span><span class="Comment"> * occur only on rescan, which is estimated in <a href="#L4528" title="optimizer/path/costsize.c:4528">cost_rescan</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2453">&#x200c;</a></span><span class="linkable">cost_material</span>(Path *path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cost input_startup_cost, Cost input_total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> tuples, <span class="Type">int</span> width)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost = input_startup_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; run_cost = input_total_cost - input_startup_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nbytes = <a href="#L6342" title="optimizer/path/costsize.c:6342">relation_byte_size</a>(tuples, width);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; work_mem_bytes = <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a> * <span class="Constant">1024L</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;rows = tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Whether spilling or not, <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> 2x <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> per tuple to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reflect bookkeeping overhead.&nbsp; (This rate must be more than what<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L4528" title="optimizer/path/costsize.c:4528">cost_rescan</a> charges for materialize, ie, <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> per tuple;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if it is exactly the same then there will be a cost tie between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nestloop with A outer, materialized B inner and nestloop with B outer,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * materialized A inner.&nbsp; The extra cost ensures we'll prefer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * materializing the smaller rel.)&nbsp; &nbsp; Note that this is normally a good deal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * less than <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a>; which is OK because a Material plan node<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't do qual-checking or projection, so it's got less overhead than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * most plan nodes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; run_cost += <span class="Constant">2</span> * <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> * tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we will spill to disk, <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> at the rate of <a href="#L119" title="optimizer/path/costsize.c:119">seq_page_cost</a> per page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This cost is assumed to be evenly spread through the plan run phase,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which isn't exactly accurate but our cost model doesn't allow for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nonuniform costs within the run phase.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nbytes &gt; work_mem_bytes)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; npages = ceil(nbytes / BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; run_cost += <a href="#L119" title="optimizer/path/costsize.c:119">seq_page_cost</a> * npages;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;total_cost = startup_cost + run_cost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2509" title="optimizer/path/costsize.c:2509">cost_memoize_rescan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Determines the estimated cost of rescanning a Memoize node.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In order to estimate this, we must gain knowledge of how often we expect to<br/></li>
<li></span><span class="Comment"> * be called and how many distinct sets of parameters we are likely to be<br/></li>
<li></span><span class="Comment"> * called with. If we expect a good cache hit ratio, then we can set our<br/></li>
<li></span><span class="Comment"> * costs to account for that hit ratio, plus a little <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of cost for the<br/></li>
<li></span><span class="Comment"> * caching itself.&nbsp; Caching will not work out well if we expect to be called<br/></li>
<li></span><span class="Comment"> * with too many distinct parameter <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; The worst-case here is that we<br/></li>
<li></span><span class="Comment"> * never see <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> parameter value twice, in which case we'd never get a cache<br/></li>
<li></span><span class="Comment"> * hit and caching would be a complete waste of effort.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2509">&#x200c;</a></span><span class="linkable">cost_memoize_rescan</span>(PlannerInfo *root, MemoizePath *mpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cost *rescan_startup_cost, Cost *rescan_total_cost)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EstimationInfo estinfo;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; input_startup_cost = mpath-&gt;subpath-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; input_total_cost = mpath-&gt;subpath-&gt;total_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; tuples = mpath-&gt;subpath-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; calls = mpath-&gt;calls;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; width = mpath-&gt;subpath-&gt;pathtarget-&gt;width;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; hash_mem_bytes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; est_entry_bytes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; est_cache_entries;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; ndistinct;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; evict_ratio;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; hit_ratio;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; total_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* available cache space */<br/></li>
<li></span>&nbsp; &nbsp; hash_mem_bytes = <a href="../../executor/nodeHash.c.html#L3595" title="executor/nodeHash.c:3595">get_hash_memory_limit</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set the number of bytes each cache entry should consume in the cache.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To provide us with better estimations on how many cache entries we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * store at once, we make a call to the executor here to ask it what<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory overheads there are for a single cache entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; est_entry_bytes = <a href="#L6342" title="optimizer/path/costsize.c:6342">relation_byte_size</a>(tuples, width) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/nodeMemoize.c.html#L1172" title="executor/nodeMemoize.c:1172">ExecEstimateCacheEntryOverheadBytes</a>(tuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* include the estimated width for the cache keys */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, mpath-&gt;param_exprs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; est_entry_bytes += <a href="#L6294" title="optimizer/path/costsize.c:6294">get_expr_width</a>(root, (Node *) lfirst(lc));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* estimate on the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> limit of cache entries we can hold at once */<br/></li>
<li></span>&nbsp; &nbsp; est_cache_entries = floor(hash_mem_bytes / est_entry_bytes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* estimate on the distinct number of parameter <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; ndistinct = <a href="../../utils/adt/selfuncs.c.html#L3416" title="utils/adt/selfuncs.c:3416">estimate_num_groups</a>(root, mpath-&gt;param_exprs, calls, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;estinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When the estimation fell back on using a default value, it's a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * risky to assume that it's ok to use a Memoize node.&nbsp; The use of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * default could cause us to use a Memoize node when it's really<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inappropriate to do so.&nbsp; If we see that this has been done, then we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assume that every call will have unique parameters, which will almost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * certainly mean a MemoizePath will never survive <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((estinfo.flags &amp; SELFLAG_USED_DEFAULT) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ndistinct = calls;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we've already estimated the maximum number of entries we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * store at once and know the estimated number of distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> we'll be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * called with, we'll take this opportunity to set the path's est_entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This will ultimately determine the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table size that the executor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will use.&nbsp; If we leave this at zero, the executor will just choose the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * size itself.&nbsp; Really this is not the right place to do this, but it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * convenient since everything is already calculated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; mpath-&gt;est_entries = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(<a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(ndistinct, est_cache_entries),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_UINT32_MAX);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When the number of distinct parameter <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> is above the amount we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * store in the cache, then we'll have to evict some entries from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cache.&nbsp; This is not free. Here we estimate how often we'll incur the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cost of that eviction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; evict_ratio = <span class="Constant">1.0</span> - <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(est_cache_entries, ndistinct) / ndistinct;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In order to estimate how costly a single scan will be, we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attempt to estimate what the cache hit ratio will be.&nbsp; To do that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must look at how many scans are estimated in total for this node and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * how many of those scans we expect to get a cache hit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hit_ratio = ((calls - ndistinct) / calls) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (est_cache_entries / Max(ndistinct, est_cache_entries));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(hit_ratio &gt;= <span class="Constant">0</span> &amp;&amp; hit_ratio &lt;= <span class="Constant">1.0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set the total_cost accounting for the expected cache hit ratio.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * also add on a <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> to account for a cache lookup. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will happen regardless of whether it's a cache hit or not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; total_cost = input_total_cost * (<span class="Constant">1.0</span> - hit_ratio) + <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now adjust the total cost to account for cache evictions */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Charge a <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> for evicting the actual cache entry */<br/></li>
<li></span>&nbsp; &nbsp; total_cost += <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> * evict_ratio;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Charge a 10th of <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> to evict every tuple in that entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The per-tuple eviction is really just a <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>, so charging a whole<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> seems a little excessive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; total_cost += <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> / <span class="Constant">10.0</span> * evict_ratio * tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now adjust for storing things in the cache, since that's not free<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * either.&nbsp; Everything must go in the cache.&nbsp; We don't proportion this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * over <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> ratio, just apply it once for the scan.&nbsp; We <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> for the creation of the cache entry and also a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> for each tuple we expect to cache.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; total_cost += <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> + <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> * tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Getting the first row must be also be proportioned according to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expected cache hit ratio.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost = input_startup_cost * (<span class="Constant">1.0</span> - hit_ratio);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Additionally we <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> a <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> to account for cache lookups,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which we'll do regardless of whether it was a cache hit or not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *rescan_startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; *rescan_total_cost = total_cost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2650" title="optimizer/path/costsize.c:2650">cost_agg</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Determines and returns the cost of performing an Agg plan node,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; including the cost of its input.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * aggcosts can be NULL when there are no actual aggregate <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> (i.e.,<br/></li>
<li></span><span class="Comment"> * we are using a hashed Agg node just to do grouping).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: when aggstrategy == AGG_SORTED, caller must ensure that input costs<br/></li>
<li></span><span class="Comment"> * are for appropriately-sorted input.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2650">&#x200c;</a></span><span class="linkable">cost_agg</span>(Path *path, PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AggStrategy aggstrategy, <span class="Type">const</span> AggClauseCosts *aggcosts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> numGroupCols, <span class="Type">double</span> numGroups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *quals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Cost input_startup_cost, Cost input_total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> input_tuples, <span class="Type">double</span> input_width)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; output_tuples;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; total_cost;<br/></li>
<li>&nbsp; &nbsp; AggClauseCosts dummy_aggcosts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use all-zero per-aggregate costs if NULL is passed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (aggcosts == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(aggstrategy == AGG_HASHED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(&amp;dummy_aggcosts, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AggClauseCosts));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggcosts = &amp;dummy_aggcosts;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The transCost.per_tuple component of aggcosts should be charged once<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * per input tuple, corresponding to the costs of evaluating the aggregate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transfns and their input expressions. The finalCost.per_tuple component<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is charged once per output tuple, corresponding to the costs of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * evaluating the finalfns.&nbsp; Startup costs are of course charged but once.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are grouping, we <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> an additional <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> per<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * grouping column per input tuple for grouping comparisons.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We will produce a single output tuple if not grouping, and a tuple per<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * group otherwise.&nbsp; We <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> for each output tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: in this cost model, AGG_SORTED and AGG_HASHED have exactly the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same total CPU cost, but AGG_SORTED has <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> startup cost.&nbsp; If the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * input path is already sorted appropriately, AGG_SORTED should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * preferred (since it has no risk of memory overflow).&nbsp; This will happen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as long as the computed total costs are indeed exactly <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> --- but if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there's roundoff error we might do the wrong thing.&nbsp; So be sure that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the computations below form the same intermediate <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (aggstrategy == AGG_PLAIN)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost = input_total_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += aggcosts-&gt;transCost.startup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += aggcosts-&gt;transCost.per_tuple * input_tuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += aggcosts-&gt;finalCost.startup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += aggcosts-&gt;finalCost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we aren't grouping */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; total_cost = startup_cost + <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; output_tuples = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (aggstrategy == AGG_SORTED || aggstrategy == AGG_MIXED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Here we are able to deliver output on-the-fly */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost = input_startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; total_cost = input_total_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggstrategy == AGG_MIXED &amp;&amp; !<a href="#L141" title="optimizer/path/costsize.c:141">enable_hashagg</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startup_cost += <a href="#L130" title="optimizer/path/costsize.c:130">disable_cost</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_cost += <a href="#L130" title="optimizer/path/costsize.c:130">disable_cost</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* calcs phrased this way to match HASHED case, see note above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; total_cost += aggcosts-&gt;transCost.startup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; total_cost += aggcosts-&gt;transCost.per_tuple * input_tuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; total_cost += (<a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> * numGroupCols) * input_tuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; total_cost += aggcosts-&gt;finalCost.startup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; total_cost += aggcosts-&gt;finalCost.per_tuple * numGroups;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; total_cost += <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> * numGroups;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; output_tuples = numGroups;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must be AGG_HASHED */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost = input_total_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L141" title="optimizer/path/costsize.c:141">enable_hashagg</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startup_cost += <a href="#L130" title="optimizer/path/costsize.c:130">disable_cost</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += aggcosts-&gt;transCost.startup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += aggcosts-&gt;transCost.per_tuple * input_tuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cost of computing <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += (<a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> * numGroupCols) * input_tuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += aggcosts-&gt;finalCost.startup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; total_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; total_cost += aggcosts-&gt;finalCost.per_tuple * numGroups;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cost of retrieving from <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; total_cost += <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> * numGroups;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; output_tuples = numGroups;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add the disk costs of <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> aggregation that spills to disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Groups that go into the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table stay in memory until finalized, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * spilling and reprocessing tuples doesn't incur additional invocations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of transCost or finalCost. Furthermore, the computed <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stored with the spilled tuples, so we don't incur extra invocations of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Hash Agg begins returning tuples after the first batch is complete.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Accrue writes (spilled tuples) to startup_cost and to total_cost;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * accrue reads only to total_cost.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (aggstrategy == AGG_HASHED || aggstrategy == AGG_MIXED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; pages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; pages_written = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; pages_read = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; spill_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; hashentrysize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nbatches;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; mem_limit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; ngroups_limit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_partitions;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; depth;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Estimate number of batches based on the computed limits. If less<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * than or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to one, all groups are expected to fit in memory;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise we expect to spill.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hashentrysize = <a href="../../executor/nodeAgg.c.html#L1694" title="executor/nodeAgg.c:1694">hash_agg_entry_size</a>(list_length(root-&gt;aggtransinfos),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_width,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggcosts-&gt;transitionSpace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/nodeAgg.c.html#L1798" title="executor/nodeAgg.c:1798">hash_agg_set_limits</a>(hashentrysize, numGroups, <span class="Constant">0</span>, &amp;mem_limit,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;ngroups_limit, &amp;num_partitions);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nbatches = Max((numGroups * hashentrysize) / mem_limit,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numGroups / ngroups_limit);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nbatches = Max(ceil(nbatches), <span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; num_partitions = Max(num_partitions, <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The number of partitions can change at different levels of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recursion; but for the purposes of this calculation assume it stays<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constant.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; depth = ceil(log(nbatches) / log(num_partitions));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Estimate number of pages read and written. For each level of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recursion, a tuple must be written and then later read.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pages = <a href="#L6342" title="optimizer/path/costsize.c:6342">relation_byte_size</a>(input_tuples, input_width) / BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pages_written = pages_read = pages * depth;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * HashAgg has somewhat worse IO behavior than Sort on typical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hardware/OS combinations. Account for this with a generic penalty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pages_read *= <span class="Constant">2.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pages_written *= <span class="Constant">2.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += pages_written * <a href="#L120" title="optimizer/path/costsize.c:120">random_page_cost</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; total_cost += pages_written * <a href="#L120" title="optimizer/path/costsize.c:120">random_page_cost</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; total_cost += pages_read * <a href="#L119" title="optimizer/path/costsize.c:119">seq_page_cost</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* account for CPU cost of spilling a tuple and reading it back */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; spill_cost = depth * input_tuples * <span class="Constant">2.0</span> * <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += spill_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; total_cost += spill_cost;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are quals (HAVING quals), account for their cost and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * selectivity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (quals)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; QualCost&nbsp; &nbsp; qual_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4640" title="optimizer/path/costsize.c:4640">cost_qual_eval</a>(&amp;qual_cost, quals, root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += qual_cost.startup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; total_cost += qual_cost.startup + output_tuples * qual_cost.per_tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; output_tuples = <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(output_tuples *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="clausesel.c.html#L100" title="optimizer/path/clausesel.c:100">clauselist_selectivity</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; quals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JOIN_INNER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;rows = output_tuples;<br/></li>
<li>&nbsp; &nbsp; path-&gt;startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;total_cost = total_cost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2854" title="optimizer/path/costsize.c:2854">get_windowclause_startup_tuples</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Estimate how many tuples we'll need to fetch from a WindowAgg's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; subnode <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we can output the first WindowAgg tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * How many tuples need to be read depends on the WindowClause.&nbsp; For example,<br/></li>
<li></span><span class="Comment"> * a WindowClause with no PARTITION BY and no ORDER BY requires that all<br/></li>
<li></span><span class="Comment"> * subnode tuples are read and aggregated <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the WindowAgg can output<br/></li>
<li></span><span class="Comment"> * anything.&nbsp; If there's a PARTITION BY, then we only need to look at tuples<br/></li>
<li></span><span class="Comment"> * in the first partition.&nbsp; Here we attempt to estimate just how many<br/></li>
<li></span><span class="Comment"> * 'input_tuples' the WindowAgg will need to read for the given WindowClause<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the first tuple can be output.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L2854">&#x200c;</a></span><span class="linkable">get_windowclause_startup_tuples</span>(PlannerInfo *root, WindowClause *wc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> input_tuples)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frameOptions = wc-&gt;frameOptions;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; partition_tuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; return_tuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; peer_tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, figure out how many partitions there are likely to be and set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partition_tuples according to that estimate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (wc-&gt;partitionClause != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; num_partitions;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *partexprs = <a href="../util/tlist.c.html#L392" title="optimizer/util/tlist.c:392">get_sortgrouplist_exprs</a>(wc-&gt;partitionClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;targetList);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; num_partitions = <a href="../../utils/adt/selfuncs.c.html#L3416" title="utils/adt/selfuncs.c:3416">estimate_num_groups</a>(root, partexprs, input_tuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(partexprs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partition_tuples = input_tuples / num_partitions;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* all tuples belong to the same partition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; partition_tuples = input_tuples;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* estimate the number of tuples in each peer group */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (wc-&gt;orderClause != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; num_groups;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *orderexprs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; orderexprs = <a href="../util/tlist.c.html#L392" title="optimizer/util/tlist.c:392">get_sortgrouplist_exprs</a>(wc-&gt;orderClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;targetList);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* estimate out how many peer groups there are in the partition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; num_groups = <a href="../../utils/adt/selfuncs.c.html#L3416" title="utils/adt/selfuncs.c:3416">estimate_num_groups</a>(root, orderexprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; partition_tuples, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(orderexprs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; peer_tuples = partition_tuples / num_groups;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no ORDER BY so only 1 tuple belongs in each peer group */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; peer_tuples = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_END_UNBOUNDED_FOLLOWING)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* include all partition rows */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; return_tuples = partition_tuples;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_END_CURRENT_ROW)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_ROWS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just count the current row */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return_tuples = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (frameOptions &amp; (FRAMEOPTION_RANGE | FRAMEOPTION_GROUPS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When in <a href="../../regex/regcomp.c.html#L339" title="regex/regcomp.c:339">RANGE</a>/GROUPS mode, it's more complex.&nbsp; If there's no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ORDER BY, then all rows in the partition are peers, otherwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll need to read the first group of peers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (wc-&gt;orderClause == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return_tuples = partition_tuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return_tuples = peer_tuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Something new we don't support yet?&nbsp; This needs attention.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We'll just return 1.0 in the meantime.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return_tuples = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_END_OFFSET_PRECEDING)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * BETWEEN ... AND N PRECEDING will only need to read the WindowAgg's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subnode after N ROWS/RANGES/GROUPS.&nbsp; N can be 0, but not negative,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so we'll just assume only the current row needs to be read to fetch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the first WindowAgg row.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; return_tuples = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_END_OFFSET_FOLLOWING)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Const&nbsp; &nbsp; &nbsp;&nbsp; *endOffset = (Const *) wc-&gt;endOffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; end_offset_value;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* try and figure out the value specified in the endOffset. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(endOffset, Const))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (endOffset-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NULLs are not allowed, but currently, there's no code to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * error out if there's a NULL Const.&nbsp; We'll only discover<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this during execution.&nbsp; For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, just pretend everything is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fine and assume that just the first row/<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>/group will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_offset_value = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (endOffset-&gt;consttype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT2OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_offset_value =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">double</span>) DatumGetInt16(endOffset-&gt;constvalue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT4OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_offset_value =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">double</span>) DatumGetInt32(endOffset-&gt;constvalue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT8OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_offset_value =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">double</span>) DatumGetInt64(endOffset-&gt;constvalue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_offset_value =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partition_tuples / peer_tuples *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DEFAULT_INEQ_SEL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When the end bound is not a Const, we'll just need to guess. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just make use of DEFAULT_INEQ_SEL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_offset_value =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partition_tuples / peer_tuples * DEFAULT_INEQ_SEL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_ROWS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* include the N FOLLOWING and the current row */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return_tuples = end_offset_value + <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (frameOptions &amp; (FRAMEOPTION_RANGE | FRAMEOPTION_GROUPS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* include N FOLLOWING ranges/group and the initial <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>/group */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return_tuples = peer_tuples * (end_offset_value + <span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Something new we don't support yet?&nbsp; This needs attention.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We'll just return 1.0 in the meantime.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return_tuples = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Something new we don't support yet?&nbsp; This needs attention.&nbsp; We'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just return 1.0 in the meantime.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; return_tuples = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (wc-&gt;partitionClause != NIL || wc-&gt;orderClause != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Cap the return value to the estimated partition tuples and account<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for the extra tuple WindowAgg will need to read to confirm the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple does not belong to the same partition or peer group.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; return_tuples = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(return_tuples + <span class="Constant">1.0</span>, partition_tuples);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Cap the return value so it's never higher than the expected tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the partition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; return_tuples = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(return_tuples, partition_tuples);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We needn't worry about <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> EXCLUDE options as those only exclude rows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from being aggregated, not from being read from the WindowAgg's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subnode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(return_tuples);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3068" title="optimizer/path/costsize.c:3068">cost_windowagg</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Determines and returns the cost of performing a WindowAgg plan node,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; including the cost of its input.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Input is assumed already properly sorted.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3068">&#x200c;</a></span><span class="linkable">cost_windowagg</span>(Path *path, PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *windowFuncs, WindowClause *winclause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Cost input_startup_cost, Cost input_total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> input_tuples)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; total_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; startup_tuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numPartCols;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numOrderCols;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; numPartCols = list_length(winclause-&gt;partitionClause);<br/></li>
<li>&nbsp; &nbsp; numOrderCols = list_length(winclause-&gt;orderClause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; startup_cost = input_startup_cost;<br/></li>
<li>&nbsp; &nbsp; total_cost = input_total_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Window <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are assumed to cost their stated execution cost, plus<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the cost of evaluating their input expressions, per tuple.&nbsp; Since they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * may in fact evaluate their inputs at multiple rows during each cycle,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this could be a drastic underestimate; but without a way to know how<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * many rows the window function will fetch, it's hard to do better.&nbsp; In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, it's a good estimate for all the built-in window <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so we'll just do this for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, windowFuncs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WindowFunc *wfunc = lfirst_node(WindowFunc, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; wfunccost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; QualCost&nbsp; &nbsp; argcosts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; argcosts.startup = argcosts.per_tuple = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/plancat.c.html#L2072" title="optimizer/util/plancat.c:2072">add_function_cost</a>(root, wfunc-&gt;winfnoid, (Node *) wfunc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;argcosts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += argcosts.startup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; wfunccost = argcosts.per_tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* also add the input expressions' cost to per-input-row costs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4666" title="optimizer/path/costsize.c:4666">cost_qual_eval_node</a>(&amp;argcosts, (Node *) wfunc-&gt;args, root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += argcosts.startup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; wfunccost += argcosts.per_tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add the filter's cost to per-input-row costs.&nbsp; </span><span class="Todo">XXX</span><span class="Comment"> We should reduce<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * input expression costs according to filter selectivity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4666" title="optimizer/path/costsize.c:4666">cost_qual_eval_node</a>(&amp;argcosts, (Node *) wfunc-&gt;aggfilter, root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += argcosts.startup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; wfunccost += argcosts.per_tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; total_cost += wfunccost * input_tuples;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We also <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> per grouping column per tuple for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * grouping comparisons, plus <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> per tuple for general<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overhead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> this neglects costs of spooling the data to disk when it overflows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>.&nbsp; Sooner or later that should get accounted for.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; total_cost += <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> * (numPartCols + numOrderCols) * input_tuples;<br/></li>
<li>&nbsp; &nbsp; total_cost += <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> * input_tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;rows = input_tuples;<br/></li>
<li>&nbsp; &nbsp; path-&gt;startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;total_cost = total_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, take into account how many tuples we need to read from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subnode in order to produce the first tuple from the WindowAgg.&nbsp; To do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this we proportion the run cost (total cost not including startup cost)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * over the estimated startup tuples.&nbsp; We already included the startup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cost of the subnode, so we only need to do this when the estimated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * startup tuples is above 1.0.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; startup_tuples = <a href="#L2854" title="optimizer/path/costsize.c:2854">get_windowclause_startup_tuples</a>(root, winclause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; input_tuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (startup_tuples &gt; <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;startup_cost += (total_cost - startup_cost) / input_tuples *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (startup_tuples - <span class="Constant">1.0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3163" title="optimizer/path/costsize.c:3163">cost_group</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Determines and returns the cost of performing a Group plan node,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; including the cost of its input.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: caller must ensure that input costs are for appropriately-sorted<br/></li>
<li></span><span class="Comment"> * input.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3163">&#x200c;</a></span><span class="linkable">cost_group</span>(Path *path, PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> numGroupCols, <span class="Type">double</span> numGroups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *quals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Cost input_startup_cost, Cost input_total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> input_tuples)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; output_tuples;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; total_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; output_tuples = numGroups;<br/></li>
<li>&nbsp; &nbsp; startup_cost = input_startup_cost;<br/></li>
<li>&nbsp; &nbsp; total_cost = input_total_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Charge one <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> per comparison per input tuple. We assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all columns get compared at most of the tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; total_cost += <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> * input_tuples * numGroupCols;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are quals (HAVING quals), account for their cost and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * selectivity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (quals)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; QualCost&nbsp; &nbsp; qual_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4640" title="optimizer/path/costsize.c:4640">cost_qual_eval</a>(&amp;qual_cost, quals, root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += qual_cost.startup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; total_cost += qual_cost.startup + output_tuples * qual_cost.per_tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; output_tuples = <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(output_tuples *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="clausesel.c.html#L100" title="optimizer/path/clausesel.c:100">clauselist_selectivity</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; quals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JOIN_INNER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;rows = output_tuples;<br/></li>
<li>&nbsp; &nbsp; path-&gt;startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;total_cost = total_cost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3233" title="optimizer/path/costsize.c:3233">initial_cost_nestloop</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Preliminary estimate of the cost of a nestloop join path.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This must quickly produce <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-bound estimates of the path's startup and<br/></li>
<li></span><span class="Comment"> * total costs.&nbsp; If we are unable to eliminate the proposed path from<br/></li>
<li></span><span class="Comment"> * consideration using the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bounds, <a href="#L3308" title="optimizer/path/costsize.c:3308">final_cost_nestloop</a> will be called<br/></li>
<li></span><span class="Comment"> * to obtain the final estimates.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The exact division of labor between this function and <a href="#L3308" title="optimizer/path/costsize.c:3308">final_cost_nestloop</a><br/></li>
<li></span><span class="Comment"> * is private to them, and represents a tradeoff between speed of the initial<br/></li>
<li></span><span class="Comment"> * estimate and getting a tight <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound.&nbsp; We choose to not examine the<br/></li>
<li></span><span class="Comment"> * join quals here, since that's by far the most expensive part of the<br/></li>
<li></span><span class="Comment"> * calculations.&nbsp; The end result is that CPU-cost considerations must be<br/></li>
<li></span><span class="Comment"> * left for the second phase; and for SEMI/ANTI joins, we must also postpone<br/></li>
<li></span><span class="Comment"> * incorporation of the inner path's run cost.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'workspace' is to be filled with startup_cost, total_cost, and perhaps<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; other data to be used by <a href="#L3308" title="optimizer/path/costsize.c:3308">final_cost_nestloop</a><br/></li>
<li></span><span class="Comment"> * 'jointype' is the type of join to be performed<br/></li>
<li></span><span class="Comment"> * 'outer_path' is the outer input to the join<br/></li>
<li></span><span class="Comment"> * 'inner_path' is the inner input to the join<br/></li>
<li></span><span class="Comment"> * 'extra' contains miscellaneous information about the join<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3233">&#x200c;</a></span><span class="linkable">initial_cost_nestloop</span>(PlannerInfo *root, JoinCostWorkspace *workspace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JoinType jointype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path *outer_path, Path *inner_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JoinPathExtraData *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; run_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; outer_path_rows = outer_path-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; inner_rescan_start_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; inner_rescan_total_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; inner_run_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; inner_rescan_run_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* estimate costs to rescan the inner relation */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4528" title="optimizer/path/costsize.c:4528">cost_rescan</a>(root, inner_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;inner_rescan_start_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;inner_rescan_total_cost);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cost of source data */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: clearly, we must pay both outer and inner paths' startup_cost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we can start returning tuples, so the join's startup cost is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * their sum.&nbsp; We'll also pay the inner path's rescan startup cost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multiple times.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += outer_path-&gt;startup_cost + inner_path-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; run_cost += outer_path-&gt;total_cost - outer_path-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (outer_path_rows &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; run_cost += (outer_path_rows - <span class="Constant">1</span>) * inner_rescan_start_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; inner_run_cost = inner_path-&gt;total_cost - inner_path-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; inner_rescan_run_cost = inner_rescan_total_cost - inner_rescan_start_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (jointype == JOIN_SEMI || jointype == JOIN_ANTI ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; extra-&gt;inner_unique)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * With a SEMI or ANTI join, or if the innerrel is known unique, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * executor will stop after the first match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Getting decent estimates requires inspection of the join quals,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which we choose to postpone to <a href="#L3308" title="optimizer/path/costsize.c:3308">final_cost_nestloop</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Save private data for <a href="#L3308" title="optimizer/path/costsize.c:3308">final_cost_nestloop</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;inner_run_cost = inner_run_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;inner_rescan_run_cost = inner_rescan_run_cost;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Normal case; we'll scan whole input rel for each outer row */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; run_cost += inner_run_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (outer_path_rows &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; run_cost += (outer_path_rows - <span class="Constant">1</span>) * inner_rescan_run_cost;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* CPU costs left for later */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Public result fields */<br/></li>
<li></span>&nbsp; &nbsp; workspace-&gt;startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; workspace-&gt;total_cost = startup_cost + run_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save private data for <a href="#L3308" title="optimizer/path/costsize.c:3308">final_cost_nestloop</a> */<br/></li>
<li></span>&nbsp; &nbsp; workspace-&gt;run_cost = run_cost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3308" title="optimizer/path/costsize.c:3308">final_cost_nestloop</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Final estimate of the cost and result size of a nestloop join path.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'path' is already filled in except for the rows and cost fields<br/></li>
<li></span><span class="Comment"> * 'workspace' is the result from <a href="#L3233" title="optimizer/path/costsize.c:3233">initial_cost_nestloop</a><br/></li>
<li></span><span class="Comment"> * 'extra' contains miscellaneous information about the join<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3308">&#x200c;</a></span><span class="linkable">final_cost_nestloop</span>(PlannerInfo *root, NestPath *path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JoinCostWorkspace *workspace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JoinPathExtraData *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *outer_path = path-&gt;jpath.outerjoinpath;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *inner_path = path-&gt;jpath.innerjoinpath;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; outer_path_rows = outer_path-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; inner_path_rows = inner_path-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost = workspace-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; run_cost = workspace-&gt;run_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; cpu_per_tuple;<br/></li>
<li>&nbsp; &nbsp; QualCost&nbsp; &nbsp; restrict_qual_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; ntuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Protect some assumptions below that rowcounts aren't zero */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (outer_path_rows &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; outer_path_rows = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (inner_path_rows &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inner_path_rows = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark the path with the correct row estimate */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (path-&gt;jpath.path.param_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;jpath.path.rows = path-&gt;jpath.path.param_info-&gt;ppi_rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;jpath.path.rows = path-&gt;jpath.path.parent-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For partial paths, scale row estimate. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (path-&gt;jpath.path.parallel_workers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; parallel_divisor = <a href="#L6363" title="optimizer/path/costsize.c:6363">get_parallel_divisor</a>(&amp;path-&gt;jpath.path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;jpath.path.rows =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(path-&gt;jpath.path.rows / parallel_divisor);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We could include <a href="#L130" title="optimizer/path/costsize.c:130">disable_cost</a> in the preliminary estimate, but that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would amount to optimizing for the case where the join method is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * disabled, which doesn't seem like the way to bet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L142" title="optimizer/path/costsize.c:142">enable_nestloop</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += <a href="#L130" title="optimizer/path/costsize.c:130">disable_cost</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cost of inner-relation source data (we already dealt with outer rel) */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (path-&gt;jpath.jointype == JOIN_SEMI || path-&gt;jpath.jointype == JOIN_ANTI ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; extra-&gt;inner_unique)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * With a SEMI or ANTI join, or if the innerrel is known unique, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * executor will stop after the first match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; inner_run_cost = workspace-&gt;inner_run_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; inner_rescan_run_cost = workspace-&gt;inner_rescan_run_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; outer_matched_rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; outer_unmatched_rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Selectivity inner_scan_frac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For an outer-rel row that has at least one match, we can expect the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inner scan to stop after a fraction 1/(match_count+1) of the inner<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rows, if the matches are evenly distributed.&nbsp; Since they probably<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aren't quite evenly distributed, we apply a fuzz factor of 2.0 to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that fraction.&nbsp; (If we used a larger fuzz factor, we'd have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clamp inner_scan_frac to at most 1.0; but since match_count is at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * least 1, no such clamp is needed <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; outer_matched_rows = rint(outer_path_rows * extra-&gt;semifactors.outer_match_frac);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; outer_unmatched_rows = outer_path_rows - outer_matched_rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inner_scan_frac = <span class="Constant">2.0</span> / (extra-&gt;semifactors.match_count + <span class="Constant">1.0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compute number of tuples processed (not number emitted!).&nbsp; First,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * account for successfully-matched outer rows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ntuples = outer_matched_rows * inner_path_rows * inner_scan_frac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now we need to estimate the actual costs of scanning the inner<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation, which may be quite a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> less than N times inner_run_cost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * due to early scan stops.&nbsp; We consider two cases.&nbsp; If the inner path<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is an indexscan using all the joinquals as indexquals, then an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unmatched outer row results in an indexscan returning no rows,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which is probably quite cheap.&nbsp; Otherwise, the executor will have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to scan the whole inner rel for an unmatched row; not so cheap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L5101" title="optimizer/path/costsize.c:5101">has_indexed_join_quals</a>(path))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Successfully-matched outer rows will only require scanning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inner_scan_frac of the inner relation.&nbsp; In this case, we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> the full inner_run_cost even when that's more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * than inner_rescan_run_cost, because we can assume that <a href="../util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the inner scans ever scan the whole inner relation.&nbsp; So it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * okay to assume that all the inner scan executions can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fractions of the full cost, even if materialization is reducing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the rescan cost.&nbsp; At this writing, it's impossible to get here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for a materialized inner scan, so inner_run_cost and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inner_rescan_run_cost will be the same anyway; but just in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case, use inner_run_cost for the first matched tuple and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inner_rescan_run_cost for additional ones.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; run_cost += inner_run_cost * inner_scan_frac;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (outer_matched_rows &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; run_cost += (outer_matched_rows - <span class="Constant">1</span>) * inner_rescan_run_cost * inner_scan_frac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add the cost of inner-scan executions for unmatched outer rows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We estimate this as the same cost as returning the first tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of a nonempty scan.&nbsp; We consider that these are all rescans,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since we used inner_run_cost once already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; run_cost += outer_unmatched_rows *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inner_rescan_run_cost / inner_path_rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We won't be evaluating <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> quals at all for unmatched rows, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't add them to ntuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Here, a complicating factor is that rescans may be cheaper than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first scans.&nbsp; If we never scan all the way to the end of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inner rel, it might be (depending on the plan type) that we'd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * never pay the whole inner first-scan run cost.&nbsp; However it is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * difficult to estimate whether that will happen (and it could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not happen if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unmatched outer rows!), so be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * conservative and always <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> the whole first-scan cost once.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We consider this <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> to correspond to the first unmatched<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * outer row, unless there isn't one in our estimate, in which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case blame it on the first matched row.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First, count all unmatched join tuples as being processed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntuples += outer_unmatched_rows * inner_path_rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now add the forced full scan, and decrement appropriate count */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; run_cost += inner_run_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (outer_unmatched_rows &gt;= <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_unmatched_rows -= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_matched_rows -= <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add inner run cost for additional outer tuples having matches */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (outer_matched_rows &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; run_cost += outer_matched_rows * inner_rescan_run_cost * inner_scan_frac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add inner run cost for additional unmatched outer tuples */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (outer_unmatched_rows &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; run_cost += outer_unmatched_rows * inner_rescan_run_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Normal-case source costs were included in preliminary estimate */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute number of tuples processed (not number emitted!) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ntuples = outer_path_rows * inner_path_rows;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* CPU costs */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4640" title="optimizer/path/costsize.c:4640">cost_qual_eval</a>(&amp;restrict_qual_cost, path-&gt;jpath.joinrestrictinfo, root);<br/></li>
<li>&nbsp; &nbsp; startup_cost += restrict_qual_cost.startup;<br/></li>
<li>&nbsp; &nbsp; cpu_per_tuple = <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> + restrict_qual_cost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; run_cost += cpu_per_tuple * ntuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* tlist eval costs are paid per output row, not per tuple scanned */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += path-&gt;jpath.path.pathtarget-&gt;cost.startup;<br/></li>
<li>&nbsp; &nbsp; run_cost += path-&gt;jpath.path.pathtarget-&gt;cost.per_tuple * path-&gt;jpath.path.rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;jpath.path.startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;jpath.path.total_cost = startup_cost + run_cost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3514" title="optimizer/path/costsize.c:3514">initial_cost_mergejoin</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Preliminary estimate of the cost of a mergejoin path.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This must quickly produce <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-bound estimates of the path's startup and<br/></li>
<li></span><span class="Comment"> * total costs.&nbsp; If we are unable to eliminate the proposed path from<br/></li>
<li></span><span class="Comment"> * consideration using the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bounds, <a href="#L3745" title="optimizer/path/costsize.c:3745">final_cost_mergejoin</a> will be called<br/></li>
<li></span><span class="Comment"> * to obtain the final estimates.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The exact division of labor between this function and <a href="#L3745" title="optimizer/path/costsize.c:3745">final_cost_mergejoin</a><br/></li>
<li></span><span class="Comment"> * is private to them, and represents a tradeoff between speed of the initial<br/></li>
<li></span><span class="Comment"> * estimate and getting a tight <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound.&nbsp; We choose to not examine the<br/></li>
<li></span><span class="Comment"> * join quals here, except for obtaining the scan selectivity estimate which<br/></li>
<li></span><span class="Comment"> * is really essential (but fortunately, use of caching keeps the cost of<br/></li>
<li></span><span class="Comment"> * getting that down to something reasonable).<br/></li>
<li></span><span class="Comment"> * We also assume that <a href="#L2124" title="optimizer/path/costsize.c:2124">cost_sort</a> is cheap enough to use here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'workspace' is to be filled with startup_cost, total_cost, and perhaps<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; other data to be used by <a href="#L3745" title="optimizer/path/costsize.c:3745">final_cost_mergejoin</a><br/></li>
<li></span><span class="Comment"> * 'jointype' is the type of join to be performed<br/></li>
<li></span><span class="Comment"> * 'mergeclauses' is the list of joinclauses to be used as <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> clauses<br/></li>
<li></span><span class="Comment"> * 'outer_path' is the outer input to the join<br/></li>
<li></span><span class="Comment"> * 'inner_path' is the inner input to the join<br/></li>
<li></span><span class="Comment"> * 'outersortkeys' is the list of sort keys for the outer path<br/></li>
<li></span><span class="Comment"> * 'innersortkeys' is the list of sort keys for the inner path<br/></li>
<li></span><span class="Comment"> * 'extra' contains miscellaneous information about the join<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: outersortkeys and innersortkeys should be NIL if no explicit<br/></li>
<li></span><span class="Comment"> * sort is needed because the respective source path is already ordered.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3514">&#x200c;</a></span><span class="linkable">initial_cost_mergejoin</span>(PlannerInfo *root, JoinCostWorkspace *workspace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JoinType jointype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *mergeclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Path *outer_path, Path *inner_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *outersortkeys, List *innersortkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JoinPathExtraData *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; run_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; outer_path_rows = outer_path-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; inner_path_rows = inner_path-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; inner_run_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; outer_rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inner_rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_skip_rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inner_skip_rows;<br/></li>
<li>&nbsp; &nbsp; Selectivity outerstartsel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outerendsel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; innerstartsel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; innerendsel;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp; &nbsp; sort_path;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dummy for result of <a href="#L2124" title="optimizer/path/costsize.c:2124">cost_sort</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Protect some assumptions below that rowcounts aren't zero */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (outer_path_rows &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; outer_path_rows = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (inner_path_rows &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inner_path_rows = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> join will stop as soon as it exhausts either input stream<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (unless it's an outer join, in which case the outer side has to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scanned all the way anyway).&nbsp; Estimate fraction of the left and right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inputs that will actually need to be scanned.&nbsp; Likewise, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimate the number of rows that will be skipped <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the first join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pair is found, which should be factored into startup cost. We use only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the first (most significant) <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> clause for this purpose. Since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/selfuncs.c.html#L2952" title="utils/adt/selfuncs.c:2952">mergejoinscansel</a>() is a fairly expensive computation, we cache the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * results in the <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> clause RestrictInfo.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (mergeclauses &amp;&amp; jointype != JOIN_FULL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *firstclause = (RestrictInfo *) linitial(mergeclauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *opathkeys;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *ipathkeys;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *opathkey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *ipathkey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MergeScanSelCache *cache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the input pathkeys to determine the sort-order details */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; opathkeys = outersortkeys ? outersortkeys : outer_path-&gt;pathkeys;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ipathkeys = innersortkeys ? innersortkeys : inner_path-&gt;pathkeys;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(opathkeys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ipathkeys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opathkey = (PathKey *) linitial(opathkeys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ipathkey = (PathKey *) linitial(ipathkeys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* debugging check */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (opathkey-&gt;pk_opfamily != ipathkey-&gt;pk_opfamily ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opathkey-&gt;pk_eclass-&gt;ec_collation != ipathkey-&gt;pk_eclass-&gt;ec_collation ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opathkey-&gt;pk_strategy != ipathkey-&gt;pk_strategy ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opathkey-&gt;pk_nulls_first != ipathkey-&gt;pk_nulls_first)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;left and right pathkeys do not match in mergejoin&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the selectivity with caching */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cache = <a href="#L3994" title="optimizer/path/costsize.c:3994">cached_scansel</a>(root, firstclause, opathkey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(firstclause-&gt;left_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_path-&gt;parent-&gt;relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* left side of clause is outer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outerstartsel = cache-&gt;leftstartsel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outerendsel = cache-&gt;leftendsel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; innerstartsel = cache-&gt;rightstartsel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; innerendsel = cache-&gt;rightendsel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* left side of clause is inner */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outerstartsel = cache-&gt;rightstartsel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outerendsel = cache-&gt;rightendsel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; innerstartsel = cache-&gt;leftstartsel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; innerendsel = cache-&gt;leftendsel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (jointype == JOIN_LEFT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jointype == JOIN_ANTI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outerstartsel = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outerendsel = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (jointype == JOIN_RIGHT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jointype == JOIN_RIGHT_ANTI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; innerstartsel = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; innerendsel = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cope with clauseless or full mergejoin */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; outerstartsel = innerstartsel = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; outerendsel = innerendsel = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Convert selectivities to row counts.&nbsp; We force outer_rows and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inner_rows to be at least 1, but the skip_rows estimates can be zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; outer_skip_rows = rint(outer_path_rows * outerstartsel);<br/></li>
<li>&nbsp; &nbsp; inner_skip_rows = rint(inner_path_rows * innerstartsel);<br/></li>
<li>&nbsp; &nbsp; outer_rows = <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(outer_path_rows * outerendsel);<br/></li>
<li>&nbsp; &nbsp; inner_rows = <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(inner_path_rows * innerendsel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(outer_skip_rows &lt;= outer_rows);<br/></li>
<li>&nbsp; &nbsp; Assert(inner_skip_rows &lt;= inner_rows);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Readjust scan selectivities to account for above rounding.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * normally an insignificant effect, but when there are only a few rows in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the inputs, failing to do this makes for a large percentage error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; outerstartsel = outer_skip_rows / outer_path_rows;<br/></li>
<li>&nbsp; &nbsp; innerstartsel = inner_skip_rows / inner_path_rows;<br/></li>
<li>&nbsp; &nbsp; outerendsel = outer_rows / outer_path_rows;<br/></li>
<li>&nbsp; &nbsp; innerendsel = inner_rows / inner_path_rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(outerstartsel &lt;= outerendsel);<br/></li>
<li>&nbsp; &nbsp; Assert(innerstartsel &lt;= innerendsel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cost of source data */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (outersortkeys)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do we need to sort outer? */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2124" title="optimizer/path/costsize.c:2124">cost_sort</a>(&amp;sort_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outersortkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_path-&gt;total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_path_rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_path-&gt;pathtarget-&gt;width,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0.0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += sort_path.startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += (sort_path.total_cost - sort_path.startup_cost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * outerstartsel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; run_cost += (sort_path.total_cost - sort_path.startup_cost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * (outerendsel - outerstartsel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += outer_path-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += (outer_path-&gt;total_cost - outer_path-&gt;startup_cost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * outerstartsel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; run_cost += (outer_path-&gt;total_cost - outer_path-&gt;startup_cost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * (outerendsel - outerstartsel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (innersortkeys)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do we need to sort inner? */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2124" title="optimizer/path/costsize.c:2124">cost_sort</a>(&amp;sort_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; innersortkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inner_path-&gt;total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inner_path_rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inner_path-&gt;pathtarget-&gt;width,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0.0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += sort_path.startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += (sort_path.total_cost - sort_path.startup_cost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * innerstartsel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inner_run_cost = (sort_path.total_cost - sort_path.startup_cost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * (innerendsel - innerstartsel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += inner_path-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += (inner_path-&gt;total_cost - inner_path-&gt;startup_cost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * innerstartsel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inner_run_cost = (inner_path-&gt;total_cost - inner_path-&gt;startup_cost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * (innerendsel - innerstartsel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can't yet determine whether rescanning occurs, or whether<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * materialization of the inner input should be done.&nbsp; The minimum<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possible inner input cost, regardless of rescan and materialization<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * considerations, is inner_run_cost.&nbsp; We include that in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * workspace-&gt;total_cost, but not yet in run_cost.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* CPU costs left for later */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Public result fields */<br/></li>
<li></span>&nbsp; &nbsp; workspace-&gt;startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; workspace-&gt;total_cost = startup_cost + run_cost + inner_run_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save private data for <a href="#L3745" title="optimizer/path/costsize.c:3745">final_cost_mergejoin</a> */<br/></li>
<li></span>&nbsp; &nbsp; workspace-&gt;run_cost = run_cost;<br/></li>
<li>&nbsp; &nbsp; workspace-&gt;inner_run_cost = inner_run_cost;<br/></li>
<li>&nbsp; &nbsp; workspace-&gt;outer_rows = outer_rows;<br/></li>
<li>&nbsp; &nbsp; workspace-&gt;inner_rows = inner_rows;<br/></li>
<li>&nbsp; &nbsp; workspace-&gt;outer_skip_rows = outer_skip_rows;<br/></li>
<li>&nbsp; &nbsp; workspace-&gt;inner_skip_rows = inner_skip_rows;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3745" title="optimizer/path/costsize.c:3745">final_cost_mergejoin</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Final estimate of the cost and result size of a mergejoin path.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike other costsize <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, this routine makes two actual decisions:<br/></li>
<li></span><span class="Comment"> * whether the executor will need to do mark/restore, and whether we should<br/></li>
<li></span><span class="Comment"> * materialize the inner path.&nbsp; It would be logically cleaner to build<br/></li>
<li></span><span class="Comment"> * separate paths testing these alternatives, but that would require repeating<br/></li>
<li></span><span class="Comment"> * most of the cost calculations, which are not all that cheap.&nbsp; Since the<br/></li>
<li></span><span class="Comment"> * choice will not affect output pathkeys or startup cost, only total cost,<br/></li>
<li></span><span class="Comment"> * there is no possibility of wanting to keep more than one path.&nbsp; So it seems<br/></li>
<li></span><span class="Comment"> * best to make the decisions here and record them in the path's<br/></li>
<li></span><span class="Comment"> * skip_mark_restore and materialize_inner fields.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Mark/restore overhead is usually required, but can be skipped if we know<br/></li>
<li></span><span class="Comment"> * that the executor need <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> only one match per outer tuple, and that the<br/></li>
<li></span><span class="Comment"> * mergeclauses are sufficient to identify a match.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We materialize the inner path if we need mark/restore and either the inner<br/></li>
<li></span><span class="Comment"> * path can't support mark/restore, or it's cheaper to use an interposed<br/></li>
<li></span><span class="Comment"> * Material node to handle mark/restore.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'path' is already filled in except for the rows and cost fields and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; skip_mark_restore and materialize_inner<br/></li>
<li></span><span class="Comment"> * 'workspace' is the result from <a href="#L3514" title="optimizer/path/costsize.c:3514">initial_cost_mergejoin</a><br/></li>
<li></span><span class="Comment"> * 'extra' contains miscellaneous information about the join<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3745">&#x200c;</a></span><span class="linkable">final_cost_mergejoin</span>(PlannerInfo *root, MergePath *path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JoinCostWorkspace *workspace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JoinPathExtraData *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *outer_path = path-&gt;jpath.outerjoinpath;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *inner_path = path-&gt;jpath.innerjoinpath;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; inner_path_rows = inner_path-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *mergeclauses = path-&gt;path_mergeclauses;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *innersortkeys = path-&gt;innersortkeys;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost = workspace-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; run_cost = workspace-&gt;run_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; inner_run_cost = workspace-&gt;inner_run_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; outer_rows = workspace-&gt;outer_rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; inner_rows = workspace-&gt;inner_rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; outer_skip_rows = workspace-&gt;outer_skip_rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; inner_skip_rows = workspace-&gt;inner_skip_rows;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; cpu_per_tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bare_inner_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mat_inner_cost;<br/></li>
<li>&nbsp; &nbsp; QualCost&nbsp; &nbsp; merge_qual_cost;<br/></li>
<li>&nbsp; &nbsp; QualCost&nbsp; &nbsp; qp_qual_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; mergejointuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rescannedtuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; rescanratio;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Protect some assumptions below that rowcounts aren't zero */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (inner_path_rows &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inner_path_rows = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark the path with the correct row estimate */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (path-&gt;jpath.path.param_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;jpath.path.rows = path-&gt;jpath.path.param_info-&gt;ppi_rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;jpath.path.rows = path-&gt;jpath.path.parent-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For partial paths, scale row estimate. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (path-&gt;jpath.path.parallel_workers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; parallel_divisor = <a href="#L6363" title="optimizer/path/costsize.c:6363">get_parallel_divisor</a>(&amp;path-&gt;jpath.path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;jpath.path.rows =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(path-&gt;jpath.path.rows / parallel_divisor);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We could include <a href="#L130" title="optimizer/path/costsize.c:130">disable_cost</a> in the preliminary estimate, but that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would amount to optimizing for the case where the join method is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * disabled, which doesn't seem like the way to bet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L145" title="optimizer/path/costsize.c:145">enable_mergejoin</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += <a href="#L130" title="optimizer/path/costsize.c:130">disable_cost</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute cost of the mergequals and qpquals (other restriction clauses)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * separately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4640" title="optimizer/path/costsize.c:4640">cost_qual_eval</a>(&amp;merge_qual_cost, mergeclauses, root);<br/></li>
<li>&nbsp; &nbsp; <a href="#L4640" title="optimizer/path/costsize.c:4640">cost_qual_eval</a>(&amp;qp_qual_cost, path-&gt;jpath.joinrestrictinfo, root);<br/></li>
<li>&nbsp; &nbsp; qp_qual_cost.startup -= merge_qual_cost.startup;<br/></li>
<li>&nbsp; &nbsp; qp_qual_cost.per_tuple -= merge_qual_cost.per_tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * With a SEMI or ANTI join, or if the innerrel is known unique, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * executor will stop scanning for matches after the first match.&nbsp; When<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all the joinclauses are <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> clauses, this means we don't ever need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * back up the <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>, and so we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> mark/restore overhead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((path-&gt;jpath.jointype == JOIN_SEMI ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path-&gt;jpath.jointype == JOIN_ANTI ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; extra-&gt;inner_unique) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (list_length(path-&gt;jpath.joinrestrictinfo) ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_length(path-&gt;path_mergeclauses)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;skip_mark_restore = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;skip_mark_restore = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get approx # tuples passing the mergequals.&nbsp; We use <a href="#L5194" title="optimizer/path/costsize.c:5194">approx_tuple_count</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here because we need an estimate done with JOIN_INNER semantics.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; mergejointuples = <a href="#L5194" title="optimizer/path/costsize.c:5194">approx_tuple_count</a>(root, &amp;path-&gt;jpath, mergeclauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When there are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> keys in the outer relation, the mergejoin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must rescan <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> matching tuples in the inner relation. This means<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * re-fetching inner tuples; we have to estimate how often that happens.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For regular inner and outer joins, the number of re-fetches can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimated approximately as size of <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> join output minus size of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inner relation. Assume that the distinct key <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are 1, 2, ..., and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * denote the number of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of each key in the outer relation as m1,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * m2, ...; in the inner relation, n1, n2, ...&nbsp; Then we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * size of join = m1 * n1 + m2 * n2 + ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number of rescanned tuples = (m1 - 1) * n1 + (m2 - 1) * n2 + ... = m1 *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * n1 + m2 * n2 + ... - (n1 + n2 + ...) = size of join - size of inner<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This equation works correctly for outer tuples having no inner match<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (nk = 0), but not for inner tuples having no outer match (mk = 0); we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are effectively subtracting those from the number of rescanned tuples,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when we should not.&nbsp; Can we do better without expensive selectivity<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * computations?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The whole issue is moot if we are working from a unique-ified outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * input, or if we know we don't need to mark/restore at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(outer_path, UniquePath) || path-&gt;skip_mark_restore)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rescannedtuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rescannedtuples = mergejointuples - inner_path_rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must clamp because of possible underestimate */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rescannedtuples &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rescannedtuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We'll inflate various costs this much to account for rescanning.&nbsp; Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that this is to be multiplied by something involving inner_rows, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * another number related to the portion of the inner rel we'll scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rescanratio = <span class="Constant">1.0</span> + (rescannedtuples / inner_rows);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Decide whether we want to materialize the inner input to shield it from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mark/restore and performing re-fetches.&nbsp; Our cost model for regular<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * re-fetches is that a re-fetch costs the same as an original fetch,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which is probably an overestimate; but on the other hand we ignore the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bookkeeping costs of mark/restore.&nbsp; Not clear if it's worth developing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a more refined model.&nbsp; So we just need to inflate the inner run cost by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rescanratio.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bare_inner_cost = inner_run_cost * rescanratio;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When we interpose a Material node the re-fetch cost is assumed to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> per tuple, independently of the underlying<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plan's cost; and we <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> an extra <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> per original<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fetch as well.&nbsp; Note that we're assuming the materialize node will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * never spill to disk, since it only has to remember tuples back to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * last mark.&nbsp; (If there are a huge number of duplicates, our other cost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * factors will make the path so expensive that it probably won't get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * chosen anyway.)&nbsp; &nbsp; So we don't use <a href="#L4528" title="optimizer/path/costsize.c:4528">cost_rescan</a> here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: keep this estimate in sync with <a href="../plan/createplan.c.html#L4439" title="optimizer/plan/createplan.c:4439">create_mergejoin_plan</a>'s labeling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the generated Material node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; mat_inner_cost = inner_run_cost +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> * inner_rows * rescanratio;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we don't need mark/restore at all, we don't need materialization.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (path-&gt;skip_mark_restore)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;materialize_inner = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prefer materializing if it looks cheaper, unless the user has asked to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * suppress materialization.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L143" title="optimizer/path/costsize.c:143">enable_material</a> &amp;&amp; mat_inner_cost &lt; bare_inner_cost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;materialize_inner = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Even if materializing doesn't look cheaper, we *must* do it if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inner path is to be used directly (without sorting) and it doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * support mark/restore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since the inner side must be ordered, and only Sorts and IndexScans can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create order to begin with, and they both support mark/restore, you<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might think there's no problem --- but you'd be wrong.&nbsp; Nestloop and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> joins can *preserve* the order of their inputs, so they can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * selected as the input of a mergejoin, and they don't support<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mark/restore at present.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't test the value of <a href="#L143" title="optimizer/path/costsize.c:143">enable_material</a> here, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * materialization is required for correctness in this case, and turning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it off does not entitle us to deliver an invalid plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (innersortkeys == NIL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="../../executor/execAmi.c.html#L417" title="executor/execAmi.c:417">ExecSupportsMarkRestore</a>(inner_path))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;materialize_inner = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, force materializing if the inner path is to be sorted and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sort is expected to spill to disk.&nbsp; This is because the final <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pass can be done on-the-fly if it doesn't have to support mark/restore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't try to adjust the cost estimates for this consideration,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since materialization is a performance optimization in this case,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rather than necessary for correctness, we <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it if <a href="#L143" title="optimizer/path/costsize.c:143">enable_material</a> is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * off.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L143" title="optimizer/path/costsize.c:143">enable_material</a> &amp;&amp; innersortkeys != NIL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L6342" title="optimizer/path/costsize.c:6342">relation_byte_size</a>(inner_path_rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inner_path-&gt;pathtarget-&gt;width) &gt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a> * <span class="Constant">1024L</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;materialize_inner = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;materialize_inner = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Charge the right incremental cost for the chosen case */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (path-&gt;materialize_inner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; run_cost += mat_inner_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; run_cost += bare_inner_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* CPU costs */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The number of tuple comparisons needed is approximately number of outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rows plus number of inner rows plus number of rescanned tuples (can we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * refine this?).&nbsp; At each one, we need to evaluate the mergejoin quals.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += merge_qual_cost.startup;<br/></li>
<li>&nbsp; &nbsp; startup_cost += merge_qual_cost.per_tuple *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (outer_skip_rows + inner_skip_rows * rescanratio);<br/></li>
<li>&nbsp; &nbsp; run_cost += merge_qual_cost.per_tuple *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((outer_rows - outer_skip_rows) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (inner_rows - inner_skip_rows) * rescanratio);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For each tuple that gets through the mergejoin proper, we <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> plus the cost of evaluating additional restriction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clauses that are to be applied at the join.&nbsp; (This is pessimistic since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not all of the quals may get evaluated at each tuple.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we could adjust for SEMI/ANTI joins skipping some qual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * evaluations here, but it's probably not worth the trouble.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += qp_qual_cost.startup;<br/></li>
<li>&nbsp; &nbsp; cpu_per_tuple = <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> + qp_qual_cost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; run_cost += cpu_per_tuple * mergejointuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* tlist eval costs are paid per output row, not per tuple scanned */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += path-&gt;jpath.path.pathtarget-&gt;cost.startup;<br/></li>
<li>&nbsp; &nbsp; run_cost += path-&gt;jpath.path.pathtarget-&gt;cost.per_tuple * path-&gt;jpath.path.rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;jpath.path.startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;jpath.path.total_cost = startup_cost + run_cost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * run <a href="../../utils/adt/selfuncs.c.html#L2952" title="utils/adt/selfuncs.c:2952">mergejoinscansel</a>() with caching<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> MergeScanSelCache *<br/></li>
<li><a id="L3994">&#x200c;</a><span class="linkable">cached_scansel</span>(PlannerInfo *root, RestrictInfo *rinfo, PathKey *pathkey)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MergeScanSelCache *cache;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; Selectivity leftstartsel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftendsel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightstartsel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightendsel;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do we have this result already? */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, rinfo-&gt;scansel_cache)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache = (MergeScanSelCache *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cache-&gt;opfamily == pathkey-&gt;pk_opfamily &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;collation == pathkey-&gt;pk_eclass-&gt;ec_collation &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;strategy == pathkey-&gt;pk_strategy &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;nulls_first == pathkey-&gt;pk_nulls_first)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> cache;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nope, do the computation */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/adt/selfuncs.c.html#L2952" title="utils/adt/selfuncs.c:2952">mergejoinscansel</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) rinfo-&gt;clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pathkey-&gt;pk_opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pathkey-&gt;pk_strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pathkey-&gt;pk_nulls_first,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;leftstartsel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;leftendsel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;rightstartsel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;rightendsel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cache the result in suitably long-lived workspace */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(root-&gt;planner_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cache = (MergeScanSelCache *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MergeScanSelCache));<br/></li>
<li>&nbsp; &nbsp; cache-&gt;opfamily = pathkey-&gt;pk_opfamily;<br/></li>
<li>&nbsp; &nbsp; cache-&gt;collation = pathkey-&gt;pk_eclass-&gt;ec_collation;<br/></li>
<li>&nbsp; &nbsp; cache-&gt;strategy = pathkey-&gt;pk_strategy;<br/></li>
<li>&nbsp; &nbsp; cache-&gt;nulls_first = pathkey-&gt;pk_nulls_first;<br/></li>
<li>&nbsp; &nbsp; cache-&gt;leftstartsel = leftstartsel;<br/></li>
<li>&nbsp; &nbsp; cache-&gt;leftendsel = leftendsel;<br/></li>
<li>&nbsp; &nbsp; cache-&gt;rightstartsel = rightstartsel;<br/></li>
<li>&nbsp; &nbsp; cache-&gt;rightendsel = rightendsel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rinfo-&gt;scansel_cache = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rinfo-&gt;scansel_cache, cache);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cache;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4073" title="optimizer/path/costsize.c:4073">initial_cost_hashjoin</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Preliminary estimate of the cost of a hashjoin path.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This must quickly produce <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-bound estimates of the path's startup and<br/></li>
<li></span><span class="Comment"> * total costs.&nbsp; If we are unable to eliminate the proposed path from<br/></li>
<li></span><span class="Comment"> * consideration using the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bounds, <a href="#L4181" title="optimizer/path/costsize.c:4181">final_cost_hashjoin</a> will be called<br/></li>
<li></span><span class="Comment"> * to obtain the final estimates.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The exact division of labor between this function and <a href="#L4181" title="optimizer/path/costsize.c:4181">final_cost_hashjoin</a><br/></li>
<li></span><span class="Comment"> * is private to them, and represents a tradeoff between speed of the initial<br/></li>
<li></span><span class="Comment"> * estimate and getting a tight <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound.&nbsp; We choose to not examine the<br/></li>
<li></span><span class="Comment"> * join quals here (other than by counting the number of <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> clauses),<br/></li>
<li></span><span class="Comment"> * so we can't do much with CPU costs.&nbsp; We do assume that<br/></li>
<li></span><span class="Comment"> * <a href="../../executor/nodeHash.c.html#L675" title="executor/nodeHash.c:675">ExecChooseHashTableSize</a> is cheap enough to use here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'workspace' is to be filled with startup_cost, total_cost, and perhaps<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; other data to be used by <a href="#L4181" title="optimizer/path/costsize.c:4181">final_cost_hashjoin</a><br/></li>
<li></span><span class="Comment"> * 'jointype' is the type of join to be performed<br/></li>
<li></span><span class="Comment"> * 'hashclauses' is the list of joinclauses to be used as <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> clauses<br/></li>
<li></span><span class="Comment"> * 'outer_path' is the outer input to the join<br/></li>
<li></span><span class="Comment"> * 'inner_path' is the inner input to the join<br/></li>
<li></span><span class="Comment"> * 'extra' contains miscellaneous information about the join<br/></li>
<li></span><span class="Comment"> * 'parallel_hash' indicates that inner_path is partial and that a shared<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table will be built in parallel<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4073">&#x200c;</a></span><span class="linkable">initial_cost_hashjoin</span>(PlannerInfo *root, JoinCostWorkspace *workspace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JoinType jointype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *hashclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path *outer_path, Path *inner_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JoinPathExtraData *extra,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> parallel_hash)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; run_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; outer_path_rows = outer_path-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; inner_path_rows = inner_path-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; inner_path_rows_total = inner_path_rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_hashclauses = list_length(hashclauses);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numbuckets;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numbatches;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_skew_mcvs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; space_allowed;&nbsp; &nbsp; <span class="Comment">/* unused */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cost of source data */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += outer_path-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; run_cost += outer_path-&gt;total_cost - outer_path-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; startup_cost += inner_path-&gt;total_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Cost of computing <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function: must do it once per input tuple. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> one <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> for each column's <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function.&nbsp; Also,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tack on one <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> per inner row, to model the costs of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inserting the row into the hashtable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> when a hashclause is more complex than a single operator, we really<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> the extra eval costs of the left or right side, as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * appropriate, here.&nbsp; This seems more work than it's worth at the moment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += (<a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> * num_hashclauses + <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; * inner_path_rows;<br/></li>
<li>&nbsp; &nbsp; run_cost += <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> * num_hashclauses * outer_path_rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is a parallel <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> build, then the value we have for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inner_rows_total currently refers only to the rows returned by each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * participant.&nbsp; For shared <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table size estimation, we need the total<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number, so we need to undo the division.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parallel_hash)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inner_path_rows_total *= <a href="#L6363" title="optimizer/path/costsize.c:6363">get_parallel_divisor</a>(inner_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table size that executor would use for inner relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> for the moment, always assume that skew optimization will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * performed.&nbsp; As long as SKEW_HASH_MEM_PERCENT is small, it's not worth<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trying to determine that for sure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> at some point it might be interesting to try to account for skew<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * optimization in the cost estimate, but for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we don't.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../executor/nodeHash.c.html#L675" title="executor/nodeHash.c:675">ExecChooseHashTableSize</a>(inner_path_rows_total,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inner_path-&gt;pathtarget-&gt;width,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>,&nbsp; &nbsp; <span class="Comment">/* useskew */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parallel_hash,&nbsp; &nbsp; <span class="Comment">/* try_combined_hash_mem */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_path-&gt;parallel_workers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;space_allowed,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;numbuckets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;numbatches,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;num_skew_mcvs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If inner relation is too big then we will need to &quot;batch&quot; the join,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which implies writing and reading most of the tuples to disk an extra<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * time.&nbsp; Charge <a href="#L119" title="optimizer/path/costsize.c:119">seq_page_cost</a> per page, since the I/O should be nice and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sequential.&nbsp; Writing the inner rel counts as startup cost, all the rest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as run cost.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (numbatches &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; outerpages = <a href="#L6353" title="optimizer/path/costsize.c:6353">page_size</a>(outer_path_rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outer_path-&gt;pathtarget-&gt;width);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; innerpages = <a href="#L6353" title="optimizer/path/costsize.c:6353">page_size</a>(inner_path_rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inner_path-&gt;pathtarget-&gt;width);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += <a href="#L119" title="optimizer/path/costsize.c:119">seq_page_cost</a> * innerpages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; run_cost += <a href="#L119" title="optimizer/path/costsize.c:119">seq_page_cost</a> * (innerpages + <span class="Constant">2</span> * outerpages);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* CPU costs left for later */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Public result fields */<br/></li>
<li></span>&nbsp; &nbsp; workspace-&gt;startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; workspace-&gt;total_cost = startup_cost + run_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save private data for <a href="#L4181" title="optimizer/path/costsize.c:4181">final_cost_hashjoin</a> */<br/></li>
<li></span>&nbsp; &nbsp; workspace-&gt;run_cost = run_cost;<br/></li>
<li>&nbsp; &nbsp; workspace-&gt;numbuckets = numbuckets;<br/></li>
<li>&nbsp; &nbsp; workspace-&gt;numbatches = numbatches;<br/></li>
<li>&nbsp; &nbsp; workspace-&gt;inner_rows_total = inner_path_rows_total;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4181" title="optimizer/path/costsize.c:4181">final_cost_hashjoin</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Final estimate of the cost and result size of a hashjoin path.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the numbatches estimate is also saved into 'path' for use later<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'path' is already filled in except for the rows and cost fields and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; num_batches<br/></li>
<li></span><span class="Comment"> * 'workspace' is the result from <a href="#L4073" title="optimizer/path/costsize.c:4073">initial_cost_hashjoin</a><br/></li>
<li></span><span class="Comment"> * 'extra' contains miscellaneous information about the join<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4181">&#x200c;</a></span><span class="linkable">final_cost_hashjoin</span>(PlannerInfo *root, HashPath *path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JoinCostWorkspace *workspace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JoinPathExtraData *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *outer_path = path-&gt;jpath.outerjoinpath;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *inner_path = path-&gt;jpath.innerjoinpath;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; outer_path_rows = outer_path-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; inner_path_rows = inner_path-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; inner_path_rows_total = workspace-&gt;inner_rows_total;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *hashclauses = path-&gt;path_hashclauses;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; startup_cost = workspace-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; run_cost = workspace-&gt;run_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numbuckets = workspace-&gt;numbuckets;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numbatches = workspace-&gt;numbatches;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; cpu_per_tuple;<br/></li>
<li>&nbsp; &nbsp; QualCost&nbsp; &nbsp; hash_qual_cost;<br/></li>
<li>&nbsp; &nbsp; QualCost&nbsp; &nbsp; qp_qual_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; hashjointuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; virtualbuckets;<br/></li>
<li>&nbsp; &nbsp; Selectivity innerbucketsize;<br/></li>
<li>&nbsp; &nbsp; Selectivity innermcvfreq;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *hcl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark the path with the correct row estimate */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (path-&gt;jpath.path.param_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;jpath.path.rows = path-&gt;jpath.path.param_info-&gt;ppi_rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;jpath.path.rows = path-&gt;jpath.path.parent-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For partial paths, scale row estimate. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (path-&gt;jpath.path.parallel_workers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; parallel_divisor = <a href="#L6363" title="optimizer/path/costsize.c:6363">get_parallel_divisor</a>(&amp;path-&gt;jpath.path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;jpath.path.rows =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(path-&gt;jpath.path.rows / parallel_divisor);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We could include <a href="#L130" title="optimizer/path/costsize.c:130">disable_cost</a> in the preliminary estimate, but that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would amount to optimizing for the case where the join method is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * disabled, which doesn't seem like the way to bet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L146" title="optimizer/path/costsize.c:146">enable_hashjoin</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += <a href="#L130" title="optimizer/path/costsize.c:130">disable_cost</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* mark the path with estimated # of batches */<br/></li>
<li></span>&nbsp; &nbsp; path-&gt;num_batches = numbatches;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* store the total number of tuples (sum of partial row estimates) */<br/></li>
<li></span>&nbsp; &nbsp; path-&gt;inner_rows_total = inner_path_rows_total;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and compute the number of &quot;virtual&quot; buckets in the whole join */<br/></li>
<li></span>&nbsp; &nbsp; virtualbuckets = (<span class="Type">double</span>) numbuckets * (<span class="Type">double</span>) numbatches;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine bucketsize fraction and MCV frequency for the inner relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use the smallest bucketsize or MCV frequency estimated for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * individual hashclause; this is undoubtedly conservative.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * BUT: if inner relation has been unique-ified, we can assume it's good<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for hashing.&nbsp; This is important both because it's the right answer, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because we avoid contaminating the cache with a value that's wrong for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-unique-ified paths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(inner_path, UniquePath))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; innerbucketsize = <span class="Constant">1.0</span> / virtualbuckets;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; innermcvfreq = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; innerbucketsize = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; innermcvfreq = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(hcl, hashclauses)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *restrictinfo = lfirst_node(RestrictInfo, hcl);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Selectivity thisbucketsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Selectivity thismcvfreq;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First we have to figure out which side of the hashjoin clause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is the inner side.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since we tend to visit the same clauses over and over when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * planning a large query, we cache the bucket stats estimates in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the RestrictInfo node to avoid repeated lookups of statistics.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(restrictinfo-&gt;right_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inner_path-&gt;parent-&gt;relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* righthand side is inner */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisbucketsize = restrictinfo-&gt;right_bucketsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (thisbucketsize &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not cached yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/selfuncs.c.html#L3798" title="utils/adt/selfuncs.c:3798">estimate_hash_bucket_stats</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; get_rightop(restrictinfo-&gt;clause),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; virtualbuckets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;restrictinfo-&gt;right_mcvfreq,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;restrictinfo-&gt;right_bucketsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisbucketsize = restrictinfo-&gt;right_bucketsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thismcvfreq = restrictinfo-&gt;right_mcvfreq;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(restrictinfo-&gt;left_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inner_path-&gt;parent-&gt;relids));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* lefthand side is inner */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisbucketsize = restrictinfo-&gt;left_bucketsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (thisbucketsize &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not cached yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/selfuncs.c.html#L3798" title="utils/adt/selfuncs.c:3798">estimate_hash_bucket_stats</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; get_leftop(restrictinfo-&gt;clause),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; virtualbuckets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;restrictinfo-&gt;left_mcvfreq,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;restrictinfo-&gt;left_bucketsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisbucketsize = restrictinfo-&gt;left_bucketsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thismcvfreq = restrictinfo-&gt;left_mcvfreq;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (innerbucketsize &gt; thisbucketsize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; innerbucketsize = thisbucketsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (innermcvfreq &gt; thismcvfreq)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; innermcvfreq = thismcvfreq;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the bucket holding the inner MCV would exceed hash_mem, we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * want to <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> unless there is really no other alternative, so apply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L130" title="optimizer/path/costsize.c:130">disable_cost</a>.&nbsp; (The executor normally copes with excessive memory usage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by splitting batches, but obviously it cannot separate <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that way, so it will be unable to drive the batch size below hash_mem<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when this is true.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L6342" title="optimizer/path/costsize.c:6342">relation_byte_size</a>(<a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(inner_path_rows * innermcvfreq),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inner_path-&gt;pathtarget-&gt;width) &gt; <a href="../../executor/nodeHash.c.html#L3595" title="executor/nodeHash.c:3595">get_hash_memory_limit</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += <a href="#L130" title="optimizer/path/costsize.c:130">disable_cost</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute cost of the hashquals and qpquals (other restriction clauses)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * separately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4640" title="optimizer/path/costsize.c:4640">cost_qual_eval</a>(&amp;hash_qual_cost, hashclauses, root);<br/></li>
<li>&nbsp; &nbsp; <a href="#L4640" title="optimizer/path/costsize.c:4640">cost_qual_eval</a>(&amp;qp_qual_cost, path-&gt;jpath.joinrestrictinfo, root);<br/></li>
<li>&nbsp; &nbsp; qp_qual_cost.startup -= hash_qual_cost.startup;<br/></li>
<li>&nbsp; &nbsp; qp_qual_cost.per_tuple -= hash_qual_cost.per_tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* CPU costs */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (path-&gt;jpath.jointype == JOIN_SEMI ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;jpath.jointype == JOIN_ANTI ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; extra-&gt;inner_unique)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; outer_matched_rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Selectivity inner_scan_frac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * With a SEMI or ANTI join, or if the innerrel is known unique, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * executor will stop after the first match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For an outer-rel row that has at least one match, we can expect the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bucket scan to stop after a fraction 1/(match_count+1) of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bucket's rows, if the matches are evenly distributed.&nbsp; Since they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * probably aren't quite evenly distributed, we apply a fuzz factor of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 2.0 to that fraction.&nbsp; (If we used a larger fuzz factor, we'd have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to clamp inner_scan_frac to at most 1.0; but since match_count is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * at least 1, no such clamp is needed <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; outer_matched_rows = rint(outer_path_rows * extra-&gt;semifactors.outer_match_frac);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inner_scan_frac = <span class="Constant">2.0</span> / (extra-&gt;semifactors.match_count + <span class="Constant">1.0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += hash_qual_cost.startup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; run_cost += hash_qual_cost.per_tuple * outer_matched_rows *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(inner_path_rows * innerbucketsize * inner_scan_frac) * <span class="Constant">0.5</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For unmatched outer-rel rows, the picture is quite a lot different.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In the first place, there is no reason to assume that these rows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * preferentially hit heavily-populated buckets; instead assume they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are uncorrelated with the inner distribution and so they see an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * average bucket size of inner_path_rows / virtualbuckets.&nbsp; In the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * second place, it seems likely that they will have few if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> exact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>-code matches and so very few of the tuples in the bucket will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * actually require eval of the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> quals.&nbsp; We don't have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> good<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * way to estimate how many will, but for the moment assume that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * effective cost per bucket entry is one-tenth what it is for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matchable tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; run_cost += hash_qual_cost.per_tuple *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (outer_path_rows - outer_matched_rows) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(inner_path_rows / virtualbuckets) * <span class="Constant">0.05</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get # of tuples that will pass the basic join */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path-&gt;jpath.jointype == JOIN_ANTI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashjointuples = outer_path_rows - outer_matched_rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashjointuples = outer_matched_rows;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The number of tuple comparisons needed is the number of outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples times the typical number of tuples in a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> bucket, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is the inner relation size times its bucketsize fraction.&nbsp; At each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one, we need to evaluate the hashjoin quals.&nbsp; But actually,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * charging the full qual eval cost at each tuple is pessimistic,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since we don't evaluate the quals unless the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> match<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exactly.&nbsp; For lack of a better idea, halve the cost estimate to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allow for that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; startup_cost += hash_qual_cost.startup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; run_cost += hash_qual_cost.per_tuple * outer_path_rows *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(inner_path_rows * innerbucketsize) * <span class="Constant">0.5</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get approx # tuples passing the hashquals.&nbsp; We use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L5194" title="optimizer/path/costsize.c:5194">approx_tuple_count</a> here because we need an estimate done with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * JOIN_INNER semantics.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hashjointuples = <a href="#L5194" title="optimizer/path/costsize.c:5194">approx_tuple_count</a>(root, &amp;path-&gt;jpath, hashclauses);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For each tuple that gets through the hashjoin proper, we <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> plus the cost of evaluating additional restriction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clauses that are to be applied at the join.&nbsp; (This is pessimistic since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not all of the quals may get evaluated at each tuple.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += qp_qual_cost.startup;<br/></li>
<li>&nbsp; &nbsp; cpu_per_tuple = <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> + qp_qual_cost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; run_cost += cpu_per_tuple * hashjointuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* tlist eval costs are paid per output row, not per tuple scanned */<br/></li>
<li></span>&nbsp; &nbsp; startup_cost += path-&gt;jpath.path.pathtarget-&gt;cost.startup;<br/></li>
<li>&nbsp; &nbsp; run_cost += path-&gt;jpath.path.pathtarget-&gt;cost.per_tuple * path-&gt;jpath.path.rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;jpath.path.startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;jpath.path.total_cost = startup_cost + run_cost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4435" title="optimizer/path/costsize.c:4435">cost_subplan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Figure the costs for a SubPlan (or initplan).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we could dig the subplan's Plan out of the root list, but in practice<br/></li>
<li></span><span class="Comment"> * all callers have it handy already, so we make them pass it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4435">&#x200c;</a></span><span class="linkable">cost_subplan</span>(PlannerInfo *root, SubPlan *subplan, Plan *plan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; QualCost&nbsp; &nbsp; sp_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Figure <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> cost for evaluating the testexpr */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4640" title="optimizer/path/costsize.c:4640">cost_qual_eval</a>(&amp;sp_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/makefuncs.c.html#L737" title="nodes/makefuncs.c:737">make_ands_implicit</a>((Expr *) subplan-&gt;testexpr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (subplan-&gt;useHashTable)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are using a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table for the subquery outputs, then the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cost of evaluating the query is a one-time cost.&nbsp; We <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> per tuple for the work of loading the hashtable,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sp_cost.startup += plan-&gt;total_cost +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> * plan-&gt;plan_rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The per-tuple costs include the cost of evaluating the lefthand<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expressions, plus the cost of probing the hashtable.&nbsp; We already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * accounted for the lefthand expressions as part of the testexpr, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will also have counted one <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> for each comparison<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operator.&nbsp; That is probably too low for the probing cost, but it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hard to make a better estimate, so live with it for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise we will be rescanning the subplan output on each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * evaluation.&nbsp; We need to estimate how much of the output we will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * actually need to scan.&nbsp; <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: this logic should agree with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple_fraction estimates used by <a href="../plan/subselect.c.html#L162" title="optimizer/plan/subselect.c:162">make_subplan</a>() in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * plan/subselect.c.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; plan_run_cost = plan-&gt;total_cost - plan-&gt;startup_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subplan-&gt;subLinkType == EXISTS_SUBLINK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we only need to fetch 1 tuple; clamp to avoid zero divide */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sp_cost.per_tuple += plan_run_cost / <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(plan-&gt;plan_rows);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (subplan-&gt;subLinkType == ALL_SUBLINK ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subplan-&gt;subLinkType == ANY_SUBLINK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* assume we need 50% of the tuples */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sp_cost.per_tuple += <span class="Constant">0.50</span> * plan_run_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* also <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> a <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> per row examined */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sp_cost.per_tuple += <span class="Constant">0.50</span> * plan-&gt;plan_rows * <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* assume we need all tuples */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sp_cost.per_tuple += plan_run_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also account for subplan's startup cost. If the subplan is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * uncorrelated or undirect correlated, AND its topmost node is one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that materializes its output, assume that we'll only need to pay<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * its startup cost once; otherwise assume we pay the startup cost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * every time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subplan-&gt;parParam == NIL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/execAmi.c.html#L635" title="executor/execAmi.c:635">ExecMaterializesOutput</a>(nodeTag(plan)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sp_cost.startup += plan-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sp_cost.per_tuple += plan-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; subplan-&gt;startup_cost = sp_cost.startup;<br/></li>
<li>&nbsp; &nbsp; subplan-&gt;per_call_cost = sp_cost.per_tuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4528" title="optimizer/path/costsize.c:4528">cost_rescan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given a finished Path, estimate the costs of rescanning it after<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; having done so the first time.&nbsp; For some Path types a rescan is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; cheaper than an original scan (if no parameters change), and this<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; function embodies knowledge about that.&nbsp; The default is to return<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the same costs stored in the Path.&nbsp; (Note that the cost estimates<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; actually stored in Paths are always for first scans.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is not currently intended to model effects such as rescans<br/></li>
<li></span><span class="Comment"> * being cheaper due to disk block caching; what we are concerned with is<br/></li>
<li></span><span class="Comment"> * plan types wherein the executor caches results explicitly, or doesn't<br/></li>
<li></span><span class="Comment"> * redo startup calculations, etc.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4528">&#x200c;</a></span><span class="linkable">cost_rescan</span>(PlannerInfo *root, Path *path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cost *rescan_startup_cost,&nbsp; &nbsp; <span class="Comment">/* output parameters */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cost *rescan_total_cost)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (path-&gt;pathtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_FunctionScan:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Currently, nodeFunctionscan.c always executes the function to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * completion <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> returning <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> rows, and caches the results in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a tuplestore.&nbsp; So the function eval cost is all startup cost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and isn't paid over again on rescans. However, all run costs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will be paid over again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rescan_startup_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rescan_total_cost = path-&gt;total_cost - path-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_HashJoin:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's a single-batch join, we don't need to rebuild the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * table during a rescan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((HashPath *) path)-&gt;num_batches == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Startup cost is exactly the cost of <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table building */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rescan_startup_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rescan_total_cost = path-&gt;total_cost - path-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise, no special treatment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rescan_startup_cost = path-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rescan_total_cost = path-&gt;total_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_CteScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_WorkTableScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * These plan types materialize their final result in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuplestore or tuplesort object.&nbsp; So the rescan cost is only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> per tuple, unless the result is large enough<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to spill to disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; run_cost = <a href="#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> * path-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nbytes = <a href="#L6342" title="optimizer/path/costsize.c:6342">relation_byte_size</a>(path-&gt;rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path-&gt;pathtarget-&gt;width);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; work_mem_bytes = <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a> * <span class="Constant">1024L</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nbytes &gt; work_mem_bytes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It will spill, so account for re-read cost */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; npages = ceil(nbytes / BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; run_cost += <a href="#L119" title="optimizer/path/costsize.c:119">seq_page_cost</a> * npages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rescan_startup_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rescan_total_cost = run_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Material:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Sort:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * These plan types not only materialize their results, but do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not implement qual filtering or projection.&nbsp; So they are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * even cheaper to rescan than the ones above.&nbsp; We <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> per tuple.&nbsp; (Note: keep that in sync with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the run_cost <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> in <a href="#L2124" title="optimizer/path/costsize.c:2124">cost_sort</a>, and also see comments in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L2453" title="optimizer/path/costsize.c:2453">cost_material</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> you change it.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; run_cost = <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> * path-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nbytes = <a href="#L6342" title="optimizer/path/costsize.c:6342">relation_byte_size</a>(path-&gt;rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path-&gt;pathtarget-&gt;width);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; work_mem_bytes = <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a> * <span class="Constant">1024L</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nbytes &gt; work_mem_bytes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It will spill, so account for re-read cost */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; npages = ceil(nbytes / BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; run_cost += <a href="#L119" title="optimizer/path/costsize.c:119">seq_page_cost</a> * npages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rescan_startup_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rescan_total_cost = run_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Memoize:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* All the hard work is done by <a href="#L2509" title="optimizer/path/costsize.c:2509">cost_memoize_rescan</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2509" title="optimizer/path/costsize.c:2509">cost_memoize_rescan</a>(root, (MemoizePath *) path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rescan_startup_cost, rescan_total_cost);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rescan_startup_cost = path-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rescan_total_cost = path-&gt;total_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4640" title="optimizer/path/costsize.c:4640">cost_qual_eval</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Estimate the CPU costs of evaluating a WHERE clause.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The input can be either an implicitly-ANDed list of boolean<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; expressions, or a list of RestrictInfo nodes.&nbsp; (The latter is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; preferred since it allows caching of the results.)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The result includes both a one-time (startup) component,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and a per-evaluation component.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4640">&#x200c;</a></span><span class="linkable">cost_qual_eval</span>(QualCost *cost, List *quals, PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L160" title="optimizer/path/costsize.c:160">cost_qual_eval_context</a> context;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.root = root;<br/></li>
<li>&nbsp; &nbsp; context.total.startup = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; context.total.per_tuple = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We don't <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> cost for the implicit ANDing at top level ... */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; foreach(l, quals)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *qual = (Node *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4680" title="optimizer/path/costsize.c:4680">cost_qual_eval_walker</a>(qual, &amp;context);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *cost = context.total;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4666" title="optimizer/path/costsize.c:4666">cost_qual_eval_node</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; As above, for a single RestrictInfo or expression.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4666">&#x200c;</a></span><span class="linkable">cost_qual_eval_node</span>(QualCost *cost, Node *qual, PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L160" title="optimizer/path/costsize.c:160">cost_qual_eval_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.root = root;<br/></li>
<li>&nbsp; &nbsp; context.total.startup = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; context.total.per_tuple = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4680" title="optimizer/path/costsize.c:4680">cost_qual_eval_walker</a>(qual, &amp;context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *cost = context.total;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4680">&#x200c;</a></span><span class="linkable">cost_qual_eval_walker</span>(Node *node, <a href="#L160" title="optimizer/path/costsize.c:160">cost_qual_eval_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * RestrictInfo nodes contain an eval_cost field reserved for this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * routine's use, so that it's not necessary to evaluate the qual clause's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cost more than once.&nbsp; If the clause's cost hasn't been computed yet,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the field's startup value will contain -1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, RestrictInfo))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rinfo-&gt;eval_cost.startup &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="optimizer/path/costsize.c:160">cost_qual_eval_context</a> locContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locContext.root = context-&gt;root;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locContext.total.startup = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locContext.total.per_tuple = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For an OR clause, recurse into the marked-up tree so that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set the eval_cost for contained RestrictInfos too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rinfo-&gt;orclause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4680" title="optimizer/path/costsize.c:4680">cost_qual_eval_walker</a>((Node *) rinfo-&gt;orclause, &amp;locContext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4680" title="optimizer/path/costsize.c:4680">cost_qual_eval_walker</a>((Node *) rinfo-&gt;clause, &amp;locContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the RestrictInfo is marked pseudoconstant, it will be tested<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only once, so treat its cost as all startup cost.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rinfo-&gt;pseudoconstant)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* count one execution during startup */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locContext.total.startup += locContext.total.per_tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locContext.total.per_tuple = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rinfo-&gt;eval_cost = locContext.total;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;total.startup += rinfo-&gt;eval_cost.startup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;total.per_tuple += rinfo-&gt;eval_cost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do NOT recurse into children */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For each operator or function node in the given tree, we <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimated execution cost given by pg_proc.procost (remember to multiply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this by <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Vars and Consts are charged zero, and so are boolean operators (AND,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OR, NOT). Simplistic, but a lot better than no model at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Should we try to account for the possibility of short-circuit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * evaluation of AND/OR?&nbsp; Probably *not*, because that would make the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * results depend on the clause ordering, and we are not in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> position<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to expect that the current ordering of the clauses is the one that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * going to end up being used.&nbsp; The above per-RestrictInfo caching would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not mix well with trying to re-order clauses anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Another issue that is entirely ignored here is that if a set-returning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function is below top level in the tree, the <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>/operators above<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it will need to be evaluated multiple times.&nbsp; In practical use, such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases arise so seldom as to not be worth the added complexity needed;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * moreover, since our rowcount estimates for <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> tend to be pretty<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * phony, the results would also be pretty phony.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, FuncExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/plancat.c.html#L2072" title="optimizer/util/plancat.c:2072">add_function_cost</a>(context-&gt;root, ((FuncExpr *) node)-&gt;funcid, node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context-&gt;total);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, OpExpr) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IsA(node, DistinctExpr) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IsA(node, NullIfExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* rely on struct equivalence to treat these all alike */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L1868" title="nodes/nodeFuncs.c:1868">set_opfuncid</a>((OpExpr *) node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/plancat.c.html#L2072" title="optimizer/util/plancat.c:2072">add_function_cost</a>(context-&gt;root, ((OpExpr *) node)-&gt;opfuncid, node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context-&gt;total);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, ScalarArrayOpExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *arraynode = (Node *) lsecond(saop-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; QualCost&nbsp; &nbsp; sacosts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; QualCost&nbsp; &nbsp; hcosts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; estarraylen = <a href="../../utils/adt/selfuncs.c.html#L2136" title="utils/adt/selfuncs.c:2136">estimate_array_length</a>(context-&gt;root, arraynode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L1879" title="nodes/nodeFuncs.c:1879">set_sa_opfuncid</a>(saop);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sacosts.startup = sacosts.per_tuple = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/plancat.c.html#L2072" title="optimizer/util/plancat.c:2072">add_function_cost</a>(context-&gt;root, saop-&gt;opfuncid, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;sacosts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(saop-&gt;hashfuncid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Handle costs for hashed ScalarArrayOpExpr */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hcosts.startup = hcosts.per_tuple = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/plancat.c.html#L2072" title="optimizer/util/plancat.c:2072">add_function_cost</a>(context-&gt;root, saop-&gt;hashfuncid, <span class="Constant">NULL</span>, &amp;hcosts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;total.startup += sacosts.startup + hcosts.startup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Estimate the cost of building the hashtable. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;total.startup += estarraylen * hcosts.per_tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> should we <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> a little <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> for sacosts.per_tuple when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * building the table, or is it ok to assume there will be zero<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> collision?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Charge for hashtable lookups.&nbsp; Charge a single <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> and a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * single comparison.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;total.per_tuple += hcosts.per_tuple + sacosts.per_tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Estimate that the operator will be applied to about half of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * array elements <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the answer is determined.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;total.startup += sacosts.startup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;total.per_tuple += sacosts.per_tuple *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/selfuncs.c.html#L2136" title="utils/adt/selfuncs.c:2136">estimate_array_length</a>(context-&gt;root, arraynode) * <span class="Constant">0.5</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, Aggref) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IsA(node, WindowFunc))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Aggref and WindowFunc nodes are (and should be) treated like Vars,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ie, zero execution cost in the current model, because they behave<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * essentially like Vars at execution.&nbsp; We disregard the costs of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * their input expressions for the same reason.&nbsp; The actual execution<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * costs of the aggregate/window <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> and their arguments have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be factored into plan-node-specific costing of the Agg or WindowAgg<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * plan node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't recurse into children */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, GroupingFunc))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Treat this as having cost 1 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;total.per_tuple += <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't recurse into children */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, CoerceViaIO))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CoerceViaIO *iocoerce = (CoerceViaIO *) node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iofunc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typioparam;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typisvarlena;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check the result type's input function */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/lsyscache.c.html#L2874" title="utils/cache/lsyscache.c:2874">getTypeInputInfo</a>(iocoerce-&gt;resulttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;iofunc, &amp;typioparam);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/plancat.c.html#L2072" title="optimizer/util/plancat.c:2072">add_function_cost</a>(context-&gt;root, iofunc, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context-&gt;total);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check the input type's output function */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/lsyscache.c.html#L2907" title="utils/cache/lsyscache.c:2907">getTypeOutputInfo</a>(<a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) iocoerce-&gt;arg),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;iofunc, &amp;typisvarlena);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/plancat.c.html#L2072" title="optimizer/util/plancat.c:2072">add_function_cost</a>(context-&gt;root, iofunc, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context-&gt;total);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, ArrayCoerceExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ArrayCoerceExpr *acoerce = (ArrayCoerceExpr *) node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; QualCost&nbsp; &nbsp; perelemcost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4666" title="optimizer/path/costsize.c:4666">cost_qual_eval_node</a>(&amp;perelemcost, (Node *) acoerce-&gt;elemexpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;total.startup += perelemcost.startup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (perelemcost.per_tuple &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;total.per_tuple += perelemcost.per_tuple *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/selfuncs.c.html#L2136" title="utils/adt/selfuncs.c:2136">estimate_array_length</a>(context-&gt;root, (Node *) acoerce-&gt;arg);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, RowCompareExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Conservatively assume we will check all the columns */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; RowCompareExpr *rcexpr = (RowCompareExpr *) node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, rcexpr-&gt;opnos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opid = lfirst_oid(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/plancat.c.html#L2072" title="optimizer/util/plancat.c:2072">add_function_cost</a>(context-&gt;root, <a href="../../utils/cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(opid), <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context-&gt;total);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, MinMaxExpr) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IsA(node, SQLValueFunction) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IsA(node, XmlExpr) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IsA(node, CoerceToDomain) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IsA(node, NextValueExpr) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IsA(node, JsonExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Treat all these as having cost 1 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;total.per_tuple += <a href="#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, CurrentOfExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report high cost to prevent selection of anything but TID scan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;total.startup += <a href="#L130" title="optimizer/path/costsize.c:130">disable_cost</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, SubLink))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This routine should not be applied to un-planned expressions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot handle unplanned sub-<a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, SubPlan))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A subplan node in an expression typically indicates that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subplan will be executed on each evaluation, so <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> accordingly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (Sub-selects that can be executed as InitPlans have already been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * removed from the expression.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SubPlan&nbsp; &nbsp; *subplan = (SubPlan *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;total.startup += subplan-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;total.per_tuple += subplan-&gt;per_call_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't want to recurse into the testexpr, because it was already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * counted in the SubPlan node's costs.&nbsp; So we're done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, AlternativeSubPlan))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Arbitrarily use the first alternative plan for costing.&nbsp; (We should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * certainly only include one alternative, and we don't yet have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * enough information to know which one the executor is most likely to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * use.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; AlternativeSubPlan *asplan = (AlternativeSubPlan *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L4680" title="optimizer/path/costsize.c:4680">cost_qual_eval_walker</a>((Node *) linitial(asplan-&gt;subplans),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A PlaceHolderVar should be given cost zero when considering general<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expression evaluation costs.&nbsp; The expense of doing the contained<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expression is charged as part of the tlist eval costs of the scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or join where the PHV is first computed (see <a href="#L6099" title="optimizer/path/costsize.c:6099">set_rel_width</a> and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../util/placeholder.c.html#L373" title="optimizer/util/placeholder.c:373">add_placeholders_to_joinrel</a>).&nbsp; If we charged it again here, we'd be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * double-counting the cost for each level of plan that the PHV<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bubbles up through.&nbsp; Hence, return without recursing into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * phexpr.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* recurse into children */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L4680" title="optimizer/path/costsize.c:4680">cost_qual_eval_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4962" title="optimizer/path/costsize.c:4962">get_restriction_qual_cost</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Compute evaluation costs of a baserel's restriction quals, plus <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; movable join quals that have been pushed down to the scan.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Results are returned into *qpqual_cost.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a convenience subroutine that works for seqscans and other cases<br/></li>
<li></span><span class="Comment"> * where all the given quals will be evaluated the hard way.&nbsp; It's not useful<br/></li>
<li></span><span class="Comment"> * for <a href="#L549" title="optimizer/path/costsize.c:549">cost_index</a>(), for example, where the index machinery takes care of<br/></li>
<li></span><span class="Comment"> * some of the quals.&nbsp; We assume baserestrictcost was previously set by<br/></li>
<li></span><span class="Comment"> * <a href="#L5239" title="optimizer/path/costsize.c:5239">set_baserel_size_estimates</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4962">&#x200c;</a></span><span class="linkable">get_restriction_qual_cost</span>(PlannerInfo *root, RelOptInfo *baserel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ParamPathInfo *param_info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QualCost *qpqual_cost)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (param_info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Include costs of pushed-down clauses */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4640" title="optimizer/path/costsize.c:4640">cost_qual_eval</a>(qpqual_cost, param_info-&gt;ppi_clauses, root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qpqual_cost-&gt;startup += baserel-&gt;baserestrictcost.startup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qpqual_cost-&gt;per_tuple += baserel-&gt;baserestrictcost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *qpqual_cost = baserel-&gt;baserestrictcost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5004" title="optimizer/path/costsize.c:5004">compute_semi_anti_join_factors</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Estimate how much of the inner input a SEMI, ANTI, or inner_unique join<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; can be expected to scan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> or nestloop SEMI/ANTI join, the executor will stop scanning<br/></li>
<li></span><span class="Comment"> * inner rows as soon as it finds a match to the current outer row.<br/></li>
<li></span><span class="Comment"> * The same happens if we have detected the inner rel is unique.<br/></li>
<li></span><span class="Comment"> * We should therefore adjust some of the cost components for this effect.<br/></li>
<li></span><span class="Comment"> * This function computes some estimates needed for these adjustments.<br/></li>
<li></span><span class="Comment"> * These estimates will be the same regardless of the particular paths used<br/></li>
<li></span><span class="Comment"> * for the outer and inner relation, so we compute these once and then pass<br/></li>
<li></span><span class="Comment"> * them to all the join cost estimation <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Input parameters:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; joinrel: join relation under consideration<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; outerrel: outer relation under consideration<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; innerrel: inner relation under consideration<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; jointype: if not JOIN_SEMI or JOIN_ANTI, we assume it's inner_unique<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; sjinfo: SpecialJoinInfo relevant to this join<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; restrictlist: join quals<br/></li>
<li></span><span class="Comment"> * Output parameters:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; *semifactors is filled in (see pathnodes.h for field definitions)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5004">&#x200c;</a></span><span class="linkable">compute_semi_anti_join_factors</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *outerrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *innerrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JoinType jointype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SpecialJoinInfo *sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *restrictlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SemiAntiJoinFactors *semifactors)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Selectivity jselec;<br/></li>
<li>&nbsp; &nbsp; Selectivity nselec;<br/></li>
<li>&nbsp; &nbsp; Selectivity avgmatch;<br/></li>
<li>&nbsp; &nbsp; SpecialJoinInfo norm_sjinfo;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *joinquals;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In an ANTI join, we must ignore clauses that are &quot;pushed down&quot;, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those won't affect the match logic.&nbsp; In a SEMI join, we do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * distinguish joinquals from &quot;pushed down&quot; quals, so just use the whole<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restrictinfo list.&nbsp; For other outer join types, we should consider only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-pushed-down quals, so that this devolves to an IS_OUTER_JOIN check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IS_OUTER_JOIN(jointype))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; joinquals = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, restrictlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!RINFO_IS_PUSHED_DOWN(rinfo, joinrel-&gt;relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinquals = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(joinquals, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; joinquals = restrictlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the JOIN_SEMI or JOIN_ANTI selectivity of the join clauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; jselec = <a href="clausesel.c.html#L100" title="optimizer/path/clausesel.c:100">clauselist_selectivity</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinquals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jointype == JOIN_ANTI) ? JOIN_ANTI : JOIN_SEMI,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sjinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also get the normal inner-join selectivity of the join clauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="joinrels.c.html#L669" title="optimizer/path/joinrels.c:669">init_dummy_sjinfo</a>(&amp;norm_sjinfo, outerrel-&gt;relids, innerrel-&gt;relids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nselec = <a href="clausesel.c.html#L100" title="optimizer/path/clausesel.c:100">clauselist_selectivity</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinquals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JOIN_INNER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;norm_sjinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Avoid leaking a lot of ListCells */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IS_OUTER_JOIN(jointype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(joinquals);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * jselec can be interpreted as the fraction of outer-rel rows that have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> matches (this is true for both SEMI and ANTI cases).&nbsp; And nselec is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the fraction of the Cartesian product that matches.&nbsp; So, the average<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number of matches for each outer-rel row that has at least one match is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nselec * inner_rows / jselec.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: it is correct to use the inner rel's &quot;rows&quot; count here, even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * though we might later be considering a parameterized inner path with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fewer rows.&nbsp; This is because we have included all the join clauses in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the selectivity estimate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (jselec &gt; <span class="Constant">0</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* protect against zero divide */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; avgmatch = nselec * innerrel-&gt;rows / jselec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Clamp to sane <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; avgmatch = Max(<span class="Constant">1.0</span>, avgmatch);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; avgmatch = <span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; semifactors-&gt;outer_match_frac = jselec;<br/></li>
<li>&nbsp; &nbsp; semifactors-&gt;match_count = avgmatch;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5101" title="optimizer/path/costsize.c:5101">has_indexed_join_quals</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Check whether all the joinquals of a nestloop join are used as<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; inner index quals.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the inner path of a SEMI/ANTI join is an indexscan (including bitmap<br/></li>
<li></span><span class="Comment"> * indexscan) that uses all the joinquals as indexquals, we can assume that an<br/></li>
<li></span><span class="Comment"> * unmatched outer tuple is cheap to process, whereas otherwise it's probably<br/></li>
<li></span><span class="Comment"> * expensive.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L5101">&#x200c;</a></span><span class="linkable">has_indexed_join_quals</span>(NestPath *path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JoinPath&nbsp;&nbsp; *joinpath = &amp;path-&gt;jpath;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; joinrelids = joinpath-&gt;path.parent-&gt;relids;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *innerpath = joinpath-&gt;innerjoinpath;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexclauses;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found_one;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If join still has quals to evaluate, it's not fast */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (joinpath-&gt;joinrestrictinfo != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nor if the inner path isn't parameterized at all */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (innerpath-&gt;param_info == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find the indexclauses list for the inner scan */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (innerpath-&gt;pathtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IndexScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IndexOnlyScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexclauses = ((IndexPath *) innerpath)-&gt;indexclauses;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_BitmapHeapScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Accept only a simple bitmap scan, not AND/OR cases */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *bmqual = ((BitmapHeapPath *) innerpath)-&gt;bitmapqual;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(bmqual, IndexPath))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexclauses = ((IndexPath *) bmqual)-&gt;indexclauses;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's not a simple indexscan, it probably doesn't run quickly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for zero rows out, even if it's a parameterized path using all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the joinquals.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Examine the inner path's param clauses.&nbsp; Any that are from the outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * path must be found in the indexclauses list, either exactly or in an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * equivalent form generated by equivclass.c.&nbsp; Also, we must <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> at least<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one such clause, else it's a clauseless join which isn't fast.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; found_one = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, innerpath-&gt;param_info-&gt;ppi_clauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/restrictinfo.c.html#L670" title="optimizer/util/restrictinfo.c:670">join_clause_is_movable_into</a>(rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; innerpath-&gt;parent-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrelids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="equivclass.c.html#L3308" title="optimizer/path/equivclass.c:3308">is_redundant_with_indexclauses</a>(rinfo, indexclauses))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found_one = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> found_one;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5194" title="optimizer/path/costsize.c:5194">approx_tuple_count</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Quick-and-dirty estimation of the number of join rows passing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; a set of qual conditions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The quals can be either an implicitly-ANDed list of boolean expressions,<br/></li>
<li></span><span class="Comment"> * or a list of RestrictInfo nodes (typically the latter).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We intentionally compute the selectivity under JOIN_INNER rules, even<br/></li>
<li></span><span class="Comment"> * if it's some type of outer join.&nbsp; This is appropriate because we are<br/></li>
<li></span><span class="Comment"> * trying to figure out how many tuples pass the initial <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> or <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment"> * join step.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is quick-and-dirty because we bypass <a href="clausesel.c.html#L100" title="optimizer/path/clausesel.c:100">clauselist_selectivity</a>, and<br/></li>
<li></span><span class="Comment"> * simply multiply the independent clause selectivities together.&nbsp; Now<br/></li>
<li></span><span class="Comment"> * <a href="clausesel.c.html#L100" title="optimizer/path/clausesel.c:100">clauselist_selectivity</a> often can't do <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> better than that anyhow, but<br/></li>
<li></span><span class="Comment"> * for some situations (such as <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> constraints) it is smarter.&nbsp; However,<br/></li>
<li></span><span class="Comment"> * we can't effectively cache the results of <a href="clausesel.c.html#L100" title="optimizer/path/clausesel.c:100">clauselist_selectivity</a>, whereas<br/></li>
<li></span><span class="Comment"> * the individual clause selectivities can be and are cached.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since we are only using the results to estimate how many potential<br/></li>
<li></span><span class="Comment"> * output tuples are generated and passed through qpqual checking, it<br/></li>
<li></span><span class="Comment"> * seems OK to live with the approximation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L5194">&#x200c;</a></span><span class="linkable">approx_tuple_count</span>(PlannerInfo *root, JoinPath *path, List *quals)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; tuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; outer_tuples = path-&gt;outerjoinpath-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; inner_tuples = path-&gt;innerjoinpath-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; SpecialJoinInfo sjinfo;<br/></li>
<li>&nbsp; &nbsp; Selectivity selec = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make up a SpecialJoinInfo for JOIN_INNER semantics.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="joinrels.c.html#L669" title="optimizer/path/joinrels.c:669">init_dummy_sjinfo</a>(&amp;sjinfo, path-&gt;outerjoinpath-&gt;parent-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path-&gt;innerjoinpath-&gt;parent-&gt;relids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the approximate selectivity */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, quals)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *qual = (Node *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Note that <a href="clausesel.c.html#L667" title="optimizer/path/clausesel.c:667">clause_selectivity</a> will be able to cache its result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; selec *= <a href="clausesel.c.html#L667" title="optimizer/path/clausesel.c:667">clause_selectivity</a>(root, qual, <span class="Constant">0</span>, JOIN_INNER, &amp;sjinfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Apply it to the input relation sizes */<br/></li>
<li></span>&nbsp; &nbsp; tuples = selec * outer_tuples * inner_tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(tuples);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5239" title="optimizer/path/costsize.c:5239">set_baserel_size_estimates</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set the size estimates for the given base relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The rel's targetlist and restrictinfo list must have been constructed<br/></li>
<li></span><span class="Comment"> * already, and rel-&gt;tuples must be set.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We set the following fields of the rel node:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; rows: the estimated number of output tuples (after applying<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restriction clauses).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; width: the estimated average output tuple width in bytes.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; baserestrictcost: estimated cost of evaluating baserestrictinfo clauses.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5239">&#x200c;</a></span><span class="linkable">set_baserel_size_estimates</span>(PlannerInfo *root, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nrows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should only be applied to base relations */<br/></li>
<li></span>&nbsp; &nbsp; Assert(rel-&gt;relid &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nrows = rel-&gt;tuples *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="clausesel.c.html#L100" title="optimizer/path/clausesel.c:100">clauselist_selectivity</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;baserestrictinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JOIN_INNER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel-&gt;rows = <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(nrows);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4640" title="optimizer/path/costsize.c:4640">cost_qual_eval</a>(&amp;rel-&gt;baserestrictcost, rel-&gt;baserestrictinfo, root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6099" title="optimizer/path/costsize.c:6099">set_rel_width</a>(root, rel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5269" title="optimizer/path/costsize.c:5269">get_parameterized_baserel_size</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Make a size estimate for a parameterized scan of a base relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'param_clauses' lists the additional join clauses to be used.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L5239" title="optimizer/path/costsize.c:5239">set_baserel_size_estimates</a> must have been applied already.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">double<br/></li>
<li><a id="L5269">&#x200c;</a></span><span class="linkable">get_parameterized_baserel_size</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *param_clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *allclauses;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nrows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate the number of rows returned by the parameterized scan, knowing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that it will apply all the extra join clauses as well as the rel's own<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restriction clauses.&nbsp; Note that we force the clauses to be treated as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-join clauses during selectivity estimation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; allclauses = <a href="../../nodes/list.c.html#L598" title="nodes/list.c:598">list_concat_copy</a>(param_clauses, rel-&gt;baserestrictinfo);<br/></li>
<li>&nbsp; &nbsp; nrows = rel-&gt;tuples *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="clausesel.c.html#L100" title="optimizer/path/clausesel.c:100">clauselist_selectivity</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; allclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;relid,&nbsp; &nbsp; <span class="Comment">/* do not use 0! */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JOIN_INNER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; nrows = <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(nrows);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For safety, make sure result is not more than the base estimate */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nrows &gt; rel-&gt;rows)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nrows = rel-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nrows;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5318" title="optimizer/path/costsize.c:5318">set_joinrel_size_estimates</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set the size estimates for the given join relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The rel's targetlist must have been constructed already, and a<br/></li>
<li></span><span class="Comment"> * restriction clause list that matches the given component rels must<br/></li>
<li></span><span class="Comment"> * be provided.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since there is more than one way to make a joinrel for more than two<br/></li>
<li></span><span class="Comment"> * base relations, the results we get here could depend on which component<br/></li>
<li></span><span class="Comment"> * rel pair is provided.&nbsp; In theory we should get the same answers no matter<br/></li>
<li></span><span class="Comment"> * which pair is provided; in practice, since the selectivity estimation<br/></li>
<li></span><span class="Comment"> * routines don't handle all cases equally well, we might not.&nbsp; But there's<br/></li>
<li></span><span class="Comment"> * not much to be done about it.&nbsp; (Would it make sense to <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> the<br/></li>
<li></span><span class="Comment"> * calculations for each pair of input rels that's encountered, and somehow<br/></li>
<li></span><span class="Comment"> * average the results?&nbsp; Probably way more trouble than it's worth, and<br/></li>
<li></span><span class="Comment"> * anyway we must keep the rowcount estimate the same for all paths for the<br/></li>
<li></span><span class="Comment"> * joinrel.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We set only the rows field here.&nbsp; The reltarget field was already set by<br/></li>
<li></span><span class="Comment"> * <a href="../util/relnode.c.html#L1112" title="optimizer/util/relnode.c:1112">build_joinrel_tlist</a>, and baserestrictcost is not used for join rels.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5318">&#x200c;</a></span><span class="linkable">set_joinrel_size_estimates</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *outer_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *inner_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SpecialJoinInfo *sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *restrictlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; rel-&gt;rows = <a href="#L5391" title="optimizer/path/costsize.c:5391">calc_joinrel_size_estimate</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outer_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inner_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outer_rel-&gt;rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inner_rel-&gt;rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; restrictlist);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5350" title="optimizer/path/costsize.c:5350">get_parameterized_joinrel_size</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Make a size estimate for a parameterized scan of a join relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rel' is the joinrel under consideration.<br/></li>
<li></span><span class="Comment"> * 'outer_path', 'inner_path' are (probably also parameterized) Paths that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; produce the relations being joined.<br/></li>
<li></span><span class="Comment"> * 'sjinfo' is <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SpecialJoinInfo relevant to this join.<br/></li>
<li></span><span class="Comment"> * 'restrict_clauses' lists the join clauses that need to be applied at the<br/></li>
<li></span><span class="Comment"> * join node (including <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> movable clauses that were moved down to this join,<br/></li>
<li></span><span class="Comment"> * and not including <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> movable clauses that were pushed down into the<br/></li>
<li></span><span class="Comment"> * child paths).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L5318" title="optimizer/path/costsize.c:5318">set_joinrel_size_estimates</a> must have been applied already.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">double<br/></li>
<li><a id="L5350">&#x200c;</a></span><span class="linkable">get_parameterized_joinrel_size</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Path *outer_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Path *inner_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SpecialJoinInfo *sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *restrict_clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nrows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate the number of rows returned by the parameterized join as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sizes of the input paths times the selectivity of the clauses that have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ended up at this join node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As with <a href="#L5318" title="optimizer/path/costsize.c:5318">set_joinrel_size_estimates</a>, the rowcount estimate could depend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on the pair of input paths provided, though ideally we'd get the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimate for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pair with the same parameterization.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nrows = <a href="#L5391" title="optimizer/path/costsize.c:5391">calc_joinrel_size_estimate</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outer_path-&gt;parent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inner_path-&gt;parent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outer_path-&gt;rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inner_path-&gt;rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; restrict_clauses);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For safety, make sure result is not more than the base estimate */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nrows &gt; rel-&gt;rows)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nrows = rel-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nrows;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5391" title="optimizer/path/costsize.c:5391">calc_joinrel_size_estimate</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Workhorse for <a href="#L5318" title="optimizer/path/costsize.c:5318">set_joinrel_size_estimates</a> and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5350" title="optimizer/path/costsize.c:5350">get_parameterized_joinrel_size</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * outer_rel/inner_rel are the relations being joined, but they should be<br/></li>
<li></span><span class="Comment"> * assumed to have sizes outer_rows/inner_rows; those numbers might be less<br/></li>
<li></span><span class="Comment"> * than what rel-&gt;rows says, when we are considering parameterized paths.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L5391">&#x200c;</a></span><span class="linkable">calc_joinrel_size_estimate</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *outer_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *inner_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> outer_rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> inner_rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SpecialJoinInfo *sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *restrictlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JoinType&nbsp; &nbsp; jointype = sjinfo-&gt;jointype;<br/></li>
<li>&nbsp; &nbsp; Selectivity fkselec;<br/></li>
<li>&nbsp; &nbsp; Selectivity jselec;<br/></li>
<li>&nbsp; &nbsp; Selectivity pselec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nrows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute joinclause selectivity.&nbsp; Note that we are only considering<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clauses that become restriction clauses at this join level; we are not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * double-counting them because they were not considered in estimating the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sizes of the component rels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, see whether <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the joinclauses can be matched to known FK<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constraints.&nbsp; If so, drop those clauses from the restrictlist, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * instead estimate their selectivity using FK semantics.&nbsp; (We do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * without regard to whether said clauses are local or &quot;pushed down&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Probably, an FK-matching clause could never be seen as pushed down at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an outer join, since it would be strict and hence would be grounds for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * join strength reduction.)&nbsp; fkselec gets the net selectivity for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * FK-matching clauses, or 1.0 if there are <a href="../util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fkselec = <a href="#L5541" title="optimizer/path/costsize.c:5541">get_foreign_key_join_selectivity</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outer_rel-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inner_rel-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;restrictlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For an outer join, we have to distinguish the selectivity of the join's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * own clauses (JOIN/ON conditions) from <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> clauses that were &quot;pushed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * down&quot;.&nbsp; For inner joins we just count them all as joinclauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IS_OUTER_JOIN(jointype))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *joinquals = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pushedquals = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Grovel through the clauses to separate into two lists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, restrictlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RINFO_IS_PUSHED_DOWN(rinfo, joinrel-&gt;relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushedquals = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(pushedquals, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinquals = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(joinquals, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the separate selectivities */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; jselec = <a href="clausesel.c.html#L100" title="optimizer/path/clausesel.c:100">clauselist_selectivity</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinquals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jointype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sjinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pselec = <a href="clausesel.c.html#L100" title="optimizer/path/clausesel.c:100">clauselist_selectivity</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushedquals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jointype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sjinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Avoid leaking a lot of ListCells */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(joinquals);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(pushedquals);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jselec = <a href="clausesel.c.html#L100" title="optimizer/path/clausesel.c:100">clauselist_selectivity</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restrictlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jointype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sjinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pselec = <span class="Constant">0.0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not used, keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Basically, we multiply size of Cartesian product by selectivity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are doing an outer join, take that into account: the joinqual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * selectivity has to be clamped using the knowledge that the output must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be at least as large as the non-nullable input.&nbsp; However, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pushed-down quals are applied after the outer join, so their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * selectivity applies fully.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For JOIN_SEMI and JOIN_ANTI, the selectivity is defined as the fraction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of LHS rows that have matches, and we apply that straightforwardly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (jointype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JOIN_INNER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrows = outer_rows * inner_rows * fkselec * jselec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pselec not used */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JOIN_LEFT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrows = outer_rows * inner_rows * fkselec * jselec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nrows &lt; outer_rows)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrows = outer_rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrows *= pselec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JOIN_FULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrows = outer_rows * inner_rows * fkselec * jselec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nrows &lt; outer_rows)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrows = outer_rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nrows &lt; inner_rows)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrows = inner_rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrows *= pselec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JOIN_SEMI:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrows = outer_rows * fkselec * jselec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pselec not used */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JOIN_ANTI:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrows = outer_rows * (<span class="Constant">1.0</span> - fkselec * jselec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrows *= pselec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* other <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> not expected here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized join type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) jointype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrows = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(nrows);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5541" title="optimizer/path/costsize.c:5541">get_foreign_key_join_selectivity</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Estimate join selectivity for foreign-key-related clauses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> clauses that can be matched to FK constraints from *restrictlist,<br/></li>
<li></span><span class="Comment"> * and return a substitute estimate of their selectivity.&nbsp; 1.0 is returned<br/></li>
<li></span><span class="Comment"> * when there are no such clauses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The reason for treating such clauses specially is that we can get better<br/></li>
<li></span><span class="Comment"> * estimates this way than by relying on <a href="clausesel.c.html#L100" title="optimizer/path/clausesel.c:100">clauselist_selectivity</a>(), especially<br/></li>
<li></span><span class="Comment"> * for multi-column FKs where that function's assumption that the clauses are<br/></li>
<li></span><span class="Comment"> * independent falls down badly.&nbsp; But even with single-column FKs, we may be<br/></li>
<li></span><span class="Comment"> * able to get a better answer when the pg_statistic stats are missing or out<br/></li>
<li></span><span class="Comment"> * of date.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Selectivity<br/></li>
<li><a id="L5541">&#x200c;</a><span class="linkable">get_foreign_key_join_selectivity</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids outer_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids inner_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SpecialJoinInfo *sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **restrictlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Selectivity fkselec = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; JoinType&nbsp; &nbsp; jointype = sjinfo-&gt;jointype;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *worklist = *restrictlist;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Consider each FK constraint that is known to match the query */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, root-&gt;fkey_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ForeignKeyOptInfo *fkinfo = (ForeignKeyOptInfo *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ref_is_outer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *removedlist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This FK is not relevant unless it connects a baserel on one side of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this join to a baserel on the other side.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(fkinfo-&gt;con_relid, outer_relids) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(fkinfo-&gt;ref_relid, inner_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ref_is_outer = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(fkinfo-&gt;ref_relid, outer_relids) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(fkinfo-&gt;con_relid, inner_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ref_is_outer = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're dealing with a semi/anti join, and the FK's referenced<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation is on the outside, then knowledge of the FK doesn't <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * us figure out what we need to know (which is the fraction of outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rows that have matches).&nbsp; On the other hand, if the referenced rel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is on the inside, then all outer rows must have matches in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * referenced table (ignoring nulls).&nbsp; But <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> restriction or join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clauses that filter that table will reduce the fraction of matches.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can account for restriction clauses, but it's too hard to guess<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * how many table rows would get through a join that's inside the RHS.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Hence, if either case applies, punt and ignore the FK.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((jointype == JOIN_SEMI || jointype == JOIN_ANTI) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ref_is_outer || <a href="../../nodes/bitmapset.c.html#L781" title="nodes/bitmapset.c:781">bms_membership</a>(inner_relids) != BMS_SINGLETON))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Modify the restrictlist by removing clauses that match the FK (and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * putting them into removedlist instead).&nbsp; It seems unsafe to modify<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the originally-passed List structure, so we make a shallow copy the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first time through.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (worklist == *restrictlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worklist = <a href="../../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(worklist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; removedlist = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(cell, worklist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; remove_it = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Drop this clause if it matches <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> column of the FK */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; fkinfo-&gt;nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rinfo-&gt;parent_ec)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * EC-derived clauses can only match by EC.&nbsp; It is okay to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consider <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> clause derived from the same EC as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matching the FK: even if equivclass.c chose to generate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a clause equating some other pair of Vars, it could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have generated one equating the FK's Vars.&nbsp; So for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * purposes of estimation, we can act as though it did so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: checking parent_ec is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of a cheat because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there are EC-derived clauses that don't have parent_ec<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set; but such clauses must <a href="../geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> expressions that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aren't just Vars, so they cannot match the FK anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fkinfo-&gt;<a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a>[i] == rinfo-&gt;parent_ec)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remove_it = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, see if rinfo was previously matched to FK as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a &quot;loose&quot; clause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/list.c.html#L682" title="nodes/list.c:682">list_member_ptr</a>(fkinfo-&gt;rinfos[i], rinfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remove_it = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (remove_it)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worklist = foreach_delete_current(worklist, cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; removedlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(removedlist, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we failed to remove all the matching clauses we expected to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a>, chicken out and ignore this FK; applying its selectivity<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might result in double-counting.&nbsp; Put <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> clauses we did manage to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remove back into the worklist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since the matching clauses are known not outerjoin-delayed, they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would normally have appeared in the initial joinclause list.&nbsp; If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> them, there are two possibilities:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 1. If the FK match is based on an EC that is ec_has_const, it won't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have generated <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> join clauses at all.&nbsp; We discount such ECs while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checking to see if we have &quot;all&quot; the clauses.&nbsp; (Below, we'll adjust<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the selectivity estimate for this case.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 2. The clauses were matched to some other FK in a previous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * iteration of this loop, and thus removed from worklist.&nbsp; (A likely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case is that two FKs are matched to the same EC; there will be only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one EC-derived clause in the initial list, so the first FK will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consume it.)&nbsp; Applying both FKs' selectivity independently risks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * underestimating the join size; in particular, this would undo one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> things that ECs were invented for, namely to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * double-counting the selectivity of redundant equality conditions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Later we might think of a reasonable way to <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> the estimates,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, just punt, since this is a fairly uncommon situation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (removedlist == NIL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(removedlist) !=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (fkinfo-&gt;nmatched_ec - fkinfo-&gt;nconst_ec + fkinfo-&gt;nmatched_ri))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worklist = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(worklist, removedlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Finally we get to the payoff: estimate selectivity using the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * knowledge that each referencing row will match exactly one row in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the referenced table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> that's not true in the presence of nulls in the referencing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column(s), so in principle we should derate the estimate for those.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However (1) if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> strict restriction clauses for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * referencing column(s) elsewhere in the query, derating here would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be double-counting the null fraction, and (2) it's not very clear<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * how to <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> null fractions for multiple referencing columns. So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we do nothing for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> about correcting for nulls.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> another point here is that if either side of an FK constraint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is an inheritance parent, we estimate as though the constraint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * covers all its children as well.&nbsp; This is not an unreasonable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assumption for a referencing table, ie the user probably applied<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * identical constraints to all child tables (though perhaps we ought<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to check that).&nbsp; But it's not possible to have done that for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * referenced table.&nbsp; Fortunately, precisely because that doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * work, it is uncommon in practice to have an FK referencing a parent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * table.&nbsp; So, at least for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, disregard inheritance here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (jointype == JOIN_SEMI || jointype == JOIN_ANTI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For JOIN_SEMI and JOIN_ANTI, we only get here when the FK's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * referenced table is exactly the inside of the join.&nbsp; The join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * selectivity is defined as the fraction of LHS rows that have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matches.&nbsp; The FK implies that every LHS row has a match *in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * referenced table*; but <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> restriction clauses on it will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reduce the number of matches.&nbsp; Hence we take the join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * selectivity as <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the selectivity of the table's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * restriction clauses, which is rows / tuples; but we must guard<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * against tuples == 0.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *ref_rel = <a href="../util/relnode.c.html#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(root, fkinfo-&gt;ref_relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; ref_tuples = Max(ref_rel-&gt;tuples, <span class="Constant">1.0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkselec *= ref_rel-&gt;rows / ref_tuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, selectivity is exactly 1/referenced-table-size; but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * guard against tuples == 0.&nbsp; Note we should use the raw table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple count, not <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> estimate of its filtered or joined size.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *ref_rel = <a href="../util/relnode.c.html#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(root, fkinfo-&gt;ref_relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; ref_tuples = Max(ref_rel-&gt;tuples, <span class="Constant">1.0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkselec *= <span class="Constant">1.0</span> / ref_tuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the FK columns participated in ec_has_const ECs, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * equivclass.c will have generated &quot;var = const&quot; restrictions for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * each side of the join, thus reducing the sizes of both input<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relations.&nbsp; Taking the fkselec at face value would amount to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * double-counting the selectivity of the constant restriction for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * referencing Var.&nbsp; Hence, look for the restriction clause(s) that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * were applied to the referencing Var(s), and divide out their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * selectivity to correct for this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fkinfo-&gt;nconst_ec &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; fkinfo-&gt;nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EquivalenceClass *ec = fkinfo-&gt;<a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ec &amp;&amp; ec-&gt;ec_has_const)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EquivalenceMember *em = fkinfo-&gt;fk_eclass_member[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = <a href="equivclass.c.html#L2607" title="optimizer/path/equivclass.c:2607">find_derived_clause_for_ec_member</a>(ec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; em);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rinfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Selectivity s0;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s0 = <a href="clausesel.c.html#L667" title="optimizer/path/clausesel.c:667">clause_selectivity</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Node *) rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jointype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sjinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s0 &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fkselec /= s0;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *restrictlist = worklist;<br/></li>
<li>&nbsp; &nbsp; CLAMP_PROBABILITY(fkselec);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> fkselec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5792" title="optimizer/path/costsize.c:5792">set_subquery_size_estimates</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set the size estimates for a base relation that is a subquery.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The rel's targetlist and restrictinfo list must have been constructed<br/></li>
<li></span><span class="Comment"> * already, and the Paths for the subquery must have been completed.<br/></li>
<li></span><span class="Comment"> * We look at the subquery's PlannerInfo to extract data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We set the same fields as <a href="#L5239" title="optimizer/path/costsize.c:5239">set_baserel_size_estimates</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5792">&#x200c;</a></span><span class="linkable">set_subquery_size_estimates</span>(PlannerInfo *root, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *subroot = rel-&gt;subroot;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *sub_final_rel;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should only be applied to base relations that are subqueries */<br/></li>
<li></span>&nbsp; &nbsp; Assert(rel-&gt;relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(planner_rt_fetch(rel-&gt;relid, root)-&gt;rtekind == RTE_SUBQUERY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy raw number of output rows from subquery.&nbsp; All of its paths should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have the same output rowcount, so just look at cheapest-total.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sub_final_rel = <a href="../util/relnode.c.html#L1470" title="optimizer/util/relnode.c:1470">fetch_upper_rel</a>(subroot, UPPERREL_FINAL, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; rel-&gt;tuples = sub_final_rel-&gt;cheapest_total_path-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute per-output-column width estimates by examining the subquery's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * targetlist.&nbsp; For <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> output that is a plain Var, get the width estimate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that was made while planning the subquery.&nbsp; Otherwise, we leave it to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L6099" title="optimizer/path/costsize.c:6099">set_rel_width</a> to fill in a datatype-based default estimate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, subroot-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;targetList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *te = lfirst_node(TargetEntry, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *texpr = (Node *) te-&gt;expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; item_width = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* junk columns aren't visible to <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> query */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (te-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The subquery could be an expansion of a view that's had columns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * added to it since the current query was parsed, so that there are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-junk tlist columns in it that don't correspond to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * visible at our query level.&nbsp; Ignore such columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (te-&gt;resno &lt; rel-&gt;min_attr || te-&gt;resno &gt; rel-&gt;max_attr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> This currently doesn't work for subqueries containing set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operations, because the Vars in their tlists are bogus references<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the first leaf subquery, which wouldn't give the right answer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * even if we could still get to its PlannerInfo.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also, the subquery could be an appendrel for which all branches are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * known empty due to constraint exclusion, in which case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="allpaths.c.html#L1232" title="optimizer/path/allpaths.c:1232">set_append_rel_pathlist</a> will have left the attr_widths set to zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In either case, we just leave the width estimate zero until<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L6099" title="optimizer/path/costsize.c:6099">set_rel_width</a> fixes it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(texpr, Var) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subroot-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;setOperations == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) texpr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *subrel = <a href="../util/relnode.c.html#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(subroot, var-&gt;varno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item_width = subrel-&gt;attr_widths[var-&gt;varattno - subrel-&gt;min_attr];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;attr_widths[te-&gt;resno - rel-&gt;min_attr] = item_width;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now estimate number of output rows, etc */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5239" title="optimizer/path/costsize.c:5239">set_baserel_size_estimates</a>(root, rel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5872" title="optimizer/path/costsize.c:5872">set_function_size_estimates</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set the size estimates for a base relation that is a function call.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The rel's targetlist and restrictinfo list must have been constructed<br/></li>
<li></span><span class="Comment"> * already.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We set the same fields as <a href="#L5239" title="optimizer/path/costsize.c:5239">set_baserel_size_estimates</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5872">&#x200c;</a></span><span class="linkable">set_function_size_estimates</span>(PlannerInfo *root, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should only be applied to base relations that are <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span>&nbsp; &nbsp; Assert(rel-&gt;relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; rte = planner_rt_fetch(rel-&gt;relid, root);<br/></li>
<li>&nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_FUNCTION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate number of rows the <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> will return. The rowcount of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * node is that of the largest function result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;tuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, rte-&gt;<a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblFunction *rtfunc = (RangeTblFunction *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; ntup = <a href="../util/clauses.c.html#L289" title="optimizer/util/clauses.c:289">expression_returns_set_rows</a>(root, rtfunc-&gt;funcexpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ntup &gt; rel-&gt;tuples)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;tuples = ntup;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now estimate number of output rows, etc */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5239" title="optimizer/path/costsize.c:5239">set_baserel_size_estimates</a>(root, rel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5872" title="optimizer/path/costsize.c:5872">set_function_size_estimates</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set the size estimates for a base relation that is a function call.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The rel's targetlist and restrictinfo list must have been constructed<br/></li>
<li></span><span class="Comment"> * already.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We set the same fields as <a href="#L5910" title="optimizer/path/costsize.c:5910">set_tablefunc_size_estimates</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5910">&#x200c;</a></span><span class="linkable">set_tablefunc_size_estimates</span>(PlannerInfo *root, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should only be applied to base relations that are <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span>&nbsp; &nbsp; Assert(rel-&gt;relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(planner_rt_fetch(rel-&gt;relid, root)-&gt;rtekind == RTE_TABLEFUNC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel-&gt;tuples = <span class="Constant">100</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now estimate number of output rows, etc */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5239" title="optimizer/path/costsize.c:5239">set_baserel_size_estimates</a>(root, rel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5932" title="optimizer/path/costsize.c:5932">set_values_size_estimates</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set the size estimates for a base relation that is a <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The rel's targetlist and restrictinfo list must have been constructed<br/></li>
<li></span><span class="Comment"> * already.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We set the same fields as <a href="#L5239" title="optimizer/path/costsize.c:5239">set_baserel_size_estimates</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5932">&#x200c;</a></span><span class="linkable">set_values_size_estimates</span>(PlannerInfo *root, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should only be applied to base relations that are <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> lists */<br/></li>
<li></span>&nbsp; &nbsp; Assert(rel-&gt;relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; rte = planner_rt_fetch(rel-&gt;relid, root);<br/></li>
<li>&nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_VALUES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate number of rows the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> list will return. We know this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * precisely based on the list length (well, barring set-returning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in list items, but that's a refinement not catered for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anywhere else either).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;tuples = list_length(rte-&gt;values_lists);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now estimate number of output rows, etc */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5239" title="optimizer/path/costsize.c:5239">set_baserel_size_estimates</a>(root, rel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5964" title="optimizer/path/costsize.c:5964">set_cte_size_estimates</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set the size estimates for a base relation that is a CTE reference.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The rel's targetlist and restrictinfo list must have been constructed<br/></li>
<li></span><span class="Comment"> * already, and we need an estimate of the number of rows returned by the CTE<br/></li>
<li></span><span class="Comment"> * (if a regular CTE) or the non-recursive term (if a self-reference).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We set the same fields as <a href="#L5239" title="optimizer/path/costsize.c:5239">set_baserel_size_estimates</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5964">&#x200c;</a></span><span class="linkable">set_cte_size_estimates</span>(PlannerInfo *root, RelOptInfo *rel, <span class="Type">double</span> cte_rows)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should only be applied to base relations that are CTE references */<br/></li>
<li></span>&nbsp; &nbsp; Assert(rel-&gt;relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; rte = planner_rt_fetch(rel-&gt;relid, root);<br/></li>
<li>&nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_CTE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;self_reference)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In a self-reference, we assume the average worktable size is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multiple of the nonrecursive term's size.&nbsp; The best multiplier will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * vary depending on query &quot;fan-out&quot;, so make its value adjustable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;tuples = <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(<a href="#L126" title="optimizer/path/costsize.c:126">recursive_worktable_factor</a> * cte_rows);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise just believe the CTE's rowcount estimate */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;tuples = cte_rows;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now estimate number of output rows, etc */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5239" title="optimizer/path/costsize.c:5239">set_baserel_size_estimates</a>(root, rel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6002" title="optimizer/path/costsize.c:6002">set_namedtuplestore_size_estimates</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set the size estimates for a base relation that is a tuplestore reference.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The rel's targetlist and restrictinfo list must have been constructed<br/></li>
<li></span><span class="Comment"> * already.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We set the same fields as <a href="#L5239" title="optimizer/path/costsize.c:5239">set_baserel_size_estimates</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L6002">&#x200c;</a></span><span class="linkable">set_namedtuplestore_size_estimates</span>(PlannerInfo *root, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should only be applied to base relations that are tuplestore references */<br/></li>
<li></span>&nbsp; &nbsp; Assert(rel-&gt;relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; rte = planner_rt_fetch(rel-&gt;relid, root);<br/></li>
<li>&nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_NAMEDTUPLESTORE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use the estimate provided by the code which is generating the named<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuplestore.&nbsp; In some cases, the actual number might be available; in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * others the same plan will be re-used, so a &quot;typical&quot; value might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimated and used.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;tuples = rte-&gt;enrtuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;tuples &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;tuples = <span class="Constant">1000</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now estimate number of output rows, etc */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5239" title="optimizer/path/costsize.c:5239">set_baserel_size_estimates</a>(root, rel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6035" title="optimizer/path/costsize.c:6035">set_result_size_estimates</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set the size estimates for an RTE_RESULT base relation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The rel's targetlist and restrictinfo list must have been constructed<br/></li>
<li></span><span class="Comment"> * already.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We set the same fields as <a href="#L5239" title="optimizer/path/costsize.c:5239">set_baserel_size_estimates</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L6035">&#x200c;</a></span><span class="linkable">set_result_size_estimates</span>(PlannerInfo *root, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should only be applied to RTE_RESULT base relations */<br/></li>
<li></span>&nbsp; &nbsp; Assert(rel-&gt;relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(planner_rt_fetch(rel-&gt;relid, root)-&gt;rtekind == RTE_RESULT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* RTE_RESULT always generates a single row, natively */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;tuples = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now estimate number of output rows, etc */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5239" title="optimizer/path/costsize.c:5239">set_baserel_size_estimates</a>(root, rel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6064" title="optimizer/path/costsize.c:6064">set_foreign_size_estimates</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set the size estimates for a base relation that is a foreign table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There is not a whole lot that we can do here; the foreign-data wrapper<br/></li>
<li></span><span class="Comment"> * is responsible for producing useful estimates.&nbsp; We can do a decent job<br/></li>
<li></span><span class="Comment"> * of estimating baserestrictcost, so we set that, and we also set up width<br/></li>
<li></span><span class="Comment"> * using what will be purely datatype-driven estimates from the targetlist.<br/></li>
<li></span><span class="Comment"> * There is no way to do anything sane with the rows value, so we just put<br/></li>
<li></span><span class="Comment"> * a default estimate and hope that the wrapper can improve on it.&nbsp; The<br/></li>
<li></span><span class="Comment"> * wrapper's GetForeignRelSize function will be called momentarily.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The rel's targetlist and restrictinfo list must have been constructed<br/></li>
<li></span><span class="Comment"> * already.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L6064">&#x200c;</a></span><span class="linkable">set_foreign_size_estimates</span>(PlannerInfo *root, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should only be applied to base relations */<br/></li>
<li></span>&nbsp; &nbsp; Assert(rel-&gt;relid &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel-&gt;rows = <span class="Constant">1000</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* entirely bogus default estimate */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L4640" title="optimizer/path/costsize.c:4640">cost_qual_eval</a>(&amp;rel-&gt;baserestrictcost, rel-&gt;baserestrictinfo, root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L6099" title="optimizer/path/costsize.c:6099">set_rel_width</a>(root, rel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6099" title="optimizer/path/costsize.c:6099">set_rel_width</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set the estimated output width of a base relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The estimated output width is the sum of the per-attribute width estimates<br/></li>
<li></span><span class="Comment"> * for the actually-referenced columns, plus <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> PHVs or other expressions<br/></li>
<li></span><span class="Comment"> * that have to be calculated at this relation.&nbsp; This is the amount of data<br/></li>
<li></span><span class="Comment"> * we'd need to pass upwards in case of a sort, <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>, etc.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function also sets reltarget-&gt;cost, so it's a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> misnamed <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: this works best on plain relations because it prefers to look at<br/></li>
<li></span><span class="Comment"> * real Vars.&nbsp; For subqueries, <a href="#L5792" title="optimizer/path/costsize.c:5792">set_subquery_size_estimates</a> will already have<br/></li>
<li></span><span class="Comment"> * copied up whatever per-column estimates were made within the subquery,<br/></li>
<li></span><span class="Comment"> * and for other types of rels there isn't much we can do anyway.&nbsp; We fall<br/></li>
<li></span><span class="Comment"> * back on (fairly stupid) datatype-based width estimates if we can't get<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> better number.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The per-attribute width estimates are cached for possible re-use while<br/></li>
<li></span><span class="Comment"> * building join relations or post-scan/join pathtargets.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6099">&#x200c;</a></span><span class="linkable">set_rel_width</span>(PlannerInfo *root, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reloid = planner_rt_fetch(rel-&gt;relid, root)-&gt;relid;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; tuple_width = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_wholerow_var = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Vars are assumed to have cost zero, but other exprs do not */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;reltarget-&gt;cost.startup = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;reltarget-&gt;cost.per_tuple = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, rel-&gt;reltarget-&gt;exprs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *node = (Node *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ordinarily, a Var in a rel's targetlist must belong to that rel;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but there are corner cases involving LATERAL references where that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * isn't so.&nbsp; If the Var has the wrong varno, fall through to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * generic case (it doesn't seem worth the trouble to be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> smarter).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((Var *) node)-&gt;varno == rel-&gt;relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; item_width;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(var-&gt;varattno &gt;= rel-&gt;min_attr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(var-&gt;varattno &lt;= rel-&gt;max_attr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndx = var-&gt;varattno - rel-&gt;min_attr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's a whole-row Var, we'll deal with it below after we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already cached as many attr widths as possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varattno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_wholerow_var = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The width may have been cached already (especially if it's a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subquery), so don't duplicate effort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;attr_widths[ndx] &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_width += rel-&gt;attr_widths[ndx];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to get column width from statistics */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (reloid != InvalidOid &amp;&amp; var-&gt;varattno &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item_width = <a href="../../utils/cache/lsyscache.c.html#L3158" title="utils/cache/lsyscache.c:3158">get_attavgwidth</a>(reloid, var-&gt;varattno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item_width &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;attr_widths[ndx] = item_width;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_width += item_width;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Not a plain relation, or can't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> statistics for it. Estimate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * using just the type info.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item_width = <a href="../../utils/cache/lsyscache.c.html#L2578" title="utils/cache/lsyscache.c:2578">get_typavgwidth</a>(var-&gt;vartype, var-&gt;vartypmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(item_width &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;attr_widths[ndx] = item_width;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_width += item_width;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We will need to evaluate the PHV's contained expression while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scanning this rel, so be sure to include it in reltarget-&gt;cost.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *phv = (PlaceHolderVar *) node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderInfo *phinfo = <a href="../util/placeholder.c.html#L83" title="optimizer/util/placeholder.c:83">find_placeholder_info</a>(root, phv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QualCost&nbsp; &nbsp; cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_width += phinfo-&gt;ph_width;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4666" title="optimizer/path/costsize.c:4666">cost_qual_eval_node</a>(&amp;cost, (Node *) phv-&gt;phexpr, root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;reltarget-&gt;cost.startup += cost.startup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;reltarget-&gt;cost.per_tuple += cost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We could be looking at an expression pulled up from a subquery,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or a ROW() representing a whole-row child Var, etc.&nbsp; Do what we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can using the expression type information.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; item_width;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QualCost&nbsp; &nbsp; cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item_width = <a href="../../utils/cache/lsyscache.c.html#L2578" title="utils/cache/lsyscache.c:2578">get_typavgwidth</a>(<a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(node), <a href="../../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>(node));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(item_width &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_width += item_width;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not entirely clear if we need to account for cost, but do so */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4666" title="optimizer/path/costsize.c:4666">cost_qual_eval_node</a>(&amp;cost, node, root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;reltarget-&gt;cost.startup += cost.startup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;reltarget-&gt;cost.per_tuple += cost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have a whole-row reference, estimate its width as the sum of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * per-column widths plus heap tuple header overhead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (have_wholerow_var)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; wholerow_width = MAXALIGN(SizeofHeapTupleHeader);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (reloid != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Real relation, so estimate true tuple width */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wholerow_width += <a href="../util/plancat.c.html#L1208" title="optimizer/util/plancat.c:1208">get_relation_data_width</a>(reloid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;attr_widths - rel-&gt;min_attr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do what we can with info for a phony rel */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= rel-&gt;max_attr; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wholerow_width += rel-&gt;attr_widths[i - rel-&gt;min_attr];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;attr_widths[<span class="Constant">0</span> - rel-&gt;min_attr] = <a href="#L231" title="optimizer/path/costsize.c:231">clamp_width_est</a>(wholerow_width);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Include the whole-row Var as part of the output tuple.&nbsp; Yes, that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * really is what happens at runtime.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tuple_width += wholerow_width;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel-&gt;reltarget-&gt;width = <a href="#L231" title="optimizer/path/costsize.c:231">clamp_width_est</a>(tuple_width);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6256" title="optimizer/path/costsize.c:6256">set_pathtarget_cost_width</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set the estimated eval cost and output width of a PathTarget tlist.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As a notational convenience, returns the same PathTarget pointer passed in.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Most, though not quite all, uses of this function occur after we've run<br/></li>
<li></span><span class="Comment"> * <a href="#L6099" title="optimizer/path/costsize.c:6099">set_rel_width</a>() for base relations; so we can usually obtain cached width<br/></li>
<li></span><span class="Comment"> * estimates for Vars.&nbsp; If we can't, fall back on datatype-based width<br/></li>
<li></span><span class="Comment"> * estimates.&nbsp; Present early-planning uses of PathTargets don't need accurate<br/></li>
<li></span><span class="Comment"> * widths badly enough to justify going to the catalogs for better data.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PathTarget *<br/></li>
<li><a id="L6256">&#x200c;</a><span class="linkable">set_pathtarget_cost_width</span>(PlannerInfo *root, PathTarget *target)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; tuple_width = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Vars are assumed to have cost zero, but other exprs do not */<br/></li>
<li></span>&nbsp; &nbsp; target-&gt;cost.startup = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; target-&gt;cost.per_tuple = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, target-&gt;exprs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *node = (Node *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple_width += <a href="#L6294" title="optimizer/path/costsize.c:6294">get_expr_width</a>(root, node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* For non-Vars, account for evaluation cost */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QualCost&nbsp; &nbsp; cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4666" title="optimizer/path/costsize.c:4666">cost_qual_eval_node</a>(&amp;cost, node, root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target-&gt;cost.startup += cost.startup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target-&gt;cost.per_tuple += cost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; target-&gt;width = <a href="#L231" title="optimizer/path/costsize.c:231">clamp_width_est</a>(tuple_width);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> target;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6294" title="optimizer/path/costsize.c:6294">get_expr_width</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Estimate the width of the given expr attempting to use the width<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; cached in a Var's owning RelOptInfo, else fallback on the type's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; average width when unable to or when the given Node is not a Var.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> int32<br/></li>
<li><a id="L6294">&#x200c;</a><span class="linkable">get_expr_width</span>(PlannerInfo *root, <span class="Type">const</span> Node *expr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; width;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(expr, Var))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> Var&nbsp; *var = (<span class="Type">const</span> Var *) expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We should not see <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level Vars here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(var-&gt;varlevelsup == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to get data from RelOptInfo cache */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IS_SPECIAL_VARNO(var-&gt;varno) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varno &lt; root-&gt;simple_rel_array_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel = root-&gt;simple_rel_array[var-&gt;varno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varattno &gt;= rel-&gt;min_attr &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varattno &lt;= rel-&gt;max_attr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndx = var-&gt;varattno - rel-&gt;min_attr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;attr_widths[ndx] &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> rel-&gt;attr_widths[ndx];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No cached data available, so estimate using just the type info.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; width = <a href="../../utils/cache/lsyscache.c.html#L2578" title="utils/cache/lsyscache.c:2578">get_typavgwidth</a>(var-&gt;vartype, var-&gt;vartypmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(width &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> width;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; width = <a href="../../utils/cache/lsyscache.c.html#L2578" title="utils/cache/lsyscache.c:2578">get_typavgwidth</a>(<a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(expr), <a href="../../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>(expr));<br/></li>
<li>&nbsp; &nbsp; Assert(width &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> width;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6342" title="optimizer/path/costsize.c:6342">relation_byte_size</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Estimate the storage space in bytes for a given number of tuples<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; of a given width (size in bytes).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L6342">&#x200c;</a></span><span class="linkable">relation_byte_size</span>(<span class="Type">double</span> tuples, <span class="Type">int</span> width)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tuples * (MAXALIGN(width) + MAXALIGN(SizeofHeapTupleHeader));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6353" title="optimizer/path/costsize.c:6353">page_size</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Returns an estimate of the number of pages covered by a given<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; number of tuples of a given width (size in bytes).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L6353">&#x200c;</a></span><span class="linkable">page_size</span>(<span class="Type">double</span> tuples, <span class="Type">int</span> width)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ceil(<a href="#L6342" title="optimizer/path/costsize.c:6342">relation_byte_size</a>(tuples, width) / BLCKSZ);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Estimate the fraction of the work that each worker will do given the<br/></li>
<li></span><span class="Comment"> * number of workers budgeted for the path.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L6363">&#x200c;</a></span><span class="linkable">get_parallel_divisor</span>(Path *path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; parallel_divisor = path-&gt;parallel_workers;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Early experience with parallel query suggests that when there is only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one worker, the leader often makes a very substantial contribution to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * executing the parallel portion of the plan, but as more workers are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * added, it does less and less, because it's busy reading tuples from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * workers and doing whatever non-parallel post-processing is needed.&nbsp; By<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the time we reach 4 workers, the leader no longer makes a meaningful<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contribution.&nbsp; Thus, for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, estimate that the leader spends 30% of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its time servicing each worker, and the remainder executing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parallel plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../plan/planner.c.html#L68" title="optimizer/plan/planner.c:68">parallel_leader_participation</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; leader_contribution;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; leader_contribution = <span class="Constant">1.0</span> - (<span class="Constant">0.3</span> * path-&gt;parallel_workers);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (leader_contribution &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parallel_divisor += leader_contribution;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> parallel_divisor;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6403" title="optimizer/path/costsize.c:6403">compute_bitmap_pages</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Estimate number of pages fetched from heap in a bitmap heap scan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'baserel' is the relation to be scanned<br/></li>
<li></span><span class="Comment"> * 'bitmapqual' is a tree of IndexPaths, BitmapAndPaths, and BitmapOrPaths<br/></li>
<li></span><span class="Comment"> * 'loop_count' is the number of repetitions of the indexscan to factor into<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; estimates of caching behavior<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If cost_p isn't NULL, the indexTotalCost estimate is returned in *cost_p.<br/></li>
<li></span><span class="Comment"> * If tuples_p isn't NULL, the tuples_fetched estimate is returned in *tuples_p.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">double<br/></li>
<li><a id="L6403">&#x200c;</a></span><span class="linkable">compute_bitmap_pages</span>(PlannerInfo *root, RelOptInfo *baserel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Path *bitmapqual, <span class="Type">double</span> loop_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Cost *cost_p, <span class="Type">double</span> *tuples_p)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; indexTotalCost;<br/></li>
<li>&nbsp; &nbsp; Selectivity indexSelectivity;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; T;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; pages_fetched;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; tuples_fetched;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; heap_pages;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; maxentries;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fetch total cost of obtaining the bitmap, as well as its total<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * selectivity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1114" title="optimizer/path/costsize.c:1114">cost_bitmap_tree_node</a>(bitmapqual, &amp;indexTotalCost, &amp;indexSelectivity);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate number of <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a>-table pages fetched.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tuples_fetched = <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(indexSelectivity * baserel-&gt;tuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; T = (baserel-&gt;pages &gt; <span class="Constant">1</span>) ? (<span class="Type">double</span>) baserel-&gt;pages : <span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For a single scan, the number of heap pages that need to be fetched is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the same as the Mackert and Lohman formula for the case T &lt;= b (ie, no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * re-reads needed).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pages_fetched = (<span class="Constant">2.0</span> * T * tuples_fetched) / (<span class="Constant">2.0</span> * T + tuples_fetched);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate the number of pages fetched from the heap.&nbsp; Then based on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a> estimate get the estimated maxentries in the bitmap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Note that we always do this calculation based on the number of pages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that would be fetched in a single iteration, even if loop_count &gt; 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * That's correct, because only that number of entries will be stored in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the bitmap at one time.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; heap_pages = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(pages_fetched, baserel-&gt;pages);<br/></li>
<li>&nbsp; &nbsp; maxentries = <a href="../../nodes/tidbitmap.c.html#L1542" title="nodes/tidbitmap.c:1542">tbm_calculate_entries</a>(<a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a> * <span class="Constant">1024L</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (loop_count &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For repeated bitmap scans, scale up the number of tuples fetched in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the Mackert and Lohman formula by the number of scans, so that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * estimate the number of pages fetched by all the scans. Then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pro-rate for one scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pages_fetched = <a href="#L898" title="optimizer/path/costsize.c:898">index_pages_fetched</a>(tuples_fetched * loop_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; baserel-&gt;pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L963" title="optimizer/path/costsize.c:963">get_indexpath_pages</a>(bitmapqual),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pages_fetched /= loop_count;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pages_fetched &gt;= T)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pages_fetched = T;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pages_fetched = ceil(pages_fetched);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (maxentries &lt; heap_pages)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; exact_pages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; lossy_pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Crude approximation of the number of lossy pages.&nbsp; Because of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * way <a href="../../nodes/tidbitmap.c.html#L1355" title="nodes/tidbitmap.c:1355">tbm_lossify</a>() is coded, the number of lossy pages increases<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * very sharply as soon as we run short of memory; this formula has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that property and seems to perform adequately in testing, but it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible we could do better somehow.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lossy_pages = Max(<span class="Constant">0</span>, heap_pages - maxentries / <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; exact_pages = heap_pages - lossy_pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there are lossy pages then recompute the number of tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * processed by the bitmap heap node.&nbsp; We assume here that the chance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of a given tuple coming from an exact page is the same as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * chance that a given page is exact.&nbsp; This might not be true, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's not clear how we can do <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> better.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lossy_pages &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuples_fetched =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(indexSelectivity *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (exact_pages / heap_pages) * baserel-&gt;tuples +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lossy_pages / heap_pages) * baserel-&gt;tuples);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cost_p)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *cost_p = indexTotalCost;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tuples_p)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *tuples_p = tuples_fetched;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pages_fetched;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
