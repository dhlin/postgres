<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>optimizer/path/indxpath.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>optimizer/path/indxpath.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L57">IndexClauseSet</a></li>
<li><a href="#L67">PathClauseUsage</a></li>
<li><a href="#L49">ScanTypeControl</a></li>
<li><a href="#L74">ec_member_matches_arg</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L2280">IsBooleanOpfamily</a></li>
<li><a href="#L1882">adjust_rowcount_for_semijoins</a></li>
<li><a href="#L1926">approximate_joinrel_size</a></li>
<li><a href="#L1560">bitmap_and_cost_est</a></li>
<li><a href="#L1526">bitmap_scan_cost_est</a></li>
<li><a href="#L804">build_index_paths</a></li>
<li><a href="#L1086">build_paths_for_OR</a></li>
<li><a href="#L1730">check_index_only</a></li>
<li><a href="#L3244">check_index_predicates</a></li>
<li><a href="#L1287">choose_bitmap_and</a></li>
<li><a href="#L1589">classify_index_clause_usage</a></li>
<li><a href="#L431">consider_index_join_clauses</a></li>
<li><a href="#L497">consider_index_join_outer_rels</a></li>
<li><a href="#L234">create_index_paths</a></li>
<li><a href="#L3382">ec_member_matches_indexcol</a></li>
<li><a href="#L678">eclass_already_used</a></li>
<li><a href="#L2798">expand_indexqual_rowcompare</a></li>
<li><a href="#L1657">find_indexpath_quals</a></li>
<li><a href="#L1704">find_list_position</a></li>
<li><a href="#L1180">generate_bitmap_or_paths</a></li>
<li><a href="#L2557">get_index_clause_from_support</a></li>
<li><a href="#L710">get_index_paths</a></li>
<li><a href="#L600">get_join_index_paths</a></li>
<li><a href="#L1829">get_loop_count</a></li>
<li><a href="#L3653">indexcol_is_bool_constant_for_query</a></li>
<li><a href="#L3790">is_pseudo_constant_for_index</a></li>
<li><a href="#L2305">match_boolean_index_clause</a></li>
<li><a href="#L2084">match_clause_to_index</a></li>
<li><a href="#L2203">match_clause_to_indexcol</a></li>
<li><a href="#L3130">match_clause_to_ordering_op</a></li>
<li><a href="#L2051">match_clauses_to_index</a></li>
<li><a href="#L2013">match_eclass_clauses_to_index</a></li>
<li><a href="#L2511">match_funcclause_to_indexcol</a></li>
<li><a href="#L3704">match_index_to_operand</a></li>
<li><a href="#L1983">match_join_clauses_to_index</a></li>
<li><a href="#L2392">match_opclause_to_indexcol</a></li>
<li><a href="#L3020">match_pathkeys_to_index</a></li>
<li><a href="#L1968">match_restriction_clauses_to_index</a></li>
<li><a href="#L2691">match_rowcompare_to_indexcol</a></li>
<li><a href="#L2623">match_saopclause_to_indexcol</a></li>
<li><a href="#L1493">path_usage_comparator</a></li>
<li><a href="#L3455">relation_has_unique_index_ext</a></li>
<li><a href="#L3440">relation_has_unique_index_for</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L40">IndexCollMatchesExprColl</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * indxpath.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Routines to determine which indexes are usable for scanning a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; given relation, and create Paths accordingly.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/optimizer/path/indxpath.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/stratnum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/sysattr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_am.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_operator.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_opfamily.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/supportnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/cost.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/pathnode.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/paths.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/prep.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/restrictinfo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/selfuncs.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> see <a href="../../partitioning/partprune.c.html#L1755" title="partitioning/partprune.c:1755">PartCollMatchesExprColl</a> */<br/></li>
<li><a id="L40">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">IndexCollMatchesExprColl</span>(idxcollation, exprcollation) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((idxcollation) == InvalidOid || (idxcollation) == (exprcollation))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Whether we are looking for plain indexscan, bitmap scan, or either */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; ST_INDEXSCAN,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must support amgettuple */<br/></li>
<li></span>&nbsp; &nbsp; ST_BITMAPSCAN,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must support amgetbitmap */<br/></li>
<li></span>&nbsp; &nbsp; ST_ANYSCAN,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* either is okay */<br/></li>
<li><a id="L49">&#x200c;</a></span>} <span class="linkable">ScanTypeControl</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Data structure for collecting qual clauses that match an index */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nonempty;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* True if lists are not all empty */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Lists of IndexClause nodes, one list per index column */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexclauses[INDEX_MAX_KEYS];<br/></li>
<li><a id="L57">&#x200c;</a>} <span class="linkable">IndexClauseSet</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Per-path data used within <a href="#L1287" title="optimizer/path/indxpath.c:1287">choose_bitmap_and</a>() */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* IndexPath, BitmapAndPath, or BitmapOrPath */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *quals;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the WHERE clauses it uses */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *preds;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* predicates of its partial index(es) */<br/></li>
<li></span>&nbsp; &nbsp; Bitmapset&nbsp; *clauseids;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* quals+preds represented as a bitmapset */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; unclassifiable; <span class="Comment">/* has too many quals+preds to process? */<br/></li>
<li><a id="L67">&#x200c;</a></span>} <span class="linkable">PathClauseUsage</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Callback argument for <a href="#L3382" title="optimizer/path/indxpath.c:3382">ec_member_matches_indexcol</a> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; IndexOptInfo *index;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* index we're considering */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexcol;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* index column we want to match to */<br/></li>
<li><a id="L74">&#x200c;</a></span>} <span class="linkable">ec_member_matches_arg</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L431" title="optimizer/path/indxpath.c:431">consider_index_join_clauses</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexOptInfo *index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *rclauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *jclauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *eclauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **bitindexpaths);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L497" title="optimizer/path/indxpath.c:497">consider_index_join_outer_rels</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexOptInfo *index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *rclauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *jclauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *eclauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **bitindexpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *indexjoinclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> considered_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **considered_relids);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L600" title="optimizer/path/indxpath.c:600">get_join_index_paths</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexOptInfo *index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *rclauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *jclauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *eclauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **bitindexpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **considered_relids);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L678" title="optimizer/path/indxpath.c:678">eclass_already_used</a>(EquivalenceClass *parent_ec, Relids oldrelids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *indexjoinclauses);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L710" title="optimizer/path/indxpath.c:710">get_index_paths</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexOptInfo *index, <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **bitindexpaths);<br/></li>
<li><span class="Type">static</span> List *<a href="#L804" title="optimizer/path/indxpath.c:804">build_index_paths</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexOptInfo *index, <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> useful_predicate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L49" title="optimizer/path/indxpath.c:49">ScanTypeControl</a> scantype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *skip_nonnative_saop);<br/></li>
<li><span class="Type">static</span> List *<a href="#L1086" title="optimizer/path/indxpath.c:1086">build_paths_for_OR</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *clauses, List *other_clauses);<br/></li>
<li><span class="Type">static</span> List *<a href="#L1180" title="optimizer/path/indxpath.c:1180">generate_bitmap_or_paths</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *clauses, List *other_clauses);<br/></li>
<li><span class="Type">static</span> Path *<a href="#L1287" title="optimizer/path/indxpath.c:1287">choose_bitmap_and</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *paths);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1493" title="optimizer/path/indxpath.c:1493">path_usage_comparator</a>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b);<br/></li>
<li><span class="Type">static</span> Cost <a href="#L1526" title="optimizer/path/indxpath.c:1526">bitmap_scan_cost_est</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Path *ipath);<br/></li>
<li><span class="Type">static</span> Cost <a href="#L1560" title="optimizer/path/indxpath.c:1560">bitmap_and_cost_est</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *paths);<br/></li>
<li><span class="Type">static</span> <a href="#L67" title="optimizer/path/indxpath.c:67">PathClauseUsage</a> *<a href="#L1589" title="optimizer/path/indxpath.c:1589">classify_index_clause_usage</a>(Path *path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **clauselist);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1657" title="optimizer/path/indxpath.c:1657">find_indexpath_quals</a>(Path *bitmapqual, List **quals, List **preds);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1704" title="optimizer/path/indxpath.c:1704">find_list_position</a>(Node *node, List **nodelist);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1730" title="optimizer/path/indxpath.c:1730">check_index_only</a>(RelOptInfo *rel, IndexOptInfo *index);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L1829" title="optimizer/path/indxpath.c:1829">get_loop_count</a>(PlannerInfo *root, Index cur_relid, Relids outer_relids);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L1882" title="optimizer/path/indxpath.c:1882">adjust_rowcount_for_semijoins</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index cur_relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index outer_relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> rowcount);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L1926" title="optimizer/path/indxpath.c:1926">approximate_joinrel_size</a>(PlannerInfo *root, Relids relids);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1968" title="optimizer/path/indxpath.c:1968">match_restriction_clauses_to_index</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexOptInfo *index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *clauseset);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1983" title="optimizer/path/indxpath.c:1983">match_join_clauses_to_index</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel, IndexOptInfo *index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *clauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **joinorclauses);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2013" title="optimizer/path/indxpath.c:2013">match_eclass_clauses_to_index</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexOptInfo *index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *clauseset);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2051" title="optimizer/path/indxpath.c:2051">match_clauses_to_index</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexOptInfo *index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *clauseset);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2084" title="optimizer/path/indxpath.c:2084">match_clause_to_index</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexOptInfo *index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *clauseset);<br/></li>
<li><span class="Type">static</span> IndexClause *<a href="#L2203" title="optimizer/path/indxpath.c:2203">match_clause_to_indexcol</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RestrictInfo *rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexOptInfo *index);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2280" title="optimizer/path/indxpath.c:2280">IsBooleanOpfamily</a>(Oid opfamily);<br/></li>
<li><span class="Type">static</span> IndexClause *<a href="#L2305" title="optimizer/path/indxpath.c:2305">match_boolean_index_clause</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RestrictInfo *rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> indexcol, IndexOptInfo *index);<br/></li>
<li><span class="Type">static</span> IndexClause *<a href="#L2392" title="optimizer/path/indxpath.c:2392">match_opclause_to_indexcol</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RestrictInfo *rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexOptInfo *index);<br/></li>
<li><span class="Type">static</span> IndexClause *<a href="#L2511" title="optimizer/path/indxpath.c:2511">match_funcclause_to_indexcol</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RestrictInfo *rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexOptInfo *index);<br/></li>
<li><span class="Type">static</span> IndexClause *<a href="#L2557" title="optimizer/path/indxpath.c:2557">get_index_clause_from_support</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid funcid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> indexarg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexOptInfo *index);<br/></li>
<li><span class="Type">static</span> IndexClause *<a href="#L2623" title="optimizer/path/indxpath.c:2623">match_saopclause_to_indexcol</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RestrictInfo *rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexOptInfo *index);<br/></li>
<li><span class="Type">static</span> IndexClause *<a href="#L2691" title="optimizer/path/indxpath.c:2691">match_rowcompare_to_indexcol</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RestrictInfo *rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexOptInfo *index);<br/></li>
<li><span class="Type">static</span> IndexClause *<a href="#L2798" title="optimizer/path/indxpath.c:2798">expand_indexqual_rowcompare</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexOptInfo *index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid expr_op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> var_on_left);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3020" title="optimizer/path/indxpath.c:3020">match_pathkeys_to_index</a>(IndexOptInfo *index, List *pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **orderby_clauses_p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **clause_columns_p);<br/></li>
<li><span class="Type">static</span> Expr *<a href="#L3130" title="optimizer/path/indxpath.c:3130">match_clause_to_ordering_op</a>(IndexOptInfo *index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> indexcol, Expr *clause, Oid pk_opfamily);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3382" title="optimizer/path/indxpath.c:3382">ec_member_matches_indexcol</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EquivalenceClass *ec, EquivalenceMember *em,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *arg);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L234" title="optimizer/path/indxpath.c:234">create_index_paths</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Generate all interesting index paths for the given relation.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Candidate paths are added to the rel's pathlist (using <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To be considered for an index scan, an index must match one or more<br/></li>
<li></span><span class="Comment"> * restriction clauses or join clauses from the query's qual condition,<br/></li>
<li></span><span class="Comment"> * or match the query's ORDER BY condition, or have a predicate that<br/></li>
<li></span><span class="Comment"> * matches the query's qual condition.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There are two basic kinds of index scans.&nbsp; A &quot;plain&quot; index scan uses<br/></li>
<li></span><span class="Comment"> * only restriction clauses (possibly <a href="../util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> at all) in its indexqual,<br/></li>
<li></span><span class="Comment"> * so it can be applied in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> context.&nbsp; A &quot;parameterized&quot; index scan uses<br/></li>
<li></span><span class="Comment"> * join clauses (plus restriction clauses, if available) in its indexqual.<br/></li>
<li></span><span class="Comment"> * When joining such a scan to one of the relations supplying the other<br/></li>
<li></span><span class="Comment"> * variables used in its indexqual, the parameterized scan must appear as<br/></li>
<li></span><span class="Comment"> * the inner relation of a nestloop join; it can't be used on the outer side,<br/></li>
<li></span><span class="Comment"> * nor in a <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> or <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> join.&nbsp; In that context, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for the other rels'<br/></li>
<li></span><span class="Comment"> * attributes are available and fixed during <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one scan of the indexpath.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * An IndexPath is generated and submitted to <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>() for each plain or<br/></li>
<li></span><span class="Comment"> * parameterized index scan this routine deems potentially interesting for<br/></li>
<li></span><span class="Comment"> * the current query.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rel' is the relation for which we want to generate index paths<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: <a href="#L3244" title="optimizer/path/indxpath.c:3244">check_index_predicates</a>() must have been run previously for this rel.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: in cases involving LATERAL references in the relation's tlist, it's<br/></li>
<li></span><span class="Comment"> * possible that rel-&gt;lateral_relids is nonempty.&nbsp; Currently, we include<br/></li>
<li></span><span class="Comment"> * lateral_relids into the parameterization reported for each path, but don't<br/></li>
<li></span><span class="Comment"> * take it into account otherwise.&nbsp; The fact that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such rels *must* be<br/></li>
<li></span><span class="Comment"> * available as parameter sources perhaps should influence our choices of<br/></li>
<li></span><span class="Comment"> * index quals ... but for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, it doesn't seem worth troubling over.<br/></li>
<li></span><span class="Comment"> * In particular, comments below about &quot;unparameterized&quot; paths should be read<br/></li>
<li></span><span class="Comment"> * as meaning &quot;unparameterized so far as the indexquals are concerned&quot;.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L234">&#x200c;</a></span><span class="linkable">create_index_paths</span>(PlannerInfo *root, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexpaths;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *bitindexpaths;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *bitjoinpaths;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *joinorclauses;<br/></li>
<li>&nbsp; &nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> rclauseset;<br/></li>
<li>&nbsp; &nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> jclauseset;<br/></li>
<li>&nbsp; &nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> eclauseset;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Skip the whole mess if no indexes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;indexlist == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Bitmap paths are collected and then dealt with at the end */<br/></li>
<li></span>&nbsp; &nbsp; bitindexpaths = bitjoinpaths = joinorclauses = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Examine each index in turn */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, rel-&gt;indexlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexOptInfo *index = (IndexOptInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Protect limited-size array in IndexClauseSets */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(index-&gt;nkeycolumns &lt;= INDEX_MAX_KEYS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore partial indexes that do not match the query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (<a href="#L1180" title="optimizer/path/indxpath.c:1180">generate_bitmap_or_paths</a>() might be able to do something with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * them, but that's of no concern here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;indpred != NIL &amp;&amp; !index-&gt;predOK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Identify the restriction clauses that can match the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(&amp;rclauseset, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(rclauseset));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1968" title="optimizer/path/indxpath.c:1968">match_restriction_clauses_to_index</a>(root, index, &amp;rclauseset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Build index paths from the restriction clauses.&nbsp; These will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-parameterized paths.&nbsp; Plain paths go directly to <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bitmap paths are added to bitindexpaths to be handled below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L710" title="optimizer/path/indxpath.c:710">get_index_paths</a>(root, rel, index, &amp;rclauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;bitindexpaths);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Identify the join clauses that can match the index.&nbsp; For the moment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we keep them separate from the restriction clauses.&nbsp; Note that this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * step finds only &quot;loose&quot; join clauses that have not been merged into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * EquivalenceClasses.&nbsp; Also, collect join OR clauses for later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(&amp;jclauseset, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(jclauseset));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1983" title="optimizer/path/indxpath.c:1983">match_join_clauses_to_index</a>(root, rel, index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;jclauseset, &amp;joinorclauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Look for EquivalenceClasses that can generate joinclauses matching<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(&amp;eclauseset, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(eclauseset));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2013" title="optimizer/path/indxpath.c:2013">match_eclass_clauses_to_index</a>(root, index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;eclauseset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we found <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> plain or <a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a> join clauses, build parameterized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index paths using them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (jclauseset.nonempty || eclauseset.nonempty)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L431" title="optimizer/path/indxpath.c:431">consider_index_join_clauses</a>(root, rel, index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;rclauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;jclauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;eclauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;bitjoinpaths);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate BitmapOrPaths for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> suitable OR-clauses present in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restriction list.&nbsp; Add these to bitindexpaths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indexpaths = <a href="#L1180" title="optimizer/path/indxpath.c:1180">generate_bitmap_or_paths</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;baserestrictinfo, NIL);<br/></li>
<li>&nbsp; &nbsp; bitindexpaths = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(bitindexpaths, indexpaths);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Likewise, generate BitmapOrPaths for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> suitable OR-clauses present in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the joinclause list.&nbsp; Add these to bitjoinpaths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indexpaths = <a href="#L1180" title="optimizer/path/indxpath.c:1180">generate_bitmap_or_paths</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinorclauses, rel-&gt;baserestrictinfo);<br/></li>
<li>&nbsp; &nbsp; bitjoinpaths = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(bitjoinpaths, indexpaths);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we found anything usable, generate a BitmapHeapPath for the most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * promising combination of restriction bitmap index paths.&nbsp; Note there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will be only one such path no matter how many indexes exist.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should be sufficient since there's basically only one figure of merit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (total cost) for such a path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bitindexpaths != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *bitmapqual;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BitmapHeapPath *bpath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitmapqual = <a href="#L1287" title="optimizer/path/indxpath.c:1287">choose_bitmap_and</a>(root, rel, bitindexpaths);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bpath = <a href="../util/pathnode.c.html#L1042" title="optimizer/util/pathnode.c:1042">create_bitmap_heap_path</a>(root, rel, bitmapqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;lateral_relids, <span class="Constant">1.0</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, (Path *) bpath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* create a partial bitmap heap path */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;consider_parallel &amp;&amp; rel-&gt;lateral_relids == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="allpaths.c.html#L4179" title="optimizer/path/allpaths.c:4179">create_partial_bitmap_paths</a>(root, rel, bitmapqual);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Likewise, if we found anything usable, generate BitmapHeapPaths for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * most promising combinations of join bitmap index paths.&nbsp; Our strategy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is to generate one such path for each distinct parameterization seen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * among the available bitmap index paths.&nbsp; This may look pretty<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expensive, but usually there won't be very many distinct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parameterizations.&nbsp; (This logic is quite similar to that in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L431" title="optimizer/path/indxpath.c:431">consider_index_join_clauses</a>, but we're working with whole paths not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * individual clauses.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bitjoinpaths != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *all_path_outers;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Identify each distinct parameterization seen in bitjoinpaths */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; all_path_outers = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, bitjoinpaths)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path = (Path *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; required_outer = PATH_REQ_OUTER(path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all_path_outers = <a href="../../nodes/list.c.html#L1343" title="nodes/list.c:1343">list_append_unique</a>(all_path_outers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; required_outer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now, for each distinct parameterization set ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, all_path_outers)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; max_outers = (Relids) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *this_path_set;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *bitmapqual;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; required_outer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; loop_count;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BitmapHeapPath *bpath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lcp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Identify all the bitmap join paths needing no more than that */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_path_set = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lcp, bitjoinpaths)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path = (Path *) lfirst(lcp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(PATH_REQ_OUTER(path), max_outers))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_path_set = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(this_path_set, path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add in restriction bitmap paths, since they can be used<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * together with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> join paths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_path_set = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(this_path_set, bitindexpaths);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Select best AND combination for this parameterization */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmapqual = <a href="#L1287" title="optimizer/path/indxpath.c:1287">choose_bitmap_and</a>(root, rel, this_path_set);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> that path into the mix */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer = PATH_REQ_OUTER(bitmapqual);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loop_count = <a href="#L1829" title="optimizer/path/indxpath.c:1829">get_loop_count</a>(root, rel-&gt;relid, required_outer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bpath = <a href="../util/pathnode.c.html#L1042" title="optimizer/util/pathnode.c:1042">create_bitmap_heap_path</a>(root, rel, bitmapqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer, loop_count, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, (Path *) bpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L431" title="optimizer/path/indxpath.c:431">consider_index_join_clauses</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Given sets of join clauses for an index, decide which parameterized<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; index paths to build.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Plain indexpaths are sent directly to <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>, while potential<br/></li>
<li></span><span class="Comment"> * bitmap indexpaths are added to *bitindexpaths for later processing.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rel' is the index's heap relation<br/></li>
<li></span><span class="Comment"> * 'index' is the index for which we want to generate paths<br/></li>
<li></span><span class="Comment"> * 'rclauseset' is the collection of indexable restriction clauses<br/></li>
<li></span><span class="Comment"> * 'jclauseset' is the collection of indexable simple join clauses<br/></li>
<li></span><span class="Comment"> * 'eclauseset' is the collection of indexable clauses from EquivalenceClasses<br/></li>
<li></span><span class="Comment"> * '*bitindexpaths' is the list to add bitmap paths to<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L431">&#x200c;</a></span><span class="linkable">consider_index_join_clauses</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexOptInfo *index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *rclauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *jclauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *eclauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **bitindexpaths)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; considered_clauses = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *considered_relids = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexcol;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The strategy here is to identify every potentially useful set of outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rels that can provide indexable join clauses.&nbsp; For each such set,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> all the join clauses available from those outer rels, add on all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the indexable restriction clauses, and generate plain and/or bitmap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index paths for that set of clauses.&nbsp; This is based on the assumption<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that it's always better to apply a clause as an indexqual than as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * filter (qpqual); which is where an available clause would end up being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * applied if we omit it from the indexquals.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This looks expensive, but in most practical cases there won't be very<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * many distinct sets of outer rels to consider.&nbsp; As a safety valve when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that's not true, we use a heuristic: limit the number of outer rel sets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * considered to a multiple of the number of clauses considered.&nbsp; (We'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * always consider using each individual join clause, though.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For simplicity in selecting relevant clauses, we represent each set of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * outer rels as a maximum set of clause_relids --- that is, the indexed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation itself is also included in the relids set.&nbsp; considered_relids<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lists all relids sets we've already tried.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (indexcol = <span class="Constant">0</span>; indexcol &lt; index-&gt;nkeycolumns; indexcol++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Consider each applicable simple join clause */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; considered_clauses += list_length(jclauseset-&gt;indexclauses[indexcol]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L497" title="optimizer/path/indxpath.c:497">consider_index_join_outer_rels</a>(root, rel, index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rclauseset, jclauseset, eclauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bitindexpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jclauseset-&gt;indexclauses[indexcol],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; considered_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;considered_relids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Consider each applicable <a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a> join clause */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; considered_clauses += list_length(eclauseset-&gt;indexclauses[indexcol]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L497" title="optimizer/path/indxpath.c:497">consider_index_join_outer_rels</a>(root, rel, index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rclauseset, jclauseset, eclauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bitindexpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; eclauseset-&gt;indexclauses[indexcol],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; considered_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;considered_relids);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L497" title="optimizer/path/indxpath.c:497">consider_index_join_outer_rels</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Generate parameterized paths based on clause relids in the clause list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Workhorse for <a href="#L431" title="optimizer/path/indxpath.c:431">consider_index_join_clauses</a>; see notes therein for rationale.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rel', 'index', 'rclauseset', 'jclauseset', 'eclauseset', and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; 'bitindexpaths' as above<br/></li>
<li></span><span class="Comment"> * 'indexjoinclauses' is a list of IndexClauses for join clauses<br/></li>
<li></span><span class="Comment"> * 'considered_clauses' is the total number of clauses considered (so far)<br/></li>
<li></span><span class="Comment"> * '*considered_relids' is a list of all relids sets already considered<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L497">&#x200c;</a></span><span class="linkable">consider_index_join_outer_rels</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexOptInfo *index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *rclauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *jclauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *eclauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **bitindexpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *indexjoinclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> considered_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **considered_relids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Examine relids of each joinclause in the given list */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, indexjoinclauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexClause *iclause = (IndexClause *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; clause_relids = iclause-&gt;rinfo-&gt;clause_relids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EquivalenceClass *parent_ec = iclause-&gt;rinfo-&gt;parent_ec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_considered_relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we already tried its relids set, no need to do so again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/list.c.html#L661" title="nodes/list.c:661">list_member</a>(*considered_relids, clause_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Generate the union of this clause's relids set with each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * previously-tried set.&nbsp; This ensures we try this clause along with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * every interesting <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of previous clauses.&nbsp; However, to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exponential growth of planning time when there are many clauses,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * limit the number of relid sets accepted to 10 * considered_clauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: <a href="#L600" title="optimizer/path/indxpath.c:600">get_join_index_paths</a> appends entries to *considered_relids,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but we do not need to visit such newly-added entries within this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * loop, so we don't use foreach() here.&nbsp; No real harm would be done<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if we did visit them, since the <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> check would reject them; but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it would waste some cycles.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; num_considered_relids = list_length(*considered_relids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> pos = <span class="Constant">0</span>; pos &lt; num_considered_relids; pos++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; oldrelids = (Relids) list_nth(*considered_relids, pos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If either is a <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of the other, no new set is possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This isn't a complete test for redundancy, but it's easy and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cheap.&nbsp; <a href="#L600" title="optimizer/path/indxpath.c:600">get_join_index_paths</a> will check more carefully if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already generated the same relids set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L445" title="nodes/bitmapset.c:445">bms_subset_compare</a>(clause_relids, oldrelids) != BMS_DIFFERENT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this clause was derived from an equivalence class, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clause list may contain other clauses derived from the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a>.&nbsp; We should not consider that combining this clause with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one of those clauses generates a usefully different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parameterization; so <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> clause derived from the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a> would already have been included when using oldrelids.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parent_ec &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L678" title="optimizer/path/indxpath.c:678">eclass_already_used</a>(parent_ec, oldrelids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexjoinclauses))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the number of relid sets considered exceeds our heuristic<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * limit, stop considering combinations of clauses.&nbsp; We'll still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consider the current clause alone, though (below this loop).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(*considered_relids) &gt;= <span class="Constant">10</span> * considered_clauses)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, try the union set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L600" title="optimizer/path/indxpath.c:600">get_join_index_paths</a>(root, rel, index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rclauseset, jclauseset, eclauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bitindexpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(clause_relids, oldrelids),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; considered_relids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Also try this set of relids by itself */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L600" title="optimizer/path/indxpath.c:600">get_join_index_paths</a>(root, rel, index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rclauseset, jclauseset, eclauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bitindexpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; clause_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; considered_relids);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L600" title="optimizer/path/indxpath.c:600">get_join_index_paths</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Generate index paths using clauses from the specified outer relations.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; In addition to generating paths, relids is added to *considered_relids<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; if not already present.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Workhorse for <a href="#L431" title="optimizer/path/indxpath.c:431">consider_index_join_clauses</a>; see notes therein for rationale.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rel', 'index', 'rclauseset', 'jclauseset', 'eclauseset',<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; 'bitindexpaths', 'considered_relids' as above<br/></li>
<li></span><span class="Comment"> * 'relids' is the current set of relids to consider (the target rel plus<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; one or more outer rels)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L600">&#x200c;</a></span><span class="linkable">get_join_index_paths</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexOptInfo *index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *rclauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *jclauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *eclauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **bitindexpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **considered_relids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> clauseset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexcol;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we already considered this relids set, don't <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> the work */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/list.c.html#L661" title="nodes/list.c:661">list_member</a>(*considered_relids, relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Identify indexclauses usable with this relids set */<br/></li>
<li></span>&nbsp; &nbsp; MemSet(&amp;clauseset, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(clauseset));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (indexcol = <span class="Constant">0</span>; indexcol &lt; index-&gt;nkeycolumns; indexcol++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> applicable simple join clauses */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, jclauseset-&gt;indexclauses[indexcol])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexClause *iclause = (IndexClause *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(iclause-&gt;rinfo-&gt;clause_relids, relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clauseset.indexclauses[indexcol] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(clauseset.indexclauses[indexcol], iclause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add applicable <a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a> join clauses.&nbsp; The clauses generated for each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column are redundant (cf <a href="equivclass.c.html#L2971" title="optimizer/path/equivclass.c:2971">generate_implied_equalities_for_column</a>),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so we need at most one.&nbsp; This is the only exception to the general<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rule of using all available index clauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, eclauseset-&gt;indexclauses[indexcol])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexClause *iclause = (IndexClause *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(iclause-&gt;rinfo-&gt;clause_relids, relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clauseset.indexclauses[indexcol] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(clauseset.indexclauses[indexcol], iclause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add restriction clauses */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; clauseset.indexclauses[indexcol] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(clauseset.indexclauses[indexcol],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rclauseset-&gt;indexclauses[indexcol]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (clauseset.indexclauses[indexcol] != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clauseset.nonempty = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We should have found something, else caller passed silly relids */<br/></li>
<li></span>&nbsp; &nbsp; Assert(clauseset.nonempty);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build index path(s) using the collected set of clauses */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L710" title="optimizer/path/indxpath.c:710">get_index_paths</a>(root, rel, index, &amp;clauseset, bitindexpaths);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remember we considered paths for this set of relids.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *considered_relids = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(*considered_relids, relids);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L678" title="optimizer/path/indxpath.c:678">eclass_already_used</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; True if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> join clause usable with oldrelids was generated from<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the specified equivalence class.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L678">&#x200c;</a></span><span class="linkable">eclass_already_used</span>(EquivalenceClass *parent_ec, Relids oldrelids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *indexjoinclauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, indexjoinclauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexClause *iclause = (IndexClause *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = iclause-&gt;rinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rinfo-&gt;parent_ec == parent_ec &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(rinfo-&gt;clause_relids, oldrelids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L710" title="optimizer/path/indxpath.c:710">get_index_paths</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Given an index and a set of index clauses for it, construct IndexPaths.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Plain indexpaths are sent directly to <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>, while potential<br/></li>
<li></span><span class="Comment"> * bitmap indexpaths are added to *bitindexpaths for later processing.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a fairly simple frontend to <a href="#L804" title="optimizer/path/indxpath.c:804">build_index_paths</a>().&nbsp; Its reason for<br/></li>
<li></span><span class="Comment"> * existence is mainly to handle ScalarArrayOpExpr quals properly.&nbsp; If the<br/></li>
<li></span><span class="Comment"> * index AM supports them natively, we should just include them in simple<br/></li>
<li></span><span class="Comment"> * index paths.&nbsp; If not, we should exclude them while building simple index<br/></li>
<li></span><span class="Comment"> * paths, and then make a separate attempt to include them in bitmap paths.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L710">&#x200c;</a></span><span class="linkable">get_index_paths</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexOptInfo *index, <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **bitindexpaths)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexpaths;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; skip_nonnative_saop = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build simple index paths using the clauses.&nbsp; Allow ScalarArrayOpExpr<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clauses only if the index AM supports them natively.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indexpaths = <a href="#L804" title="optimizer/path/indxpath.c:804">build_index_paths</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index, clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index-&gt;predOK,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ST_ANYSCAN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;skip_nonnative_saop);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Submit all the ones that can form plain IndexScan plans to <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>. (A<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plain IndexPath can represent either a plain IndexScan or an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * IndexOnlyScan, but for our purposes here that distinction does not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * matter.&nbsp; However, some of the indexes might support only bitmap scans,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and those we mustn't submit to <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a> here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, pick out the ones that are usable as bitmap scans.&nbsp; For that, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must discard indexes that don't support bitmap scans, and we also are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only interested in paths that have some selectivity; we should discard<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anything that was generated solely for ordering purposes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, indexpaths)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexPath&nbsp; *ipath = (IndexPath *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;amhasgettuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, (Path *) ipath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;amhasgetbitmap &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ipath-&gt;path.pathkeys == NIL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ipath-&gt;indexselectivity &lt; <span class="Constant">1.0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *bitindexpaths = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(*bitindexpaths, ipath);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there were ScalarArrayOpExpr clauses that the index can't handle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * natively, generate bitmap scan paths relying on executor-managed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ScalarArrayOpExpr.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (skip_nonnative_saop)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexpaths = <a href="#L804" title="optimizer/path/indxpath.c:804">build_index_paths</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index, clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ST_BITMAPSCAN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *bitindexpaths = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(*bitindexpaths, indexpaths);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L804" title="optimizer/path/indxpath.c:804">build_index_paths</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Given an index and a set of index clauses for it, construct zero<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; or more IndexPaths. It also constructs zero or more partial IndexPaths.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We return a list of paths because (1) this routine checks some cases<br/></li>
<li></span><span class="Comment"> * that should cause us to not generate <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> IndexPath, and (2) in some<br/></li>
<li></span><span class="Comment"> * cases we want to consider both a forward and a backward scan, so as<br/></li>
<li></span><span class="Comment"> * to obtain both sort orders.&nbsp; Note that the paths are just returned<br/></li>
<li></span><span class="Comment"> * to the caller and not immediately fed to <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At top level, useful_predicate should be exactly the index's predOK flag<br/></li>
<li></span><span class="Comment"> * (ie, true if it has a predicate that was proven from the restriction<br/></li>
<li></span><span class="Comment"> * clauses).&nbsp; When working on an arm of an OR clause, useful_predicate<br/></li>
<li></span><span class="Comment"> * should be true if the predicate required the current OR list to be proven.<br/></li>
<li></span><span class="Comment"> * Note that this routine should never be called at all if the index has an<br/></li>
<li></span><span class="Comment"> * unprovable predicate.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * scantype indicates whether we want to create plain indexscans, bitmap<br/></li>
<li></span><span class="Comment"> * indexscans, or both.&nbsp; When it's ST_BITMAPSCAN, we will not consider<br/></li>
<li></span><span class="Comment"> * index ordering while deciding if a Path is worth generating.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If skip_nonnative_saop is non-NULL, we ignore ScalarArrayOpExpr clauses<br/></li>
<li></span><span class="Comment"> * unless the index AM supports them directly, and we set *skip_nonnative_saop<br/></li>
<li></span><span class="Comment"> * to true if we found <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such clauses (caller must <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the variable<br/></li>
<li></span><span class="Comment"> * to false).&nbsp; If it's NULL, we do not ignore ScalarArrayOpExpr clauses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rel' is the index's heap relation<br/></li>
<li></span><span class="Comment"> * 'index' is the index for which we want to generate paths<br/></li>
<li></span><span class="Comment"> * 'clauses' is the collection of indexable clauses (IndexClause nodes)<br/></li>
<li></span><span class="Comment"> * 'useful_predicate' indicates whether the index has a useful predicate<br/></li>
<li></span><span class="Comment"> * 'scantype' indicates whether we need plain or bitmap scan support<br/></li>
<li></span><span class="Comment"> * 'skip_nonnative_saop' indicates whether to <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> SAOP if index AM doesn't<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L804">&#x200c;</a><span class="linkable">build_index_paths</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexOptInfo *index, <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> useful_predicate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="optimizer/path/indxpath.c:49">ScanTypeControl</a> scantype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *skip_nonnative_saop)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li>&nbsp; &nbsp; IndexPath&nbsp; *ipath;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *index_clauses;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; outer_relids;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; loop_count;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *orderbyclauses;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *orderbyclausecols;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *index_pathkeys;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *useful_pathkeys;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; pathkeys_possibly_useful;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; index_is_ordered;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; index_only_scan;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexcol;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(skip_nonnative_saop != <span class="Constant">NULL</span> || scantype == ST_BITMAPSCAN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that index supports the desired scan type(s)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (scantype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ST_INDEXSCAN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!index-&gt;amhasgettuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ST_BITMAPSCAN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!index-&gt;amhasgetbitmap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ST_ANYSCAN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* either or both are OK */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 1. Combine the per-column IndexClause lists into an overall list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In the resulting list, clauses are ordered by index key, so that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * column numbers form a nondecreasing sequence.&nbsp; (This order is depended<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on by btree and possibly other places.)&nbsp; The list can be empty, if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index AM allows that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We also build a Relids set showing which outer rels are required by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * selected clauses.&nbsp; Any lateral_relids are included in that, but not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otherwise accounted for.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; index_clauses = NIL;<br/></li>
<li>&nbsp; &nbsp; outer_relids = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(rel-&gt;lateral_relids);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (indexcol = <span class="Constant">0</span>; indexcol &lt; index-&gt;nkeycolumns; indexcol++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, clauses-&gt;indexclauses[indexcol])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexClause *iclause = (IndexClause *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = iclause-&gt;rinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (skip_nonnative_saop &amp;&amp; !index-&gt;amsearcharray &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IsA(rinfo-&gt;clause, ScalarArrayOpExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Caller asked us to generate IndexPaths that omit <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ScalarArrayOpExpr clauses when the underlying index AM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lacks native support.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must omit this clause (and tell caller about it).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *skip_nonnative_saop = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK to include this clause */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_clauses = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(index_clauses, iclause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_relids = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(outer_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rinfo-&gt;clause_relids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If no clauses match the first index column, check for amoptionalkey<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * restriction.&nbsp; We can't generate a scan over an index with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * amoptionalkey = false unless there's at least one index clause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (When working on columns after the first, this test cannot fail. It<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is always okay for columns after the first to not have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clauses.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index_clauses == NIL &amp;&amp; !index-&gt;amoptionalkey)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We do not want the index's rel itself listed in outer_relids */<br/></li>
<li></span>&nbsp; &nbsp; outer_relids = <a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(outer_relids, rel-&gt;relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute loop_count for cost estimation purposes */<br/></li>
<li></span>&nbsp; &nbsp; loop_count = <a href="#L1829" title="optimizer/path/indxpath.c:1829">get_loop_count</a>(root, rel-&gt;relid, outer_relids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 2. Compute pathkeys describing index's ordering, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, then see how<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * many of them are actually useful for this query.&nbsp; This is not relevant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we are only trying to build bitmap indexscans.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pathkeys_possibly_useful = (scantype != ST_BITMAPSCAN &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="pathkeys.c.html#L2261" title="optimizer/path/pathkeys.c:2261">has_useful_pathkeys</a>(root, rel));<br/></li>
<li>&nbsp; &nbsp; index_is_ordered = (index-&gt;sortopfamily != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (index_is_ordered &amp;&amp; pathkeys_possibly_useful)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; index_pathkeys = <a href="pathkeys.c.html#L755" title="optimizer/path/pathkeys.c:755">build_index_pathkeys</a>(root, index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForwardScanDirection);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; useful_pathkeys = <a href="pathkeys.c.html#L2215" title="optimizer/path/pathkeys.c:2215">truncate_useless_pathkeys</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_pathkeys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; orderbyclauses = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; orderbyclausecols = NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (index-&gt;amcanorderbyop &amp;&amp; pathkeys_possibly_useful)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * See if we can generate ordering operators for query_pathkeys or at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * least some prefix thereof.&nbsp; Matching to just a prefix of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * query_pathkeys will allow an incremental sort to be considered on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the index's partially sorted results.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3020" title="optimizer/path/indxpath.c:3020">match_pathkeys_to_index</a>(index, root-&gt;query_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;orderbyclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;orderbyclausecols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(root-&gt;query_pathkeys) == list_length(orderbyclauses))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; useful_pathkeys = root-&gt;query_pathkeys;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; useful_pathkeys = <a href="../../nodes/list.c.html#L1593" title="nodes/list.c:1593">list_copy_head</a>(root-&gt;query_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_length(orderbyclauses));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; useful_pathkeys = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; orderbyclauses = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; orderbyclausecols = NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 3. Check if an index-only scan is possible.&nbsp; If we're not building<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plain indexscans, this isn't relevant since bitmap scans don't support<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index data retrieval anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; index_only_scan = (scantype != ST_BITMAPSCAN &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1730" title="optimizer/path/indxpath.c:1730">check_index_only</a>(rel, index));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 4. Generate an indexscan path if there are relevant restriction clauses<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the current clauses, OR the index ordering is potentially useful for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * later merging or final output ordering, OR the index has a useful<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * predicate, OR an index-only scan is possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (index_clauses != NIL || useful_pathkeys != NIL || useful_predicate ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; index_only_scan)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ipath = <a href="../util/pathnode.c.html#L993" title="optimizer/util/pathnode.c:993">create_index_path</a>(root, index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orderbyclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orderbyclausecols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; useful_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForwardScanDirection,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_only_scan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loop_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, ipath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If appropriate, consider parallel index scan.&nbsp; We don't allow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parallel index scan for bitmap index scans.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;amcanparallel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;consider_parallel &amp;&amp; outer_relids == <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scantype != ST_BITMAPSCAN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ipath = <a href="../util/pathnode.c.html#L993" title="optimizer/util/pathnode.c:993">create_index_path</a>(root, index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orderbyclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orderbyclausecols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; useful_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForwardScanDirection,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_only_scan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loop_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if, after costing the path, we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> that it's not worth using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parallel workers, just free it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ipath-&gt;path.parallel_workers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L747" title="optimizer/util/pathnode.c:747">add_partial_path</a>(rel, (Path *) ipath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ipath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 5. If the index is ordered, a backwards scan might be interesting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (index_is_ordered &amp;&amp; pathkeys_possibly_useful)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; index_pathkeys = <a href="pathkeys.c.html#L755" title="optimizer/path/pathkeys.c:755">build_index_pathkeys</a>(root, index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BackwardScanDirection);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; useful_pathkeys = <a href="pathkeys.c.html#L2215" title="optimizer/path/pathkeys.c:2215">truncate_useless_pathkeys</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_pathkeys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (useful_pathkeys != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ipath = <a href="../util/pathnode.c.html#L993" title="optimizer/util/pathnode.c:993">create_index_path</a>(root, index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; useful_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BackwardScanDirection,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_only_scan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loop_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, ipath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If appropriate, consider parallel index scan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;amcanparallel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;consider_parallel &amp;&amp; outer_relids == <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scantype != ST_BITMAPSCAN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ipath = <a href="../util/pathnode.c.html#L993" title="optimizer/util/pathnode.c:993">create_index_path</a>(root, index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; useful_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BackwardScanDirection,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_only_scan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loop_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if, after costing the path, we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> that it's not worth<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * using parallel workers, just free it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ipath-&gt;path.parallel_workers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L747" title="optimizer/util/pathnode.c:747">add_partial_path</a>(rel, (Path *) ipath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ipath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1086" title="optimizer/path/indxpath.c:1086">build_paths_for_OR</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Given a list of restriction clauses from one arm of an OR clause,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; construct all matching IndexPaths for the relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Here we must scan all indexes of the relation, since a bitmap OR tree<br/></li>
<li></span><span class="Comment"> * can use multiple indexes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller actually supplies two lists of restriction clauses: some<br/></li>
<li></span><span class="Comment"> * &quot;current&quot; ones and some &quot;other&quot; ones.&nbsp; Both lists can be used freely<br/></li>
<li></span><span class="Comment"> * to match keys of the index, but an index must use at least one of the<br/></li>
<li></span><span class="Comment"> * &quot;current&quot; clauses to be considered usable.&nbsp; The motivation for this is<br/></li>
<li></span><span class="Comment"> * examples like<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; WHERE (x = 42) AND (... OR (y = 52 AND z = 77) OR ....)<br/></li>
<li></span><span class="Comment"> * While we are considering the y/z subclause of the OR, we can use &quot;x = 42&quot;<br/></li>
<li></span><span class="Comment"> * as one of the available index conditions; but we shouldn't match the<br/></li>
<li></span><span class="Comment"> * subclause to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> index on x alone, because such a Path would already have<br/></li>
<li></span><span class="Comment"> * been generated at the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> level.&nbsp; So we could use an index on x,y,z<br/></li>
<li></span><span class="Comment"> * or an index on x,y for the OR subclause, but not an index on just x.<br/></li>
<li></span><span class="Comment"> * When dealing with a partial index, a match of the index predicate to<br/></li>
<li></span><span class="Comment"> * one of the &quot;current&quot; clauses also makes the index usable.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rel' is the relation for which we want to generate index paths<br/></li>
<li></span><span class="Comment"> * 'clauses' is the current list of clauses (RestrictInfo nodes)<br/></li>
<li></span><span class="Comment"> * 'other_clauses' is the list of additional <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level clauses<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L1086">&#x200c;</a><span class="linkable">build_paths_for_OR</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *clauses, List *other_clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *all_clauses = NIL;&nbsp; &nbsp; <span class="Comment">/* not computed till needed */<br/></li>
<li></span>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, rel-&gt;indexlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexOptInfo *index = (IndexOptInfo *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> clauseset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexpaths;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; useful_predicate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore index if it doesn't support bitmap scans */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!index-&gt;amhasgetbitmap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore partial indexes that do not match the query.&nbsp; If a partial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index is marked predOK then we know it's OK.&nbsp; Otherwise, we have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * test whether the added clauses are sufficient to imply the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * predicate. If so, we can use the index in the current context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We set useful_predicate to true iff the predicate was proven using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the current set of clauses.&nbsp; This is needed to prevent matching a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * predOK index to an arm of an OR, which would be a legal but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pointlessly inefficient plan.&nbsp; (A better plan will be generated by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just scanning the predOK index alone, no OR.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; useful_predicate = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;indpred != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;predOK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Usable, but don't set useful_predicate */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Form all_clauses if not done already */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (all_clauses == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all_clauses = <a href="../../nodes/list.c.html#L598" title="nodes/list.c:598">list_concat_copy</a>(clauses, other_clauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../util/predtest.c.html#L152" title="optimizer/util/predtest.c:152">predicate_implied_by</a>(index-&gt;indpred, all_clauses, <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; <span class="Comment">/* can't use it at all */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../util/predtest.c.html#L152" title="optimizer/util/predtest.c:152">predicate_implied_by</a>(index-&gt;indpred, other_clauses, <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; useful_predicate = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Identify the restriction clauses that can match the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(&amp;clauseset, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(clauseset));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2051" title="optimizer/path/indxpath.c:2051">match_clauses_to_index</a>(root, clauses, index, &amp;clauseset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If no matches so far, and the index predicate isn't useful, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't want it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!clauseset.nonempty &amp;&amp; !useful_predicate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add &quot;other&quot; restriction clauses to the clauseset.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2051" title="optimizer/path/indxpath.c:2051">match_clauses_to_index</a>(root, other_clauses, index, &amp;clauseset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Construct paths if possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; indexpaths = <a href="#L804" title="optimizer/path/indxpath.c:804">build_index_paths</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index, &amp;clauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; useful_predicate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ST_BITMAPSCAN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(result, indexpaths);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1180" title="optimizer/path/indxpath.c:1180">generate_bitmap_or_paths</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Look through the list of clauses to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> OR clauses, and generate<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; a BitmapOrPath for each one we can handle that way.&nbsp; Return a list<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; of the generated BitmapOrPaths.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * other_clauses is a list of additional clauses that can be assumed true<br/></li>
<li></span><span class="Comment"> * for the purpose of generating indexquals, but are not to be searched for<br/></li>
<li></span><span class="Comment"> * ORs.&nbsp; (See <a href="#L1086" title="optimizer/path/indxpath.c:1086">build_paths_for_OR</a>() for motivation.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L1180">&#x200c;</a><span class="linkable">generate_bitmap_or_paths</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *clauses, List *other_clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *all_clauses;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can use both the current and other clauses as context for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1086" title="optimizer/path/indxpath.c:1086">build_paths_for_OR</a>; no need to remove ORs from the lists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; all_clauses = <a href="../../nodes/list.c.html#L598" title="nodes/list.c:598">list_concat_copy</a>(clauses, other_clauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, clauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pathlist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *bitmapqual;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore RestrictInfos that aren't ORs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../util/restrictinfo.c.html#L416" title="optimizer/util/restrictinfo.c:416">restriction_is_or_clause</a>(rinfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must be able to match at least one index to each of the arms of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the OR, else we can't use it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pathlist = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(j, ((BoolExpr *) rinfo-&gt;orclause)-&gt;args)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *orarg = (Node *) lfirst(j);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OR arguments should be ANDs or sub-RestrictInfos */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_andclause(orarg))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *andargs = ((BoolExpr *) orarg)-&gt;args;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indlist = <a href="#L1086" title="optimizer/path/indxpath.c:1086">build_paths_for_OR</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; andargs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; all_clauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse in case there are sub-ORs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indlist = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(indlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1180" title="optimizer/path/indxpath.c:1180">generate_bitmap_or_paths</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; andargs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; all_clauses));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *ri = castNode(RestrictInfo, orarg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *orargs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../util/restrictinfo.c.html#L416" title="optimizer/util/restrictinfo.c:416">restriction_is_or_clause</a>(ri));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orargs = list_make1(ri);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indlist = <a href="#L1086" title="optimizer/path/indxpath.c:1086">build_paths_for_OR</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; orargs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; all_clauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If nothing matched this arm, we can't do anything with this OR<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indlist == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathlist = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OK, pick the most promising AND combination, and add it to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pathlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmapqual = <a href="#L1287" title="optimizer/path/indxpath.c:1287">choose_bitmap_and</a>(root, rel, indlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(pathlist, bitmapqual);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have a match for every arm, then turn them into a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * BitmapOrPath, and add to result list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pathlist != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmapqual = (Path *) <a href="../util/pathnode.c.html#L1127" title="optimizer/util/pathnode.c:1127">create_bitmap_or_path</a>(root, rel, pathlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, bitmapqual);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1287" title="optimizer/path/indxpath.c:1287">choose_bitmap_and</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given a nonempty list of bitmap paths, AND them into one path.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a nontrivial decision since we can legally use <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of the<br/></li>
<li></span><span class="Comment"> * given path set.&nbsp; We want to choose a good tradeoff between selectivity<br/></li>
<li></span><span class="Comment"> * and cost of computing the bitmap.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is either a single one of the inputs, or a BitmapAndPath<br/></li>
<li></span><span class="Comment"> * combining multiple inputs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Path *<br/></li>
<li><a id="L1287">&#x200c;</a><span class="linkable">choose_bitmap_and</span>(PlannerInfo *root, RelOptInfo *rel, List *paths)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npaths = list_length(paths);<br/></li>
<li>&nbsp; &nbsp; <a href="#L67" title="optimizer/path/indxpath.c:67">PathClauseUsage</a> **pathinfoarray;<br/></li>
<li>&nbsp; &nbsp; <a href="#L67" title="optimizer/path/indxpath.c:67">PathClauseUsage</a> *pathinfo;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *clauselist;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *bestpaths = NIL;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; bestcost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(npaths &gt; <span class="Constant">0</span>);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else caller error */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (npaths == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Path *) linitial(paths);&nbsp; &nbsp; <span class="Comment">/* easy case */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In theory we should consider every nonempty <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of the given paths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In practice that seems like overkill, given the crude nature of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimates, not to mention the possible effects of higher-level AND and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OR clauses.&nbsp; Moreover, it's completely impractical if there are a large<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number of paths, since the work would grow as O(2^N).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As a heuristic, we first check for paths using exactly the same sets of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WHERE clauses + index predicate conditions, and reject all but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cheapest-to-scan in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such group.&nbsp; This primarily gets rid of indexes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that include the interesting columns but also irrelevant columns.&nbsp; (In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * situations where the DBA has gone overboard on creating variant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indexes, this can make for a very large reduction in the number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * paths considered further.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We then sort the surviving paths with the cheapest-to-scan first, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for each path, consider using that path alone as the basis for a bitmap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan.&nbsp; Then we consider bitmap AND scans formed from that path plus<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * each subsequent (higher-cost) path, adding on a subsequent path if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * results in a reduction in the estimated total scan cost. This means we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consider about O(N^2) rather than O(2^N) path combinations, which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * quite tolerable, especially given than N is usually reasonably small<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because of the prefiltering step.&nbsp; The cheapest of these is returned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We will only consider AND combinations in which no two indexes use the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same WHERE clause.&nbsp; This is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of a kluge: it's needed because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * costsize.c and clausesel.c aren't very smart about redundant clauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * They will usually double-count the redundant clauses, producing a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * too-small selectivity that makes a redundant AND step look like it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reduces the total cost.&nbsp; Perhaps someday that code will be smarter and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we can remove this limitation.&nbsp; (But note that this also defends<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * against flat-out duplicate input paths, which can happen because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1983" title="optimizer/path/indxpath.c:1983">match_join_clauses_to_index</a> will <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the same OR join clauses that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../util/orclauses.c.html#L75" title="optimizer/util/orclauses.c:75">extract_restriction_or_clauses</a> has pulled OR restriction clauses out<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For the same reason, we reject AND combinations in which an index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * predicate clause duplicates another clause.&nbsp; Here we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it necessary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to be even stricter: we'll reject a partial index if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * predicate clauses are implied by the set of WHERE clauses and predicate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clauses used so far.&nbsp; This covers cases such as a condition &quot;x = 42&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * used with a plain index, followed by a clauseless scan of a partial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index &quot;WHERE x &gt;= 40 AND x &lt; 50&quot;.&nbsp; The partial index has been accepted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only because &quot;x = 42&quot; was present, and so allowing it would partially<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * double-count selectivity.&nbsp; (We could use <a href="../util/predtest.c.html#L152" title="optimizer/util/predtest.c:152">predicate_implied_by</a> on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * regular qual clauses too, to have a more intelligent, but much more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expensive, check for redundancy --- but in most cases simple equality<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * seems to suffice.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Extract clause usage info and detect <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> paths that use exactly the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same set of clauses; keep only the cheapest-to-scan of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such groups.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The surviving paths are put into an array for qsort'ing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pathinfoarray = (<a href="#L67" title="optimizer/path/indxpath.c:67">PathClauseUsage</a> **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(npaths * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L67" title="optimizer/path/indxpath.c:67">PathClauseUsage</a> *));<br/></li>
<li>&nbsp; &nbsp; clauselist = NIL;<br/></li>
<li>&nbsp; &nbsp; npaths = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(l, paths)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *ipath = (Path *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathinfo = <a href="#L1589" title="optimizer/path/indxpath.c:1589">classify_index_clause_usage</a>(ipath, &amp;clauselist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's unclassifiable, treat it as distinct from all others */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pathinfo-&gt;unclassifiable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathinfoarray[npaths++] = pathinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; npaths; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pathinfoarray[i]-&gt;unclassifiable &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(pathinfo-&gt;clauseids, pathinfoarray[i]-&gt;clauseids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; npaths)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* duplicate clauseids, keep the cheaper one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; ncost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; ocost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Selectivity nselec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Selectivity oselec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="costsize.c.html#L1114" title="optimizer/path/costsize.c:1114">cost_bitmap_tree_node</a>(pathinfo-&gt;path, &amp;ncost, &amp;nselec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="costsize.c.html#L1114" title="optimizer/path/costsize.c:1114">cost_bitmap_tree_node</a>(pathinfoarray[i]-&gt;path, &amp;ocost, &amp;oselec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ncost &lt; ocost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathinfoarray[i] = pathinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not duplicate clauseids, add to array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathinfoarray[npaths++] = pathinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If only one surviving path, we're done */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (npaths == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> pathinfoarray[<span class="Constant">0</span>]-&gt;path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort the surviving paths by index access cost */<br/></li>
<li></span>&nbsp; &nbsp; qsort(pathinfoarray, npaths, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L67" title="optimizer/path/indxpath.c:67">PathClauseUsage</a> *),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1493" title="optimizer/path/indxpath.c:1493">path_usage_comparator</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For each surviving index, consider it as an &quot;AND group leader&quot;, and see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whether adding on <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the later indexes results in an AND path with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cheaper total cost than <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>.&nbsp; Then take the cheapest AND group.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: paths that are either clauseless or unclassifiable will have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * empty clauseids, so that they will not be rejected by the clauseids<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * filter here, nor will they cause later paths to be rejected by it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; npaths; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; costsofar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *qualsofar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *clauseidsofar;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathinfo = pathinfoarray[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; paths = list_make1(pathinfo-&gt;path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; costsofar = <a href="#L1526" title="optimizer/path/indxpath.c:1526">bitmap_scan_cost_est</a>(root, rel, pathinfo-&gt;path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qualsofar = <a href="../../nodes/list.c.html#L598" title="nodes/list.c:598">list_concat_copy</a>(pathinfo-&gt;quals, pathinfo-&gt;preds);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; clauseidsofar = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(pathinfo-&gt;clauseids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = i + <span class="Constant">1</span>; j &lt; npaths; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; newcost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathinfo = pathinfoarray[j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for redundancy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(pathinfo-&gt;clauseids, clauseidsofar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* consider it redundant */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pathinfo-&gt;preds)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; redundant = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we check each predicate clause separately */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, pathinfo-&gt;preds)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *np = (Node *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/predtest.c.html#L152" title="optimizer/util/predtest.c:152">predicate_implied_by</a>(list_make1(np), qualsofar, <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; redundant = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; <span class="Comment">/* out of inner foreach loop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (redundant)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tentatively add new path to paths, so we can estimate cost */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paths = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(paths, pathinfo-&gt;path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcost = <a href="#L1560" title="optimizer/path/indxpath.c:1560">bitmap_and_cost_est</a>(root, rel, paths);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newcost &lt; costsofar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep new path in paths, update subsidiary variables */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; costsofar = newcost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qualsofar = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(qualsofar, pathinfo-&gt;quals);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qualsofar = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(qualsofar, pathinfo-&gt;preds);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clauseidsofar = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(clauseidsofar,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathinfo-&gt;clauseids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reject new path, remove it from paths list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paths = <a href="../../nodes/list.c.html#L631" title="nodes/list.c:631">list_truncate</a>(paths, list_length(paths) - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Keep the cheapest AND-group (or singleton) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == <span class="Constant">0</span> || costsofar &lt; bestcost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bestpaths = paths;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bestcost = costsofar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* some easy <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> (we don't try real hard though) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(qualsofar);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(bestpaths) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Path *) linitial(bestpaths);&nbsp; &nbsp; <span class="Comment">/* no need for AND */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (Path *) <a href="../util/pathnode.c.html#L1075" title="optimizer/util/pathnode.c:1075">create_bitmap_and_path</a>(root, rel, bestpaths);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* qsort comparator to sort in increasing index access cost order */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1493">&#x200c;</a></span><span class="linkable">path_usage_comparator</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L67" title="optimizer/path/indxpath.c:67">PathClauseUsage</a> *pa = *(<a href="#L67" title="optimizer/path/indxpath.c:67">PathClauseUsage</a> *<span class="Type">const</span> *) a;<br/></li>
<li>&nbsp; &nbsp; <a href="#L67" title="optimizer/path/indxpath.c:67">PathClauseUsage</a> *pb = *(<a href="#L67" title="optimizer/path/indxpath.c:67">PathClauseUsage</a> *<span class="Type">const</span> *) b;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; acost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; bcost;<br/></li>
<li>&nbsp; &nbsp; Selectivity aselec;<br/></li>
<li>&nbsp; &nbsp; Selectivity bselec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="costsize.c.html#L1114" title="optimizer/path/costsize.c:1114">cost_bitmap_tree_node</a>(pa-&gt;path, &amp;acost, &amp;aselec);<br/></li>
<li>&nbsp; &nbsp; <a href="costsize.c.html#L1114" title="optimizer/path/costsize.c:1114">cost_bitmap_tree_node</a>(pb-&gt;path, &amp;bcost, &amp;bselec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If costs are the same, sort by selectivity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (acost &lt; bcost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (acost &gt; bcost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aselec &lt; bselec)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aselec &gt; bselec)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Estimate the cost of actually executing a bitmap scan with a single<br/></li>
<li></span><span class="Comment"> * index path (which could be a BitmapAnd or BitmapOr node).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Cost<br/></li>
<li><a id="L1526">&#x200c;</a><span class="linkable">bitmap_scan_cost_est</span>(PlannerInfo *root, RelOptInfo *rel, Path *ipath)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BitmapHeapPath bpath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up a dummy BitmapHeapPath */<br/></li>
<li></span>&nbsp; &nbsp; bpath.path.type = T_BitmapHeapPath;<br/></li>
<li>&nbsp; &nbsp; bpath.path.pathtype = T_BitmapHeapScan;<br/></li>
<li>&nbsp; &nbsp; bpath.path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; bpath.path.pathtarget = rel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; bpath.path.param_info = ipath-&gt;param_info;<br/></li>
<li>&nbsp; &nbsp; bpath.path.pathkeys = NIL;<br/></li>
<li>&nbsp; &nbsp; bpath.bitmapqual = ipath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check the cost of temporary path without considering parallelism.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Parallel bitmap heap path will be considered at later stage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bpath.path.parallel_workers = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we can do <a href="costsize.c.html#L1013" title="optimizer/path/costsize.c:1013">cost_bitmap_heap_scan</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="costsize.c.html#L1013" title="optimizer/path/costsize.c:1013">cost_bitmap_heap_scan</a>(&amp;bpath.path, root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bpath.path.param_info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ipath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1829" title="optimizer/path/indxpath.c:1829">get_loop_count</a>(root, rel-&gt;relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PATH_REQ_OUTER(ipath)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> bpath.path.total_cost;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Estimate the cost of actually executing a BitmapAnd scan with the given<br/></li>
<li></span><span class="Comment"> * inputs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Cost<br/></li>
<li><a id="L1560">&#x200c;</a><span class="linkable">bitmap_and_cost_est</span>(PlannerInfo *root, RelOptInfo *rel, List *paths)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BitmapAndPath *apath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Might as well build a real BitmapAndPath here, as the work is slightly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * too complicated to be worth repeating just to save one <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; apath = <a href="../util/pathnode.c.html#L1075" title="optimizer/util/pathnode.c:1075">create_bitmap_and_path</a>(root, rel, paths);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1526" title="optimizer/path/indxpath.c:1526">bitmap_scan_cost_est</a>(root, rel, (Path *) apath);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1589" title="optimizer/path/indxpath.c:1589">classify_index_clause_usage</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Construct a <a href="#L67" title="optimizer/path/indxpath.c:67">PathClauseUsage</a> struct describing the WHERE clauses and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; index predicate clauses used by the given indexscan path.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; We consider two clauses the same if they are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At some point we might want to migrate this info into the Path data<br/></li>
<li></span><span class="Comment"> * structure proper, but for the moment it's only needed within<br/></li>
<li></span><span class="Comment"> * <a href="#L1287" title="optimizer/path/indxpath.c:1287">choose_bitmap_and</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *clauselist is used and expanded as needed to identify all the distinct<br/></li>
<li></span><span class="Comment"> * clauses seen across successive calls.&nbsp; Caller must <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> it to NIL<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> first call of a set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L67" title="optimizer/path/indxpath.c:67">PathClauseUsage</a> *<br/></li>
<li><a id="L1589">&#x200c;</a><span class="linkable">classify_index_clause_usage</span>(Path *path, List **clauselist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L67" title="optimizer/path/indxpath.c:67">PathClauseUsage</a> *result;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *clauseids;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (<a href="#L67" title="optimizer/path/indxpath.c:67">PathClauseUsage</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L67" title="optimizer/path/indxpath.c:67">PathClauseUsage</a>));<br/></li>
<li>&nbsp; &nbsp; result-&gt;path = path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Recursively <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the quals and preds used by the path */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;quals = NIL;<br/></li>
<li>&nbsp; &nbsp; result-&gt;preds = NIL;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1657" title="optimizer/path/indxpath.c:1657">find_indexpath_quals</a>(path, &amp;result-&gt;quals, &amp;result-&gt;preds);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Some machine-generated queries have outlandish numbers of qual clauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To avoid getting into O(N^2) behavior even in this preliminary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * classification step, we want to limit the number of entries we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * accumulate in *clauselist.&nbsp; Treat <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> path with more than 100 quals +<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * preds as unclassifiable, which will cause calling code to consider it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * distinct from all other paths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(result-&gt;quals) + list_length(result-&gt;preds) &gt; <span class="Constant">100</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;clauseids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;unclassifiable = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build up a bitmapset representing the quals and preds */<br/></li>
<li></span>&nbsp; &nbsp; clauseids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, result-&gt;quals)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *node = (Node *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; clauseids = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(clauseids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1704" title="optimizer/path/indxpath.c:1704">find_list_position</a>(node, clauselist));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; foreach(lc, result-&gt;preds)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *node = (Node *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; clauseids = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(clauseids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1704" title="optimizer/path/indxpath.c:1704">find_list_position</a>(node, clauselist));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; result-&gt;clauseids = clauseids;<br/></li>
<li>&nbsp; &nbsp; result-&gt;unclassifiable = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1657" title="optimizer/path/indxpath.c:1657">find_indexpath_quals</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given the Path structure for a plain or bitmap indexscan, extract lists<br/></li>
<li></span><span class="Comment"> * of all the index clauses and index predicate conditions used in the Path.<br/></li>
<li></span><span class="Comment"> * These are appended to the initial contents of *quals and *preds (hence<br/></li>
<li></span><span class="Comment"> * caller should <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> those to NIL).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note we are not trying to produce an accurate representation of the AND/OR<br/></li>
<li></span><span class="Comment"> * semantics of the Path, but just <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out all the base conditions used.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result lists contain pointers to the expressions used in the Path,<br/></li>
<li></span><span class="Comment"> * but all the list cells are freshly built, so it's safe to destructively<br/></li>
<li></span><span class="Comment"> * modify the lists (eg, by concat'ing with other lists).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1657">&#x200c;</a></span><span class="linkable">find_indexpath_quals</span>(Path *bitmapqual, List **quals, List **preds)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(bitmapqual, BitmapAndPath))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BitmapAndPath *apath = (BitmapAndPath *) bitmapqual;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, apath-&gt;bitmapquals)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1657" title="optimizer/path/indxpath.c:1657">find_indexpath_quals</a>((Path *) lfirst(l), quals, preds);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(bitmapqual, BitmapOrPath))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BitmapOrPath *opath = (BitmapOrPath *) bitmapqual;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, opath-&gt;bitmapquals)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1657" title="optimizer/path/indxpath.c:1657">find_indexpath_quals</a>((Path *) lfirst(l), quals, preds);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(bitmapqual, IndexPath))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexPath&nbsp; *ipath = (IndexPath *) bitmapqual;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, ipath-&gt;indexclauses)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexClause *iclause = (IndexClause *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *quals = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(*quals, iclause-&gt;rinfo-&gt;clause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *preds = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(*preds, ipath-&gt;indexinfo-&gt;indpred);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, nodeTag(bitmapqual));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1704" title="optimizer/path/indxpath.c:1704">find_list_position</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return the given node's position (counting from 0) in the given<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; list of nodes.&nbsp; If it's not <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>() to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing list member,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; add it at the end, and return that position.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1704">&#x200c;</a></span><span class="linkable">find_list_position</span>(Node *node, List **nodelist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, *nodelist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *oldnode = (Node *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(node, oldnode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *nodelist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(*nodelist, node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> i;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1730" title="optimizer/path/indxpath.c:1730">check_index_only</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Determine whether an index-only scan is possible for this index.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1730">&#x200c;</a></span><span class="linkable">check_index_only</span>(RelOptInfo *rel, IndexOptInfo *index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *attrs_used = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *index_canreturn_attrs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Index-only scans must be enabled */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="costsize.c.html#L136" title="optimizer/path/costsize.c:136">enable_indexonlyscan</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that all needed attributes of the relation are available from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, identify all the attributes needed for joins or final output.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we must look at rel's targetlist, not the attr_needed data,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because attr_needed isn't computed for inheritance child rels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/var.c.html#L291" title="optimizer/util/var.c:291">pull_varattnos</a>((Node *) rel-&gt;reltarget-&gt;exprs, rel-&gt;relid, &amp;attrs_used);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add all the attributes used by restriction clauses; but consider only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those clauses not implied by the index predicate, since ones that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so implied don't need to be checked explicitly in the plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: attributes used only in index quals would not be needed at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * runtime either, if we are certain that the index is not lossy.&nbsp; However<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it'd be complicated to account for that accurately, and it doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * matter in most cases, since we'd conclude that such attributes are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * available from the index anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, index-&gt;indrestrictinfo)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/var.c.html#L291" title="optimizer/util/var.c:291">pull_varattnos</a>((Node *) rinfo-&gt;clause, rel-&gt;relid, &amp;attrs_used);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Construct a bitmapset of columns that the index can return back in an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index-only scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; index-&gt;ncolumns; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attno = index-&gt;indexkeys[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For the moment, we just ignore index expressions.&nbsp; It might be nice<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to do something with them, later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;canreturn[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_canreturn_attrs =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(index_canreturn_attrs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attno - FirstLowInvalidHeapAttributeNumber);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do we have all the necessary attributes? */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(attrs_used, index_canreturn_attrs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(attrs_used);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(index_canreturn_attrs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1829" title="optimizer/path/indxpath.c:1829">get_loop_count</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Choose the loop count estimate to use for costing a parameterized path<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; with the given set of outer relids.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since we produce parameterized paths <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we've begun to generate join<br/></li>
<li></span><span class="Comment"> * relations, it's impossible to predict exactly how many times a parameterized<br/></li>
<li></span><span class="Comment"> * path will be iterated; we don't know the size of the relation that will be<br/></li>
<li></span><span class="Comment"> * on the outside of the nestloop.&nbsp; However, we should try to account for<br/></li>
<li></span><span class="Comment"> * multiple iterations somehow in costing the path.&nbsp; The heuristic embodied<br/></li>
<li></span><span class="Comment"> * here is to use the rowcount of the smallest other base relation needed in<br/></li>
<li></span><span class="Comment"> * the join clauses used by the path.&nbsp; (We could alternatively consider the<br/></li>
<li></span><span class="Comment"> * largest one, but that seems too optimistic.)&nbsp; This is of course the right<br/></li>
<li></span><span class="Comment"> * answer for single-other-relation cases, and it seems like a reasonable<br/></li>
<li></span><span class="Comment"> * zero-order approximation for multiway-join cases.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In addition, we check to see if the other side of each join clause is on<br/></li>
<li></span><span class="Comment"> * the inside of some semijoin that the current relation is on the outside of.<br/></li>
<li></span><span class="Comment"> * If so, the only way that a parameterized path could be used is if the<br/></li>
<li></span><span class="Comment"> * semijoin RHS has been unique-ified, so we should use the number of unique<br/></li>
<li></span><span class="Comment"> * RHS rows rather than using the relation's raw rowcount.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: for this to work, allpaths.c must establish all baserel size<br/></li>
<li></span><span class="Comment"> * estimates <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it begins to compute paths, or at least <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it<br/></li>
<li></span><span class="Comment"> * calls <a href="#L234" title="optimizer/path/indxpath.c:234">create_index_paths</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L1829">&#x200c;</a></span><span class="linkable">get_loop_count</span>(PlannerInfo *root, Index cur_relid, Relids outer_relids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For a non-parameterized path, just return 1.0 quickly */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (outer_relids == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; outer_relid = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((outer_relid = <a href="../../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(outer_relids, outer_relid)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *outer_rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; rowcount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Paranoia: ignore bogus relid indexes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (outer_relid &gt;= root-&gt;simple_rel_array_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; outer_rel = root-&gt;simple_rel_array[outer_relid];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (outer_rel == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(outer_rel-&gt;relid == outer_relid);&nbsp; &nbsp; <span class="Comment">/* sanity check on array */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Other relation could be proven empty, if so ignore */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IS_DUMMY_REL(outer_rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise, rel's rows estimate should be valid by <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(outer_rel-&gt;rows &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check to see if rel is on the inside of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> semijoins */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rowcount = <a href="#L1882" title="optimizer/path/indxpath.c:1882">adjust_rowcount_for_semijoins</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur_relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outer_relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outer_rel-&gt;rows);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remember smallest row count estimate among the outer rels */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result == <span class="Constant">0.0</span> || result &gt; rowcount)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = rowcount;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return 1.0 if we found no valid relations (shouldn't happen) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (result &gt; <span class="Constant">0.0</span>) ? result : <span class="Constant">1.0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check to see if outer_relid is on the inside of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> semijoin that cur_relid<br/></li>
<li></span><span class="Comment"> * is on the outside of.&nbsp; If so, replace rowcount with the estimated number of<br/></li>
<li></span><span class="Comment"> * unique rows from the semijoin RHS (assuming that's smaller, which it might<br/></li>
<li></span><span class="Comment"> * not be).&nbsp; The estimate is crude but it's the best we can do at this stage<br/></li>
<li></span><span class="Comment"> * of the proceedings.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L1882">&#x200c;</a></span><span class="linkable">adjust_rowcount_for_semijoins</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index cur_relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index outer_relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> rowcount)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, root-&gt;join_info_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpecialJoinInfo *sjinfo = (SpecialJoinInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sjinfo-&gt;jointype == JOIN_SEMI &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(cur_relid, sjinfo-&gt;syn_lefthand) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(outer_relid, sjinfo-&gt;syn_righthand))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Estimate number of unique-ified rows */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nraw;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nunique;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nraw = <a href="#L1926" title="optimizer/path/indxpath.c:1926">approximate_joinrel_size</a>(root, sjinfo-&gt;syn_righthand);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nunique = <a href="../../utils/adt/selfuncs.c.html#L3416" title="utils/adt/selfuncs.c:3416">estimate_num_groups</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sjinfo-&gt;semi_rhs_exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nraw,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rowcount &gt; nunique)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowcount = nunique;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rowcount;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Make an approximate estimate of the size of a joinrel.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We don't have enough info at this point to get a good estimate, so we<br/></li>
<li></span><span class="Comment"> * just multiply the base relation sizes together.&nbsp; Fortunately, this is<br/></li>
<li></span><span class="Comment"> * the right answer anyway for the most common case with a single relation<br/></li>
<li></span><span class="Comment"> * on the RHS of a semijoin.&nbsp; Also, <a href="../../utils/adt/selfuncs.c.html#L3416" title="utils/adt/selfuncs.c:3416">estimate_num_groups</a>() has only a weak<br/></li>
<li></span><span class="Comment"> * dependency on its input_rows argument (it basically uses it as a clamp).<br/></li>
<li></span><span class="Comment"> * So we might be able to get a fairly decent end result even with a severe<br/></li>
<li></span><span class="Comment"> * overestimate of the RHS's raw size.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L1926">&#x200c;</a></span><span class="linkable">approximate_joinrel_size</span>(PlannerInfo *root, Relids relids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; rowcount = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relid = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((relid = <a href="../../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(relids, relid)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Paranoia: ignore bogus relid indexes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relid &gt;= root-&gt;simple_rel_array_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel = root-&gt;simple_rel_array[relid];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(rel-&gt;relid == relid);&nbsp; &nbsp; <span class="Comment">/* sanity check on array */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Relation could be proven empty, if so ignore */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IS_DUMMY_REL(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise, rel's rows estimate should be valid by <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(rel-&gt;rows &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Accumulate product */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rowcount *= rel-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rowcount;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ----&nbsp; ROUTINES TO CHECK QUERY CLAUSES&nbsp; ----<br/></li>
<li></span><span class="Comment"> ****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1968" title="optimizer/path/indxpath.c:1968">match_restriction_clauses_to_index</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Identify restriction clauses for the rel that match the index.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Matching clauses are added to *clauseset.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1968">&#x200c;</a></span><span class="linkable">match_restriction_clauses_to_index</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexOptInfo *index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *clauseset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can ignore clauses that are implied by the index predicate */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2051" title="optimizer/path/indxpath.c:2051">match_clauses_to_index</a>(root, index-&gt;indrestrictinfo, index, clauseset);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1983" title="optimizer/path/indxpath.c:1983">match_join_clauses_to_index</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Identify join clauses for the rel that match the index.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Matching clauses are added to *clauseset.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Also, add <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> potentially usable join OR clauses to *joinorclauses.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1983">&#x200c;</a></span><span class="linkable">match_join_clauses_to_index</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel, IndexOptInfo *index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *clauseset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **joinorclauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan the rel's join clauses */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, rel-&gt;joininfo)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check if clause can be moved to this rel */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../util/restrictinfo.c.html#L584" title="optimizer/util/restrictinfo.c:584">join_clause_is_movable_to</a>(rinfo, rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Potentially usable, so see if it matches the index or is an OR */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/restrictinfo.c.html#L416" title="optimizer/util/restrictinfo.c:416">restriction_is_or_clause</a>(rinfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *joinorclauses = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(*joinorclauses, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2084" title="optimizer/path/indxpath.c:2084">match_clause_to_index</a>(root, rinfo, index, clauseset);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2013" title="optimizer/path/indxpath.c:2013">match_eclass_clauses_to_index</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Identify EquivalenceClass join clauses for the rel that match the index.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Matching clauses are added to *clauseset.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2013">&#x200c;</a></span><span class="linkable">match_eclass_clauses_to_index</span>(PlannerInfo *root, IndexOptInfo *index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *clauseset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexcol;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No work if rel is not in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such ECs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!index-&gt;rel-&gt;has_eclass_joins)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (indexcol = <span class="Constant">0</span>; indexcol &lt; index-&gt;nkeycolumns; indexcol++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L74" title="optimizer/path/indxpath.c:74">ec_member_matches_arg</a> arg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *clauses;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Generate clauses, skipping <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> that join to lateral_referencers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; arg.index = index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arg.indexcol = indexcol;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; clauses = <a href="equivclass.c.html#L2971" title="optimizer/path/equivclass.c:2971">generate_implied_equalities_for_column</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index-&gt;rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L3382" title="optimizer/path/indxpath.c:3382">ec_member_matches_indexcol</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) &amp;arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index-&gt;rel-&gt;lateral_referencers);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have to check whether the results actually do match the index,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since for non-btree indexes the EC's equality operators might not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be in the index opclass (cf <a href="#L3382" title="optimizer/path/indxpath.c:3382">ec_member_matches_indexcol</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2051" title="optimizer/path/indxpath.c:2051">match_clauses_to_index</a>(root, clauses, index, clauseset);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2051" title="optimizer/path/indxpath.c:2051">match_clauses_to_index</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Perform <a href="#L2084" title="optimizer/path/indxpath.c:2084">match_clause_to_index</a>() for each clause in a list.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Matching clauses are added to *clauseset.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2051">&#x200c;</a></span><span class="linkable">match_clauses_to_index</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexOptInfo *index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *clauseset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, clauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2084" title="optimizer/path/indxpath.c:2084">match_clause_to_index</a>(root, rinfo, index, clauseset);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2084" title="optimizer/path/indxpath.c:2084">match_clause_to_index</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Test whether a qual clause can be used with an index.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the clause is usable, add an IndexClause entry for it to the appropriate<br/></li>
<li></span><span class="Comment"> * list in *clauseset.&nbsp; (*clauseset must be initialized to zeroes <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> first<br/></li>
<li></span><span class="Comment"> * call.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: in some circumstances we may <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the same RestrictInfos coming from<br/></li>
<li></span><span class="Comment"> * multiple places.&nbsp; Defend against redundant outputs by refusing to add a<br/></li>
<li></span><span class="Comment"> * clause twice (pointer equality should be a good enough check for this).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: it's possible that a badly-defined index could have multiple matching<br/></li>
<li></span><span class="Comment"> * columns.&nbsp; We always <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> the first match if so; this avoids scenarios<br/></li>
<li></span><span class="Comment"> * wherein we get an inflated idea of the index's selectivity by using the<br/></li>
<li></span><span class="Comment"> * same clause multiple times with different index columns.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2084">&#x200c;</a></span><span class="linkable">match_clause_to_index</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexOptInfo *index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L57" title="optimizer/path/indxpath.c:57">IndexClauseSet</a> *clauseset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexcol;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Never match pseudoconstants to indexes.&nbsp; (Normally a match could not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happen anyway, since a pseudoconstant clause couldn't contain a Var,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but what if someone builds an expression index on a constant? It's not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * totally unreasonable to do so with a partial index, either.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rinfo-&gt;pseudoconstant)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If clause can't be used as an indexqual because it must wait till after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-security-level restriction clause, reject it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../util/restrictinfo.c.html#L431" title="optimizer/util/restrictinfo.c:431">restriction_is_securely_promotable</a>(rinfo, index-&gt;rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, check each index key column for a match */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (indexcol = <span class="Constant">0</span>; indexcol &lt; index-&gt;nkeycolumns; indexcol++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexClause *iclause;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore duplicates */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, clauseset-&gt;indexclauses[indexcol])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause = (IndexClause *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (iclause-&gt;rinfo == rinfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, try to match the clause to the index column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; iclause = <a href="#L2203" title="optimizer/path/indxpath.c:2203">match_clause_to_indexcol</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (iclause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Success, so record it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clauseset-&gt;indexclauses[indexcol] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(clauseset-&gt;indexclauses[indexcol], iclause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clauseset-&gt;nonempty = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2203" title="optimizer/path/indxpath.c:2203">match_clause_to_indexcol</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Determine whether a restriction clause matches a column of an index,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; and if so, build an IndexClause node describing the details.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; To match an index normally, an operator clause:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; (1)&nbsp; must be in the form (indexkey op const) or (const op indexkey);<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; (2)&nbsp; must contain an operator which is in the index's operator family<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; for this column; and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; (3)&nbsp; must match the collation of the index, if collation is relevant.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Our definition of &quot;const&quot; is exceedingly liberal: we allow anything that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; doesn't involve a volatile function or a Var of the index's relation.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; In particular, Vars belonging to other relations of the query are<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; accepted here, since a clause of that form can be used in a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; parameterized indexscan.&nbsp; It's the responsibility of higher code levels<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; to manage restriction and join clauses appropriately.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Note: we do need to check for Vars of the index's relation on the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &quot;const&quot; side of the clause, since clauses like (a.f1 OP (b.f2 OP a.f3))<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; are not processable by a parameterized indexscan on a.f1, whereas<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; something like (a.f1 OP (b.f2 OP c.f3)) is.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Presently, the executor can only deal with indexquals that have the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; indexkey on the left, so we can only use clauses that have the indexkey<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; on the right if we can commute the clause to put the key on the left.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; We handle that by generating an IndexClause with the correctly-commuted<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; opclause as a derived indexqual.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; If the index has a collation, the clause must have the same collation.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; For collation-less indexes, we assume it doesn't matter; this is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; necessary for cases like &quot;hstore ? text&quot;, wherein hstore's operators<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; don't care about collation but the clause will get marked with a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; collation anyway because of the text argument.&nbsp; (This logic is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; embodied in the macro <a href="#L40" title="optimizer/path/indxpath.c:40">IndexCollMatchesExprColl</a>.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; It is also possible to match RowCompareExpr clauses to indexes (but<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; currently, only btree indexes handle this).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; It is also possible to match ScalarArrayOpExpr clauses to indexes, when<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the clause is of the form &quot;indexkey op ANY (arrayconst)&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; For boolean indexes, it is also possible to match the clause directly<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; to the indexkey; or perhaps the clause is (NOT indexkey).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; And, last but not least, some operators and <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> can be processed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; to derive (typically lossy) indexquals from a clause that isn't in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; itself indexable.&nbsp; If we see that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> operand of an OpExpr or FuncExpr<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; matches the index key, and the function has a <a href="../plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> support function<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; attached to it, we'll invoke the support function to see if such an<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; indexqual can be built.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rinfo' is the clause to be tested (as a RestrictInfo node).<br/></li>
<li></span><span class="Comment"> * 'indexcol' is a column number of 'index' (counting from 0).<br/></li>
<li></span><span class="Comment"> * 'index' is the index of interest.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns an IndexClause if the clause can be used with this index key,<br/></li>
<li></span><span class="Comment"> * or NULL if not.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>:&nbsp; returns NULL if clause is an OR or AND clause; it is the<br/></li>
<li></span><span class="Comment"> * responsibility of higher-level routines to cope with those.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> IndexClause *<br/></li>
<li><a id="L2203">&#x200c;</a><span class="linkable">match_clause_to_indexcol</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RestrictInfo *rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexOptInfo *index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexClause *iclause;<br/></li>
<li>&nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *clause = rinfo-&gt;clause;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfamily;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(indexcol &lt; index-&gt;nkeycolumns);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Historically this code has coped with NULL clauses.&nbsp; That's probably<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not possible anymore, but we might as well continue to cope.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (clause == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First check for boolean-index cases. */<br/></li>
<li></span>&nbsp; &nbsp; opfamily = index-&gt;opfamily[indexcol];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2280" title="optimizer/path/indxpath.c:2280">IsBooleanOpfamily</a>(opfamily))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iclause = <a href="#L2305" title="optimizer/path/indxpath.c:2305">match_boolean_index_clause</a>(root, rinfo, indexcol, index);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (iclause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> iclause;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clause must be an opclause, funcclause, ScalarArrayOpExpr, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * RowCompareExpr.&nbsp; Or, if the index supports it, we can handle IS<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NULL/NOT NULL clauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(clause, OpExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2392" title="optimizer/path/indxpath.c:2392">match_opclause_to_indexcol</a>(root, rinfo, indexcol, index);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(clause, FuncExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2511" title="optimizer/path/indxpath.c:2511">match_funcclause_to_indexcol</a>(root, rinfo, indexcol, index);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(clause, ScalarArrayOpExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2623" title="optimizer/path/indxpath.c:2623">match_saopclause_to_indexcol</a>(root, rinfo, indexcol, index);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(clause, RowCompareExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2691" title="optimizer/path/indxpath.c:2691">match_rowcompare_to_indexcol</a>(root, rinfo, indexcol, index);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (index-&gt;amsearchnulls &amp;&amp; IsA(clause, NullTest))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; NullTest&nbsp;&nbsp; *nt = (NullTest *) clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!nt-&gt;argisrow &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3704" title="optimizer/path/indxpath.c:3704">match_index_to_operand</a>((Node *) nt-&gt;arg, indexcol, index))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause = makeNode(IndexClause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;rinfo = rinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;indexquals = list_make1(rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;lossy = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;indexcol = indexcol;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;indexcols = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> iclause;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2280" title="optimizer/path/indxpath.c:2280">IsBooleanOpfamily</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Detect whether an opfamily supports boolean equality as an operator.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the opfamily OID is in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of built-in objects, we can rely<br/></li>
<li></span><span class="Comment"> * on hard-wired knowledge of which built-in opfamilies support this.<br/></li>
<li></span><span class="Comment"> * For extension opfamilies, there's no choice but to do a catcache lookup.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2280">&#x200c;</a></span><span class="linkable">IsBooleanOpfamily</span>(Oid opfamily)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (opfamily &lt; FirstNormalObjectId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> IsBuiltinBooleanOpfamily(opfamily);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../utils/cache/lsyscache.c.html#L66" title="utils/cache/lsyscache.c:66">op_in_opfamily</a>(BooleanEqualOperator, opfamily);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2305" title="optimizer/path/indxpath.c:2305">match_boolean_index_clause</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Recognize restriction clauses that can be matched to a boolean index.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The idea here is that, for an index on a boolean column that supports the<br/></li>
<li></span><span class="Comment"> * BooleanEqualOperator, we can transform a plain reference to the indexkey<br/></li>
<li></span><span class="Comment"> * into &quot;indexkey = true&quot;, or &quot;NOT indexkey&quot; into &quot;indexkey = false&quot;, etc,<br/></li>
<li></span><span class="Comment"> * so as to make the expression indexable using the index's &quot;=&quot; operator.<br/></li>
<li></span><span class="Comment"> * Since Postgres 8.1, we must do this because constant simplification does<br/></li>
<li></span><span class="Comment"> * the reverse transformation; without this code there'd be no way to use<br/></li>
<li></span><span class="Comment"> * such an index at all.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be called only when <a href="#L2280" title="optimizer/path/indxpath.c:2280">IsBooleanOpfamily</a>() recognizes the<br/></li>
<li></span><span class="Comment"> * index's operator family.&nbsp; We check to see if the clause matches the<br/></li>
<li></span><span class="Comment"> * index's key, and if so, build a suitable IndexClause.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> IndexClause *<br/></li>
<li><a id="L2305">&#x200c;</a><span class="linkable">match_boolean_index_clause</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RestrictInfo *rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexOptInfo *index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *clause = (Node *) rinfo-&gt;clause;<br/></li>
<li>&nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *op = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Direct match? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3704" title="optimizer/path/indxpath.c:3704">match_index_to_operand</a>(clause, indexcol, index))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* convert to indexkey = TRUE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; op = <a href="../../nodes/makefuncs.c.html#L628" title="nodes/makefuncs.c:628">make_opclause</a>(BooleanEqualOperator, BOOLOID, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Expr *) clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Expr *) <a href="../../nodes/makefuncs.c.html#L359" title="nodes/makefuncs.c:359">makeBoolConst</a>(<span class="Constant">true</span>, <span class="Constant">false</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, InvalidOid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* NOT clause? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (is_notclause(clause))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *arg = (Node *) get_notclausearg((Expr *) clause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3704" title="optimizer/path/indxpath.c:3704">match_index_to_operand</a>(arg, indexcol, index))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* convert to indexkey = FALSE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op = <a href="../../nodes/makefuncs.c.html#L628" title="nodes/makefuncs.c:628">make_opclause</a>(BooleanEqualOperator, BOOLOID, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Expr *) arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Expr *) <a href="../../nodes/makefuncs.c.html#L359" title="nodes/makefuncs.c:359">makeBoolConst</a>(<span class="Constant">false</span>, <span class="Constant">false</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, InvalidOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we only consider clauses at top level of WHERE, we can convert<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indexkey IS TRUE and indexkey IS FALSE to index searches as well.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * different meaning for NULL isn't important.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (clause &amp;&amp; IsA(clause, BooleanTest))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BooleanTest *btest = (BooleanTest *) clause;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *arg = (Node *) btest-&gt;arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (btest-&gt;booltesttype == IS_TRUE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3704" title="optimizer/path/indxpath.c:3704">match_index_to_operand</a>(arg, indexcol, index))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* convert to indexkey = TRUE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op = <a href="../../nodes/makefuncs.c.html#L628" title="nodes/makefuncs.c:628">make_opclause</a>(BooleanEqualOperator, BOOLOID, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Expr *) arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Expr *) <a href="../../nodes/makefuncs.c.html#L359" title="nodes/makefuncs.c:359">makeBoolConst</a>(<span class="Constant">true</span>, <span class="Constant">false</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, InvalidOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (btest-&gt;booltesttype == IS_FALSE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L3704" title="optimizer/path/indxpath.c:3704">match_index_to_operand</a>(arg, indexcol, index))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* convert to indexkey = FALSE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op = <a href="../../nodes/makefuncs.c.html#L628" title="nodes/makefuncs.c:628">make_opclause</a>(BooleanEqualOperator, BOOLOID, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Expr *) arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Expr *) <a href="../../nodes/makefuncs.c.html#L359" title="nodes/makefuncs.c:359">makeBoolConst</a>(<span class="Constant">false</span>, <span class="Constant">false</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, InvalidOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we successfully made an operator clause from the given qual, we must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wrap it in an IndexClause.&nbsp; It's not lossy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (op)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexClause *iclause = makeNode(IndexClause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;rinfo = rinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;indexquals = list_make1(make_simple_restrictinfo(root, op));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;lossy = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;indexcol = indexcol;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;indexcols = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> iclause;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2392" title="optimizer/path/indxpath.c:2392">match_opclause_to_indexcol</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Handles the OpExpr case for <a href="#L2203" title="optimizer/path/indxpath.c:2203">match_clause_to_indexcol</a>(),<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; which see for comments.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> IndexClause *<br/></li>
<li><a id="L2392">&#x200c;</a><span class="linkable">match_opclause_to_indexcol</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RestrictInfo *rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexOptInfo *index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexClause *iclause;<br/></li>
<li>&nbsp; &nbsp; OpExpr&nbsp; &nbsp; &nbsp;&nbsp; *clause = (OpExpr *) rinfo-&gt;clause;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *leftop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *rightop;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr_op;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr_coll;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; index_relid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfamily;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idxcollation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Only binary operators need apply.&nbsp; (In theory, a <a href="../plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> support<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function could do something with a unary operator, but it seems<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unlikely to be worth the cycles to check.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(clause-&gt;args) != <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; leftop = (Node *) linitial(clause-&gt;args);<br/></li>
<li>&nbsp; &nbsp; rightop = (Node *) lsecond(clause-&gt;args);<br/></li>
<li>&nbsp; &nbsp; expr_op = clause-&gt;opno;<br/></li>
<li>&nbsp; &nbsp; expr_coll = clause-&gt;inputcollid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; index_relid = index-&gt;rel-&gt;relid;<br/></li>
<li>&nbsp; &nbsp; opfamily = index-&gt;opfamily[indexcol];<br/></li>
<li>&nbsp; &nbsp; idxcollation = index-&gt;indexcollations[indexcol];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for clauses of the form: (indexkey operator constant) or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (constant operator indexkey).&nbsp; See <a href="#L2203" title="optimizer/path/indxpath.c:2203">match_clause_to_indexcol</a>'s notes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * about const-ness.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we don't ask the support function about clauses that don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have one of these forms.&nbsp; Again, in principle it might be possible to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do something, but it seems unlikely to be worth the cycles to check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3704" title="optimizer/path/indxpath.c:3704">match_index_to_operand</a>(leftop, indexcol, index) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(index_relid, rinfo-&gt;right_relids) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>(rightop))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L40" title="optimizer/path/indxpath.c:40">IndexCollMatchesExprColl</a>(idxcollation, expr_coll) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/lsyscache.c.html#L66" title="utils/cache/lsyscache.c:66">op_in_opfamily</a>(expr_op, opfamily))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause = makeNode(IndexClause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;rinfo = rinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;indexquals = list_make1(rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;lossy = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;indexcol = indexcol;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;indexcols = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> iclause;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a member of the index's opfamily, try the support<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function for the operator's underlying function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L1868" title="nodes/nodeFuncs.c:1868">set_opfuncid</a>(clause);&nbsp; &nbsp; <span class="Comment">/* make sure we have opfuncid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2557" title="optimizer/path/indxpath.c:2557">get_index_clause_from_support</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; clause-&gt;opfuncid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>, <span class="Comment">/* indexarg on left */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3704" title="optimizer/path/indxpath.c:3704">match_index_to_operand</a>(rightop, indexcol, index) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(index_relid, rinfo-&gt;left_relids) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>(leftop))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L40" title="optimizer/path/indxpath.c:40">IndexCollMatchesExprColl</a>(idxcollation, expr_coll))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; comm_op = <a href="../../utils/cache/lsyscache.c.html#L1509" title="utils/cache/lsyscache.c:1509">get_commutator</a>(expr_op);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(comm_op) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/lsyscache.c.html#L66" title="utils/cache/lsyscache.c:66">op_in_opfamily</a>(comm_op, opfamily))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *commrinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Build a commuted OpExpr and RestrictInfo */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commrinfo = <a href="../util/restrictinfo.c.html#L359" title="optimizer/util/restrictinfo.c:359">commute_restrictinfo</a>(rinfo, comm_op);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make an IndexClause showing that as a derived qual */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause = makeNode(IndexClause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;rinfo = rinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;indexquals = list_make1(commrinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;lossy = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;indexcol = indexcol;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;indexcols = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> iclause;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a member of the index's opfamily, try the support<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function for the operator's underlying function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L1868" title="nodes/nodeFuncs.c:1868">set_opfuncid</a>(clause);&nbsp; &nbsp; <span class="Comment">/* make sure we have opfuncid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2557" title="optimizer/path/indxpath.c:2557">get_index_clause_from_support</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; clause-&gt;opfuncid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1</span>, <span class="Comment">/* indexarg on right */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2511" title="optimizer/path/indxpath.c:2511">match_funcclause_to_indexcol</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Handles the FuncExpr case for <a href="#L2203" title="optimizer/path/indxpath.c:2203">match_clause_to_indexcol</a>(),<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; which see for comments.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> IndexClause *<br/></li>
<li><a id="L2511">&#x200c;</a><span class="linkable">match_funcclause_to_indexcol</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RestrictInfo *rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexOptInfo *index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FuncExpr&nbsp;&nbsp; *clause = (FuncExpr *) rinfo-&gt;clause;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexarg;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have no built-in intelligence about function clauses, but if there's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a <a href="../plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> support function, it might be able to do something.&nbsp; But, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cut down on wasted planning cycles, only call the support function if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * at least one argument matches the target index column.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we don't insist on the other arguments being pseudoconstants;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the support function has to check that.&nbsp; This is to allow cases where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only some of the other arguments need to be included in the indexqual.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indexarg = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, clause-&gt;args)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *op = (Node *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3704" title="optimizer/path/indxpath.c:3704">match_index_to_operand</a>(op, indexcol, index))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2557" title="optimizer/path/indxpath.c:2557">get_index_clause_from_support</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; clause-&gt;funcid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexarg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexarg++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2557" title="optimizer/path/indxpath.c:2557">get_index_clause_from_support</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If the function has a <a href="../plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> support function, try to construct<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; an IndexClause using indexquals created by the support function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> IndexClause *<br/></li>
<li><a id="L2557">&#x200c;</a><span class="linkable">get_index_clause_from_support</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid funcid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> indexarg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexOptInfo *index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prosupport = <a href="../../utils/cache/lsyscache.c.html#L1858" title="utils/cache/lsyscache.c:1858">get_func_support</a>(funcid);<br/></li>
<li>&nbsp; &nbsp; SupportRequestIndexCondition req;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(prosupport))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; req.type = T_SupportRequestIndexCondition;<br/></li>
<li>&nbsp; &nbsp; req.root = root;<br/></li>
<li>&nbsp; &nbsp; req.funcid = funcid;<br/></li>
<li>&nbsp; &nbsp; req.node = (Node *) rinfo-&gt;clause;<br/></li>
<li>&nbsp; &nbsp; req.indexarg = indexarg;<br/></li>
<li>&nbsp; &nbsp; req.index = index;<br/></li>
<li>&nbsp; &nbsp; req.indexcol = indexcol;<br/></li>
<li>&nbsp; &nbsp; req.opfamily = index-&gt;opfamily[indexcol];<br/></li>
<li>&nbsp; &nbsp; req.indexcollation = index-&gt;indexcollations[indexcol];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; req.lossy = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* default assumption */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; sresult = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DatumGetPointer(OidFunctionCall1(prosupport,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(&amp;req)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sresult != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexClause *iclause = makeNode(IndexClause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexquals = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The support function API says it should just give back bare<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clauses, so here we must wrap each one in a RestrictInfo.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, sresult)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *clause = (Expr *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexquals = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(indexquals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; make_simple_restrictinfo(root, clause));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;rinfo = rinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;indexquals = indexquals;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;lossy = req.lossy;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;indexcol = indexcol;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;indexcols = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> iclause;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2623" title="optimizer/path/indxpath.c:2623">match_saopclause_to_indexcol</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Handles the ScalarArrayOpExpr case for <a href="#L2203" title="optimizer/path/indxpath.c:2203">match_clause_to_indexcol</a>(),<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; which see for comments.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> IndexClause *<br/></li>
<li><a id="L2623">&#x200c;</a><span class="linkable">match_saopclause_to_indexcol</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RestrictInfo *rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexOptInfo *index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) rinfo-&gt;clause;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *leftop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *rightop;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; right_relids;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr_op;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr_coll;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; index_relid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfamily;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idxcollation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We only <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> ANY clauses, not ALL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!saop-&gt;useOr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; leftop = (Node *) linitial(saop-&gt;args);<br/></li>
<li>&nbsp; &nbsp; rightop = (Node *) lsecond(saop-&gt;args);<br/></li>
<li>&nbsp; &nbsp; right_relids = <a href="../util/var.c.html#L108" title="optimizer/util/var.c:108">pull_varnos</a>(root, rightop);<br/></li>
<li>&nbsp; &nbsp; expr_op = saop-&gt;opno;<br/></li>
<li>&nbsp; &nbsp; expr_coll = saop-&gt;inputcollid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; index_relid = index-&gt;rel-&gt;relid;<br/></li>
<li>&nbsp; &nbsp; opfamily = index-&gt;opfamily[indexcol];<br/></li>
<li>&nbsp; &nbsp; idxcollation = index-&gt;indexcollations[indexcol];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must have indexkey on the left and a pseudo-constant array argument.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3704" title="optimizer/path/indxpath.c:3704">match_index_to_operand</a>(leftop, indexcol, index) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(index_relid, right_relids) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>(rightop))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L40" title="optimizer/path/indxpath.c:40">IndexCollMatchesExprColl</a>(idxcollation, expr_coll) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/lsyscache.c.html#L66" title="utils/cache/lsyscache.c:66">op_in_opfamily</a>(expr_op, opfamily))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexClause *iclause = makeNode(IndexClause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;rinfo = rinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;indexquals = list_make1(rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;lossy = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;indexcol = indexcol;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;indexcols = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> iclause;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We do not currently ask support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> about ScalarArrayOpExprs,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * though in principle we could.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2691" title="optimizer/path/indxpath.c:2691">match_rowcompare_to_indexcol</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Handles the RowCompareExpr case for <a href="#L2203" title="optimizer/path/indxpath.c:2203">match_clause_to_indexcol</a>(),<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; which see for comments.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In this routine we check whether the first column of the row comparison<br/></li>
<li></span><span class="Comment"> * matches the target index column.&nbsp; This is sufficient to guarantee that some<br/></li>
<li></span><span class="Comment"> * index condition can be constructed from the RowCompareExpr --- the rest<br/></li>
<li></span><span class="Comment"> * is handled by <a href="#L2798" title="optimizer/path/indxpath.c:2798">expand_indexqual_rowcompare</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> IndexClause *<br/></li>
<li><a id="L2691">&#x200c;</a><span class="linkable">match_rowcompare_to_indexcol</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RestrictInfo *rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexOptInfo *index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RowCompareExpr *clause = (RowCompareExpr *) rinfo-&gt;clause;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; index_relid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfamily;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idxcollation;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *leftop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *rightop;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; var_on_left;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr_op;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr_coll;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Forget it if we're not dealing with a btree index */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;relam != BTREE_AM_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; index_relid = index-&gt;rel-&gt;relid;<br/></li>
<li>&nbsp; &nbsp; opfamily = index-&gt;opfamily[indexcol];<br/></li>
<li>&nbsp; &nbsp; idxcollation = index-&gt;indexcollations[indexcol];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We could do the matching on the basis of insisting that the opfamily<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shown in the RowCompareExpr be the same as the index column's opfamily,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but that could fail in the presence of reverse-sort opfamilies: it'd be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a matter of chance whether RowCompareExpr had picked the forward or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reverse-sort family.&nbsp; So look only at the operator, and match if it is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a member of the index's opfamily (after commutation, if the indexkey is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on the right).&nbsp; We'll worry later about whether <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> additional<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operators are matchable to the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; leftop = (Node *) linitial(clause-&gt;largs);<br/></li>
<li>&nbsp; &nbsp; rightop = (Node *) linitial(clause-&gt;rargs);<br/></li>
<li>&nbsp; &nbsp; expr_op = linitial_oid(clause-&gt;opnos);<br/></li>
<li>&nbsp; &nbsp; expr_coll = linitial_oid(clause-&gt;inputcollids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Collations must match, if relevant */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L40" title="optimizer/path/indxpath.c:40">IndexCollMatchesExprColl</a>(idxcollation, expr_coll))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * These syntactic tests are the same as in <a href="#L2392" title="optimizer/path/indxpath.c:2392">match_opclause_to_indexcol</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3704" title="optimizer/path/indxpath.c:3704">match_index_to_operand</a>(leftop, indexcol, index) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(index_relid, <a href="../util/var.c.html#L108" title="optimizer/util/var.c:108">pull_varnos</a>(root, rightop)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>(rightop))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, indexkey is on left */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; var_on_left = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L3704" title="optimizer/path/indxpath.c:3704">match_index_to_operand</a>(rightop, indexcol, index) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(index_relid, <a href="../util/var.c.html#L108" title="optimizer/util/var.c:108">pull_varnos</a>(root, leftop)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="../util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>(leftop))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* indexkey is on right, so commute the operator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; expr_op = <a href="../../utils/cache/lsyscache.c.html#L1509" title="utils/cache/lsyscache.c:1509">get_commutator</a>(expr_op);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (expr_op == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var_on_left = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We're good if the operator is the right type of opfamily member */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="../../utils/cache/lsyscache.c.html#L83" title="utils/cache/lsyscache.c:83">get_op_opfamily_strategy</a>(expr_op, opfamily))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTLessStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTLessEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTGreaterEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTGreaterStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2798" title="optimizer/path/indxpath.c:2798">expand_indexqual_rowcompare</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; expr_op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var_on_left);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2798" title="optimizer/path/indxpath.c:2798">expand_indexqual_rowcompare</a> --- expand a single indexqual condition<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; that is a RowCompareExpr<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It's already known that the first column of the row comparison matches<br/></li>
<li></span><span class="Comment"> * the specified column of the index.&nbsp; We can use additional columns of the<br/></li>
<li></span><span class="Comment"> * row comparison as index qualifications, so long as they match the index<br/></li>
<li></span><span class="Comment"> * in the &quot;same direction&quot;, ie, the indexkeys are all on the same side of the<br/></li>
<li></span><span class="Comment"> * clause and the operators are all the same-type members of the opfamilies.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If all the columns of the RowCompareExpr match in this way, we just use it<br/></li>
<li></span><span class="Comment"> * as-is, except for possibly commuting it to put the indexkeys on the left.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Otherwise, we build a shortened RowCompareExpr (if more than one<br/></li>
<li></span><span class="Comment"> * column matches) or a simple OpExpr (if the first-column match is all<br/></li>
<li></span><span class="Comment"> * there is).&nbsp; In these cases the modified clause is always &quot;&lt;=&quot; or &quot;&gt;=&quot;<br/></li>
<li></span><span class="Comment"> * even when the original was &quot;&lt;&quot; or &quot;&gt;&quot; --- this is necessary to match all<br/></li>
<li></span><span class="Comment"> * the rows that could match the original.&nbsp; (We are building a lossy version<br/></li>
<li></span><span class="Comment"> * of the row comparison when we do this, so we set lossy = true.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this is really just the last half of <a href="#L2691" title="optimizer/path/indxpath.c:2691">match_rowcompare_to_indexcol</a>,<br/></li>
<li></span><span class="Comment"> * but we split it out for comprehensibility.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> IndexClause *<br/></li>
<li><a id="L2798">&#x200c;</a><span class="linkable">expand_indexqual_rowcompare</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexOptInfo *index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid expr_op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> var_on_left)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexClause *iclause = makeNode(IndexClause);<br/></li>
<li>&nbsp; &nbsp; RowCompareExpr *clause = (RowCompareExpr *) rinfo-&gt;clause;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_strategy;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_lefttype;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_righttype;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matching_cols;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *expr_ops;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *opfamilies;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *lefttypes;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *righttypes;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *new_ops;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *var_args;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *non_var_args;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; iclause-&gt;rinfo = rinfo;<br/></li>
<li>&nbsp; &nbsp; iclause-&gt;indexcol = indexcol;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (var_on_left)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var_args = clause-&gt;largs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; non_var_args = clause-&gt;rargs;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var_args = clause-&gt;rargs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; non_var_args = clause-&gt;largs;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/cache/lsyscache.c.html#L136" title="utils/cache/lsyscache.c:136">get_op_opfamily_properties</a>(expr_op, index-&gt;opfamily[indexcol], <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;op_strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;op_lefttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;op_righttype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize returned list of which index columns are used */<br/></li>
<li></span>&nbsp; &nbsp; iclause-&gt;indexcols = list_make1_int(indexcol);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build lists of ops, opfamilies and operator datatypes in case needed */<br/></li>
<li></span>&nbsp; &nbsp; expr_ops = list_make1_oid(expr_op);<br/></li>
<li>&nbsp; &nbsp; opfamilies = list_make1_oid(index-&gt;opfamily[indexcol]);<br/></li>
<li>&nbsp; &nbsp; lefttypes = list_make1_oid(op_lefttype);<br/></li>
<li>&nbsp; &nbsp; righttypes = list_make1_oid(op_righttype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See how many of the remaining columns match some index column in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same way.&nbsp; As in <a href="#L2203" title="optimizer/path/indxpath.c:2203">match_clause_to_indexcol</a>(), the &quot;other&quot; side of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * potential index condition is OK as long as it doesn't use Vars from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indexed relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; matching_cols = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (matching_cols &lt; list_length(var_args))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *varop = (Node *) list_nth(var_args, matching_cols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *constop = (Node *) list_nth(non_var_args, matching_cols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; expr_op = list_nth_oid(clause-&gt;opnos, matching_cols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!var_on_left)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* indexkey is on right, so commute the operator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr_op = <a href="../../utils/cache/lsyscache.c.html#L1509" title="utils/cache/lsyscache.c:1509">get_commutator</a>(expr_op);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (expr_op == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* operator is not usable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(index-&gt;rel-&gt;relid, <a href="../util/var.c.html#L108" title="optimizer/util/var.c:108">pull_varnos</a>(root, constop)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no good, Var on wrong side */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>(constop))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no good, volatile comparison value */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The Var side can match <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> key column of the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; index-&gt;nkeycolumns; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3704" title="optimizer/path/indxpath.c:3704">match_index_to_operand</a>(varop, i, index) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/lsyscache.c.html#L83" title="utils/cache/lsyscache.c:83">get_op_opfamily_strategy</a>(expr_op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index-&gt;opfamily[i]) == op_strategy &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L40" title="optimizer/path/indxpath.c:40">IndexCollMatchesExprColl</a>(index-&gt;indexcollations[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_nth_oid(clause-&gt;inputcollids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matching_cols)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt;= index-&gt;nkeycolumns)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no match found */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add column number to returned list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;indexcols = <a href="../../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(iclause-&gt;indexcols, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add operator info to lists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/lsyscache.c.html#L136" title="utils/cache/lsyscache.c:136">get_op_opfamily_properties</a>(expr_op, index-&gt;opfamily[i], <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;op_strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;op_lefttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;op_righttype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; expr_ops = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(expr_ops, expr_op);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opfamilies = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(opfamilies, index-&gt;opfamily[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lefttypes = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(lefttypes, op_lefttype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; righttypes = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(righttypes, op_righttype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This column matches, keep scanning */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; matching_cols++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Result is non-lossy if all columns are usable as index quals */<br/></li>
<li></span>&nbsp; &nbsp; iclause-&gt;lossy = (matching_cols != list_length(clause-&gt;opnos));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can use rinfo-&gt;clause as-is if we have var on left and it's all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * usable as index quals.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var_on_left &amp;&amp; !iclause-&gt;lossy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;indexquals = list_make1(rinfo);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have to generate a modified rowcompare (possibly just one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OpExpr).&nbsp; The painful part of this is changing &lt; to &lt;= or &gt; to &gt;=,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so deal with that first.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!iclause-&gt;lossy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* very easy, just use the commuted operators */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_ops = expr_ops;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (op_strategy == BTLessEqualStrategyNumber ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op_strategy == BTGreaterEqualStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* easy, just use the same (possibly commuted) operators */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_ops = <a href="../../nodes/list.c.html#L631" title="nodes/list.c:631">list_truncate</a>(expr_ops, matching_cols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *opfamilies_cell;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lefttypes_cell;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *righttypes_cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op_strategy == BTLessStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_strategy = BTLessEqualStrategyNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (op_strategy == BTGreaterStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_strategy = BTGreaterEqualStrategyNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected strategy number </span><span class="Special">%d</span><span class="Constant">&quot;</span>, op_strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_ops = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; forthree(opfamilies_cell, opfamilies,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lefttypes_cell, lefttypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; righttypes_cell, righttypes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfam = lfirst_oid(opfamilies_cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lefttype = lfirst_oid(lefttypes_cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; righttype = lfirst_oid(righttypes_cell);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr_op = <a href="../../utils/cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfam, lefttype, righttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(expr_op))&nbsp; &nbsp; <span class="Comment">/* should not happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing operator </span><span class="Special">%d</span><span class="Constant">(</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) in opfamily </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op_strategy, lefttype, righttype, opfam);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_ops = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(new_ops, expr_op);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we have more than one matching col, create a <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> rowcompare */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (matching_cols &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RowCompareExpr *rc = makeNode(RowCompareExpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc-&gt;rctype = (RowCompareType) op_strategy;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc-&gt;opnos = new_ops;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc-&gt;opfamilies = <a href="../../nodes/list.c.html#L1593" title="nodes/list.c:1593">list_copy_head</a>(clause-&gt;opfamilies,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matching_cols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc-&gt;inputcollids = <a href="../../nodes/list.c.html#L1593" title="nodes/list.c:1593">list_copy_head</a>(clause-&gt;inputcollids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matching_cols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc-&gt;largs = <a href="../../nodes/list.c.html#L1593" title="nodes/list.c:1593">list_copy_head</a>(var_args, matching_cols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc-&gt;rargs = <a href="../../nodes/list.c.html#L1593" title="nodes/list.c:1593">list_copy_head</a>(non_var_args, matching_cols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;indexquals = list_make1(make_simple_restrictinfo(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Expr *) rc));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *op;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't report an index column list in this case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;indexcols = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op = <a href="../../nodes/makefuncs.c.html#L628" title="nodes/makefuncs.c:628">make_opclause</a>(linitial_oid(new_ops), BOOLOID, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copyObject(linitial(var_args)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copyObject(linitial(non_var_args)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; linitial_oid(clause-&gt;inputcollids));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iclause-&gt;indexquals = list_make1(make_simple_restrictinfo(root, op));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> iclause;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ----&nbsp; ROUTINES TO CHECK ORDERING OPERATORS&nbsp; &nbsp; ----<br/></li>
<li></span><span class="Comment"> ****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3020" title="optimizer/path/indxpath.c:3020">match_pathkeys_to_index</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; For the given 'index' and 'pathkeys', output a list of suitable ORDER<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; BY expressions, each of the form &quot;indexedcol operator pseudoconstant&quot;,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; along with an integer list of the index column numbers (zero based)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; that each clause would be used with.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This attempts to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an ORDER BY and index column number for all items in<br/></li>
<li></span><span class="Comment"> * the pathkey list, however, if we're unable to match <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> given pathkey to an<br/></li>
<li></span><span class="Comment"> * index column, we return just the ones matched by the function so far.&nbsp; This<br/></li>
<li></span><span class="Comment"> * allows callers who are interested in partial matches to get them.&nbsp; Callers<br/></li>
<li></span><span class="Comment"> * can determine a partial match vs a full match by checking the outputted<br/></li>
<li></span><span class="Comment"> * list lengths.&nbsp; A full match will have one item in the output lists for each<br/></li>
<li></span><span class="Comment"> * item in the given 'pathkeys' list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3020">&#x200c;</a></span><span class="linkable">match_pathkeys_to_index</span>(IndexOptInfo *index, List *pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **orderby_clauses_p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **clause_columns_p)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *orderby_clauses_p = NIL;&nbsp; &nbsp; <span class="Comment">/* set default results */<br/></li>
<li></span>&nbsp; &nbsp; *clause_columns_p = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Only indexes with the amcanorderbyop property are interesting here */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!index-&gt;amcanorderbyop)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc1, pathkeys)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *pathkey = (PathKey *) lfirst(lc1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Pathkey must request default sort order for the target opfamily */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pathkey-&gt;pk_strategy != BTLessStrategyNumber ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkey-&gt;pk_nulls_first)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If <a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a> is volatile, no hope of using an indexscan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pathkey-&gt;pk_eclass-&gt;ec_has_volatile)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to match <a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a> member expression(s) to index.&nbsp; Note that child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * EC members are considered, but only when they belong to the target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation.&nbsp; (Unlike regular members, the same expression could be a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * child member of more than one EC.&nbsp; Therefore, the same index could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be considered to match more than one pathkey list, which is OK<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here.&nbsp; See also <a href="equivclass.c.html#L587" title="optimizer/path/equivclass.c:587">get_eclass_for_sort_expr</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, pathkey-&gt;pk_eclass-&gt;ec_members)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EquivalenceMember *member = (EquivalenceMember *) lfirst(lc2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexcol;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No possibility of match if it references other relations */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(member-&gt;em_relids, index-&gt;rel-&gt;relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We allow <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> column of the index to match each pathkey; they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't have to match left-to-right as you might expect.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * correct for GiST, and it doesn't matter for SP-GiST because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that doesn't handle multiple columns anyway, and no other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * existing AMs support amcanorderbyop.&nbsp; We might need different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * logic in future for other implementations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (indexcol = <span class="Constant">0</span>; indexcol &lt; index-&gt;nkeycolumns; indexcol++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr = <a href="#L3130" title="optimizer/path/indxpath.c:3130">match_clause_to_ordering_op</a>(index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; member-&gt;em_expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pathkey-&gt;pk_opfamily);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (expr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *orderby_clauses_p = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(*orderby_clauses_p, expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *clause_columns_p = <a href="../../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(*clause_columns_p, indexcol);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't want to look at remaining members */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Return the matches found so far when this pathkey couldn't be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matched to the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3130" title="optimizer/path/indxpath.c:3130">match_clause_to_ordering_op</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Determines whether an ordering operator expression matches an<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; index column.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; This is similar to, but simpler than, <a href="#L2203" title="optimizer/path/indxpath.c:2203">match_clause_to_indexcol</a>.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; We only care about simple OpExpr cases.&nbsp; The input is a bare<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; expression that is being ordered by, which must be of the form<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; (indexkey op const) or (const op indexkey) where op is an ordering<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; operator for the column's opfamily.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'index' is the index of interest.<br/></li>
<li></span><span class="Comment"> * 'indexcol' is a column number of 'index' (counting from 0).<br/></li>
<li></span><span class="Comment"> * 'clause' is the ordering expression to be tested.<br/></li>
<li></span><span class="Comment"> * 'pk_opfamily' is the btree opfamily describing the required sort order.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we currently do not consider the collation of the ordering<br/></li>
<li></span><span class="Comment"> * operator's result.&nbsp; In practical cases the result type will be <a href="../../utils/adt/numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a><br/></li>
<li></span><span class="Comment"> * and thus have no collation, and it's not very clear what to match to<br/></li>
<li></span><span class="Comment"> * if it did have a collation.&nbsp; The index's collation should match the<br/></li>
<li></span><span class="Comment"> * ordering operator's input collation, not its result.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If successful, return 'clause' as-is if the indexkey is on the left,<br/></li>
<li></span><span class="Comment"> * otherwise a commuted copy of 'clause'.&nbsp; If no match, return NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Expr *<br/></li>
<li><a id="L3130">&#x200c;</a><span class="linkable">match_clause_to_ordering_op</span>(IndexOptInfo *index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Expr *clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid pk_opfamily)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfamily;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idxcollation;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *leftop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *rightop;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr_op;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr_coll;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortfamily;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; commuted;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(indexcol &lt; index-&gt;nkeycolumns);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opfamily = index-&gt;opfamily[indexcol];<br/></li>
<li>&nbsp; &nbsp; idxcollation = index-&gt;indexcollations[indexcol];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clause must be a binary opclause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!is_opclause(clause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; leftop = get_leftop(clause);<br/></li>
<li>&nbsp; &nbsp; rightop = get_rightop(clause);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!leftop || !rightop)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; expr_op = ((OpExpr *) clause)-&gt;opno;<br/></li>
<li>&nbsp; &nbsp; expr_coll = ((OpExpr *) clause)-&gt;inputcollid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can forget the whole thing right away if wrong collation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L40" title="optimizer/path/indxpath.c:40">IndexCollMatchesExprColl</a>(idxcollation, expr_coll))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for clauses of the form: (indexkey operator constant) or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (constant operator indexkey).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3704" title="optimizer/path/indxpath.c:3704">match_index_to_operand</a>(leftop, indexcol, index) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../util/var.c.html#L403" title="optimizer/util/var.c:403">contain_var_clause</a>(rightop) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>(rightop))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; commuted = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L3704" title="optimizer/path/indxpath.c:3704">match_index_to_operand</a>(rightop, indexcol, index) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="../util/var.c.html#L403" title="optimizer/util/var.c:403">contain_var_clause</a>(leftop) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="../util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>(leftop))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Might match, but we need a commuted operator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; expr_op = <a href="../../utils/cache/lsyscache.c.html#L1509" title="utils/cache/lsyscache.c:1509">get_commutator</a>(expr_op);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (expr_op == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; commuted = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Is the (commuted) operator an ordering operator for the opfamily? And<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if so, does it yield the right sorting semantics?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sortfamily = <a href="../../utils/cache/lsyscache.c.html#L108" title="utils/cache/lsyscache.c:108">get_op_opfamily_sortfamily</a>(expr_op, opfamily);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sortfamily != pk_opfamily)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We have a match.&nbsp; Return clause or a commuted version thereof. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (commuted)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OpExpr&nbsp; &nbsp; &nbsp;&nbsp; *newclause = makeNode(OpExpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* flat-copy all the fields of clause */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(newclause, clause, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OpExpr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* commute it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newclause-&gt;opno = expr_op;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newclause-&gt;opfuncid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newclause-&gt;args = list_make2(rightop, leftop);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; clause = (Expr *) newclause;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> clause;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ----&nbsp; ROUTINES TO DO PARTIAL INDEX PREDICATE TESTS&nbsp; &nbsp; ----<br/></li>
<li></span><span class="Comment"> ****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3244" title="optimizer/path/indxpath.c:3244">check_index_predicates</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set the predicate-derived IndexOptInfo fields for each index<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; of the specified relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * predOK is set true if the index is partial and its predicate is satisfied<br/></li>
<li></span><span class="Comment"> * for this query, ie the query's WHERE clauses imply the predicate.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * indrestrictinfo is set to the relation's baserestrictinfo list less <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * conditions that are implied by the index's predicate.&nbsp; (Obviously, for a<br/></li>
<li></span><span class="Comment"> * non-partial index, this is the same as baserestrictinfo.)&nbsp; Such conditions<br/></li>
<li></span><span class="Comment"> * can be dropped from the plan when using the index, in certain cases.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At one time it was possible for this to get re-run after adding more<br/></li>
<li></span><span class="Comment"> * restrictions to the rel, thus possibly letting us prove more indexes OK.<br/></li>
<li></span><span class="Comment"> * That doesn't happen <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more (at least not in the core code's usage),<br/></li>
<li></span><span class="Comment"> * but this code still supports it in case extensions want to mess with the<br/></li>
<li></span><span class="Comment"> * baserestrictinfo list.&nbsp; We assume that adding more restrictions can't make<br/></li>
<li></span><span class="Comment"> * an index not predOK.&nbsp; We must recompute indrestrictinfo each time, though,<br/></li>
<li></span><span class="Comment"> * to make sure <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> newly-added restrictions get into it if needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3244">&#x200c;</a></span><span class="linkable">check_index_predicates</span>(PlannerInfo *root, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *clauselist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_partial;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_target_rel;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; otherrels;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Indexes are available only on base or &quot;other&quot; member relations. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(IS_SIMPLE_REL(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize the indrestrictinfo lists to be identical to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * baserestrictinfo, and check whether there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> partial indexes.&nbsp; If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not, this is all we need to do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; have_partial = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, rel-&gt;indexlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexOptInfo *index = (IndexOptInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; index-&gt;indrestrictinfo = rel-&gt;baserestrictinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;indpred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_partial = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!have_partial)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Construct a list of clauses that we can assume true for the purpose of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * proving the index(es) usable.&nbsp; Restriction clauses for the rel are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * always usable, and so are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> join clauses that are &quot;movable to&quot; this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rel.&nbsp; Also, we can consider <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> EC-derivable join clauses (which must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be &quot;movable to&quot; this rel, by definition).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; clauselist = <a href="../../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(rel-&gt;baserestrictinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan the rel's join clauses */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, rel-&gt;joininfo)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check if clause can be moved to this rel */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../util/restrictinfo.c.html#L584" title="optimizer/util/restrictinfo.c:584">join_clause_is_movable_to</a>(rinfo, rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; clauselist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(clauselist, rinfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add on <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> equivalence-derivable join clauses.&nbsp; Computing the correct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relid sets for <a href="equivclass.c.html#L1392" title="optimizer/path/equivclass.c:1392">generate_join_implied_equalities</a> is slightly tricky<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because the rel could be a child rel rather than a true baserel, and in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that case we must subtract its parents' relid(s) from all_query_rels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Additionally, we mustn't consider clauses that are only computable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after outer joins that can null the rel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;reloptkind == RELOPT_OTHER_MEMBER_REL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; otherrels = <a href="../../nodes/bitmapset.c.html#L346" title="nodes/bitmapset.c:346">bms_difference</a>(root-&gt;all_query_rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/relnode.c.html#L1521" title="optimizer/util/relnode.c:1521">find_childrel_parents</a>(root, rel));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; otherrels = <a href="../../nodes/bitmapset.c.html#L346" title="nodes/bitmapset.c:346">bms_difference</a>(root-&gt;all_query_rels, rel-&gt;relids);<br/></li>
<li>&nbsp; &nbsp; otherrels = <a href="../../nodes/bitmapset.c.html#L1161" title="nodes/bitmapset.c:1161">bms_del_members</a>(otherrels, rel-&gt;nulling_relids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!bms_is_empty(otherrels))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; clauselist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(clauselist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="equivclass.c.html#L1392" title="optimizer/path/equivclass.c:1392">generate_join_implied_equalities</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(rel-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; otherrels),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; otherrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Normally we remove quals that are implied by a partial index's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * predicate from indrestrictinfo, indicating that they need not be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checked explicitly by an indexscan plan using this index.&nbsp; However, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the rel is a target relation of UPDATE/DELETE/MERGE/SELECT FOR UPDATE,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we cannot remove such quals from the plan, because they need to be in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the plan so that they will be properly rechecked by <a href="../../executor/execMain.c.html#L2470" title="executor/execMain.c:2470">EvalPlanQual</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * testing.&nbsp; Some day we might want to remove such quals from the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plan anyway and pass them through to <a href="../../executor/execMain.c.html#L2470" title="executor/execMain.c:2470">EvalPlanQual</a> via a side channel;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we just don't remove implied quals at all for target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; is_target_rel = (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(rel-&gt;relid, root-&gt;all_result_relids) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../prep/preptlist.c.html#L509" title="optimizer/prep/preptlist.c:509">get_plan_rowmark</a>(root-&gt;rowMarks, rel-&gt;relid) != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now try to prove each index predicate true, and compute the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indrestrictinfo lists for partial indexes.&nbsp; Note that we compute the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indrestrictinfo list even for non-predOK indexes; this might seem<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wasteful, but we may be able to use such indexes in OR clauses, cf<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1180" title="optimizer/path/indxpath.c:1180">generate_bitmap_or_paths</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, rel-&gt;indexlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexOptInfo *index = (IndexOptInfo *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lcr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;indpred == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore non-partial indexes here */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!index-&gt;predOK)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> work if already proven OK */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;predOK = <a href="../util/predtest.c.html#L152" title="optimizer/util/predtest.c:152">predicate_implied_by</a>(index-&gt;indpred, clauselist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If rel is an update target, leave indrestrictinfo as set above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_target_rel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Else compute indrestrictinfo as the non-implied quals */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; index-&gt;indrestrictinfo = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lcr, rel-&gt;baserestrictinfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(lcr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../util/predtest.c.html#L152" title="optimizer/util/predtest.c:152">predicate_implied_by</a>() assumes first arg is immutable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/clauses.c.html#L370" title="optimizer/util/clauses.c:370">contain_mutable_functions</a>((Node *) rinfo-&gt;clause) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../util/predtest.c.html#L152" title="optimizer/util/predtest.c:152">predicate_implied_by</a>(list_make1(rinfo-&gt;clause),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;indpred, <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;indrestrictinfo = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(index-&gt;indrestrictinfo, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ----&nbsp; ROUTINES TO CHECK EXTERNALLY-VISIBLE CONDITIONS&nbsp; ----<br/></li>
<li></span><span class="Comment"> ****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3382" title="optimizer/path/indxpath.c:3382">ec_member_matches_indexcol</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Test whether an EquivalenceClass member matches an index column.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a callback for use by <a href="equivclass.c.html#L2971" title="optimizer/path/equivclass.c:2971">generate_implied_equalities_for_column</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3382">&#x200c;</a></span><span class="linkable">ec_member_matches_indexcol</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EquivalenceClass *ec, EquivalenceMember *em,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexOptInfo *index = ((<a href="#L74" title="optimizer/path/indxpath.c:74">ec_member_matches_arg</a> *) arg)-&gt;index;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexcol = ((<a href="#L74" title="optimizer/path/indxpath.c:74">ec_member_matches_arg</a> *) arg)-&gt;indexcol;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curFamily;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curCollation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(indexcol &lt; index-&gt;nkeycolumns);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; curFamily = index-&gt;opfamily[indexcol];<br/></li>
<li>&nbsp; &nbsp; curCollation = index-&gt;indexcollations[indexcol];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's a btree index, we can reject it if its opfamily isn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * compatible with the EC, since no clause generated from the EC could be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * used with the index.&nbsp; For non-btree indexes, we can't easily tell<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whether clauses generated from the EC could be used with the index, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't check the opfamily.&nbsp; This might mean we return &quot;true&quot; for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * useless EC, so we have to recheck the results of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="equivclass.c.html#L2971" title="optimizer/path/equivclass.c:2971">generate_implied_equalities_for_column</a>; see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L2013" title="optimizer/path/indxpath.c:2013">match_eclass_clauses_to_index</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;relam == BTREE_AM_OID &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(ec-&gt;ec_opfamilies, curFamily))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We insist on collation match for all index types, though */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L40" title="optimizer/path/indxpath.c:40">IndexCollMatchesExprColl</a>(curCollation, ec-&gt;ec_collation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3704" title="optimizer/path/indxpath.c:3704">match_index_to_operand</a>((Node *) em-&gt;em_expr, indexcol, index);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3440" title="optimizer/path/indxpath.c:3440">relation_has_unique_index_for</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Determine whether the relation provably has at most one row satisfying<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; a set of equality conditions, because the conditions constrain all<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; columns of some unique index.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The conditions can be represented in either or both of two ways:<br/></li>
<li></span><span class="Comment"> * 1. A list of RestrictInfo nodes, where the caller has already determined<br/></li>
<li></span><span class="Comment"> * that each condition is a mergejoinable equality with an expression in<br/></li>
<li></span><span class="Comment"> * this relation on one side, and an expression not involving this relation<br/></li>
<li></span><span class="Comment"> * on the other.&nbsp; The transient outer_is_left flag is used to identify which<br/></li>
<li></span><span class="Comment"> * side we should look at: left side if outer_is_left is false, right side<br/></li>
<li></span><span class="Comment"> * if it is true.<br/></li>
<li></span><span class="Comment"> * 2. A list of expressions in this relation, and a corresponding list of<br/></li>
<li></span><span class="Comment"> * equality operators. The caller must have already checked that the operators<br/></li>
<li></span><span class="Comment"> * represent equality.&nbsp; (Note: the operators could be cross-type; the<br/></li>
<li></span><span class="Comment"> * expressions should correspond to their RHS inputs.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller need only supply equality conditions arising from joins;<br/></li>
<li></span><span class="Comment"> * this routine automatically adds in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> usable baserestrictinfo clauses.<br/></li>
<li></span><span class="Comment"> * (Note that the passed-in restrictlist will be destructively modified!)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3440">&#x200c;</a></span><span class="linkable">relation_has_unique_index_for</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *restrictlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *exprlist, List *oprlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3455" title="optimizer/path/indxpath.c:3455">relation_has_unique_index_ext</a>(root, rel, restrictlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; exprlist, oprlist, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3455" title="optimizer/path/indxpath.c:3455">relation_has_unique_index_ext</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Same as <a href="#L3440" title="optimizer/path/indxpath.c:3440">relation_has_unique_index_for</a>(), but supports extra_clauses<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; parameter.&nbsp; If extra_clauses isn't NULL, return baserestrictinfo clauses<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; which were used to derive uniqueness.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3455">&#x200c;</a></span><span class="linkable">relation_has_unique_index_ext</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *restrictlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *exprlist, List *oprlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **extra_clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *ic;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(list_length(exprlist) == list_length(oprlist));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Short-circuit if no indexes... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;indexlist == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Examine the rel's restriction clauses for usable var = const clauses<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that we can add to the restrictlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(ic, rel-&gt;baserestrictinfo)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *restrictinfo = (RestrictInfo *) lfirst(ic);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: can_join won't be set for a restriction clause, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mergeopfamilies will be if it has a mergejoinable operator and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doesn't contain volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (restrictinfo-&gt;mergeopfamilies == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not mergejoinable */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The clause certainly doesn't refer to anything but the given rel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If either side is pseudoconstant then we can use it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bms_is_empty(restrictinfo-&gt;left_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* righthand side is inner */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restrictinfo-&gt;outer_is_left = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (bms_is_empty(restrictinfo-&gt;right_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* lefthand side is inner */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restrictinfo-&gt;outer_is_left = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, add to list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; restrictlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(restrictlist, restrictinfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Short-circuit the easy case */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (restrictlist == NIL &amp;&amp; exprlist == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Examine each index of the relation ... */<br/></li>
<li></span>&nbsp; &nbsp; foreach(ic, rel-&gt;indexlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexOptInfo *ind = (IndexOptInfo *) lfirst(ic);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *exprs = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the index is not unique, or not immediately enforced, or if it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a partial index, it's useless here.&nbsp; We're unable to make use of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * predOK partial unique indexes due to the fact that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L3244" title="optimizer/path/indxpath.c:3244">check_index_predicates</a>() also makes use of join predicates to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * determine if the partial index is usable. Here we need proofs that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hold true <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> joins are evaluated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ind-&gt;unique || !ind-&gt;immediate || ind-&gt;indpred != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> each index column in the lists of conditions.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * O(N^2) or worse, but we expect all the lists to be short.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (c = <span class="Constant">0</span>; c &lt; ind-&gt;nkeycolumns; c++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; matched = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, restrictlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *rexpr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The condition's equality operator must be a member of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index opfamily, else it is not asserting the right kind of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * equality behavior for this index.&nbsp; We check this first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since it's probably cheaper than <a href="#L3704" title="optimizer/path/indxpath.c:3704">match_index_to_operand</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(rinfo-&gt;mergeopfamilies, ind-&gt;opfamily[c]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> at some point we may need to check collations here too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For the moment we assume all collations reduce to the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * notion of equality.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, see if the condition operand matches the index key */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rinfo-&gt;outer_is_left)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rexpr = get_rightop(rinfo-&gt;clause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rexpr = get_leftop(rinfo-&gt;clause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3704" title="optimizer/path/indxpath.c:3704">match_index_to_operand</a>(rexpr, c, ind))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matched = <span class="Constant">true</span>; <span class="Comment">/* column is unique */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L781" title="nodes/bitmapset.c:781">bms_membership</a>(rinfo-&gt;clause_relids) == BMS_SINGLETON)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldMemCtx =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(root-&gt;planner_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add filter clause into a list allowing caller to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * know if uniqueness have made not only by join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(bms_is_empty(rinfo-&gt;left_relids) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bms_is_empty(rinfo-&gt;right_relids));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (extra_clauses)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exprs = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(exprs, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldMemCtx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (matched)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; forboth(lc, exprlist, lc2, oprlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *expr = (Node *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opr = lfirst_oid(lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See if the expression matches the index key */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3704" title="optimizer/path/indxpath.c:3704">match_index_to_operand</a>(expr, c, ind))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The equality operator must be a member of the index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * opfamily, else it is not asserting the right kind of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * equality behavior for this index.&nbsp; We assume the caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * determined it is an equality operator, so we don't need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more tightly than this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/cache/lsyscache.c.html#L66" title="utils/cache/lsyscache.c:66">op_in_opfamily</a>(opr, ind-&gt;opfamily[c]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> at some point we may need to check collations here too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For the moment we assume all collations reduce to the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * notion of equality.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matched = <span class="Constant">true</span>; <span class="Comment">/* column is unique */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!matched)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no match; this index doesn't <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> us */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Matched all key columns of this index? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (c == ind-&gt;nkeycolumns)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (extra_clauses)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *extra_clauses = exprs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3653" title="optimizer/path/indxpath.c:3653">indexcol_is_bool_constant_for_query</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If an index column is constrained to have a constant value by the query's<br/></li>
<li></span><span class="Comment"> * WHERE conditions, then it's irrelevant for sort-order considerations.<br/></li>
<li></span><span class="Comment"> * Usually that means we have a restriction clause WHERE indexcol = constant,<br/></li>
<li></span><span class="Comment"> * which gets turned into an EquivalenceClass containing a constant, which<br/></li>
<li></span><span class="Comment"> * is recognized as redundant by <a href="pathkeys.c.html#L755" title="optimizer/path/pathkeys.c:755">build_index_pathkeys</a>().&nbsp; But if the index<br/></li>
<li></span><span class="Comment"> * column is a boolean variable (or expression), then we are not going to<br/></li>
<li></span><span class="Comment"> * see WHERE indexcol = constant, because expression preprocessing will have<br/></li>
<li></span><span class="Comment"> * simplified that to &quot;WHERE indexcol&quot; or &quot;WHERE NOT indexcol&quot;.&nbsp; So we are not<br/></li>
<li></span><span class="Comment"> * going to have a matching EquivalenceClass (unless the query also contains<br/></li>
<li></span><span class="Comment"> * &quot;ORDER BY indexcol&quot;).&nbsp; To allow such cases to work the same as they would<br/></li>
<li></span><span class="Comment"> * for non-boolean <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, this function is provided to detect whether the<br/></li>
<li></span><span class="Comment"> * specified index column matches a boolean restriction clause.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3653">&#x200c;</a></span><span class="linkable">indexcol_is_bool_constant_for_query</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexOptInfo *index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> indexcol)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If the index isn't boolean, we can't possibly get a match */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2280" title="optimizer/path/indxpath.c:2280">IsBooleanOpfamily</a>(index-&gt;opfamily[indexcol]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check each restriction clause for the index's rel */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, index-&gt;rel-&gt;baserestrictinfo)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As in <a href="#L2203" title="optimizer/path/indxpath.c:2203">match_clause_to_indexcol</a>, never match pseudoconstants to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indexes.&nbsp; (It might be semantically okay to do so here, but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * odds of getting a match are negligible, so don't waste the cycles.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rinfo-&gt;pseudoconstant)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See if we can match the clause's expression to the index column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2305" title="optimizer/path/indxpath.c:2305">match_boolean_index_clause</a>(root, rinfo, indexcol, index))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ----&nbsp; ROUTINES TO CHECK OPERANDS&nbsp; ----<br/></li>
<li></span><span class="Comment"> ****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3704" title="optimizer/path/indxpath.c:3704">match_index_to_operand</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Generalized test for a match between an index's key<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; and the operand on one side of a restriction or join clause.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * operand: the nodetree to be compared to the index<br/></li>
<li></span><span class="Comment"> * indexcol: the column number of the index (counting from 0)<br/></li>
<li></span><span class="Comment"> * index: the index of interest<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we aren't interested in collations here; the caller must check<br/></li>
<li></span><span class="Comment"> * for a collation match, if it's dealing with an operator where that matters.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is exported for use in selfuncs.c.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3704">&#x200c;</a></span><span class="linkable">match_index_to_operand</span>(Node *operand,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> indexcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexOptInfo *index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indkey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ignore <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> RelabelType node above the operand.&nbsp;&nbsp; This is needed to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * able to apply indexscanning in binary-compatible-operator cases. Note:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we can assume there is at most one RelabelType node;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../util/clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a>() will have simplified if more than one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (operand &amp;&amp; IsA(operand, RelabelType))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; operand = (Node *) ((RelabelType *) operand)-&gt;arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indkey = index-&gt;indexkeys[indexcol];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (indkey != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Simple index column; operand must be a matching Var.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (operand &amp;&amp; IsA(operand, Var) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;rel-&gt;relid == ((Var *) operand)-&gt;varno &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indkey == ((Var *) operand)-&gt;varattno &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((Var *) operand)-&gt;varnullingrels == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Index expression; <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the correct expression.&nbsp; (This search could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be avoided, at the cost of complicating all the callers of this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * routine; doesn't seem worth it.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *indexpr_item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *indexkey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexpr_item = list_head(index-&gt;indexprs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; indexcol; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;indexkeys[i] == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexpr_item == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;wrong number of index expressions&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexpr_item = lnext(index-&gt;indexprs, indexpr_item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexpr_item == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;wrong number of index expressions&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexkey = (Node *) lfirst(indexpr_item);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Does it match the operand?&nbsp; Again, strip <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> relabeling.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexkey &amp;&amp; IsA(indexkey, RelabelType))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexkey = (Node *) ((RelabelType *) indexkey)-&gt;arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(indexkey, operand))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3790" title="optimizer/path/indxpath.c:3790">is_pseudo_constant_for_index</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Test whether the given expression can be used as an indexscan<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; comparison value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * An indexscan comparison value must not contain <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>,<br/></li>
<li></span><span class="Comment"> * and it can't contain <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> Vars of the index's own table.&nbsp; Vars of<br/></li>
<li></span><span class="Comment"> * other tables are okay, though; in that case we'd be producing an<br/></li>
<li></span><span class="Comment"> * indexqual usable in a parameterized indexscan.&nbsp; This is, therefore,<br/></li>
<li></span><span class="Comment"> * a weaker condition than <a href="../util/clauses.c.html#L2088" title="optimizer/util/clauses.c:2088">is_pseudo_constant_clause</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is exported for use by <a href="../plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>,<br/></li>
<li></span><span class="Comment"> * which will have available the IndexOptInfo, but not <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> RestrictInfo<br/></li>
<li></span><span class="Comment"> * infrastructure.&nbsp; It is making the same test made by <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> above<br/></li>
<li></span><span class="Comment"> * such as <a href="#L2392" title="optimizer/path/indxpath.c:2392">match_opclause_to_indexcol</a>(), but those rely where possible<br/></li>
<li></span><span class="Comment"> * on RestrictInfo information about variable membership.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * expr: the nodetree to be checked<br/></li>
<li></span><span class="Comment"> * index: the index of interest<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3790">&#x200c;</a></span><span class="linkable">is_pseudo_constant_for_index</span>(PlannerInfo *root, Node *expr, IndexOptInfo *index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../util/var.c.html#L108" title="optimizer/util/var.c:108">pull_varnos</a> is cheaper than volatility check, so do that first */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(index-&gt;rel-&gt;relid, <a href="../util/var.c.html#L108" title="optimizer/util/var.c:108">pull_varnos</a>(root, expr)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no good, contains Var of table */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>(expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no good, volatile comparison value */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
