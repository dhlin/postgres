<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>optimizer/path/pathkeys.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>optimizer/path/pathkeys.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L31">enable_group_by_reordering</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L106">append_pathkeys</a></li>
<li><a href="#L1015">build_expression_pathkey</a></li>
<li><a href="#L755">build_index_pathkeys</a></li>
<li><a href="#L1309">build_join_pathkeys</a></li>
<li><a href="#L934">build_partition_pathkeys</a></li>
<li><a href="#L302">compare_pathkeys</a></li>
<li><a href="#L1069">convert_subquery_pathkeys</a></li>
<li><a href="#L1527">find_mergeclauses_for_outer_pathkeys</a></li>
<li><a href="#L1266">find_var_for_subquery_tle</a></li>
<li><a href="#L681">get_cheapest_fractional_path_for_pathkeys</a></li>
<li><a href="#L714">get_cheapest_parallel_safe_total_inner</a></li>
<li><a href="#L635">get_cheapest_path_for_pathkeys</a></li>
<li><a href="#L485">get_useful_group_keys_orderings</a></li>
<li><a href="#L368">group_keys_reorder_by_pathkeys</a></li>
<li><a href="#L2261">has_useful_pathkeys</a></li>
<li><a href="#L1446">initialize_mergeclause_eclasses</a></li>
<li><a href="#L55">make_canonical_pathkey</a></li>
<li><a href="#L1838">make_inner_pathkeys_for_merge</a></li>
<li><a href="#L197">make_pathkey_from_sortinfo</a></li>
<li><a href="#L255">make_pathkey_from_sortop</a></li>
<li><a href="#L1347">make_pathkeys_for_sortclauses</a></li>
<li><a href="#L1384">make_pathkeys_for_sortclauses_extended</a></li>
<li><a href="#L899">matches_boolean_partition_clause</a></li>
<li><a href="#L859">partkey_is_bool_constant_for_query</a></li>
<li><a href="#L158">pathkey_is_redundant</a></li>
<li><a href="#L456">pathkeys_are_duplicate</a></li>
<li><a href="#L341">pathkeys_contained_in</a></li>
<li><a href="#L573">pathkeys_count_contained_in</a></li>
<li><a href="#L2170">pathkeys_useful_for_grouping</a></li>
<li><a href="#L2036">pathkeys_useful_for_merging</a></li>
<li><a href="#L2140">pathkeys_useful_for_ordering</a></li>
<li><a href="#L2200">pathkeys_useful_for_setop</a></li>
<li><a href="#L2103">right_merge_direction</a></li>
<li><a href="#L1642">select_outer_pathkeys_for_merge</a></li>
<li><a href="#L1941">trim_mergeclauses_for_inner_pathkeys</a></li>
<li><a href="#L2215">truncate_useless_pathkeys</a></li>
<li><a href="#L1493">update_mergeclause_eclasses</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * pathkeys.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Utilities for matching and building path keys<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See src/backend/optimizer/README for a great deal of information about<br/></li>
<li></span><span class="Comment"> * the nature and use of path keys.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/optimizer/path/pathkeys.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/stratnum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_opfamily.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/cost.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/pathnode.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/paths.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;partitioning/partbounds.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Consider reordering of GROUP BY keys? */<br/></li>
<li><a id="L31">&#x200c;</a></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">enable_group_by_reordering</span> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L158" title="optimizer/path/pathkeys.c:158">pathkey_is_redundant</a>(PathKey *new_pathkey, List *pathkeys);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L899" title="optimizer/path/pathkeys.c:899">matches_boolean_partition_clause</a>(RestrictInfo *rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *partrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> partkeycol);<br/></li>
<li><span class="Type">static</span> Var *<a href="#L1266" title="optimizer/path/pathkeys.c:1266">find_var_for_subquery_tle</a>(RelOptInfo *rel, TargetEntry *tle);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2103" title="optimizer/path/pathkeys.c:2103">right_merge_direction</a>(PlannerInfo *root, PathKey *pathkey);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; PATHKEY CONSTRUCTION AND REDUNDANCY TESTING<br/></li>
<li></span><span class="Comment"> ****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L55" title="optimizer/path/pathkeys.c:55">make_canonical_pathkey</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Given the parameters for a PathKey, <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pre-existing matching<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; pathkey in the query's list of &quot;canonical&quot; pathkeys.&nbsp; Make a new<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; entry if there's not one already.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this function must not be used until after we have completed<br/></li>
<li></span><span class="Comment"> * merging EquivalenceClasses.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PathKey *<br/></li>
<li><a id="L55">&#x200c;</a><span class="linkable">make_canonical_pathkey</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EquivalenceClass *<a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a>, Oid opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> strategy, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nulls_first)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PathKey&nbsp; &nbsp; *pk;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't make canonical pathkeys if the set of ECs might still change */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!root-&gt;ec_merging_done)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;too soon to build canonical pathkeys&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The passed <a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a> might be non-canonical, so chase up to the top */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a>-&gt;ec_merged)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a> = <a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a>-&gt;ec_merged;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, root-&gt;canon_pathkeys)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pk = (PathKey *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a> == pk-&gt;pk_eclass &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfamily == pk-&gt;pk_opfamily &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strategy == pk-&gt;pk_strategy &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls_first == pk-&gt;pk_nulls_first)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> pk;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Be sure canonical pathkeys are allocated in the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> planning context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Not an issue in normal planning, but it is for GEQO.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(root-&gt;planner_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pk = makeNode(PathKey);<br/></li>
<li>&nbsp; &nbsp; pk-&gt;pk_eclass = <a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a>;<br/></li>
<li>&nbsp; &nbsp; pk-&gt;pk_opfamily = opfamily;<br/></li>
<li>&nbsp; &nbsp; pk-&gt;pk_strategy = strategy;<br/></li>
<li>&nbsp; &nbsp; pk-&gt;pk_nulls_first = nulls_first;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; root-&gt;canon_pathkeys = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;canon_pathkeys, pk);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pk;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L106" title="optimizer/path/pathkeys.c:106">append_pathkeys</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Append all non-redundant PathKeys in 'source' onto 'target' and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; returns the updated 'target' list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L106">&#x200c;</a><span class="linkable">append_pathkeys</span>(List *target, List *source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(target != NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, source)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *pk = lfirst_node(PathKey, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L158" title="optimizer/path/pathkeys.c:158">pathkey_is_redundant</a>(pk, target))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(target, pk);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> target;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L158" title="optimizer/path/pathkeys.c:158">pathkey_is_redundant</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; Is a pathkey redundant with one already in the given list?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We detect two cases:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 1. If the new pathkey's equivalence class contains a constant, and isn't<br/></li>
<li></span><span class="Comment"> * below an outer join, then we can disregard it as a sort key.&nbsp; An example:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SELECT ... WHERE x = 42 ORDER BY x, y;<br/></li>
<li></span><span class="Comment"> * We may as well just sort by y.&nbsp; Note that because of opfamily matching,<br/></li>
<li></span><span class="Comment"> * this is semantically correct: we know that the equality constraint is one<br/></li>
<li></span><span class="Comment"> * that actually binds the variable to a single value in the terms of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * ordering operator that might go with the <a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a>.&nbsp; This rule not only lets<br/></li>
<li></span><span class="Comment"> * us simplify (or even <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>) explicit sorts, but also allows matching index<br/></li>
<li></span><span class="Comment"> * sort orders to a query when there are don't-care index columns.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 2. If the new pathkey's equivalence class is the same as that of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * existing member of the pathkey list, then it is redundant.&nbsp; Some examples:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SELECT ... ORDER BY x, x;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SELECT ... ORDER BY x, x DESC;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SELECT ... WHERE x = y ORDER BY x, y;<br/></li>
<li></span><span class="Comment"> * In all these cases the second sort key cannot distinguish <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that are<br/></li>
<li></span><span class="Comment"> * considered <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> by the first, and so there's no point in using it.<br/></li>
<li></span><span class="Comment"> * Note in particular that we need not <a href="../geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> opfamily (all the opfamilies<br/></li>
<li></span><span class="Comment"> * of the EC have the same notion of equality) nor sort direction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Both the given pathkey and the list members must be canonical for this<br/></li>
<li></span><span class="Comment"> * to work properly, but that's okay since we no longer ever construct <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * non-canonical pathkeys.&nbsp; (Note: the notion of a pathkey *list* being<br/></li>
<li></span><span class="Comment"> * canonical includes the additional requirement of no redundant entries,<br/></li>
<li></span><span class="Comment"> * which is exactly what we are checking for here.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Because the equivclass.c machinery forms only one copy of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> EC per query,<br/></li>
<li></span><span class="Comment"> * pointer comparison is enough to decide whether canonical ECs are the same.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L158">&#x200c;</a></span><span class="linkable">pathkey_is_redundant</span>(PathKey *new_pathkey, List *pathkeys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EquivalenceClass *new_ec = new_pathkey-&gt;pk_eclass;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for EC containing a constant --- unconditionally redundant */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (EC_MUST_BE_REDUNDANT(new_ec))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If same EC already used in list, then redundant */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, pathkeys)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *old_pathkey = (PathKey *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (new_ec == old_pathkey-&gt;pk_eclass)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L197" title="optimizer/path/pathkeys.c:197">make_pathkey_from_sortinfo</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Given an expression and sort-order information, create a PathKey.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; The result is always a &quot;canonical&quot; PathKey, but it might be redundant.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the PathKey is being generated from a SortGroupClause, sortref should be<br/></li>
<li></span><span class="Comment"> * the SortGroupClause's SortGroupRef; otherwise zero.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If rel is not NULL, it identifies a specific relation we're considering<br/></li>
<li></span><span class="Comment"> * a path for, and indicates that child EC members for that relation can be<br/></li>
<li></span><span class="Comment"> * considered.&nbsp; Otherwise child members are ignored.&nbsp; (See the comments for<br/></li>
<li></span><span class="Comment"> * <a href="equivclass.c.html#L587" title="optimizer/path/equivclass.c:587">get_eclass_for_sort_expr</a>.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * create_it is true if we should create <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> missing EquivalenceClass<br/></li>
<li></span><span class="Comment"> * needed to represent the sort key.&nbsp; If it's false, we return NULL if the<br/></li>
<li></span><span class="Comment"> * sort key isn't already present in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> EquivalenceClass.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> PathKey *<br/></li>
<li><a id="L197">&#x200c;</a><span class="linkable">make_pathkey_from_sortinfo</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Expr *expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid opcintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> reverse_sort,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nulls_first,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index sortref,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> create_it)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; strategy;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; equality_op;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *opfamilies;<br/></li>
<li>&nbsp; &nbsp; EquivalenceClass *<a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; strategy = reverse_sort ? BTGreaterStrategyNumber : BTLessStrategyNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * EquivalenceClasses need to contain opfamily lists based on the family<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * membership of mergejoinable equality operators, which could belong to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more than one opfamily.&nbsp; So we have to look up the opfamily's equality<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operator and get its membership.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; equality_op = <a href="../../utils/cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(equality_op))&nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing operator </span><span class="Special">%d</span><span class="Constant">(</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) in opfamily </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTEqualStrategyNumber, opcintype, opcintype, opfamily);<br/></li>
<li>&nbsp; &nbsp; opfamilies = <a href="../../utils/cache/lsyscache.c.html#L366" title="utils/cache/lsyscache.c:366">get_mergejoin_opfamilies</a>(equality_op);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!opfamilies)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* certainly should <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> some */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> opfamilies for equality operator </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; equality_op);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> or (optionally) create a matching EquivalenceClass */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a> = <a href="equivclass.c.html#L587" title="optimizer/path/equivclass.c:587">get_eclass_for_sort_expr</a>(root, expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfamilies, opcintype, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortref, rel, create_it);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fail if no EC and !create_it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And finally we can <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> or create a PathKey node */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L55" title="optimizer/path/pathkeys.c:55">make_canonical_pathkey</a>(root, <a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a>, opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strategy, nulls_first);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L255" title="optimizer/path/pathkeys.c:255">make_pathkey_from_sortop</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Like <a href="#L197" title="optimizer/path/pathkeys.c:197">make_pathkey_from_sortinfo</a>, but work from a sort operator.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should eventually go away, but we need to restructure SortGroupClause<br/></li>
<li></span><span class="Comment"> * first.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> PathKey *<br/></li>
<li><a id="L255">&#x200c;</a><span class="linkable">make_pathkey_from_sortop</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Expr *expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid ordering_op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nulls_first,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index sortref,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> create_it)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; strategy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find the operator in pg_amop --- failure shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/cache/lsyscache.c.html#L207" title="utils/cache/lsyscache.c:207">get_ordering_op_properties</a>(ordering_op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;opfamily, &amp;opcintype, &amp;strategy))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;operator </span><span class="Special">%u</span><span class="Constant"> is not a valid ordering operator&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ordering_op);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Because SortGroupClause doesn't carry collation, consult the expr */<br/></li>
<li></span>&nbsp; &nbsp; collation = <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L197" title="optimizer/path/pathkeys.c:197">make_pathkey_from_sortinfo</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (strategy == BTGreaterStrategyNumber),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls_first,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortref,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; create_it);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; PATHKEY COMPARISONS<br/></li>
<li></span><span class="Comment"> ****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L302" title="optimizer/path/pathkeys.c:302">compare_pathkeys</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Compare two pathkeys to see if they are equivalent, and if not whether<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; one is &quot;better&quot; than the other.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; We assume the pathkeys are canonical, and so they can be checked for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; equality by simple pointer comparison.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PathKeysComparison<br/></li>
<li><a id="L302">&#x200c;</a><span class="linkable">compare_pathkeys</span>(List *keys1, List *keys2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *key1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *key2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fall out quickly if we are passed two identical lists.&nbsp; This mostly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catches the case where both are NIL, but that's common enough to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * warrant the test.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (keys1 == keys2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PATHKEYS_EQUAL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; forboth(key1, keys1, key2, keys2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *pathkey1 = (PathKey *) lfirst(key1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *pathkey2 = (PathKey *) lfirst(key2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pathkey1 != pathkey2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PATHKEYS_DIFFERENT;&nbsp; &nbsp; <span class="Comment">/* no need to keep looking */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we reached the end of only one list, the other is longer and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * therefore not a <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (key1 != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PATHKEYS_BETTER1;&nbsp; &nbsp; <span class="Comment">/* key1 is longer */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (key2 != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PATHKEYS_BETTER2;&nbsp; &nbsp; <span class="Comment">/* key2 is longer */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> PATHKEYS_EQUAL;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L341" title="optimizer/path/pathkeys.c:341">pathkeys_contained_in</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Common special case of <a href="#L302" title="optimizer/path/pathkeys.c:302">compare_pathkeys</a>: we just want to know<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; if keys2 are at least as well sorted as keys1.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L341">&#x200c;</a></span><span class="linkable">pathkeys_contained_in</span>(List *keys1, List *keys2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L302" title="optimizer/path/pathkeys.c:302">compare_pathkeys</a>(keys1, keys2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PATHKEYS_EQUAL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PATHKEYS_BETTER2:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L368" title="optimizer/path/pathkeys.c:368">group_keys_reorder_by_pathkeys</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Reorder GROUP BY pathkeys and clauses to match the input pathkeys.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'pathkeys' is an input list of pathkeys<br/></li>
<li></span><span class="Comment"> * '*group_pathkeys' and '*group_clauses' are pathkeys and clauses lists to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; reorder.&nbsp; The pointers are redirected to new lists, original lists<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; stay untouched.<br/></li>
<li></span><span class="Comment"> * 'num_groupby_pathkeys' is the number of first '*group_pathkeys' items to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; search matching pathkeys.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the number of GROUP BY keys with a matching pathkey.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L368">&#x200c;</a></span><span class="linkable">group_keys_reorder_by_pathkeys</span>(List *pathkeys, List **group_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **group_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> num_groupby_pathkeys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *new_group_pathkeys = NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *new_group_clauses = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *grouping_pathkeys;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pathkeys == NIL || *group_pathkeys == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We're going to search within just the first num_groupby_pathkeys of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * *group_pathkeys.&nbsp; The thing is that root-&gt;group_pathkeys is passed as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * *group_pathkeys containing grouping pathkeys altogether with aggregate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pathkeys.&nbsp; If we process aggregate pathkeys we could get an invalid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * result of <a href="../util/tlist.c.html#L443" title="optimizer/util/tlist.c:443">get_sortgroupref_clause_noerr</a>(), because their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pathkey-&gt;pk_eclass-&gt;ec_sortref doesn't reference query targetlist.&nbsp; So,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we allocate a separate list of pathkeys for lookups.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; grouping_pathkeys = <a href="../../nodes/list.c.html#L1593" title="nodes/list.c:1593">list_copy_head</a>(*group_pathkeys, num_groupby_pathkeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Walk the pathkeys (determining ordering of the input path) and see if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there's a matching GROUP BY key. If we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one, we append it to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list, and do the same for the clauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Once we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the first pathkey without a matching GROUP BY key, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rest of the pathkeys are useless and can't be used to evaluate the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * grouping, so we abort the loop and ignore the remaining pathkeys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, pathkeys)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *pathkey = (PathKey *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *sgc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pathkeys are built in a way that allows simply comparing pointers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Give up if we can't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the matching pointer.&nbsp; Also give up if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there is no sortclause reference for some reason.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (foreach_current_index(lc) &gt;= num_groupby_pathkeys ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../nodes/list.c.html#L682" title="nodes/list.c:682">list_member_ptr</a>(grouping_pathkeys, pathkey) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkey-&gt;pk_eclass-&gt;ec_sortref == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since 1349d27 pathkey coming from underlying node can be in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * root-&gt;group_pathkeys but not in the processed_groupClause. So, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should be careful here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sgc = <a href="../util/tlist.c.html#L443" title="optimizer/util/tlist.c:443">get_sortgroupref_clause_noerr</a>(pathkey-&gt;pk_eclass-&gt;ec_sortref,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *group_clauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!sgc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The grouping clause does not cover this pathkey */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sort group clause should have an ordering operator as long as there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is an associated pathkey.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(OidIsValid(sgc-&gt;sortop));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_group_pathkeys = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(new_group_pathkeys, pathkey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_group_clauses = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(new_group_clauses, sgc);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* remember the number of pathkeys with a matching GROUP BY key */<br/></li>
<li></span>&nbsp; &nbsp; n = list_length(new_group_pathkeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* append the remaining group pathkeys (will be treated as not sorted) */<br/></li>
<li></span>&nbsp; &nbsp; *group_pathkeys = <a href="../../nodes/list.c.html#L1427" title="nodes/list.c:1427">list_concat_unique_ptr</a>(new_group_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *group_pathkeys);<br/></li>
<li>&nbsp; &nbsp; *group_clauses = <a href="../../nodes/list.c.html#L1427" title="nodes/list.c:1427">list_concat_unique_ptr</a>(new_group_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *group_clauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(grouping_pathkeys);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> n;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L456" title="optimizer/path/pathkeys.c:456">pathkeys_are_duplicate</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Check if give pathkeys are already contained the list of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; PathKeyInfo's.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L456">&#x200c;</a></span><span class="linkable">pathkeys_are_duplicate</span>(List *infos, List *pathkeys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, infos)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKeyInfo *info = lfirst_node(PathKeyInfo, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L302" title="optimizer/path/pathkeys.c:302">compare_pathkeys</a>(pathkeys, info-&gt;pathkeys) == PATHKEYS_EQUAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L485" title="optimizer/path/pathkeys.c:485">get_useful_group_keys_orderings</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Determine which orderings of GROUP BY keys are potentially interesting.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a list of PathKeyInfo items, each representing an interesting<br/></li>
<li></span><span class="Comment"> * ordering of GROUP BY keys.&nbsp; Each item stores pathkeys and clauses in the<br/></li>
<li></span><span class="Comment"> * matching order.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The function considers (and keeps) multiple GROUP BY orderings:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * - the original ordering, as specified by the GROUP BY clause,<br/></li>
<li></span><span class="Comment"> * - GROUP BY keys reordered to match 'path' ordering (as much as possible),<br/></li>
<li></span><span class="Comment"> * - GROUP BY keys to match target ORDER BY clause (as much as possible).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L485">&#x200c;</a><span class="linkable">get_useful_group_keys_orderings</span>(PlannerInfo *root, Path *path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *infos = NIL;<br/></li>
<li>&nbsp; &nbsp; PathKeyInfo *info;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pathkeys = root-&gt;group_pathkeys;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *clauses = root-&gt;processed_groupClause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* always return at least the original pathkeys/clauses */<br/></li>
<li></span>&nbsp; &nbsp; info = makeNode(PathKeyInfo);<br/></li>
<li>&nbsp; &nbsp; info-&gt;pathkeys = pathkeys;<br/></li>
<li>&nbsp; &nbsp; info-&gt;clauses = clauses;<br/></li>
<li>&nbsp; &nbsp; infos = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(infos, info);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Should we try generating alternative orderings of the group keys? If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not, we produce only the order specified in the query, i.e. the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * optimization is effectively disabled.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L31" title="optimizer/path/pathkeys.c:31">enable_group_by_reordering</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> infos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Grouping sets have own and more complex logic to decide the ordering.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupingSets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> infos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the path is sorted in some way, try reordering the group keys to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * match the path as much of the ordering as possible.&nbsp; Then thanks to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * incremental sort we would get this sort as cheap as possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (path-&gt;pathkeys &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L341" title="optimizer/path/pathkeys.c:341">pathkeys_contained_in</a>(path-&gt;pathkeys, root-&gt;group_pathkeys))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n = <a href="#L368" title="optimizer/path/pathkeys.c:368">group_keys_reorder_by_pathkeys</a>(path-&gt;pathkeys, &amp;pathkeys, &amp;clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;num_groupby_pathkeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (n &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="costsize.c.html#L140" title="optimizer/path/costsize.c:140">enable_incremental_sort</a> || n == root-&gt;num_groupby_pathkeys) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L456" title="optimizer/path/pathkeys.c:456">pathkeys_are_duplicate</a>(infos, pathkeys))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info = makeNode(PathKeyInfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info-&gt;pathkeys = pathkeys;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info-&gt;clauses = clauses;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; infos = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(infos, info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try reordering pathkeys to minimize the sort cost (this time consider<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the ORDER BY clause).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;sort_pathkeys &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L341" title="optimizer/path/pathkeys.c:341">pathkeys_contained_in</a>(root-&gt;sort_pathkeys, root-&gt;group_pathkeys))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n = <a href="#L368" title="optimizer/path/pathkeys.c:368">group_keys_reorder_by_pathkeys</a>(root-&gt;sort_pathkeys, &amp;pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;num_groupby_pathkeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (n &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="costsize.c.html#L140" title="optimizer/path/costsize.c:140">enable_incremental_sort</a> || n == list_length(root-&gt;sort_pathkeys)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L456" title="optimizer/path/pathkeys.c:456">pathkeys_are_duplicate</a>(infos, pathkeys))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info = makeNode(PathKeyInfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info-&gt;pathkeys = pathkeys;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info-&gt;clauses = clauses;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; infos = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(infos, info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> infos;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L573" title="optimizer/path/pathkeys.c:573">pathkeys_count_contained_in</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Same as <a href="#L341" title="optimizer/path/pathkeys.c:341">pathkeys_contained_in</a>, but also sets length of <a href="../../regex/rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; common prefix of keys1 and keys2.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L573">&#x200c;</a></span><span class="linkable">pathkeys_count_contained_in</span>(List *keys1, List *keys2, <span class="Type">int</span> *n_common)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *key1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *key2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See if we can avoiding looping through both lists. This optimization<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * gains us several percent in planning time in a worst-case test.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (keys1 == keys2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *n_common = list_length(keys1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (keys1 == NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *n_common = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (keys2 == NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *n_common = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If both lists are non-empty, iterate through both to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out how many<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * items are shared.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; forboth(key1, keys1, key2, keys2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *pathkey1 = (PathKey *) lfirst(key1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *pathkey2 = (PathKey *) lfirst(key2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pathkey1 != pathkey2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *n_common = n;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we ended with a null value, then we've processed the whole list. */<br/></li>
<li></span>&nbsp; &nbsp; *n_common = n;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (key1 == <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L635" title="optimizer/path/pathkeys.c:635">get_cheapest_path_for_pathkeys</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Find the cheapest path (according to the specified criterion) that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; satisfies the given pathkeys and parameterization, and is parallel-safe<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; if required.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Return NULL if no such path.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'paths' is a list of possible paths that all generate the same relation<br/></li>
<li></span><span class="Comment"> * 'pathkeys' represents a required ordering (in canonical form!)<br/></li>
<li></span><span class="Comment"> * 'required_outer' denotes allowable outer relations for parameterized paths<br/></li>
<li></span><span class="Comment"> * 'cost_criterion' is STARTUP_COST or TOTAL_COST<br/></li>
<li></span><span class="Comment"> * 'require_parallel_safe' causes us to consider only parallel-safe paths<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Path *<br/></li>
<li><a id="L635">&#x200c;</a><span class="linkable">get_cheapest_path_for_pathkeys</span>(List *paths, List *pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids required_outer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CostSelector cost_criterion,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> require_parallel_safe)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *matched_path = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, paths)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path = (Path *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If required, reject paths that are not parallel-safe */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (require_parallel_safe &amp;&amp; !path-&gt;parallel_safe)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since cost comparison is a lot cheaper than pathkey comparison, do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that first.&nbsp; (</span><span class="Todo">XXX</span><span class="Comment"> is that still true?)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (matched_path != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L69" title="optimizer/util/pathnode.c:69">compare_path_costs</a>(matched_path, path, cost_criterion) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L341" title="optimizer/path/pathkeys.c:341">pathkeys_contained_in</a>(pathkeys, path-&gt;pathkeys) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(PATH_REQ_OUTER(path), required_outer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matched_path = path;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> matched_path;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L681" title="optimizer/path/pathkeys.c:681">get_cheapest_fractional_path_for_pathkeys</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Find the cheapest path (for retrieving a specified fraction of all<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the tuples) that satisfies the given pathkeys and parameterization.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Return NULL if no such path.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See <a href="../util/pathnode.c.html#L115" title="optimizer/util/pathnode.c:115">compare_fractional_path_costs</a>() for the interpretation of the fraction<br/></li>
<li></span><span class="Comment"> * parameter.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'paths' is a list of possible paths that all generate the same relation<br/></li>
<li></span><span class="Comment"> * 'pathkeys' represents a required ordering (in canonical form!)<br/></li>
<li></span><span class="Comment"> * 'required_outer' denotes allowable outer relations for parameterized paths<br/></li>
<li></span><span class="Comment"> * 'fraction' is the fraction of the total tuples expected to be retrieved<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Path *<br/></li>
<li><a id="L681">&#x200c;</a><span class="linkable">get_cheapest_fractional_path_for_pathkeys</span>(List *paths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids required_outer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> fraction)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *matched_path = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, paths)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path = (Path *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since cost comparison is a lot cheaper than pathkey comparison, do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that first.&nbsp; (</span><span class="Todo">XXX</span><span class="Comment"> is that still true?)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (matched_path != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L115" title="optimizer/util/pathnode.c:115">compare_fractional_path_costs</a>(matched_path, path, fraction) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L341" title="optimizer/path/pathkeys.c:341">pathkeys_contained_in</a>(pathkeys, path-&gt;pathkeys) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(PATH_REQ_OUTER(path), required_outer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matched_path = path;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> matched_path;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L714" title="optimizer/path/pathkeys.c:714">get_cheapest_parallel_safe_total_inner</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Find the unparameterized parallel-safe path with the least total cost.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Path *<br/></li>
<li><a id="L714">&#x200c;</a><span class="linkable">get_cheapest_parallel_safe_total_inner</span>(List *paths)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, paths)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *innerpath = (Path *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (innerpath-&gt;parallel_safe &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bms_is_empty(PATH_REQ_OUTER(innerpath)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> innerpath;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; NEW PATHKEY FORMATION<br/></li>
<li></span><span class="Comment"> ****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L755" title="optimizer/path/pathkeys.c:755">build_index_pathkeys</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Build a pathkeys list that describes the ordering induced by an index<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; scan using the given index.&nbsp; (Note that an unordered index doesn't<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; induce <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> ordering, so we return NIL.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If 'scandir' is BackwardScanDirection, build pathkeys representing a<br/></li>
<li></span><span class="Comment"> * backwards scan of the index.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We iterate only key columns of covering indexes, since non-key columns<br/></li>
<li></span><span class="Comment"> * don't influence index ordering.&nbsp; The result is canonical, meaning that<br/></li>
<li></span><span class="Comment"> * redundant pathkeys are removed; it may therefore have fewer entries than<br/></li>
<li></span><span class="Comment"> * there are key columns in the index.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Another reason for stopping early is that we may be able to tell that<br/></li>
<li></span><span class="Comment"> * an index column's sort order is uninteresting for this query.&nbsp; However,<br/></li>
<li></span><span class="Comment"> * that test is just based on the existence of an EquivalenceClass and not<br/></li>
<li></span><span class="Comment"> * on position in pathkey lists, so it's not complete.&nbsp; Caller should call<br/></li>
<li></span><span class="Comment"> * <a href="#L2215" title="optimizer/path/pathkeys.c:2215">truncate_useless_pathkeys</a>() to possibly remove more pathkeys.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L755">&#x200c;</a><span class="linkable">build_index_pathkeys</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexOptInfo *index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanDirection scandir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *retval = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;sortopfamily == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* non-orderable index */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, index-&gt;indextlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *indextle = (TargetEntry *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *indexkey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; reverse_sort;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls_first;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *cpathkey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * INCLUDE columns are stored in index unordered, so they don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * support ordered index scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt;= index-&gt;nkeycolumns)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We assume we don't need to make a copy of the tlist item */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; indexkey = indextle-&gt;expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsBackward(scandir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reverse_sort = !index-&gt;reverse_sort[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls_first = !index-&gt;nulls_first[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reverse_sort = index-&gt;reverse_sort[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls_first = index-&gt;nulls_first[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OK, try to make a canonical pathkey for this sort key.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cpathkey = <a href="#L197" title="optimizer/path/pathkeys.c:197">make_pathkey_from_sortinfo</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;sortopfamily[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;opcintype[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;indexcollations[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reverse_sort,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls_first,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;rel-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cpathkey)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We found the sort key in an EquivalenceClass, so it's relevant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for this query.&nbsp; Add it to list, unless it's redundant.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L158" title="optimizer/path/pathkeys.c:158">pathkey_is_redundant</a>(cpathkey, retval))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(retval, cpathkey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Boolean index keys might be redundant even if they do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * appear in an EquivalenceClass, because of our special treatment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of boolean equality conditions --- see the comment for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="indxpath.c.html#L3653" title="optimizer/path/indxpath.c:3653">indexcol_is_bool_constant_for_query</a>().&nbsp; If that applies, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * continue to examine <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-order index columns.&nbsp; Otherwise, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sort key is not an interesting sort order for this query, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should stop considering index columns; <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-order sort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keys won't be useful either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="indxpath.c.html#L3653" title="optimizer/path/indxpath.c:3653">indexcol_is_bool_constant_for_query</a>(root, index, i))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> retval;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L859" title="optimizer/path/pathkeys.c:859">partkey_is_bool_constant_for_query</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If a partition key column is constrained to have a constant value by the<br/></li>
<li></span><span class="Comment"> * query's WHERE conditions, then it's irrelevant for sort-order<br/></li>
<li></span><span class="Comment"> * considerations.&nbsp; Usually that means we have a restriction clause<br/></li>
<li></span><span class="Comment"> * WHERE partkeycol = constant, which gets turned into an EquivalenceClass<br/></li>
<li></span><span class="Comment"> * containing a constant, which is recognized as redundant by<br/></li>
<li></span><span class="Comment"> * <a href="#L934" title="optimizer/path/pathkeys.c:934">build_partition_pathkeys</a>().&nbsp; But if the partition key column is a<br/></li>
<li></span><span class="Comment"> * boolean variable (or expression), then we are not going to see such a<br/></li>
<li></span><span class="Comment"> * WHERE clause, because expression preprocessing will have simplified it<br/></li>
<li></span><span class="Comment"> * to &quot;WHERE partkeycol&quot; or &quot;WHERE NOT partkeycol&quot;.&nbsp; So we are not going<br/></li>
<li></span><span class="Comment"> * to have a matching EquivalenceClass (unless the query also contains<br/></li>
<li></span><span class="Comment"> * &quot;ORDER BY partkeycol&quot;).&nbsp; To allow such cases to work the same as they would<br/></li>
<li></span><span class="Comment"> * for non-boolean <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, this function is provided to detect whether the<br/></li>
<li></span><span class="Comment"> * specified partition key column matches a boolean restriction clause.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L859">&#x200c;</a></span><span class="linkable">partkey_is_bool_constant_for_query</span>(RelOptInfo *partrel, <span class="Type">int</span> partkeycol)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PartitionScheme partscheme = partrel-&gt;part_scheme;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the partkey isn't boolean, we can't possibly get a match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Partitioning currently can only use built-in AMs, so checking for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * built-in boolean opfamilies is good enough.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IsBuiltinBooleanOpfamily(partscheme-&gt;partopfamily[partkeycol]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check each restriction clause for the partitioned rel */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, partrel-&gt;baserestrictinfo)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore pseudoconstant quals, they won't match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rinfo-&gt;pseudoconstant)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See if we can match the clause's expression to the partkey column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L899" title="optimizer/path/pathkeys.c:899">matches_boolean_partition_clause</a>(rinfo, partrel, partkeycol))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L899" title="optimizer/path/pathkeys.c:899">matches_boolean_partition_clause</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Determine if the boolean clause described by rinfo matches<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; partrel's partkeycol-th partition key column.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;Matches&quot; can be either an exact match (equivalent to partkey = true),<br/></li>
<li></span><span class="Comment"> * or a NOT above an exact match (equivalent to partkey = false).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L899">&#x200c;</a></span><span class="linkable">matches_boolean_partition_clause</span>(RestrictInfo *rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *partrel, <span class="Type">int</span> partkeycol)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *clause = (Node *) rinfo-&gt;clause;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *partexpr = (Node *) linitial(partrel-&gt;partexprs[partkeycol]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Direct match? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(partexpr, clause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* NOT clause? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (is_notclause(clause))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *arg = (Node *) get_notclausearg((Expr *) clause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(partexpr, arg))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L934" title="optimizer/path/pathkeys.c:934">build_partition_pathkeys</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Build a pathkeys list that describes the ordering induced by the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; partitions of partrel, under either forward or backward scan<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; as per scandir.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must have checked that the partitions are properly ordered,<br/></li>
<li></span><span class="Comment"> * as detected by <a href="../../partitioning/partbounds.c.html#L2852" title="partitioning/partbounds.c:2852">partitions_are_ordered</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Sets *partialkeys to true if pathkeys were only built for a prefix of the<br/></li>
<li></span><span class="Comment"> * partition key, or false if the pathkeys include all columns of the<br/></li>
<li></span><span class="Comment"> * partition key.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L934">&#x200c;</a><span class="linkable">build_partition_pathkeys</span>(PlannerInfo *root, RelOptInfo *partrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanDirection scandir, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *partialkeys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *retval = NIL;<br/></li>
<li>&nbsp; &nbsp; PartitionScheme partscheme = partrel-&gt;part_scheme;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(partscheme != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../partitioning/partbounds.c.html#L2852" title="partitioning/partbounds.c:2852">partitions_are_ordered</a>(partrel-&gt;boundinfo, partrel-&gt;live_parts));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we can only cope with baserels */<br/></li>
<li></span>&nbsp; &nbsp; Assert(IS_SIMPLE_REL(partrel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; partscheme-&gt;partnatts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *cpathkey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *keyCol = (Expr *) linitial(partrel-&gt;partexprs[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to make a canonical pathkey for this partkey.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We assume the PartitionDesc lists <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> NULL partition last, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * treat the scan like a NULLS LAST index: we have nulls_first for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backwards scan only.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cpathkey = <a href="#L197" title="optimizer/path/pathkeys.c:197">make_pathkey_from_sortinfo</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyCol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partscheme-&gt;partopfamily[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partscheme-&gt;partopcintype[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partscheme-&gt;partcollation[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanDirectionIsBackward(scandir),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanDirectionIsBackward(scandir),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partrel-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cpathkey)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We found the sort key in an EquivalenceClass, so it's relevant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for this query.&nbsp; Add it to list, unless it's redundant.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L158" title="optimizer/path/pathkeys.c:158">pathkey_is_redundant</a>(cpathkey, retval))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(retval, cpathkey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Boolean partition keys might be redundant even if they do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * appear in an EquivalenceClass, because of our special treatment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of boolean equality conditions --- see the comment for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L859" title="optimizer/path/pathkeys.c:859">partkey_is_bool_constant_for_query</a>().&nbsp; If that applies, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * continue to examine <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-order partition keys.&nbsp; Otherwise, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sort key is not an interesting sort order for this query, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should stop considering partition columns; <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-order sort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keys won't be useful either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L859" title="optimizer/path/pathkeys.c:859">partkey_is_bool_constant_for_query</a>(partrel, i))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *partialkeys = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> retval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *partialkeys = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> retval;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1015" title="optimizer/path/pathkeys.c:1015">build_expression_pathkey</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Build a pathkeys list that describes an ordering by a single expression<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; using the given sort operator.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * expr and rel are as for <a href="#L197" title="optimizer/path/pathkeys.c:197">make_pathkey_from_sortinfo</a>.<br/></li>
<li></span><span class="Comment"> * We induce the other arguments assuming default sort order for the operator.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Similarly to <a href="#L197" title="optimizer/path/pathkeys.c:197">make_pathkey_from_sortinfo</a>, the result is NIL if create_it<br/></li>
<li></span><span class="Comment"> * is false and the expression isn't already in some EquivalenceClass.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1015">&#x200c;</a><span class="linkable">build_expression_pathkey</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Expr *expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid opno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> create_it)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pathkeys;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcintype;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; strategy;<br/></li>
<li>&nbsp; &nbsp; PathKey&nbsp; &nbsp; *cpathkey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find the operator in pg_amop --- failure shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/cache/lsyscache.c.html#L207" title="utils/cache/lsyscache.c:207">get_ordering_op_properties</a>(opno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;opfamily, &amp;opcintype, &amp;strategy))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;operator </span><span class="Special">%u</span><span class="Constant"> is not a valid ordering operator&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; opno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cpathkey = <a href="#L197" title="optimizer/path/pathkeys.c:197">make_pathkey_from_sortinfo</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) expr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (strategy == BTGreaterStrategyNumber),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (strategy == BTGreaterStrategyNumber),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; create_it);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cpathkey)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathkeys = list_make1(cpathkey);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pathkeys = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathkeys;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1069" title="optimizer/path/pathkeys.c:1069">convert_subquery_pathkeys</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Build a pathkeys list that describes the ordering of a subquery's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; result, in the terms of the outer query.&nbsp; This is essentially a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; task of conversion.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rel': outer query's RelOptInfo for the subquery relation.<br/></li>
<li></span><span class="Comment"> * 'subquery_pathkeys': the subquery's output pathkeys, in its terms.<br/></li>
<li></span><span class="Comment"> * 'subquery_tlist': the subquery's output targetlist, in its terms.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We intentionally don't do <a href="#L2215" title="optimizer/path/pathkeys.c:2215">truncate_useless_pathkeys</a>() here, because there<br/></li>
<li></span><span class="Comment"> * are situations where seeing the raw ordering of the subquery is helpful.<br/></li>
<li></span><span class="Comment"> * For example, if it returns ORDER BY x DESC, that may prompt us to<br/></li>
<li></span><span class="Comment"> * construct a mergejoin using DESC order rather than ASC order; but the<br/></li>
<li></span><span class="Comment"> * <a href="#L2103" title="optimizer/path/pathkeys.c:2103">right_merge_direction</a> heuristic would have us throw the knowledge away.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1069">&#x200c;</a><span class="linkable">convert_subquery_pathkeys</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *subquery_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *subquery_tlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *retval = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retvallen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_query_keys = list_length(root-&gt;query_pathkeys);<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(i, subquery_pathkeys)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *sub_pathkey = (PathKey *) lfirst(i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EquivalenceClass *sub_eclass = sub_pathkey-&gt;pk_eclass;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *best_pathkey = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sub_eclass-&gt;ec_has_volatile)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the sub_pathkey's EquivalenceClass is volatile, then it must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have come from an ORDER BY clause, and we have to match it to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that same targetlist entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *outer_var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sub_eclass-&gt;ec_sortref == <span class="Constant">0</span>)&nbsp; &nbsp; <span class="Comment">/* can't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;volatile EquivalenceClass has no sortref&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../util/tlist.c.html#L345" title="optimizer/util/tlist.c:345">get_sortgroupref_tle</a>(sub_eclass-&gt;ec_sortref, subquery_tlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(tle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Is TLE actually available to the outer query? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_var = <a href="#L1266" title="optimizer/path/pathkeys.c:1266">find_var_for_subquery_tle</a>(rel, tle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (outer_var)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can represent this sub_pathkey */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EquivalenceMember *sub_member;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EquivalenceClass *outer_ec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(sub_eclass-&gt;ec_members) == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_member = (EquivalenceMember *) linitial(sub_eclass-&gt;ec_members);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: it might look funny to be setting sortref = 0 for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reference to a volatile sub_eclass.&nbsp; However, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expression is *not* volatile in the outer query: it's just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a Var referencing whatever the subquery emitted. (IOW, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * outer query isn't going to re-execute the volatile<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expression itself.)&nbsp; &nbsp; So this is okay.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_ec =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="equivclass.c.html#L587" title="optimizer/path/equivclass.c:587">get_eclass_for_sort_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Expr *) outer_var,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sub_eclass-&gt;ec_opfamilies,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sub_member-&gt;em_datatype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sub_eclass-&gt;ec_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we don't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a matching EC, sub-pathkey isn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interesting to the outer query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (outer_ec)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_pathkey =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L55" title="optimizer/path/pathkeys.c:55">make_canonical_pathkey</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outer_ec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sub_pathkey-&gt;pk_opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sub_pathkey-&gt;pk_strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sub_pathkey-&gt;pk_nulls_first);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, the sub_pathkey's EquivalenceClass could contain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multiple elements (representing knowledge that multiple items<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are effectively <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>).&nbsp; Each <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> might match <a href="../util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>, one, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * more of the output columns that are visible to the outer query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This means we may have multiple possible representations of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sub_pathkey in the context of the outer query.&nbsp; Ideally we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would generate them all and put them all into an EC of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * outer query, thereby propagating equality knowledge up to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * outer query.&nbsp; Right <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we cannot do so, because the outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * query's EquivalenceClasses are already frozen when this is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * called. Instead we prefer the one that has the highest &quot;score&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (number of EC peers, plus one if it matches the outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * query_pathkeys). This is the most likely to be useful in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * outer query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_score = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(j, sub_eclass-&gt;ec_members)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EquivalenceMember *sub_member = (EquivalenceMember *) lfirst(j);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *sub_expr = sub_member-&gt;em_expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_expr_type = sub_member-&gt;em_datatype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_expr_coll = sub_eclass-&gt;ec_collation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *k;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sub_member-&gt;em_is_child)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; <span class="Comment">/* ignore children here */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(k, subquery_tlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(k);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *outer_var;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *tle_expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EquivalenceClass *outer_ec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *outer_pk;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; score;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Is TLE actually available to the outer query? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_var = <a href="#L1266" title="optimizer/path/pathkeys.c:1266">find_var_for_subquery_tle</a>(rel, tle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!outer_var)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The targetlist entry is considered to match if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matches after sort-key canonicalization.&nbsp; That is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * needed since the sub_expr has been through the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle_expr = <a href="equivclass.c.html#L472" title="optimizer/path/equivclass.c:472">canonicalize_ec_expression</a>(tle-&gt;expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_expr_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_expr_coll);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(tle_expr, sub_expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See if we have a matching EC for the TLE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_ec = <a href="equivclass.c.html#L587" title="optimizer/path/equivclass.c:587">get_eclass_for_sort_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Expr *) outer_var,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_eclass-&gt;ec_opfamilies,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_expr_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_expr_coll,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we don't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a matching EC, this sub-pathkey isn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interesting to the outer query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!outer_ec)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_pk = <a href="#L55" title="optimizer/path/pathkeys.c:55">make_canonical_pathkey</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_ec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_pathkey-&gt;pk_opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_pathkey-&gt;pk_strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_pathkey-&gt;pk_nulls_first);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* score = # of equivalence peers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; score = list_length(outer_ec-&gt;ec_members) - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* +1 if it matches the proper query_pathkeys item */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retvallen &lt; outer_query_keys &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_nth(root-&gt;query_pathkeys, retvallen) == outer_pk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; score++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (score &gt; best_score)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_pathkey = outer_pk;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_score = score;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we couldn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a representation of this sub_pathkey, we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * done (we can't use the ones to its right, either).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!best_pathkey)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Eliminate redundant ordering info; could happen if outer query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * equivalences subquery keys...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L158" title="optimizer/path/pathkeys.c:158">pathkey_is_redundant</a>(best_pathkey, retval))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(retval, best_pathkey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retvallen++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> retval;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1266" title="optimizer/path/pathkeys.c:1266">find_var_for_subquery_tle</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the given subquery tlist entry is due to be emitted by the subquery's<br/></li>
<li></span><span class="Comment"> * scan node, return a Var for it, else return NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We need this to ensure that we don't return pathkeys describing <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> * that are unavailable above the level of the subquery scan.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Var *<br/></li>
<li><a id="L1266">&#x200c;</a><span class="linkable">find_var_for_subquery_tle</span>(RelOptInfo *rel, TargetEntry *tle)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If the TLE is resjunk, it's certainly not visible to the outer query */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Search the rel's targetlist to see what it will return */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, rel-&gt;reltarget-&gt;exprs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore placeholders */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsA(var, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(var-&gt;varno == rel-&gt;relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a Var referencing this TLE, we're good */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varattno == tle-&gt;resno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> copyObject(var); <span class="Comment">/* Make a copy for safety */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1309" title="optimizer/path/pathkeys.c:1309">build_join_pathkeys</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Build the path keys for a join relation constructed by mergejoin or<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; nestloop join.&nbsp; This is normally the same as the outer path's keys.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; EXCEPTION: in a FULL, RIGHT or RIGHT_ANTI join, we cannot treat the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; result as having the outer path's path keys, because null lefthand rows<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; may be inserted at random points.&nbsp; It must be treated as unsorted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; We truncate away <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pathkeys that are uninteresting for higher joins.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'joinrel' is the join relation that paths are being formed for<br/></li>
<li></span><span class="Comment"> * 'jointype' is the join type (inner, left, full, etc)<br/></li>
<li></span><span class="Comment"> * 'outer_pathkeys' is the list of the current outer path's path keys<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the list of new path keys.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1309">&#x200c;</a><span class="linkable">build_join_pathkeys</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JoinType jointype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *outer_pathkeys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (jointype == JOIN_FULL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jointype == JOIN_RIGHT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jointype == JOIN_RIGHT_ANTI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This used to be quite a complex <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of code, but <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that all pathkey<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sublists start out life canonicalized, we don't have to do a darn thing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do, however, need to truncate the pathkeys list, since it may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contain pathkeys that were useful for forming this joinrel but are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * uninteresting to higher levels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2215" title="optimizer/path/pathkeys.c:2215">truncate_useless_pathkeys</a>(root, joinrel, outer_pathkeys);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; PATHKEYS AND SORT CLAUSES<br/></li>
<li></span><span class="Comment"> ****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1347" title="optimizer/path/pathkeys.c:1347">make_pathkeys_for_sortclauses</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Generate a pathkeys list that represents the sort order specified<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; by a list of SortGroupClauses<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The resulting PathKeys are always in canonical form.&nbsp; (Actually, there<br/></li>
<li></span><span class="Comment"> * is no longer <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> code anywhere that creates non-canonical PathKeys.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'sortclauses' is a list of SortGroupClause nodes<br/></li>
<li></span><span class="Comment"> * 'tlist' is the targetlist to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the referenced tlist entries in<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1347">&#x200c;</a><span class="linkable">make_pathkeys_for_sortclauses</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *sortclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *tlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sortable;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L1384" title="optimizer/path/pathkeys.c:1384">make_pathkeys_for_sortclauses_extended</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;sortclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;sortable);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* It's caller error if not all clauses were sortable */<br/></li>
<li></span>&nbsp; &nbsp; Assert(sortable);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1384" title="optimizer/path/pathkeys.c:1384">make_pathkeys_for_sortclauses_extended</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Generate a pathkeys list that represents the sort order specified<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; by a list of SortGroupClauses<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The comments for <a href="#L1347" title="optimizer/path/pathkeys.c:1347">make_pathkeys_for_sortclauses</a> apply here too. In addition:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If remove_redundant is true, then <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> sort clauses that are found to<br/></li>
<li></span><span class="Comment"> * give rise to redundant pathkeys are removed from the sortclauses list<br/></li>
<li></span><span class="Comment"> * (which therefore must be pass-by-reference in this version).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *sortable is set to true if all the sort clauses are in fact sortable.<br/></li>
<li></span><span class="Comment"> * If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> are not, they are ignored except for setting *sortable false.<br/></li>
<li></span><span class="Comment"> * (In that case, the output pathkey list isn't really useful.&nbsp; However,<br/></li>
<li></span><span class="Comment"> * we process the whole sortclauses list anyway, because it's still valid<br/></li>
<li></span><span class="Comment"> * to remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> clauses that can be proven redundant via the <a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a> logic.<br/></li>
<li></span><span class="Comment"> * Even though we'll have to <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> in that case, we might as well not <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment"> * redundant columns.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1384">&#x200c;</a><span class="linkable">make_pathkeys_for_sortclauses_extended</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **sortclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> remove_redundant,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *sortable)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pathkeys = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *sortable = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(l, *sortclauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *sortcl = (SortGroupClause *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *sortkey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *pathkey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortkey = (Expr *) <a href="../util/tlist.c.html#L379" title="optimizer/util/tlist.c:379">get_sortgroupclause_expr</a>(sortcl, tlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(sortcl-&gt;sortop))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *sortable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathkey = <a href="#L255" title="optimizer/path/pathkeys.c:255">make_pathkey_from_sortop</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sortkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sortcl-&gt;sortop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sortcl-&gt;nulls_first,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sortcl-&gt;tleSortGroupRef,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Canonical form eliminates redundant ordering keys */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L158" title="optimizer/path/pathkeys.c:158">pathkey_is_redundant</a>(pathkey, pathkeys))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkeys = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(pathkeys, pathkey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (remove_redundant)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *sortclauses = foreach_delete_current(*sortclauses, l);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathkeys;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; PATHKEYS AND MERGECLAUSES<br/></li>
<li></span><span class="Comment"> ****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1446" title="optimizer/path/pathkeys.c:1446">initialize_mergeclause_eclasses</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set the EquivalenceClass links in a mergeclause restrictinfo.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * RestrictInfo contains fields in which we may cache pointers to<br/></li>
<li></span><span class="Comment"> * EquivalenceClasses for the left and right inputs of the mergeclause.<br/></li>
<li></span><span class="Comment"> * (If the mergeclause is a true equivalence clause these will be the<br/></li>
<li></span><span class="Comment"> * same EquivalenceClass, otherwise not.)&nbsp; If the mergeclause is either<br/></li>
<li></span><span class="Comment"> * used to generate an EquivalenceClass, or derived from an EquivalenceClass,<br/></li>
<li></span><span class="Comment"> * then it's easy to set up the left_ec and right_ec members --- otherwise,<br/></li>
<li></span><span class="Comment"> * this function should be called to set them up.&nbsp; We will generate new<br/></li>
<li></span><span class="Comment"> * EquivalenceClauses if necessary to represent the mergeclause's left and<br/></li>
<li></span><span class="Comment"> * right sides.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note this is called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> EC merging is complete, so the links won't<br/></li>
<li></span><span class="Comment"> * necessarily point to canonical ECs.&nbsp; Before they are actually used for<br/></li>
<li></span><span class="Comment"> * anything, <a href="#L1493" title="optimizer/path/pathkeys.c:1493">update_mergeclause_eclasses</a> must be called to ensure that<br/></li>
<li></span><span class="Comment"> * they've been updated to point to canonical ECs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1446">&#x200c;</a></span><span class="linkable">initialize_mergeclause_eclasses</span>(PlannerInfo *root, RestrictInfo *restrictinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *clause = restrictinfo-&gt;clause;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lefttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; righttype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should be a mergeclause ... */<br/></li>
<li></span>&nbsp; &nbsp; Assert(restrictinfo-&gt;mergeopfamilies != NIL);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... with links not yet set */<br/></li>
<li></span>&nbsp; &nbsp; Assert(restrictinfo-&gt;left_ec == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(restrictinfo-&gt;right_ec == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Need the declared input types of the operator */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/lsyscache.c.html#L1358" title="utils/cache/lsyscache.c:1358">op_input_types</a>(((OpExpr *) clause)-&gt;opno, &amp;lefttype, &amp;righttype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find or create a matching EquivalenceClass for each side */<br/></li>
<li></span>&nbsp; &nbsp; restrictinfo-&gt;left_ec =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="equivclass.c.html#L587" title="optimizer/path/equivclass.c:587">get_eclass_for_sort_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Expr *) get_leftop(clause),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; restrictinfo-&gt;mergeopfamilies,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lefttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((OpExpr *) clause)-&gt;inputcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; restrictinfo-&gt;right_ec =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="equivclass.c.html#L587" title="optimizer/path/equivclass.c:587">get_eclass_for_sort_expr</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Expr *) get_rightop(clause),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; restrictinfo-&gt;mergeopfamilies,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; righttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((OpExpr *) clause)-&gt;inputcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1493" title="optimizer/path/pathkeys.c:1493">update_mergeclause_eclasses</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Make the cached EquivalenceClass links valid in a mergeclause<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; restrictinfo.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These pointers should have been set by <a href="equivclass.c.html#L118" title="optimizer/path/equivclass.c:118">process_equivalence</a> or<br/></li>
<li></span><span class="Comment"> * <a href="#L1446" title="optimizer/path/pathkeys.c:1446">initialize_mergeclause_eclasses</a>, but they might have been set to<br/></li>
<li></span><span class="Comment"> * non-canonical ECs that got merged later.&nbsp; Chase up to the canonical<br/></li>
<li></span><span class="Comment"> * merged parent if so.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1493">&#x200c;</a></span><span class="linkable">update_mergeclause_eclasses</span>(PlannerInfo *root, RestrictInfo *restrictinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should be a <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> clause ... */<br/></li>
<li></span>&nbsp; &nbsp; Assert(restrictinfo-&gt;mergeopfamilies != NIL);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... with pointers already set */<br/></li>
<li></span>&nbsp; &nbsp; Assert(restrictinfo-&gt;left_ec != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(restrictinfo-&gt;right_ec != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Chase up to the top as needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (restrictinfo-&gt;left_ec-&gt;ec_merged)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; restrictinfo-&gt;left_ec = restrictinfo-&gt;left_ec-&gt;ec_merged;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (restrictinfo-&gt;right_ec-&gt;ec_merged)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; restrictinfo-&gt;right_ec = restrictinfo-&gt;right_ec-&gt;ec_merged;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1527" title="optimizer/path/pathkeys.c:1527">find_mergeclauses_for_outer_pathkeys</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; This routine attempts to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a list of mergeclauses that can be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; used with a specified ordering for the join's outer relation.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; If successful, it returns a list of mergeclauses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'pathkeys' is a pathkeys list showing the ordering of an outer-rel path.<br/></li>
<li></span><span class="Comment"> * 'restrictinfos' is a list of mergejoinable restriction clauses for the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; join relation being formed, in no particular order.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The restrictinfos must be marked (via outer_is_left) to show which side<br/></li>
<li></span><span class="Comment"> * of each clause is associated with the current outer path.&nbsp; (See<br/></li>
<li></span><span class="Comment"> * <a href="joinpath.c.html#L2347" title="optimizer/path/joinpath.c:2347">select_mergejoin_clauses</a>())<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is NIL if no <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> can be done, else a maximal list of<br/></li>
<li></span><span class="Comment"> * usable mergeclauses (represented as a list of their restrictinfo nodes).<br/></li>
<li></span><span class="Comment"> * The list is ordered to match the pathkeys, as required for execution.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1527">&#x200c;</a><span class="linkable">find_mergeclauses_for_outer_pathkeys</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *restrictinfos)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *mergeclauses = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure we have eclasses cached in the clauses */<br/></li>
<li></span>&nbsp; &nbsp; foreach(i, restrictinfos)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1493" title="optimizer/path/pathkeys.c:1493">update_mergeclause_eclasses</a>(root, rinfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(i, pathkeys)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *pathkey = (PathKey *) lfirst(i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EquivalenceClass *pathkey_ec = pathkey-&gt;pk_eclass;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *matched_restrictinfos = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A mergejoin clause matches a pathkey if it has the same EC.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there are multiple matching clauses, take them all.&nbsp; In plain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inner-join scenarios we expect only one match, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * equivalence-class processing will have removed <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> redundant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mergeclauses.&nbsp; However, in outer-join scenarios there might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multiple matches.&nbsp; An example is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> * from a full join b<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; on a.v1 = b.v1 and a.v2 = b.v2 and a.v1 = b.v2;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Given the pathkeys ({a.v1}, {a.v2}) it is okay to return all three<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clauses (in the order a.v1=b.v1, a.v1=b.v2, a.v2=b.v2) and indeed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we *must* do so or we will be unable to form a valid plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We expect that the given pathkeys list is canonical, which means<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no two members have the same EC, so it's not possible for this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * code to enter the same mergeclause into the result list twice.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's possible that multiple matching clauses might have different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ECs on the other side, in which case the order we put them into our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result makes a difference in the pathkeys required for the inner<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * input rel.&nbsp; However this routine hasn't got <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> info about which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * order would be best, so we don't worry about that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's also possible that the selected mergejoin clauses produce<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a noncanonical ordering of pathkeys for the inner side, ie, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> clauses that reference b.v1, b.v2, b.v1 in that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * order.&nbsp; This is not harmful in itself, though it suggests that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the clauses are partially redundant.&nbsp; Since the alternative is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to omit mergejoin clauses and thereby possibly fail to generate a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * plan altogether, we live with it.&nbsp; <a href="#L1838" title="optimizer/path/pathkeys.c:1838">make_inner_pathkeys_for_merge</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * has to delete duplicates when it constructs the inner pathkeys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list, and we also have to deal with such cases specially in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../plan/createplan.c.html#L4439" title="optimizer/plan/createplan.c:4439">create_mergejoin_plan</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(j, restrictinfos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(j);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EquivalenceClass *clause_ec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clause_ec = rinfo-&gt;outer_is_left ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rinfo-&gt;left_ec : rinfo-&gt;right_ec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (clause_ec == pathkey_ec)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matched_restrictinfos = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(matched_restrictinfos, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a mergeclause, we're done --- <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> additional<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sort-key positions in the pathkeys are useless.&nbsp; (But we can still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mergejoin if we found at least one mergeclause.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (matched_restrictinfos == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we did <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> usable mergeclause(s) for this sort-key position,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * add them to result list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mergeclauses = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(mergeclauses, matched_restrictinfos);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> mergeclauses;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1642" title="optimizer/path/pathkeys.c:1642">select_outer_pathkeys_for_merge</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Builds a pathkey list representing a possible sort ordering<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; that can be used with the given mergeclauses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'mergeclauses' is a list of RestrictInfos for mergejoin clauses<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; that will be used in a <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> join.<br/></li>
<li></span><span class="Comment"> * 'joinrel' is the join relation we are trying to construct.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The restrictinfos must be marked (via outer_is_left) to show which side<br/></li>
<li></span><span class="Comment"> * of each clause is associated with the current outer path.&nbsp; (See<br/></li>
<li></span><span class="Comment"> * <a href="joinpath.c.html#L2347" title="optimizer/path/joinpath.c:2347">select_mergejoin_clauses</a>())<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a pathkeys list that can be applied to the outer relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since we assume here that a sort is required, there is no particular use<br/></li>
<li></span><span class="Comment"> * in matching <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> available ordering of the outerrel.&nbsp; (joinpath.c has an<br/></li>
<li></span><span class="Comment"> * entirely separate code path for considering sort-free mergejoins.)&nbsp; Rather,<br/></li>
<li></span><span class="Comment"> * it's interesting to try to match, or match a prefix of the requested<br/></li>
<li></span><span class="Comment"> * query_pathkeys so that a second output sort may be avoided or an<br/></li>
<li></span><span class="Comment"> * incremental sort may be done instead.&nbsp; We can get away with just a prefix<br/></li>
<li></span><span class="Comment"> * of the query_pathkeys when that prefix covers the entire join condition.<br/></li>
<li></span><span class="Comment"> * Failing that, we try to list &quot;more popular&quot; keys&nbsp; (those with the most<br/></li>
<li></span><span class="Comment"> * unmatched EquivalenceClass peers) earlier, in hopes of making the resulting<br/></li>
<li></span><span class="Comment"> * ordering useful for as many higher-level mergejoins as possible.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1642">&#x200c;</a><span class="linkable">select_outer_pathkeys_for_merge</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *mergeclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *joinrel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pathkeys = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nClauses = list_length(mergeclauses);<br/></li>
<li>&nbsp; &nbsp; EquivalenceClass **ecs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *scores;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; necs;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Might have no mergeclauses */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nClauses == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make arrays of the ECs used by the mergeclauses (dropping <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * duplicates) and their &quot;popularity&quot; scores.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ecs = (EquivalenceClass **) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nClauses * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(EquivalenceClass *));<br/></li>
<li>&nbsp; &nbsp; scores = (<span class="Type">int</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nClauses * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; necs = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, mergeclauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EquivalenceClass *oeclass;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; score;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* get the outer <a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1493" title="optimizer/path/pathkeys.c:1493">update_mergeclause_eclasses</a>(root, rinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rinfo-&gt;outer_is_left)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oeclass = rinfo-&gt;left_ec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oeclass = rinfo-&gt;right_ec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reject duplicates */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; necs; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ecs[j] == oeclass)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j &lt; necs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* compute score */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; score = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, oeclass-&gt;ec_members)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EquivalenceMember *em = (EquivalenceMember *) lfirst(lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Potential future join partner? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!em-&gt;em_is_const &amp;&amp; !em-&gt;em_is_child &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(em-&gt;em_relids, joinrel-&gt;relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; score++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ecs[necs] = oeclass;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scores[necs] = score;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; necs++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find out if we have all the ECs mentioned in query_pathkeys; if so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can generate a sort order that's also useful for final output. If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only have a prefix of the query_pathkeys, and that prefix is the entire<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * join condition, then it's useful to use the prefix as the pathkeys as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this increases the chances that an incremental sort will be able to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * used by the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> <a href="../plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;query_pathkeys)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, root-&gt;query_pathkeys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *query_pathkey = (PathKey *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EquivalenceClass *query_ec = query_pathkey-&gt;pk_eclass;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; necs; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ecs[j] == query_ec)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* found match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j &gt;= necs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> match */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if we got to the end of the list, we have them all */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy query_pathkeys as starting point for our output */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkeys = <a href="../../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(root-&gt;query_pathkeys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mark their ECs as already-emitted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, root-&gt;query_pathkeys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *query_pathkey = (PathKey *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EquivalenceClass *query_ec = query_pathkey-&gt;pk_eclass;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; necs; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ecs[j] == query_ec)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scores[j] = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we didn't match to all of the query_pathkeys, but did match to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all of the join clauses then we'll make use of these as partially<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sorted input is better than nothing for the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> <a href="../plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> as it may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lead to incremental sorts instead of full sorts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (matches == nClauses)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkeys = <a href="../../nodes/list.c.html#L1593" title="nodes/list.c:1593">list_copy_head</a>(root-&gt;query_pathkeys, matches);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we have all of the join pathkeys, so nothing more to do */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ecs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(scores);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> pathkeys;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add remaining ECs to the list in popularity order, using a default sort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ordering.&nbsp; (We could use qsort() here, but the list length is usually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so small it's not worth it.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_j;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_score;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EquivalenceClass *ec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *pathkey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; best_j = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; best_score = scores[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">1</span>; j &lt; necs; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scores[j] &gt; best_score)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_j = j;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_score = scores[j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (best_score &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* all done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ec = ecs[best_j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scores[best_j] = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathkey = <a href="#L55" title="optimizer/path/pathkeys.c:55">make_canonical_pathkey</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; linitial_oid(ec-&gt;ec_opfamilies),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTLessStrategyNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can't be redundant because no duplicate ECs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="#L158" title="optimizer/path/pathkeys.c:158">pathkey_is_redundant</a>(pathkey, pathkeys));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathkeys = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(pathkeys, pathkey);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ecs);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(scores);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathkeys;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1838" title="optimizer/path/pathkeys.c:1838">make_inner_pathkeys_for_merge</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Builds a pathkey list representing the explicit sort order that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; must be applied to an inner path to make it usable with the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; given mergeclauses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'mergeclauses' is a list of RestrictInfos for the mergejoin clauses<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; that will be used in a <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> join, in order.<br/></li>
<li></span><span class="Comment"> * 'outer_pathkeys' are the already-known canonical pathkeys for the outer<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; side of the join.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The restrictinfos must be marked (via outer_is_left) to show which side<br/></li>
<li></span><span class="Comment"> * of each clause is associated with the current outer path.&nbsp; (See<br/></li>
<li></span><span class="Comment"> * <a href="joinpath.c.html#L2347" title="optimizer/path/joinpath.c:2347">select_mergejoin_clauses</a>())<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a pathkeys list that can be applied to the inner relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that it is not this routine's job to decide whether sorting is<br/></li>
<li></span><span class="Comment"> * actually needed for a particular input path.&nbsp; Assume a sort is necessary;<br/></li>
<li></span><span class="Comment"> * just make the keys, eh?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1838">&#x200c;</a><span class="linkable">make_inner_pathkeys_for_merge</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *mergeclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *outer_pathkeys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pathkeys = NIL;<br/></li>
<li>&nbsp; &nbsp; EquivalenceClass *lastoeclass;<br/></li>
<li>&nbsp; &nbsp; PathKey&nbsp; &nbsp; *opathkey;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lop;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lastoeclass = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; opathkey = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; lop = list_head(outer_pathkeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, mergeclauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EquivalenceClass *oeclass;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EquivalenceClass *ieclass;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *pathkey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1493" title="optimizer/path/pathkeys.c:1493">update_mergeclause_eclasses</a>(root, rinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rinfo-&gt;outer_is_left)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oeclass = rinfo-&gt;left_ec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ieclass = rinfo-&gt;right_ec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oeclass = rinfo-&gt;right_ec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ieclass = rinfo-&gt;left_ec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* outer <a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a> should match current or <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> pathkeys */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we check this carefully for debugging reasons */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oeclass != lastoeclass)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!lop)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;too few pathkeys for mergeclauses&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opathkey = (PathKey *) lfirst(lop);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lop = lnext(outer_pathkeys, lop);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastoeclass = opathkey-&gt;pk_eclass;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oeclass != lastoeclass)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;outer pathkeys do not match mergeclause&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Often, we'll have same EC on both sides, in which case the outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pathkey is also canonical for the inner side, and we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * useless search.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ieclass == oeclass)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkey = opathkey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkey = <a href="#L55" title="optimizer/path/pathkeys.c:55">make_canonical_pathkey</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ieclass,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; opathkey-&gt;pk_opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; opathkey-&gt;pk_strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; opathkey-&gt;pk_nulls_first);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't generate redundant pathkeys (which can happen if multiple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mergeclauses refer to the same EC).&nbsp; Because we do this, the output<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pathkey list isn't necessarily ordered like the mergeclauses, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * complicates life for <a href="../plan/createplan.c.html#L4439" title="optimizer/plan/createplan.c:4439">create_mergejoin_plan</a>().&nbsp; But if we didn't,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'd have a noncanonical sort key list, which would be bad; for one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reason, it certainly wouldn't match <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> available sort order for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the input relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L158" title="optimizer/path/pathkeys.c:158">pathkey_is_redundant</a>(pathkey, pathkeys))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkeys = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(pathkeys, pathkey);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathkeys;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1941" title="optimizer/path/pathkeys.c:1941">trim_mergeclauses_for_inner_pathkeys</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; This routine trims a list of mergeclauses to include just those that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; work with a specified ordering for the join's inner relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'mergeclauses' is a list of RestrictInfos for mergejoin clauses for the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; join relation being formed, in an order known to work for the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currently-considered sort ordering of the join's outer rel.<br/></li>
<li></span><span class="Comment"> * 'pathkeys' is a pathkeys list showing the ordering of an inner-rel path;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; it should be <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to, or a truncation of, the result of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1838" title="optimizer/path/pathkeys.c:1838">make_inner_pathkeys_for_merge</a> for these mergeclauses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * What we return will be a prefix of the given mergeclauses list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We need this logic because <a href="#L1838" title="optimizer/path/pathkeys.c:1838">make_inner_pathkeys_for_merge</a>'s result isn't<br/></li>
<li></span><span class="Comment"> * necessarily in the same order as the mergeclauses.&nbsp; That means that if we<br/></li>
<li></span><span class="Comment"> * consider an inner-rel pathkey list that is a truncation of that result,<br/></li>
<li></span><span class="Comment"> * we might need to drop mergeclauses even though they match a surviving inner<br/></li>
<li></span><span class="Comment"> * pathkey.&nbsp; This happens when they are to the right of a mergeclause that<br/></li>
<li></span><span class="Comment"> * matches a removed inner pathkey.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The mergeclauses must be marked (via outer_is_left) to show which side<br/></li>
<li></span><span class="Comment"> * of each clause is associated with the current outer path.&nbsp; (See<br/></li>
<li></span><span class="Comment"> * <a href="joinpath.c.html#L2347" title="optimizer/path/joinpath.c:2347">select_mergejoin_clauses</a>())<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1941">&#x200c;</a><span class="linkable">trim_mergeclauses_for_inner_pathkeys</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *mergeclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *pathkeys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *new_mergeclauses = NIL;<br/></li>
<li>&nbsp; &nbsp; PathKey&nbsp; &nbsp; *pathkey;<br/></li>
<li>&nbsp; &nbsp; EquivalenceClass *pathkey_ec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; matched_pathkey;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lip;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No pathkeys =&gt; no mergeclauses (though we don't expect this case) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pathkeys == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize to consider first pathkey */<br/></li>
<li></span>&nbsp; &nbsp; lip = list_head(pathkeys);<br/></li>
<li>&nbsp; &nbsp; pathkey = (PathKey *) lfirst(lip);<br/></li>
<li>&nbsp; &nbsp; pathkey_ec = pathkey-&gt;pk_eclass;<br/></li>
<li>&nbsp; &nbsp; lip = lnext(pathkeys, lip);<br/></li>
<li>&nbsp; &nbsp; matched_pathkey = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan mergeclauses to see how many we can use */<br/></li>
<li></span>&nbsp; &nbsp; foreach(i, mergeclauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EquivalenceClass *clause_ec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Assume we needn't do <a href="#L1493" title="optimizer/path/pathkeys.c:1493">update_mergeclause_eclasses</a> again here */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check clause's inner-rel EC against current pathkey */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; clause_ec = rinfo-&gt;outer_is_left ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rinfo-&gt;right_ec : rinfo-&gt;left_ec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we don't have a match, attempt to advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> pathkey */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (clause_ec != pathkey_ec)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we had no clauses matching this inner pathkey, must stop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!matched_pathkey)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> inner pathkey, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lip == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkey = (PathKey *) lfirst(lip);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkey_ec = pathkey-&gt;pk_eclass;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lip = lnext(pathkeys, lip);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matched_pathkey = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If mergeclause matches current inner pathkey, we can use it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (clause_ec == pathkey_ec)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_mergeclauses = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(new_mergeclauses, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matched_pathkey = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Else, no hope of adding <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more mergeclauses */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> new_mergeclauses;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; PATHKEY USEFULNESS CHECKS<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We only want to remember as many of the pathkeys of a path as have some<br/></li>
<li></span><span class="Comment"> * potential use, either for subsequent mergejoins or for meeting the query's<br/></li>
<li></span><span class="Comment"> * requested output ordering.&nbsp; This ensures that <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>() won't consider<br/></li>
<li></span><span class="Comment"> * a path to have a usefully different ordering unless it really is useful.<br/></li>
<li></span><span class="Comment"> * These routines check for usefulness of given pathkeys.<br/></li>
<li></span><span class="Comment"> ****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2036" title="optimizer/path/pathkeys.c:2036">pathkeys_useful_for_merging</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Count the number of pathkeys that may be useful for mergejoins<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; above the given relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We consider a pathkey potentially useful if it corresponds to the <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a><br/></li>
<li></span><span class="Comment"> * ordering of either side of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> joinclause for the rel.&nbsp; This might be<br/></li>
<li></span><span class="Comment"> * overoptimistic, since joinclauses that require different other relations<br/></li>
<li></span><span class="Comment"> * might never be usable at the same time, but trying to be exact is likely<br/></li>
<li></span><span class="Comment"> * to be more trouble than it's worth.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To avoid doubling the number of mergejoin paths considered, we would like<br/></li>
<li></span><span class="Comment"> * to consider only one of the two scan directions (ASC or DESC) as useful<br/></li>
<li></span><span class="Comment"> * for merging for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> given target column.&nbsp; The choice is arbitrary unless<br/></li>
<li></span><span class="Comment"> * one of the directions happens to match an ORDER BY key, in which case<br/></li>
<li></span><span class="Comment"> * that direction should be preferred, in hopes of avoiding a final sort step.<br/></li>
<li></span><span class="Comment"> * <a href="#L2103" title="optimizer/path/pathkeys.c:2103">right_merge_direction</a>() implements this heuristic.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2036">&#x200c;</a></span><span class="linkable">pathkeys_useful_for_merging</span>(PlannerInfo *root, RelOptInfo *rel, List *pathkeys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; useful = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(i, pathkeys)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *pathkey = (PathKey *) lfirst(i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; matched = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If &quot;wrong&quot; direction, not useful for merging */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2103" title="optimizer/path/pathkeys.c:2103">right_merge_direction</a>(root, pathkey))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First look into the EquivalenceClass of the pathkey, to see if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> members not yet joined to the rel.&nbsp; If so, it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * surely possible to generate a mergejoin clause using them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;has_eclass_joins &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="equivclass.c.html#L3223" title="optimizer/path/equivclass.c:3223">eclass_useful_for_merging</a>(root, pathkey-&gt;pk_eclass, rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matched = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise search the rel's joininfo list, which contains<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-EquivalenceClass-derivable join clauses that might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nonetheless be mergejoinable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(j, rel-&gt;joininfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *restrictinfo = (RestrictInfo *) lfirst(j);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (restrictinfo-&gt;mergeopfamilies == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1493" title="optimizer/path/pathkeys.c:1493">update_mergeclause_eclasses</a>(root, restrictinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pathkey-&gt;pk_eclass == restrictinfo-&gt;left_ec ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkey-&gt;pk_eclass == restrictinfo-&gt;right_ec)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matched = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a mergeclause, we're done --- <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> additional<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sort-key positions in the pathkeys are useless.&nbsp; (But we can still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mergejoin if we found at least one mergeclause.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (matched)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; useful++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> useful;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2103" title="optimizer/path/pathkeys.c:2103">right_merge_direction</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Check whether the pathkey embodies the preferred sort direction<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; for merging its target column.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2103">&#x200c;</a></span><span class="linkable">right_merge_direction</span>(PlannerInfo *root, PathKey *pathkey)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, root-&gt;query_pathkeys)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *query_pathkey = (PathKey *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pathkey-&gt;pk_eclass == query_pathkey-&gt;pk_eclass &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkey-&gt;pk_opfamily == query_pathkey-&gt;pk_opfamily)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Found a matching query sort column.&nbsp; Prefer this pathkey's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * direction iff it matches.&nbsp; Note that we ignore pk_nulls_first,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which means that a sort might be needed anyway ... but we still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * want to prefer only one of the two possible directions, and we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might as well use this one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (pathkey-&gt;pk_strategy == query_pathkey-&gt;pk_strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If no matching ORDER BY request, prefer the ASC direction */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (pathkey-&gt;pk_strategy == BTLessStrategyNumber);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2140" title="optimizer/path/pathkeys.c:2140">pathkeys_useful_for_ordering</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Count the number of pathkeys that are useful for meeting the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; query's requested output ordering.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Because we the have the possibility of incremental sort, a prefix list of<br/></li>
<li></span><span class="Comment"> * keys is potentially useful for improving the performance of the requested<br/></li>
<li></span><span class="Comment"> * ordering. Thus we return 0, if no valuable keys are found, or the number<br/></li>
<li></span><span class="Comment"> * of leading keys shared by the list and the requested ordering..<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2140">&#x200c;</a></span><span class="linkable">pathkeys_useful_for_ordering</span>(PlannerInfo *root, List *pathkeys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n_common_pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L573" title="optimizer/path/pathkeys.c:573">pathkeys_count_contained_in</a>(root-&gt;query_pathkeys, pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;n_common_pathkeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> n_common_pathkeys;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2170" title="optimizer/path/pathkeys.c:2170">pathkeys_useful_for_grouping</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Count the number of pathkeys that are useful for grouping (instead of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; explicit sort)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Group pathkeys could be reordered to benefit from the ordering. The<br/></li>
<li></span><span class="Comment"> * ordering may not be &quot;complete&quot; and may require incremental sort, but that's<br/></li>
<li></span><span class="Comment"> * fine. So we simply count prefix pathkeys with a matching group key, and<br/></li>
<li></span><span class="Comment"> * stop once we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the first pathkey without a match.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * So e.g. with pathkeys (a,b,c) and group keys (a,b,e) this determines (a,b)<br/></li>
<li></span><span class="Comment"> * pathkeys are useful for grouping, and we might do incremental sort to get<br/></li>
<li></span><span class="Comment"> * path ordered by (a,b,e).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This logic is necessary to retain paths with ordering not matching grouping<br/></li>
<li></span><span class="Comment"> * keys directly, without the reordering.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the length of pathkey prefix with matching group keys.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2170">&#x200c;</a></span><span class="linkable">pathkeys_useful_for_grouping</span>(PlannerInfo *root, List *pathkeys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *key;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no special ordering requested for grouping */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;group_pathkeys == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* walk the pathkeys and search for matching group key */<br/></li>
<li></span>&nbsp; &nbsp; foreach(key, pathkeys)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *pathkey = (PathKey *) lfirst(key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no matching group key, we're done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/list.c.html#L682" title="nodes/list.c:682">list_member_ptr</a>(root-&gt;group_pathkeys, pathkey))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> n;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2200" title="optimizer/path/pathkeys.c:2200">pathkeys_useful_for_setop</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Count the number of leading common pathkeys root's 'setop_pathkeys' in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; 'pathkeys'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2200">&#x200c;</a></span><span class="linkable">pathkeys_useful_for_setop</span>(PlannerInfo *root, List *pathkeys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n_common_pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L573" title="optimizer/path/pathkeys.c:573">pathkeys_count_contained_in</a>(root-&gt;setop_pathkeys, pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;n_common_pathkeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> n_common_pathkeys;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2215" title="optimizer/path/pathkeys.c:2215">truncate_useless_pathkeys</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Shorten the given pathkey list to just the useful pathkeys.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L2215">&#x200c;</a><span class="linkable">truncate_useless_pathkeys</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *pathkeys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nuseful;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nuseful2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nuseful = <a href="#L2036" title="optimizer/path/pathkeys.c:2036">pathkeys_useful_for_merging</a>(root, rel, pathkeys);<br/></li>
<li>&nbsp; &nbsp; nuseful2 = <a href="#L2140" title="optimizer/path/pathkeys.c:2140">pathkeys_useful_for_ordering</a>(root, pathkeys);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nuseful2 &gt; nuseful)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nuseful = nuseful2;<br/></li>
<li>&nbsp; &nbsp; nuseful2 = <a href="#L2170" title="optimizer/path/pathkeys.c:2170">pathkeys_useful_for_grouping</a>(root, pathkeys);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nuseful2 &gt; nuseful)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nuseful = nuseful2;<br/></li>
<li>&nbsp; &nbsp; nuseful2 = <a href="#L2200" title="optimizer/path/pathkeys.c:2200">pathkeys_useful_for_setop</a>(root, pathkeys);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nuseful2 &gt; nuseful)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nuseful = nuseful2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: not safe to modify input list destructively, but we can avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * copying the list if we're not actually going to change it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nuseful == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (nuseful == list_length(pathkeys))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> pathkeys;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../nodes/list.c.html#L1593" title="nodes/list.c:1593">list_copy_head</a>(pathkeys, nuseful);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2261" title="optimizer/path/pathkeys.c:2261">has_useful_pathkeys</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Detect whether the specified rel could have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pathkeys that are<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; useful according to <a href="#L2215" title="optimizer/path/pathkeys.c:2215">truncate_useless_pathkeys</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a cheap test that lets us <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> building pathkeys at all in very<br/></li>
<li></span><span class="Comment"> * simple queries.&nbsp; It's OK to err in the direction of returning &quot;true&quot; when<br/></li>
<li></span><span class="Comment"> * there really aren't <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> usable pathkeys, but erring in the other direction<br/></li>
<li></span><span class="Comment"> * is bad --- so keep this in sync with the routines above!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We could make the test more complex, for example checking to see if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of<br/></li>
<li></span><span class="Comment"> * the joinclauses are really mergejoinable, but that likely wouldn't win<br/></li>
<li></span><span class="Comment"> * often enough to repay the extra cycles.&nbsp; Queries with neither a join nor<br/></li>
<li></span><span class="Comment"> * a sort are reasonably common, though, so this much work seems worthwhile.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2261">&#x200c;</a></span><span class="linkable">has_useful_pathkeys</span>(PlannerInfo *root, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;joininfo != NIL || rel-&gt;has_eclass_joins)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* might be able to use pathkeys for merging */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;group_pathkeys != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* might be able to use pathkeys for grouping */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;query_pathkeys != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* might be able to use them for ordering */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* definitely useless */<br/></li>
<li></span>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
