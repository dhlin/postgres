<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>optimizer/path/allpaths.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>optimizer/path/allpaths.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L79">enable_geqo</a></li>
<li><a href="#L80">geqo_threshold</a></li>
<li><a href="#L88">join_search_hook</a></li>
<li><a href="#L82">min_parallel_index_scan_size</a></li>
<li><a href="#L81">min_parallel_table_scan_size</a></li>
<li><a href="#L85">set_rel_pathlist_hook</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L70">pushdown_safe_type</a></li>
<li><a href="#L76">pushdown_safe_type</a></li>
<li><a href="#L60">pushdown_safety_info</a></li>
<li><a href="#L67">pushdown_safety_info</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L2087">accumulate_append_subpath</a></li>
<li><a href="#L1302">add_paths_to_append_rel</a></li>
<li><a href="#L2419">check_and_push_window_quals</a></li>
<li><a href="#L3719">check_output_expressions</a></li>
<li><a href="#L3791">compare_tlist_datatypes</a></li>
<li><a href="#L4215">compute_parallel_worker</a></li>
<li><a href="#L4179">create_partial_bitmap_paths</a></li>
<li><a href="#L794">create_plain_partial_paths</a></li>
<li><a href="#L2214">find_window_run_conditions</a></li>
<li><a href="#L3064">generate_gather_paths</a></li>
<li><a href="#L1714">generate_orderedappend_paths</a></li>
<li><a href="#L4303">generate_partitionwise_join_paths</a></li>
<li><a href="#L3202">generate_useful_gather_paths</a></li>
<li><a href="#L1999">get_cheapest_parameterized_child_path</a></li>
<li><a href="#L2132">get_singleton_append_subpath</a></li>
<li><a href="#L3134">get_useful_pathkeys_for_relation</a></li>
<li><a href="#L171">make_one_rel</a></li>
<li><a href="#L3318">make_rel_from_joinlist</a></li>
<li><a href="#L3867">qual_is_pushdown_safe</a></li>
<li><a href="#L4015">recurse_push_qual</a></li>
<li><a href="#L3650">recurse_pushdown_safe</a></li>
<li><a href="#L4067">remove_unused_subquery_outputs</a></li>
<li><a href="#L1232">set_append_rel_pathlist</a></li>
<li><a href="#L944">set_append_rel_size</a></li>
<li><a href="#L247">set_base_rel_consider_startup</a></li>
<li><a href="#L333">set_base_rel_pathlists</a></li>
<li><a href="#L290">set_base_rel_sizes</a></li>
<li><a href="#L2872">set_cte_pathlist</a></li>
<li><a href="#L2166">set_dummy_rel_pathlist</a></li>
<li><a href="#L926">set_foreign_pathlist</a></li>
<li><a href="#L902">set_foreign_size</a></li>
<li><a href="#L2761">set_function_pathlist</a></li>
<li><a href="#L2951">set_namedtuplestore_pathlist</a></li>
<li><a href="#L764">set_plain_rel_pathlist</a></li>
<li><a href="#L572">set_plain_rel_size</a></li>
<li><a href="#L589">set_rel_consider_parallel</a></li>
<li><a href="#L469">set_rel_pathlist</a></li>
<li><a href="#L360">set_rel_size</a></li>
<li><a href="#L2978">set_result_pathlist</a></li>
<li><a href="#L2494">set_subquery_pathlist</a></li>
<li><a href="#L2848">set_tablefunc_pathlist</a></li>
<li><a href="#L854">set_tablesample_rel_pathlist</a></li>
<li><a href="#L814">set_tablesample_rel_size</a></li>
<li><a href="#L2828">set_values_pathlist</a></li>
<li><a href="#L3005">set_worktable_pathlist</a></li>
<li><a href="#L3423">standard_join_search</a></li>
<li><a href="#L3594">subquery_is_pushdown_safe</a></li>
<li><a href="#L3968">subquery_push_qual</a></li>
<li><a href="#L3824">targetIsInAllPartitionLists</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L54">UNSAFE_HAS_SET_FUNC</a></li>
<li><a href="#L53">UNSAFE_HAS_VOLATILE_FUNC</a></li>
<li><a href="#L55">UNSAFE_NOTIN_DISTINCTON_CLAUSE</a></li>
<li><a href="#L56">UNSAFE_NOTIN_PARTITIONBY_CLAUSE</a></li>
<li><a href="#L57">UNSAFE_TYPE_MISMATCH</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * allpaths.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Routines to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> possible search paths for processing a query<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/optimizer/path/allpaths.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/sysattr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tsmapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_class.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_operator.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;foreign/fdwapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/supportnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#ifdef OPTIMIZER_DEBUG<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/<a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/appendinfo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/clauses.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/cost.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/<a href="../geqo/geqo_main.c.html#L72" title="optimizer/geqo/geqo_main.c:72">geqo</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/pathnode.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/paths.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/plancat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/<a href="../plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/tlist.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_clause.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parsetree.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;partitioning/partbounds.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bitutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;rewrite/rewriteManip.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* Bitmask flags for <a href="#L60" title="optimizer/path/allpaths.c:60">pushdown_safety_info</a>.unsafeFlags */<br/></li>
<li><a id="L53">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">UNSAFE_HAS_VOLATILE_FUNC</span>&nbsp; &nbsp; &nbsp; &nbsp; (</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L54">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">UNSAFE_HAS_SET_FUNC</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; </span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li><a id="L55">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">UNSAFE_NOTIN_DISTINCTON_CLAUSE</span>&nbsp; &nbsp; (</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; </span><span class="Constant">2</span><span class="PreProc">)<br/></li>
<li><a id="L56">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">UNSAFE_NOTIN_PARTITIONBY_CLAUSE</span>&nbsp; &nbsp; (</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; </span><span class="Constant">3</span><span class="PreProc">)<br/></li>
<li><a id="L57">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">UNSAFE_TYPE_MISMATCH</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; </span><span class="Constant">4</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* results of <a href="#L3594" title="optimizer/path/allpaths.c:3594">subquery_is_pushdown_safe</a> */<br/></li>
<li><a id="L60">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">pushdown_safety_info</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *unsafeFlags; <span class="Comment">/* bitmask of reasons why this target list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column is unsafe for qual pushdown, or 0 if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no reason. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; unsafeVolatile; <span class="Comment">/* don't <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> down volatile quals */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; unsafeLeaky;&nbsp; &nbsp; <span class="Comment">/* don't <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> down leaky quals */<br/></li>
<li><a id="L67">&#x200c;</a></span>} <span class="linkable">pushdown_safety_info</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Return type for <a href="#L3867" title="optimizer/path/allpaths.c:3867">qual_is_pushdown_safe</a> */<br/></li>
<li><a id="L70">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">enum</span> <span class="linkable">pushdown_safe_type</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PUSHDOWN_UNSAFE,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* unsafe to <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> qual into subquery */<br/></li>
<li></span>&nbsp; &nbsp; PUSHDOWN_SAFE,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* safe to <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> qual into subquery */<br/></li>
<li></span>&nbsp; &nbsp; PUSHDOWN_WINDOWCLAUSE_RUNCOND,&nbsp; &nbsp; <span class="Comment">/* unsafe, but may work as WindowClause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * run condition */<br/></li>
<li><a id="L76">&#x200c;</a></span>} <span class="linkable">pushdown_safe_type</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* These parameters are set by GUC */<br/></li>
<li><a id="L79">&#x200c;</a></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">enable_geqo</span> = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* just in case GUC doesn't set it */<br/></li>
<li><a id="L80">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">geqo_threshold</span>;<br/></li>
<li><a id="L81">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">min_parallel_table_scan_size</span>;<br/></li>
<li><a id="L82">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">min_parallel_index_scan_size</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Hook for plugins to get control in <a href="#L469" title="optimizer/path/allpaths.c:469">set_rel_pathlist</a>() */<br/></li>
<li><a id="L85">&#x200c;</a></span>set_rel_pathlist_hook_type <span class="linkable">set_rel_pathlist_hook</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Hook for plugins to replace <a href="#L3423" title="optimizer/path/allpaths.c:3423">standard_join_search</a>() */<br/></li>
<li><a id="L88">&#x200c;</a></span>join_search_hook_type <span class="linkable">join_search_hook</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L247" title="optimizer/path/allpaths.c:247">set_base_rel_consider_startup</a>(PlannerInfo *root);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L290" title="optimizer/path/allpaths.c:290">set_base_rel_sizes</a>(PlannerInfo *root);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L333" title="optimizer/path/allpaths.c:333">set_base_rel_pathlists</a>(PlannerInfo *root);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L360" title="optimizer/path/allpaths.c:360">set_rel_size</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index rti, RangeTblEntry *rte);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L469" title="optimizer/path/allpaths.c:469">set_rel_pathlist</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index rti, RangeTblEntry *rte);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L572" title="optimizer/path/allpaths.c:572">set_plain_rel_size</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RangeTblEntry *rte);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L794" title="optimizer/path/allpaths.c:794">create_plain_partial_paths</a>(PlannerInfo *root, RelOptInfo *rel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L589" title="optimizer/path/allpaths.c:589">set_rel_consider_parallel</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L764" title="optimizer/path/allpaths.c:764">set_plain_rel_pathlist</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RangeTblEntry *rte);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L814" title="optimizer/path/allpaths.c:814">set_tablesample_rel_size</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RangeTblEntry *rte);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L854" title="optimizer/path/allpaths.c:854">set_tablesample_rel_pathlist</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RangeTblEntry *rte);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L902" title="optimizer/path/allpaths.c:902">set_foreign_size</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RangeTblEntry *rte);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L926" title="optimizer/path/allpaths.c:926">set_foreign_pathlist</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RangeTblEntry *rte);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L944" title="optimizer/path/allpaths.c:944">set_append_rel_size</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index rti, RangeTblEntry *rte);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1232" title="optimizer/path/allpaths.c:1232">set_append_rel_pathlist</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index rti, RangeTblEntry *rte);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1714" title="optimizer/path/allpaths.c:1714">generate_orderedappend_paths</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *live_childrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *all_child_pathkeys);<br/></li>
<li><span class="Type">static</span> Path *<a href="#L1999" title="optimizer/path/allpaths.c:1999">get_cheapest_parameterized_child_path</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids required_outer);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2087" title="optimizer/path/allpaths.c:2087">accumulate_append_subpath</a>(Path *path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **subpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **special_subpaths);<br/></li>
<li><span class="Type">static</span> Path *<a href="#L2132" title="optimizer/path/allpaths.c:2132">get_singleton_append_subpath</a>(Path *path);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2166" title="optimizer/path/allpaths.c:2166">set_dummy_rel_pathlist</a>(RelOptInfo *rel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2494" title="optimizer/path/allpaths.c:2494">set_subquery_pathlist</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index rti, RangeTblEntry *rte);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2761" title="optimizer/path/allpaths.c:2761">set_function_pathlist</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2828" title="optimizer/path/allpaths.c:2828">set_values_pathlist</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2848" title="optimizer/path/allpaths.c:2848">set_tablefunc_pathlist</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RangeTblEntry *rte);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2872" title="optimizer/path/allpaths.c:2872">set_cte_pathlist</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RangeTblEntry *rte);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2951" title="optimizer/path/allpaths.c:2951">set_namedtuplestore_pathlist</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RangeTblEntry *rte);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2978" title="optimizer/path/allpaths.c:2978">set_result_pathlist</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3005" title="optimizer/path/allpaths.c:3005">set_worktable_pathlist</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RangeTblEntry *rte);<br/></li>
<li><span class="Type">static</span> RelOptInfo *<a href="#L3318" title="optimizer/path/allpaths.c:3318">make_rel_from_joinlist</a>(PlannerInfo *root, List *joinlist);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3594" title="optimizer/path/allpaths.c:3594">subquery_is_pushdown_safe</a>(Query *subquery, Query *topquery,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L60" title="optimizer/path/allpaths.c:60">pushdown_safety_info</a> *safetyInfo);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3650" title="optimizer/path/allpaths.c:3650">recurse_pushdown_safe</a>(Node *setOp, Query *topquery,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L60" title="optimizer/path/allpaths.c:60">pushdown_safety_info</a> *safetyInfo);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3719" title="optimizer/path/allpaths.c:3719">check_output_expressions</a>(Query *subquery,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L60" title="optimizer/path/allpaths.c:60">pushdown_safety_info</a> *safetyInfo);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3791" title="optimizer/path/allpaths.c:3791">compare_tlist_datatypes</a>(List *tlist, List *colTypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L60" title="optimizer/path/allpaths.c:60">pushdown_safety_info</a> *safetyInfo);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3824" title="optimizer/path/allpaths.c:3824">targetIsInAllPartitionLists</a>(TargetEntry *tle, Query *query);<br/></li>
<li><span class="Type">static</span> <a href="#L70" title="optimizer/path/allpaths.c:70">pushdown_safe_type</a> <a href="#L3867" title="optimizer/path/allpaths.c:3867">qual_is_pushdown_safe</a>(Query *subquery, Index rti,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L60" title="optimizer/path/allpaths.c:60">pushdown_safety_info</a> *safetyInfo);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3968" title="optimizer/path/allpaths.c:3968">subquery_push_qual</a>(Query *subquery,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RangeTblEntry *rte, Index rti, Node *qual);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4015" title="optimizer/path/allpaths.c:4015">recurse_push_qual</a>(Node *setOp, Query *topquery,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte, Index rti, Node *qual);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4067" title="optimizer/path/allpaths.c:4067">remove_unused_subquery_outputs</a>(Query *subquery, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Bitmapset *extra_used_attrs);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L171" title="optimizer/path/allpaths.c:171">make_one_rel</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Finds all possible access paths for executing a query, returning a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; single rel that represents the join of all base rels in the query.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RelOptInfo *<br/></li>
<li><a id="L171">&#x200c;</a><span class="linkable">make_one_rel</span>(PlannerInfo *root, List *joinlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *rel;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; rti;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; total_pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark base rels as to whether we care about fast-start plans */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L247" title="optimizer/path/allpaths.c:247">set_base_rel_consider_startup</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute size estimates and consider_parallel flags for each base rel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L290" title="optimizer/path/allpaths.c:290">set_base_rel_sizes</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We should <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> have size estimates for every actual table involved in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the query, and we also know which if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> have been deleted from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * query by join removal, pruned by partition pruning, or eliminated by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constraint exclusion.&nbsp; So we can <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> compute total_table_pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that appendrels are not double-counted here, even though we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bother to distinguish RelOptInfos for appendrel parents, because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parents will have pages = 0.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> if a table is self-joined, we will count it once per appearance,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which perhaps is the wrong thing ... but that's not completely clear,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and detecting self-joins here is difficult, so ignore it for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; total_pages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (rti = <span class="Constant">1</span>; rti &lt; root-&gt;simple_rel_array_size; rti++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *brel = root-&gt;simple_rel_array[rti];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there may be empty slots corresponding to non-baserel RTEs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (brel == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(brel-&gt;relid == rti); <span class="Comment">/* sanity check on array */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IS_DUMMY_REL(brel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IS_SIMPLE_REL(brel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_pages += (<span class="Type">double</span>) brel-&gt;pages;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; root-&gt;total_table_pages = total_pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate access paths for each base rel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L333" title="optimizer/path/allpaths.c:333">set_base_rel_pathlists</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate access paths for the entire join tree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rel = <a href="#L3318" title="optimizer/path/allpaths.c:3318">make_rel_from_joinlist</a>(root, joinlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The result should join all and only the query's base + outer-join rels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(rel-&gt;relids, root-&gt;all_query_rels));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L247" title="optimizer/path/allpaths.c:247">set_base_rel_consider_startup</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Set the consider_[param_]startup flags for each base-relation entry.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For the moment, we only deal with consider_param_startup here; because the<br/></li>
<li></span><span class="Comment"> * logic for consider_startup is pretty trivial and is the same for every base<br/></li>
<li></span><span class="Comment"> * relation, we just let <a href="../util/relnode.c.html#L192" title="optimizer/util/relnode.c:192">build_simple_rel</a>() <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> that flag correctly to<br/></li>
<li></span><span class="Comment"> * start with.&nbsp; If that logic ever gets more complicated it would probably<br/></li>
<li></span><span class="Comment"> * be better to move it here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L247">&#x200c;</a></span><span class="linkable">set_base_rel_consider_startup</span>(PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since parameterized paths can only be used on the inside of a nestloop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * join plan, there is usually little value in considering fast-start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plans for them.&nbsp; However, for relations that are on the RHS of a SEMI<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or ANTI join, a fast-start plan can be useful because we're only going<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to care about fetching one tuple anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To minimize growth of planning time, we currently restrict this to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases where the RHS is a single base relation, not a join; there is no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * provision for consider_param_startup to get set at all on joinrels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also we don't worry about appendrels.&nbsp; costsize.c's costing rules for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nestloop semi/antijoins don't consider such cases either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, root-&gt;join_info_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpecialJoinInfo *sjinfo = (SpecialJoinInfo *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((sjinfo-&gt;jointype == JOIN_SEMI || sjinfo-&gt;jointype == JOIN_ANTI) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L715" title="nodes/bitmapset.c:715">bms_get_singleton_member</a>(sjinfo-&gt;syn_righthand, &amp;varno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel = <a href="../util/relnode.c.html#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(root, varno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;consider_param_startup = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L290" title="optimizer/path/allpaths.c:290">set_base_rel_sizes</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Set the size estimates (rows and widths) for each base-relation entry.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Also determine whether to consider parallel paths for base relations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We do this in a separate pass over the base rels so that rowcount<br/></li>
<li></span><span class="Comment"> * estimates are available for parameterized path generation, and also so<br/></li>
<li></span><span class="Comment"> * that each rel's consider_parallel flag is set correctly <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we begin to<br/></li>
<li></span><span class="Comment"> * generate paths.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L290">&#x200c;</a></span><span class="linkable">set_base_rel_sizes</span>(PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; rti;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (rti = <span class="Constant">1</span>; rti &lt; root-&gt;simple_rel_array_size; rti++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel = root-&gt;simple_rel_array[rti];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there may be empty slots corresponding to non-baserel RTEs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(rel-&gt;relid == rti);&nbsp; &nbsp; <span class="Comment">/* sanity check on array */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore RTEs that are &quot;other rels&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;reloptkind != RELOPT_BASEREL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rte = root-&gt;simple_rte_array[rti];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If parallelism is allowable for this query in general, see whether<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's allowable for this rel in particular.&nbsp; We have to do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="#L360" title="optimizer/path/allpaths.c:360">set_rel_size</a>(), because (a) if this rel is an inheritance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parent, <a href="#L944" title="optimizer/path/allpaths.c:944">set_append_rel_size</a>() will use and perhaps change the rel's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consider_parallel flag, and (b) for some RTE types, <a href="#L360" title="optimizer/path/allpaths.c:360">set_rel_size</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * goes ahead and makes paths immediately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;glob-&gt;parallelModeOK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L589" title="optimizer/path/allpaths.c:589">set_rel_consider_parallel</a>(root, rel, rte);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L360" title="optimizer/path/allpaths.c:360">set_rel_size</a>(root, rel, rti, rte);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L333" title="optimizer/path/allpaths.c:333">set_base_rel_pathlists</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Finds all paths available for scanning each base-relation entry.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Sequential scan and <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> available indices are considered.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Each useful path is attached to its relation's 'pathlist' field.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L333">&#x200c;</a></span><span class="linkable">set_base_rel_pathlists</span>(PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; rti;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (rti = <span class="Constant">1</span>; rti &lt; root-&gt;simple_rel_array_size; rti++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel = root-&gt;simple_rel_array[rti];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there may be empty slots corresponding to non-baserel RTEs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(rel-&gt;relid == rti);&nbsp; &nbsp; <span class="Comment">/* sanity check on array */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore RTEs that are &quot;other rels&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;reloptkind != RELOPT_BASEREL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L469" title="optimizer/path/allpaths.c:469">set_rel_pathlist</a>(root, rel, rti, root-&gt;simple_rte_array[rti]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L360" title="optimizer/path/allpaths.c:360">set_rel_size</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Set size estimates for a base relation<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L360">&#x200c;</a></span><span class="linkable">set_rel_size</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index rti, RangeTblEntry *rte)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;reloptkind == RELOPT_BASEREL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/plancat.c.html#L1557" title="optimizer/util/plancat.c:1557">relation_excluded_by_constraints</a>(root, rel, rte))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We proved we don't need to scan the rel via constraint exclusion,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so set up a single dummy path for it.&nbsp; Here we only check this for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * regular baserels; if it's an otherrel, CE was already checked in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L944" title="optimizer/path/allpaths.c:944">set_append_rel_size</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In this case, we go ahead and set up the relation's path right away<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * instead of leaving it for <a href="#L469" title="optimizer/path/allpaths.c:469">set_rel_pathlist</a> to do.&nbsp; This is because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we don't have a convention for marking a rel as dummy except by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assigning a dummy path to it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2166" title="optimizer/path/allpaths.c:2166">set_dummy_rel_pathlist</a>(rel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rte-&gt;inh)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It's an &quot;append relation&quot;, process accordingly */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L944" title="optimizer/path/allpaths.c:944">set_append_rel_size</a>(root, rel, rti, rte);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (rel-&gt;rtekind)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_RELATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;relkind == RELKIND_FOREIGN_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Foreign table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L902" title="optimizer/path/allpaths.c:902">set_foreign_size</a>(root, rel, rte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rte-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We could get here if asked to scan a partitioned table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with ONLY.&nbsp; In that case we shouldn't scan <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partitions, so mark it as a dummy rel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2166" title="optimizer/path/allpaths.c:2166">set_dummy_rel_pathlist</a>(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rte-&gt;tablesample != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sampled relation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L814" title="optimizer/path/allpaths.c:814">set_tablesample_rel_size</a>(root, rel, rte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Plain relation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L572" title="optimizer/path/allpaths.c:572">set_plain_rel_size</a>(root, rel, rte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_SUBQUERY:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Subqueries don't support making a choice between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parameterized and unparameterized paths, so just go ahead<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and build their paths immediately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2494" title="optimizer/path/allpaths.c:2494">set_subquery_pathlist</a>(root, rel, rti, rte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_FUNCTION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="costsize.c.html#L5872" title="optimizer/path/costsize.c:5872">set_function_size_estimates</a>(root, rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_TABLEFUNC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="costsize.c.html#L5910" title="optimizer/path/costsize.c:5910">set_tablefunc_size_estimates</a>(root, rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_VALUES:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="costsize.c.html#L5932" title="optimizer/path/costsize.c:5932">set_values_size_estimates</a>(root, rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_CTE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * CTEs don't support making a choice between parameterized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and unparameterized paths, so just go ahead and build their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * paths immediately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;self_reference)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3005" title="optimizer/path/allpaths.c:3005">set_worktable_pathlist</a>(root, rel, rte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2872" title="optimizer/path/allpaths.c:2872">set_cte_pathlist</a>(root, rel, rte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_NAMEDTUPLESTORE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Might as well just build the path immediately */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2951" title="optimizer/path/allpaths.c:2951">set_namedtuplestore_pathlist</a>(root, rel, rte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_RESULT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Might as well just build the path immediately */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2978" title="optimizer/path/allpaths.c:2978">set_result_pathlist</a>(root, rel, rte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected rtekind: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) rel-&gt;rtekind);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We insist that all non-dummy rels have a nonzero rowcount estimate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(rel-&gt;rows &gt; <span class="Constant">0</span> || IS_DUMMY_REL(rel));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L469" title="optimizer/path/allpaths.c:469">set_rel_pathlist</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Build access paths for a base relation<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L469">&#x200c;</a></span><span class="linkable">set_rel_pathlist</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index rti, RangeTblEntry *rte)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IS_DUMMY_REL(rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We already proved the relation empty, so nothing more to do */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rte-&gt;inh)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It's an &quot;append relation&quot;, process accordingly */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1232" title="optimizer/path/allpaths.c:1232">set_append_rel_pathlist</a>(root, rel, rti, rte);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (rel-&gt;rtekind)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_RELATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;relkind == RELKIND_FOREIGN_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Foreign table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L926" title="optimizer/path/allpaths.c:926">set_foreign_pathlist</a>(root, rel, rte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rte-&gt;tablesample != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sampled relation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L854" title="optimizer/path/allpaths.c:854">set_tablesample_rel_pathlist</a>(root, rel, rte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Plain relation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L764" title="optimizer/path/allpaths.c:764">set_plain_rel_pathlist</a>(root, rel, rte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_SUBQUERY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Subquery --- fully handled during <a href="#L360" title="optimizer/path/allpaths.c:360">set_rel_size</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_FUNCTION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* RangeFunction */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2761" title="optimizer/path/allpaths.c:2761">set_function_pathlist</a>(root, rel, rte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_TABLEFUNC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Table Function */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2848" title="optimizer/path/allpaths.c:2848">set_tablefunc_pathlist</a>(root, rel, rte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_VALUES:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Values list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2828" title="optimizer/path/allpaths.c:2828">set_values_pathlist</a>(root, rel, rte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_CTE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* CTE reference --- fully handled during <a href="#L360" title="optimizer/path/allpaths.c:360">set_rel_size</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_NAMEDTUPLESTORE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tuplestore reference --- fully handled during <a href="#L360" title="optimizer/path/allpaths.c:360">set_rel_size</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_RESULT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* simple Result --- fully handled during <a href="#L360" title="optimizer/path/allpaths.c:360">set_rel_size</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected rtekind: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) rel-&gt;rtekind);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allow a plugin to editorialize on the set of Paths for this base<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation.&nbsp; It could add new paths (such as CustomPaths) by calling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(), or <a href="../util/pathnode.c.html#L747" title="optimizer/util/pathnode.c:747">add_partial_path</a>() if parallel aware.&nbsp; It could also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * delete or modify paths added by the core code.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L85" title="optimizer/path/allpaths.c:85">set_rel_pathlist_hook</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*<a href="#L85" title="optimizer/path/allpaths.c:85">set_rel_pathlist_hook</a>) (root, rel, rti, rte);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is a baserel, we should normally consider gathering <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> partial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * paths we may have created for it.&nbsp; We have to do this after calling the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L85" title="optimizer/path/allpaths.c:85">set_rel_pathlist_hook</a>, else it cannot add partial paths to be included<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, if this is an inheritance child, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it.&nbsp; Otherwise, we could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end up with a very large number of gather nodes, each trying to grab<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its own pool of workers.&nbsp; Instead, we'll consider gathering partial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * paths for the parent appendrel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, if this is the topmost scan/join rel, we postpone gathering until<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the final scan/join targetlist is available (see <a href="../plan/planner.c.html#L1305" title="optimizer/plan/planner.c:1305">grouping_planner</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;reloptkind == RELOPT_BASEREL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(rel-&gt;relids, root-&gt;all_query_rels))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3202" title="optimizer/path/allpaths.c:3202">generate_useful_gather_paths</a>(root, rel, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the cheapest of the paths for this rel */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/pathnode.c.html#L242" title="optimizer/util/pathnode.c:242">set_cheapest</a>(rel);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef OPTIMIZER_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../nodes/print.c.html#L54" title="nodes/print.c:54">pprint</a>(rel);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L572" title="optimizer/path/allpaths.c:572">set_plain_rel_size</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Set size estimates for a plain relation (no subquery, no inheritance)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L572">&#x200c;</a></span><span class="linkable">set_plain_rel_size</span>(PlannerInfo *root, RelOptInfo *rel, RangeTblEntry *rte)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Test <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> partial indexes of rel for applicability.&nbsp; We must do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first since partial unique indexes can affect size estimates.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="indxpath.c.html#L3244" title="optimizer/path/indxpath.c:3244">check_index_predicates</a>(root, rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark rel with estimated output rows, width, etc */<br/></li>
<li></span>&nbsp; &nbsp; <a href="costsize.c.html#L5239" title="optimizer/path/costsize.c:5239">set_baserel_size_estimates</a>(root, rel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * If this relation could possibly be scanned from within a worker, then set<br/></li>
<li></span><span class="Comment"> * its consider_parallel flag.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L589">&#x200c;</a></span><span class="linkable">set_rel_consider_parallel</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The flag has previously been initialized to false, so we can just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * return if it becomes clear that we can't safely set it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!rel-&gt;consider_parallel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't call this if parallelism is disallowed for the entire query. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(root-&gt;glob-&gt;parallelModeOK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This should only be called for baserels and appendrel children. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(IS_SIMPLE_REL(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assorted checks based on rtekind. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (rte-&gt;rtekind)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_RELATION:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Currently, parallel workers can't access the leader's temporary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tables.&nbsp; We could possibly relax this if we wrote all of its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * local buffers at the start of the query and made no changes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * thereafter (maybe we could allow hint <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> changes), and if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * taught the workers to read them.&nbsp; Writing a large number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * temporary buffers could be expensive, though, and we don't have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the rest of the necessary infrastructure right <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> anyway.&nbsp; So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, bail out if we see a temporary table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/cache/lsyscache.c.html#L2078" title="utils/cache/lsyscache.c:2078">get_rel_persistence</a>(rte-&gt;relid) == RELPERSISTENCE_TEMP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Table sampling can be pushed down to workers if the sample<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function and its arguments are safe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;tablesample != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; proparallel = <a href="../../utils/cache/lsyscache.c.html#L1799" title="utils/cache/lsyscache.c:1799">func_parallel</a>(rte-&gt;tablesample-&gt;tsmhandler);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proparallel != PROPARALLEL_SAFE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../util/clauses.c.html#L753" title="optimizer/util/clauses.c:753">is_parallel_safe</a>(root, (Node *) rte-&gt;tablesample-&gt;args))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ask FDWs whether they can support performing a ForeignScan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * within a worker.&nbsp; Most often, the answer will be no.&nbsp; For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * example, if the nature of the FDW is such that it opens a TCP<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * connection with a remote server, each parallel worker would end<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * up with a separate connection, and these connections might not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be appropriately coordinated between workers and the leader.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;relkind == RELKIND_FOREIGN_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rel-&gt;fdwroutine);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rel-&gt;fdwroutine-&gt;IsForeignScanParallelSafe)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rel-&gt;fdwroutine-&gt;IsForeignScanParallelSafe(root, rel, rte))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There are additional considerations for appendrels, which we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deal with in <a href="#L944" title="optimizer/path/allpaths.c:944">set_append_rel_size</a> and <a href="#L1232" title="optimizer/path/allpaths.c:1232">set_append_rel_pathlist</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, just set consider_parallel based on the rel's own<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * quals and targetlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_SUBQUERY:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There's no intrinsic problem with scanning a subquery-in-FROM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (as distinct from a SubPlan or <a href="../../executor/execMain.c.html#L833" title="executor/execMain.c:833">InitPlan</a>) in a parallel worker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the subquery doesn't happen to have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> parallel-safe paths,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then flagging it as consider_parallel won't change anything,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but that's true for plain tables, too.&nbsp; We must set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consider_parallel based on the rel's own quals and targetlist,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so that if a subquery path is parallel-safe but the quals and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * projection we're sticking onto it are not, we correctly mark<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the SubqueryScanPath as not parallel-safe.&nbsp; (Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L2494" title="optimizer/path/allpaths.c:2494">set_subquery_pathlist</a>() might <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> some of these quals down<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * into the subquery itself, but that doesn't change anything.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can't <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> sub-<a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> containing LIMIT/OFFSET to workers as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there is no guarantee that the row order will be fully<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deterministic, and applying LIMIT/OFFSET will lead to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inconsistent results at the top-level.&nbsp; (In some cases, where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the result is ordered, we could relax this restriction.&nbsp; But it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doesn't currently seem worth expending extra effort to do so.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *subquery = castNode(Query, rte-&gt;subquery);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../plan/planner.c.html#L2628" title="optimizer/plan/planner.c:2628">limit_needed</a>(subquery))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_JOIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Shouldn't happen; we're only considering baserels here. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_FUNCTION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for parallel-restricted <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../util/clauses.c.html#L753" title="optimizer/util/clauses.c:753">is_parallel_safe</a>(root, (Node *) rte-&gt;<a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_TABLEFUNC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not parallel safe */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_VALUES:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for parallel-restricted <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../util/clauses.c.html#L753" title="optimizer/util/clauses.c:753">is_parallel_safe</a>(root, (Node *) rte-&gt;values_lists))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_CTE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * CTE tuplestores aren't shared among parallel workers, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * force all CTE scans to happen in the leader.&nbsp; Also, populating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the CTE would require executing a subplan that's not available<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the worker, might be parallel-restricted, and must get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * executed only once.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_NAMEDTUPLESTORE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuplestore cannot be shared, at least without more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * infrastructure to support that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_RESULT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* RESULT RTEs, in themselves, are no problem. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there's anything in baserestrictinfo that's parallel-restricted, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * give up on parallelizing access to this relation.&nbsp; We could consider<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * instead postponing application of the restricted quals until we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * above all the parallelism in the plan tree, but it's not clear that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that would be a win in very many cases, and it might be tricky to make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * outer join clauses work correctly.&nbsp; It would likely break equivalence<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * classes, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../util/clauses.c.html#L753" title="optimizer/util/clauses.c:753">is_parallel_safe</a>(root, (Node *) rel-&gt;baserestrictinfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Likewise, if the relation's outputs are not parallel-safe, give up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Usually, they're just Vars, but sometimes they're not.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../util/clauses.c.html#L753" title="optimizer/util/clauses.c:753">is_parallel_safe</a>(root, (Node *) rel-&gt;reltarget-&gt;exprs))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We have a winner. */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;consider_parallel = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L764" title="optimizer/path/allpaths.c:764">set_plain_rel_pathlist</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Build access paths for a plain relation (no subquery, no inheritance)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L764">&#x200c;</a></span><span class="linkable">set_plain_rel_pathlist</span>(PlannerInfo *root, RelOptInfo *rel, RangeTblEntry *rte)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; required_outer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't support pushing join clauses into the quals of a seqscan, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it could still have required parameterization due to LATERAL refs in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its tlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; required_outer = rel-&gt;lateral_relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Consider sequential scan */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, <a href="../util/pathnode.c.html#L927" title="optimizer/util/pathnode.c:927">create_seqscan_path</a>(root, rel, required_outer, <span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If appropriate, consider parallel sequential scan */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;consider_parallel &amp;&amp; required_outer == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L794" title="optimizer/path/allpaths.c:794">create_plain_partial_paths</a>(root, rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Consider index scans */<br/></li>
<li></span>&nbsp; &nbsp; <a href="indxpath.c.html#L234" title="optimizer/path/indxpath.c:234">create_index_paths</a>(root, rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Consider TID scans */<br/></li>
<li></span>&nbsp; &nbsp; <a href="tidpath.c.html#L459" title="optimizer/path/tidpath.c:459">create_tidscan_paths</a>(root, rel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L794" title="optimizer/path/allpaths.c:794">create_plain_partial_paths</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Build partial access paths for parallel scan of a plain relation<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L794">&#x200c;</a></span><span class="linkable">create_plain_partial_paths</span>(PlannerInfo *root, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parallel_workers;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; parallel_workers = <a href="#L4215" title="optimizer/path/allpaths.c:4215">compute_parallel_worker</a>(rel, rel-&gt;pages, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="costsize.c.html#L132" title="optimizer/path/costsize.c:132">max_parallel_workers_per_gather</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> limit was set to zero, the user doesn't want a parallel scan. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parallel_workers &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add an unordered partial path based on a parallel sequential scan. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/pathnode.c.html#L747" title="optimizer/util/pathnode.c:747">add_partial_path</a>(rel, <a href="../util/pathnode.c.html#L927" title="optimizer/util/pathnode.c:927">create_seqscan_path</a>(root, rel, <span class="Constant">NULL</span>, parallel_workers));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L814" title="optimizer/path/allpaths.c:814">set_tablesample_rel_size</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Set size estimates for a sampled relation<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L814">&#x200c;</a></span><span class="linkable">set_tablesample_rel_size</span>(PlannerInfo *root, RelOptInfo *rel, RangeTblEntry *rte)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TableSampleClause *tsc = rte-&gt;tablesample;<br/></li>
<li>&nbsp; &nbsp; TsmRoutine *tsm;<br/></li>
<li>&nbsp; &nbsp; BlockNumber pages;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Test <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> partial indexes of rel for applicability.&nbsp; We must do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first since partial unique indexes can affect size estimates.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="indxpath.c.html#L3244" title="optimizer/path/indxpath.c:3244">check_index_predicates</a>(root, rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Call the sampling method's estimation function to estimate the number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of pages it will read and the number of tuples it will return.&nbsp; (Note:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we assume the function returns sane <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tsm = <a href="../../access/tablesample/tablesample.c.html#L27" title="access/tablesample/tablesample.c:27">GetTsmRoutine</a>(tsc-&gt;tsmhandler);<br/></li>
<li>&nbsp; &nbsp; tsm-&gt;SampleScanGetSampleSize(root, rel, tsc-&gt;args,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;pages, &amp;tuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For the moment, because we will only consider a SampleScan path for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rel, it's okay to just overwrite the pages and tuples estimates for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whole relation.&nbsp; If we ever consider multiple path types for sampled<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rels, we'll need more complication.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;pages = pages;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;tuples = tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark rel with estimated output rows, width, etc */<br/></li>
<li></span>&nbsp; &nbsp; <a href="costsize.c.html#L5239" title="optimizer/path/costsize.c:5239">set_baserel_size_estimates</a>(root, rel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L854" title="optimizer/path/allpaths.c:854">set_tablesample_rel_pathlist</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Build access paths for a sampled relation<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L854">&#x200c;</a></span><span class="linkable">set_tablesample_rel_pathlist</span>(PlannerInfo *root, RelOptInfo *rel, RangeTblEntry *rte)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; required_outer;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't support pushing join clauses into the quals of a samplescan,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but it could still have required parameterization due to LATERAL refs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in its tlist or TABLESAMPLE arguments.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; required_outer = rel-&gt;lateral_relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Consider sampled scan */<br/></li>
<li></span>&nbsp; &nbsp; path = <a href="../util/pathnode.c.html#L952" title="optimizer/util/pathnode.c:952">create_samplescan_path</a>(root, rel, required_outer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the sampling method does not support repeatable scans, we must avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plans that would scan the rel multiple times.&nbsp; Ideally, we'd simply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * avoid putting the rel on the inside of a nestloop join; but adding such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a consideration to the <a href="../plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> seems like a great deal of complication<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to support an uncommon usage of second-rate sampling methods.&nbsp; Instead,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if there is a risk that the query might perform an unsafe join, just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wrap the SampleScan in a Materialize node.&nbsp; We can check for joins by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * counting the membership of all_query_rels (note that this correctly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * counts inheritance trees as single rels).&nbsp; If we're inside a subquery,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we can't easily check whether a join might occur in the outer query, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just assume one is possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../access/tablesample/tablesample.c.html#L27" title="access/tablesample/tablesample.c:27">GetTsmRoutine</a> is relatively expensive compared to the other tests here,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so check repeatable_across_scans last, even though that's a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> odd.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((root-&gt;query_level &gt; <span class="Constant">1</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/bitmapset.c.html#L781" title="nodes/bitmapset.c:781">bms_membership</a>(root-&gt;all_query_rels) != BMS_SINGLETON) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !(<a href="../../access/tablesample/tablesample.c.html#L27" title="access/tablesample/tablesample.c:27">GetTsmRoutine</a>(rte-&gt;tablesample-&gt;tsmhandler)-&gt;repeatable_across_scans))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path = (Path *) <a href="../util/pathnode.c.html#L1566" title="optimizer/util/pathnode.c:1566">create_material_path</a>(rel, path);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For the moment, at least, there are no other paths to consider */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L902" title="optimizer/path/allpaths.c:902">set_foreign_size</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set size estimates for a foreign table RTE<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L902">&#x200c;</a></span><span class="linkable">set_foreign_size</span>(PlannerInfo *root, RelOptInfo *rel, RangeTblEntry *rte)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark rel with estimated output rows, width, etc */<br/></li>
<li></span>&nbsp; &nbsp; <a href="costsize.c.html#L6064" title="optimizer/path/costsize.c:6064">set_foreign_size_estimates</a>(root, rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Let FDW adjust the size estimates, if it can */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;fdwroutine-&gt;GetForeignRelSize(root, rel, rte-&gt;relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... but do not let it set the rows estimate to zero */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;rows = <a href="costsize.c.html#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(rel-&gt;rows);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, make sure rel-&gt;tuples is not insane relative to rel-&gt;rows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Notably, this ensures sanity if pg_class.reltuples contains -1 and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * FDW doesn't do anything to replace that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;tuples = Max(rel-&gt;tuples, rel-&gt;rows);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L926" title="optimizer/path/allpaths.c:926">set_foreign_pathlist</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Build access paths for a foreign table RTE<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L926">&#x200c;</a></span><span class="linkable">set_foreign_pathlist</span>(PlannerInfo *root, RelOptInfo *rel, RangeTblEntry *rte)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Call the FDW's GetForeignPaths function to generate path(s) */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;fdwroutine-&gt;GetForeignPaths(root, rel, rte-&gt;relid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L944" title="optimizer/path/allpaths.c:944">set_append_rel_size</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Set size estimates for a simple &quot;append relation&quot;<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The passed-in rel and RTE represent the entire append relation.&nbsp; The<br/></li>
<li></span><span class="Comment"> * relation's contents are computed by appending together the output of the<br/></li>
<li></span><span class="Comment"> * individual member relations.&nbsp; Note that in the non-partitioned inheritance<br/></li>
<li></span><span class="Comment"> * case, the first member relation is actually the same table as is mentioned<br/></li>
<li></span><span class="Comment"> * in the parent RTE ... but it has a different RTE and RelOptInfo.&nbsp; This is<br/></li>
<li></span><span class="Comment"> * a good thing because their outputs are not the same size.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L944">&#x200c;</a></span><span class="linkable">set_append_rel_size</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index rti, RangeTblEntry *rte)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentRTindex = rti;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_live_children;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; parent_rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; parent_size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp;&nbsp; *parent_attrsizes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nattrs;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Guard against stack overflow due to overly deep inheritance tree. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(IS_SIMPLE_REL(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is a partitioned baserel, set the consider_partitionwise_join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * flag; currently, we only consider partitionwise joins with the baserel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if its targetlist doesn't contain a whole-row Var.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="costsize.c.html#L148" title="optimizer/path/costsize.c:148">enable_partitionwise_join</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;reloptkind == RELOPT_BASEREL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;relkind == RELKIND_PARTITIONED_TABLE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bms_is_empty(rel-&gt;attr_needed[InvalidAttrNumber - rel-&gt;min_attr]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;consider_partitionwise_join = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize to compute size estimates for whole append relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We handle width estimates by weighting the widths of different child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rels proportionally to their number of rows.&nbsp; This is sensible because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the use of width estimates is mainly to compute the total relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;footprint&quot; if we have to sort or <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> it.&nbsp; To do this, we sum the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * total equivalent size (in &quot;double&quot; arithmetic) and then divide by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * total rowcount estimate.&nbsp; This is done separately for the total rel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * width and each attribute.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: if you consider changing this logic, beware that child rels could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have zero rows and/or width, if they were excluded by constraints.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; has_live_children = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; parent_rows = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; parent_size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; nattrs = rel-&gt;max_attr - rel-&gt;min_attr + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; parent_attrsizes = (<span class="Type">double</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(nattrs * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">double</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, root-&gt;append_rel_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AppendRelInfo *appinfo = (AppendRelInfo *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childRTindex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *childRTE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *childrel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *childrinfos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *parentvars;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *childvars;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* append_rel_list contains all append rels; ignore others */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (appinfo-&gt;parent_relid != parentRTindex)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; childRTindex = appinfo-&gt;child_relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; childRTE = root-&gt;simple_rte_array[childRTindex];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The child rel's RelOptInfo was already created during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../plan/initsplan.c.html#L195" title="optimizer/plan/initsplan.c:195">add_other_rels_to_query</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; childrel = <a href="../util/relnode.c.html#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(root, childRTindex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(childrel-&gt;reloptkind == RELOPT_OTHER_MEMBER_REL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We may have already proven the child to be dummy. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IS_DUMMY_REL(childrel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have to copy the parent's targetlist and quals to the child,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with appropriate substitution of variables.&nbsp; However, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * baserestrictinfo quals were already copied/substituted when the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * child RelOptInfo was built.&nbsp; So we don't need <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> additional setup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> applying constraint exclusion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/plancat.c.html#L1557" title="optimizer/util/plancat.c:1557">relation_excluded_by_constraints</a>(root, childrel, childRTE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This child need not be scanned, so we can omit it from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * appendrel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2166" title="optimizer/path/allpaths.c:2166">set_dummy_rel_pathlist</a>(childrel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Constraint exclusion failed, so copy the parent's join quals and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * targetlist to the child, with appropriate variable substitutions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> join quals that came from above outer joins that can null<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this rel, since they would be of no value while generating paths<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for the child.&nbsp; This saves some effort while processing the child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rel, and it also avoids an implementation restriction in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../util/appendinfo.c.html#L196" title="optimizer/util/appendinfo.c:196">adjust_appendrel_attrs</a> (it can't apply nullingrels to a non-Var).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; childrinfos = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, rel-&gt;joininfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(rinfo-&gt;clause_relids, rel-&gt;nulling_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrinfos = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(childrinfos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/appendinfo.c.html#L196" title="optimizer/util/appendinfo.c:196">adjust_appendrel_attrs</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1</span>, &amp;appinfo));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; childrel-&gt;joininfo = childrinfos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now for the child's targetlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NB: the resulting childrel-&gt;reltarget-&gt;exprs may contain arbitrary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expressions, which otherwise would not occur in a rel's targetlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Code that might be looking at an appendrel child must cope with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * such.&nbsp; (Normally, a rel's targetlist would only include Vars and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PlaceHolderVars.)&nbsp; </span><span class="Todo">XXX</span><span class="Comment"> we do not bother to update the cost or width<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fields of childrel-&gt;reltarget; not clear if that would be useful.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; childrel-&gt;reltarget-&gt;exprs = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/appendinfo.c.html#L196" title="optimizer/util/appendinfo.c:196">adjust_appendrel_attrs</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) rel-&gt;reltarget-&gt;exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1</span>, &amp;appinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have to make child entries in the EquivalenceClass data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * structures as well.&nbsp; This is needed either if the parent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * participates in some <a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a> joins (because we will want to consider<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inner-indexscan joins on the individual children) or if the parent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * has useful pathkeys (because we should try to build MergeAppend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * paths that produce those sort orderings).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;has_eclass_joins || <a href="pathkeys.c.html#L2261" title="optimizer/path/pathkeys.c:2261">has_useful_pathkeys</a>(root, rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="equivclass.c.html#L2647" title="optimizer/path/equivclass.c:2647">add_child_rel_equivalences</a>(root, appinfo, rel, childrel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; childrel-&gt;has_eclass_joins = rel-&gt;has_eclass_joins;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: we could compute appropriate attr_needed data for the child's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * variables, by transforming the parent's attr_needed through the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * translated_vars mapping.&nbsp; However, currently there's no need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because attr_needed is only examined for base relations not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherrels.&nbsp; So we just leave the child's attr_needed empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we consider partitionwise joins with the parent rel, do the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for partitioned child rels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: here we abuse the consider_partitionwise_join flag by setting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it for child rels that are not themselves partitioned.&nbsp; We do so to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tell <a href="joinrels.c.html#L1478" title="optimizer/path/joinrels.c:1478">try_partitionwise_join</a>() that the child rel is sufficiently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * valid to be used as a per-partition input, even if it later gets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * proven to be dummy.&nbsp; (It's not usable until we've set up the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reltarget and EC entries, which we just did.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;consider_partitionwise_join)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrel-&gt;consider_partitionwise_join = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If parallelism is allowable for this query in general, see whether<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's allowable for this childrel in particular.&nbsp; But if we've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already decided the appendrel is not parallel-safe as a whole,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there's no point in considering parallelism for this child.&nbsp; For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consistency, do this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling <a href="#L360" title="optimizer/path/allpaths.c:360">set_rel_size</a>() for the child.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;glob-&gt;parallelModeOK &amp;&amp; rel-&gt;consider_parallel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L589" title="optimizer/path/allpaths.c:589">set_rel_consider_parallel</a>(root, childrel, childRTE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compute the child's size.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L360" title="optimizer/path/allpaths.c:360">set_rel_size</a>(root, childrel, childRTindex, childRTE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It is possible that constraint exclusion detected a contradiction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * within a child subquery, even though we didn't prove one above. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so, we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this child.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IS_DUMMY_REL(childrel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We have at least one live child. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; has_live_children = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> live child is not parallel-safe, treat the whole appendrel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as not parallel-safe.&nbsp; In future we might be able to generate plans<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in which some children are farmed out to workers while others are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not; but we don't have that today, so it's a waste to consider<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partial paths anywhere in the appendrel unless it's all safe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (Child rels visited <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> this one will be unmarked in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1232" title="optimizer/path/allpaths.c:1232">set_append_rel_pathlist</a>().)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!childrel-&gt;consider_parallel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;consider_parallel = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Accumulate size information from each live child.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(childrel-&gt;rows &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent_rows += childrel-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent_size += childrel-&gt;reltarget-&gt;width * childrel-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Accumulate per-column estimates too.&nbsp; We need not do anything for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PlaceHolderVars in the parent list.&nbsp; If child expression isn't a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Var, or we didn't record a width estimate for it, we have to fall<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * back on a datatype-based estimate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * By construction, child's targetlist is 1-to-1 with parent's.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; forboth(parentvars, rel-&gt;reltarget-&gt;exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childvars, childrel-&gt;reltarget-&gt;exprs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *parentvar = (Var *) lfirst(parentvars);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *childvar = (Node *) lfirst(childvars);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(parentvar, Var) &amp;&amp; parentvar-&gt;varno == parentRTindex)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pndx = parentvar-&gt;varattno - rel-&gt;min_attr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; child_width = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(childvar, Var) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((Var *) childvar)-&gt;varno == childrel-&gt;relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cndx = ((Var *) childvar)-&gt;varattno - childrel-&gt;min_attr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_width = childrel-&gt;attr_widths[cndx];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (child_width &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_width = <a href="../../utils/cache/lsyscache.c.html#L2578" title="utils/cache/lsyscache.c:2578">get_typavgwidth</a>(<a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(childvar),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>(childvar));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(child_width &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent_attrsizes[pndx] += child_width * childrel-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (has_live_children)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Save the finished size estimates.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(parent_rows &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rows = parent_rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;reltarget-&gt;width = rint(parent_size / parent_rows);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nattrs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;attr_widths[i] = rint(parent_attrsizes[i] / parent_rows);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set &quot;raw tuples&quot; count <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to &quot;rows&quot; for the appendrel; needed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because some places assume rel-&gt;tuples is valid for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> baserel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;tuples = parent_rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that we leave rel-&gt;pages as zero; this is important to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * double-counting the appendrel tree in total_table_pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * All children were excluded by constraints, so mark the whole<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * appendrel dummy.&nbsp; We must do this in this phase so that the rel's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dummy-ness is visible when we generate paths for other rels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2166" title="optimizer/path/allpaths.c:2166">set_dummy_rel_pathlist</a>(rel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(parent_attrsizes);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1232" title="optimizer/path/allpaths.c:1232">set_append_rel_pathlist</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Build access paths for an &quot;append relation&quot;<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1232">&#x200c;</a></span><span class="linkable">set_append_rel_pathlist</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index rti, RangeTblEntry *rte)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentRTindex = rti;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *live_childrels = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate access paths for each member relation, and remember the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-dummy children.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, root-&gt;append_rel_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AppendRelInfo *appinfo = (AppendRelInfo *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childRTindex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *childRTE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *childrel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* append_rel_list contains all append rels; ignore others */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (appinfo-&gt;parent_relid != parentRTindex)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Re-locate the child RTE and RelOptInfo */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; childRTindex = appinfo-&gt;child_relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; childRTE = root-&gt;simple_rte_array[childRTindex];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; childrel = root-&gt;simple_rel_array[childRTindex];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If <a href="#L944" title="optimizer/path/allpaths.c:944">set_append_rel_size</a>() decided the parent appendrel was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parallel-unsafe at some point after visiting this child rel, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to propagate the unsafety marking down to the child, so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we don't generate useless partial paths for it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rel-&gt;consider_parallel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrel-&gt;consider_parallel = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compute the child's access paths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L469" title="optimizer/path/allpaths.c:469">set_rel_pathlist</a>(root, childrel, childRTindex, childRTE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If child is dummy, ignore it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IS_DUMMY_REL(childrel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Child is live, so add it to the live_childrels list for use below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; live_childrels = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(live_childrels, childrel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add paths to the append relation. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1302" title="optimizer/path/allpaths.c:1302">add_paths_to_append_rel</a>(root, rel, live_childrels);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1302" title="optimizer/path/allpaths.c:1302">add_paths_to_append_rel</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Generate paths for the given append relation given the set of non-dummy<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; child rels.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The function collects all parameterizations and orderings supported by the<br/></li>
<li></span><span class="Comment"> * non-dummy children. For every such parameterization or ordering, it creates<br/></li>
<li></span><span class="Comment"> * an append path collecting one path from each non-dummy child with given<br/></li>
<li></span><span class="Comment"> * parameterization or ordering. Similarly it collects partial paths from<br/></li>
<li></span><span class="Comment"> * non-dummy children to create partial append paths.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1302">&#x200c;</a></span><span class="linkable">add_paths_to_append_rel</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *live_childrels)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *subpaths = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; subpaths_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *startup_subpaths = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; startup_subpaths_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *partial_subpaths = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pa_partial_subpaths = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pa_nonpartial_subpaths = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; partial_subpaths_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; pa_subpaths_valid;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *all_child_pathkeys = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *all_child_outers = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; partial_rows = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If appropriate, consider parallel append */<br/></li>
<li></span>&nbsp; &nbsp; pa_subpaths_valid = <a href="costsize.c.html#L150" title="optimizer/path/costsize.c:150">enable_parallel_append</a> &amp;&amp; rel-&gt;consider_parallel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For every non-dummy child, remember the cheapest path.&nbsp; Also, identify<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all pathkeys (orderings) and parameterizations (required_outer sets)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * available for the non-dummy member relations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, live_childrels)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *childrel = lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lcp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *cheapest_partial_path = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If child has an unparameterized cheapest-total path, add that to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the unparameterized Append path we are constructing for the parent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If not, there's no workable unparameterized path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * With partitionwise aggregates, the child rel's pathlist may be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * empty, so don't assume that a path exists here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (childrel-&gt;pathlist != NIL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrel-&gt;cheapest_total_path-&gt;param_info == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2087" title="optimizer/path/allpaths.c:2087">accumulate_append_subpath</a>(childrel-&gt;cheapest_total_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;subpaths, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpaths_valid = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When the <a href="../plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> is considering cheap startup plans, we'll also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * collect all the cheapest_startup_paths (if set) and build an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * AppendPath containing those as subpaths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;consider_startup &amp;&amp; childrel-&gt;cheapest_startup_path != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cheapest_startup_path must not be a parameterized path. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(childrel-&gt;cheapest_startup_path-&gt;param_info == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2087" title="optimizer/path/allpaths.c:2087">accumulate_append_subpath</a>(childrel-&gt;cheapest_startup_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;startup_subpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startup_subpaths_valid = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Same idea, but for a partial plan. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (childrel-&gt;partial_pathlist != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cheapest_partial_path = linitial(childrel-&gt;partial_pathlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2087" title="optimizer/path/allpaths.c:2087">accumulate_append_subpath</a>(cheapest_partial_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;partial_subpaths, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partial_subpaths_valid = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Same idea, but for a parallel append mixing partial and non-partial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * paths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pa_subpaths_valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *nppath = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nppath =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="pathkeys.c.html#L714" title="optimizer/path/pathkeys.c:714">get_cheapest_parallel_safe_total_inner</a>(childrel-&gt;pathlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cheapest_partial_path == <span class="Constant">NULL</span> &amp;&amp; nppath == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Neither a partial nor a parallel-safe path?&nbsp; Forget it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pa_subpaths_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (nppath == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (cheapest_partial_path != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cheapest_partial_path-&gt;total_cost &lt; nppath-&gt;total_cost))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Partial path is cheaper or the only option. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(cheapest_partial_path != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2087" title="optimizer/path/allpaths.c:2087">accumulate_append_subpath</a>(cheapest_partial_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;pa_partial_subpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;pa_nonpartial_subpaths);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Either we've got only a non-partial path, or we think that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a single backend can execute the best non-partial path<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * faster than all the parallel backends working together can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * execute the best partial path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It might make sense to be more aggressive here.&nbsp; Even if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the best non-partial path is more expensive than the best<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partial path, it could still be better to choose the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-partial path if there are several such paths that can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be given to different workers.&nbsp; For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we don't try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * figure that out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2087" title="optimizer/path/allpaths.c:2087">accumulate_append_subpath</a>(nppath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;pa_nonpartial_subpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Collect lists of all the available path orderings and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parameterizations for all the children.&nbsp; We use these as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * heuristic to indicate which sort orderings and parameterizations we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should build Append and MergeAppend paths for.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lcp, childrel-&gt;pathlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *childpath = (Path *) lfirst(lcp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *childkeys = childpath-&gt;pathkeys;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; childouter = PATH_REQ_OUTER(childpath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Unsorted paths don't contribute to pathkey list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (childkeys != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lpk;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Have we already seen this ordering? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lpk, all_child_pathkeys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *existing_pathkeys = (List *) lfirst(lpk);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="pathkeys.c.html#L302" title="optimizer/path/pathkeys.c:302">compare_pathkeys</a>(existing_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; childkeys) == PATHKEYS_EQUAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No, so add it to all_child_pathkeys */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all_child_pathkeys = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(all_child_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; childkeys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Unparameterized paths don't contribute to param-set list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (childouter)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lco;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Have we already seen this param set? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lco, all_child_outers)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; existing_outers = (Relids) lfirst(lco);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(existing_outers, childouter))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No, so add it to all_child_outers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all_child_outers = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(all_child_outers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; childouter);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we found unparameterized paths for all children, build an unordered,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unparameterized Append path for the rel.&nbsp; (Note: this is correct even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we have zero or one live subpath due to constraint exclusion.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (subpaths_valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, (Path *) <a href="../util/pathnode.c.html#L1244" title="optimizer/util/pathnode.c:1244">create_append_path</a>(root, rel, subpaths, NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NIL, <span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build an AppendPath for the cheap startup paths, if valid */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (startup_subpaths_valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, (Path *) <a href="../util/pathnode.c.html#L1244" title="optimizer/util/pathnode.c:1244">create_append_path</a>(root, rel, startup_subpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NIL, NIL, <span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">false</span>, -<span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Consider an append of unordered, unparameterized partial paths.&nbsp; Make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it parallel-aware if possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (partial_subpaths_valid &amp;&amp; partial_subpaths != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AppendPath *appendpath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parallel_workers = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find the highest number of workers requested for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subpath. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, partial_subpaths)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path = lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parallel_workers = Max(parallel_workers, path-&gt;parallel_workers);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(parallel_workers &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the use of parallel append is permitted, always request at least<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * log2(# of children) workers.&nbsp; We assume it can be useful to have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * extra workers in this case because they will be spread out across<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the children.&nbsp; The precise formula is just a guess, but we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * want to end up with a radically different answer for a table with N<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partitions vs. an unpartitioned table with the same data, so the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * use of some kind of log-scaling here seems to make some sense.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="costsize.c.html#L150" title="optimizer/path/costsize.c:150">enable_parallel_append</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parallel_workers = Max(parallel_workers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_leftmost_one_pos32(list_length(live_childrels)) + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parallel_workers = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(parallel_workers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="costsize.c.html#L132" title="optimizer/path/costsize.c:132">max_parallel_workers_per_gather</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(parallel_workers &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Generate a partial append path. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; appendpath = <a href="../util/pathnode.c.html#L1244" title="optimizer/util/pathnode.c:1244">create_append_path</a>(root, rel, NIL, partial_subpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NIL, <span class="Constant">NULL</span>, parallel_workers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="costsize.c.html#L150" title="optimizer/path/costsize.c:150">enable_parallel_append</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subsequent partial paths use the same row count<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * estimate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; partial_rows = appendpath-&gt;path.rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add the path. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L747" title="optimizer/util/pathnode.c:747">add_partial_path</a>(rel, (Path *) appendpath);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Consider a parallel-aware append using a mix of partial and non-partial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * paths.&nbsp; (This only makes sense if there's at least one child which has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a non-partial path that is substantially cheaper than <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> partial path;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otherwise, we should use the append path added in the previous step.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pa_subpaths_valid &amp;&amp; pa_nonpartial_subpaths != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AppendPath *appendpath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parallel_workers = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find the highest number of workers requested for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> partial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subpath.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, pa_partial_subpaths)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path = lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parallel_workers = Max(parallel_workers, path-&gt;parallel_workers);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Same formula here as above.&nbsp; It's even more important in this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * instance because the non-partial paths won't contribute anything to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the planned number of parallel workers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; parallel_workers = Max(parallel_workers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_leftmost_one_pos32(list_length(live_childrels)) + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parallel_workers = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(parallel_workers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="costsize.c.html#L132" title="optimizer/path/costsize.c:132">max_parallel_workers_per_gather</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(parallel_workers &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendpath = <a href="../util/pathnode.c.html#L1244" title="optimizer/util/pathnode.c:1244">create_append_path</a>(root, rel, pa_nonpartial_subpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pa_partial_subpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NIL, <span class="Constant">NULL</span>, parallel_workers, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partial_rows);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L747" title="optimizer/util/pathnode.c:747">add_partial_path</a>(rel, (Path *) appendpath);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also build unparameterized ordered append paths based on the collected<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list of child pathkeys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (subpaths_valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1714" title="optimizer/path/allpaths.c:1714">generate_orderedappend_paths</a>(root, rel, live_childrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; all_child_pathkeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build Append paths for each parameterization seen among the child rels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (This may look pretty expensive, but in most cases of practical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interest, the child rels will expose mostly the same parameterizations,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so that not that many cases actually get considered here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The Append node itself cannot enforce quals, so all qual checking must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be done in the child paths.&nbsp; This means that to have a parameterized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Append path, we must have the exact same parameterization for each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * child path; otherwise some children might be failing to check the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * moved-down quals.&nbsp; To make them match up, we can try to increase the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parameterization of lesser-parameterized paths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, all_child_outers)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; required_outer = (Relids) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lcr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Select the child paths for an Append with this parameterization */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; subpaths = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subpaths_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lcr, live_childrels)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *childrel = (RelOptInfo *) lfirst(lcr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *subpath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (childrel-&gt;pathlist == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* failed to make a suitable path for this child */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpaths_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath = <a href="#L1999" title="optimizer/path/allpaths.c:1999">get_cheapest_parameterized_child_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subpath == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* failed to make a suitable path for this child */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpaths_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2087" title="optimizer/path/allpaths.c:2087">accumulate_append_subpath</a>(subpath, &amp;subpaths, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subpaths_valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/pathnode.c.html#L1244" title="optimizer/util/pathnode.c:1244">create_append_path</a>(root, rel, subpaths, NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NIL, required_outer, <span class="Constant">0</span>, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When there is only a single child relation, the Append path can inherit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> ordering available for the child rel's path, so that it's useful to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consider ordered partial paths.&nbsp; Above we only considered the cheapest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partial path for each child, but let's also make paths using <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partial paths that have pathkeys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(live_childrels) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *childrel = (RelOptInfo *) linitial(live_childrels);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the cheapest partial path, since we already used that above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; for_each_from(l, childrel-&gt;partial_pathlist, <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path = (Path *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AppendPath *appendpath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> paths with no pathkeys. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path-&gt;pathkeys == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendpath = <a href="../util/pathnode.c.html#L1244" title="optimizer/util/pathnode.c:1244">create_append_path</a>(root, rel, NIL, list_make1(path),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NIL, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path-&gt;parallel_workers, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partial_rows);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L747" title="optimizer/util/pathnode.c:747">add_partial_path</a>(rel, (Path *) appendpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1714" title="optimizer/path/allpaths.c:1714">generate_orderedappend_paths</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Generate ordered append paths for an append relation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Usually we generate MergeAppend paths here, but there are some special<br/></li>
<li></span><span class="Comment"> * cases where we can generate simple Append paths, because the subpaths<br/></li>
<li></span><span class="Comment"> * can provide tuples in the required order already.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We generate a path for each ordering (pathkey list) appearing in<br/></li>
<li></span><span class="Comment"> * all_child_pathkeys.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We consider both cheapest-startup and cheapest-total cases, ie, for each<br/></li>
<li></span><span class="Comment"> * interesting ordering, collect all the cheapest startup subpaths and all the<br/></li>
<li></span><span class="Comment"> * cheapest total paths, and build a suitable path for each case.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We don't currently generate <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> parameterized ordered paths here.&nbsp; While<br/></li>
<li></span><span class="Comment"> * it would not take much more code here to do so, it's very unclear that it<br/></li>
<li></span><span class="Comment"> * is worth the planning cycles to investigate such paths: there's little<br/></li>
<li></span><span class="Comment"> * use for an ordered path on the inside of a nestloop.&nbsp; In fact, it's likely<br/></li>
<li></span><span class="Comment"> * that the current coding of <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a> would reject such paths out of hand,<br/></li>
<li></span><span class="Comment"> * because <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a> gives no credit for sort ordering of parameterized paths,<br/></li>
<li></span><span class="Comment"> * and a parameterized MergeAppend is going to be more expensive than the<br/></li>
<li></span><span class="Comment"> * corresponding parameterized Append path.&nbsp; If we ever try harder to support<br/></li>
<li></span><span class="Comment"> * parameterized mergejoin plans, it might be worth adding support for<br/></li>
<li></span><span class="Comment"> * parameterized paths here to feed such joins.&nbsp; (See notes in<br/></li>
<li></span><span class="Comment"> * optimizer/README for why that might not ever happen, though.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1714">&#x200c;</a></span><span class="linkable">generate_orderedappend_paths</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *live_childrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *all_child_pathkeys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lcp;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *partition_pathkeys = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *partition_pathkeys_desc = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; partition_pathkeys_partial = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; partition_pathkeys_desc_partial = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Some partitioned table setups may allow us to use an Append node<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * instead of a MergeAppend.&nbsp; This is possible in cases such as <a href="../../regex/regcomp.c.html#L339" title="regex/regcomp.c:339">RANGE</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partitioned tables where it's guaranteed that an earlier partition must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contain rows which come earlier in the sort order.&nbsp; To detect whether<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this is relevant, build pathkey descriptions of the partition ordering,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for both forward and reverse scans.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;part_scheme != <span class="Constant">NULL</span> &amp;&amp; IS_SIMPLE_REL(rel) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../partitioning/partbounds.c.html#L2852" title="partitioning/partbounds.c:2852">partitions_are_ordered</a>(rel-&gt;boundinfo, rel-&gt;live_parts))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partition_pathkeys = <a href="pathkeys.c.html#L934" title="optimizer/path/pathkeys.c:934">build_partition_pathkeys</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForwardScanDirection,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;partition_pathkeys_partial);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partition_pathkeys_desc = <a href="pathkeys.c.html#L934" title="optimizer/path/pathkeys.c:934">build_partition_pathkeys</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BackwardScanDirection,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;partition_pathkeys_desc_partial);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * You might think we should <a href="pathkeys.c.html#L2215" title="optimizer/path/pathkeys.c:2215">truncate_useless_pathkeys</a> here, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allowing partition keys which are a <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of the query's pathkeys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can often be useful.&nbsp; For example, consider a table partitioned by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L339" title="regex/regcomp.c:339">RANGE</a> (a, b), and a query with ORDER BY a, b, c.&nbsp; If we have child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * paths that can produce the a, b, c ordering (perhaps via indexes on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (a, b, c)) then it works to consider the appendrel output as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ordered by a, b, c.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now consider each interesting sort ordering */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lcp, all_child_pathkeys)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pathkeys = (List *) lfirst(lcp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *startup_subpaths = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *total_subpaths = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *fractional_subpaths = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; startup_neq_total = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; match_partition_order;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; match_partition_order_desc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; direction;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Determine if this sort ordering matches <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> partition pathkeys we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have, for both ascending and descending partition order.&nbsp; If the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partition pathkeys happen to be contained in pathkeys then it still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * works, as described above, providing that the partition pathkeys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are complete and not just a prefix of the partition keys.&nbsp; (In such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cases we'll be relying on the child paths to have sorted the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-order columns of the required pathkeys.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; match_partition_order =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="pathkeys.c.html#L341" title="optimizer/path/pathkeys.c:341">pathkeys_contained_in</a>(pathkeys, partition_pathkeys) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (!partition_pathkeys_partial &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="pathkeys.c.html#L341" title="optimizer/path/pathkeys.c:341">pathkeys_contained_in</a>(partition_pathkeys, pathkeys));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; match_partition_order_desc = !match_partition_order &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="pathkeys.c.html#L341" title="optimizer/path/pathkeys.c:341">pathkeys_contained_in</a>(pathkeys, partition_pathkeys_desc) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (!partition_pathkeys_desc_partial &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="pathkeys.c.html#L341" title="optimizer/path/pathkeys.c:341">pathkeys_contained_in</a>(partition_pathkeys_desc, pathkeys)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When the required pathkeys match the reverse of the partition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * order, we must build the list of paths in reverse starting with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * last matching partition first.&nbsp; We can get away without making <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * special cases for this in the loop below by just looping backward<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * over the child relations in this case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (match_partition_order_desc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* loop backward */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first_index = list_length(live_childrels) - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_index = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; direction = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set this to true to save us having to check for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * match_partition_order_desc in the loop below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match_partition_order = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for all other case, loop forward */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first_index = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_index = list_length(live_childrels);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; direction = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Select the child paths for this ordering... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = first_index; i != end_index; i += direction)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *childrel = list_nth_node(RelOptInfo, live_childrels, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *cheapest_startup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *cheapest_total,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *cheapest_fractional = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Locate the right paths, if they are available. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cheapest_startup =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="pathkeys.c.html#L635" title="optimizer/path/pathkeys.c:635">get_cheapest_path_for_pathkeys</a>(childrel-&gt;pathlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; STARTUP_COST,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cheapest_total =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="pathkeys.c.html#L635" title="optimizer/path/pathkeys.c:635">get_cheapest_path_for_pathkeys</a>(childrel-&gt;pathlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TOTAL_COST,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we can't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> paths with the right order just use the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cheapest-total path; we'll have to sort it later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cheapest_startup == <span class="Constant">NULL</span> || cheapest_total == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cheapest_startup = cheapest_total =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrel-&gt;cheapest_total_path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Assert we do have an unparameterized path for this child */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(cheapest_total-&gt;param_info == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When building a fractional path, determine a cheapest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fractional path for each child relation too. Looking at startup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and total costs is not enough, because the cheapest fractional<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * path may be dominated by two separate paths (one for startup,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one for total).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When needed (building fractional path), determine the cheapest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fractional path too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;tuple_fraction &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; path_fraction = (<span class="Constant">1.0</span> / root-&gt;tuple_fraction);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cheapest_fractional =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="pathkeys.c.html#L681" title="optimizer/path/pathkeys.c:681">get_cheapest_fractional_path_for_pathkeys</a>(childrel-&gt;pathlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path_fraction);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we found no path with matching pathkeys, use the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cheapest total path instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> We might consider partially sorted paths too (with an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * incremental sort on top). But we'd have to build all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * incremental paths, do the costing etc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!cheapest_fractional)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cheapest_fractional = cheapest_total;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Notice whether we actually have different paths for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;cheapest&quot; and &quot;total&quot; cases; frequently there will be no point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in two <a href="../util/pathnode.c.html#L1415" title="optimizer/util/pathnode.c:1415">create_merge_append_path</a>() calls.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cheapest_startup != cheapest_total)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startup_neq_total = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Collect the appropriate child paths.&nbsp; The required logic varies<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for the Append and MergeAppend cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (match_partition_order)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're going to make a plain Append path.&nbsp; We don't need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * most of what <a href="#L2087" title="optimizer/path/allpaths.c:2087">accumulate_append_subpath</a> would do, but we do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * want to cut out child Appends or MergeAppends if they have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just a single subpath (and hence aren't doing anything<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * useful).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cheapest_startup = <a href="#L2132" title="optimizer/path/allpaths.c:2132">get_singleton_append_subpath</a>(cheapest_startup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cheapest_total = <a href="#L2132" title="optimizer/path/allpaths.c:2132">get_singleton_append_subpath</a>(cheapest_total);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startup_subpaths = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(startup_subpaths, cheapest_startup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_subpaths = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(total_subpaths, cheapest_total);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cheapest_fractional)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cheapest_fractional = <a href="#L2132" title="optimizer/path/allpaths.c:2132">get_singleton_append_subpath</a>(cheapest_fractional);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fractional_subpaths = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(fractional_subpaths, cheapest_fractional);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, rely on <a href="#L2087" title="optimizer/path/allpaths.c:2087">accumulate_append_subpath</a> to collect the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * child paths for the MergeAppend.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2087" title="optimizer/path/allpaths.c:2087">accumulate_append_subpath</a>(cheapest_startup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;startup_subpaths, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2087" title="optimizer/path/allpaths.c:2087">accumulate_append_subpath</a>(cheapest_total,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;total_subpaths, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cheapest_fractional)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2087" title="optimizer/path/allpaths.c:2087">accumulate_append_subpath</a>(cheapest_fractional,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;fractional_subpaths, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and build the Append or MergeAppend paths */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (match_partition_order)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We only need Append */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, (Path *) <a href="../util/pathnode.c.html#L1244" title="optimizer/util/pathnode.c:1244">create_append_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startup_subpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (startup_neq_total)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, (Path *) <a href="../util/pathnode.c.html#L1244" title="optimizer/util/pathnode.c:1244">create_append_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_subpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fractional_subpaths)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, (Path *) <a href="../util/pathnode.c.html#L1244" title="optimizer/util/pathnode.c:1244">create_append_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fractional_subpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We need MergeAppend */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, (Path *) <a href="../util/pathnode.c.html#L1415" title="optimizer/util/pathnode.c:1415">create_merge_append_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startup_subpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (startup_neq_total)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, (Path *) <a href="../util/pathnode.c.html#L1415" title="optimizer/util/pathnode.c:1415">create_merge_append_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_subpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fractional_subpaths)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, (Path *) <a href="../util/pathnode.c.html#L1415" title="optimizer/util/pathnode.c:1415">create_merge_append_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fractional_subpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1999" title="optimizer/path/allpaths.c:1999">get_cheapest_parameterized_child_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get cheapest path for this relation that has exactly the requested<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; parameterization.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns NULL if unable to create such a path.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Path *<br/></li>
<li><a id="L1999">&#x200c;</a><span class="linkable">get_cheapest_parameterized_child_path</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids required_outer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *cheapest;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look up the cheapest existing path with no more than the needed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parameterization.&nbsp; If it has exactly the needed parameterization, we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cheapest = <a href="pathkeys.c.html#L635" title="optimizer/path/pathkeys.c:635">get_cheapest_path_for_pathkeys</a>(rel-&gt;pathlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TOTAL_COST,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(cheapest != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(PATH_REQ_OUTER(cheapest), required_outer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> cheapest;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, we can &quot;reparameterize&quot; an existing path to match the given<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parameterization, which effectively means pushing down additional<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * joinquals to be checked within the path's scan.&nbsp; However, some existing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * paths might check the available joinquals already while others don't;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * therefore, it's not clear which existing path will be cheapest after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reparameterization.&nbsp; We have to go through them all and <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cheapest = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, rel-&gt;pathlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path = (Path *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can't use it if it needs more than requested parameterization */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(PATH_REQ_OUTER(path), required_outer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reparameterization can only increase the path's cost, so if it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already more expensive than the current cheapest, forget it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cheapest != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L69" title="optimizer/util/pathnode.c:69">compare_path_costs</a>(cheapest, path, TOTAL_COST) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reparameterize if needed, then recheck cost */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(PATH_REQ_OUTER(path), required_outer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path = <a href="../util/pathnode.c.html#L3946" title="optimizer/util/pathnode.c:3946">reparameterize_path</a>(root, path, required_outer, <span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* failed to reparameterize this one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(PATH_REQ_OUTER(path), required_outer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cheapest != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L69" title="optimizer/util/pathnode.c:69">compare_path_costs</a>(cheapest, path, TOTAL_COST) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We have a new best path */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cheapest = path;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return the best path, or NULL if we found no suitable candidate */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> cheapest;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2087" title="optimizer/path/allpaths.c:2087">accumulate_append_subpath</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Add a subpath to the list being built for an Append or MergeAppend.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It's possible that the child is itself an Append or MergeAppend path, in<br/></li>
<li></span><span class="Comment"> * which case we can &quot;cut out the middleman&quot; and just add its child paths to<br/></li>
<li></span><span class="Comment"> * our own list.&nbsp; (We don't try to do this earlier because we need to apply<br/></li>
<li></span><span class="Comment"> * both levels of transformation to the quals.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that if we omit a child MergeAppend in this way, we are effectively<br/></li>
<li></span><span class="Comment"> * omitting a sort step, which seems fine: if the parent is to be an Append,<br/></li>
<li></span><span class="Comment"> * its result would be unsorted anyway, while if the parent is to be a<br/></li>
<li></span><span class="Comment"> * MergeAppend, there's no point in a separate sort on a child.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Normally, either path is a partial path and subpaths is a list of partial<br/></li>
<li></span><span class="Comment"> * paths, or else path is a non-partial plan and subpaths is a list of those.<br/></li>
<li></span><span class="Comment"> * However, if path is a parallel-aware Append, then we add its partial path<br/></li>
<li></span><span class="Comment"> * children to subpaths and the rest to special_subpaths.&nbsp; If the latter is<br/></li>
<li></span><span class="Comment"> * NULL, we don't flatten the path at all (unless it contains only partial<br/></li>
<li></span><span class="Comment"> * paths).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2087">&#x200c;</a></span><span class="linkable">accumulate_append_subpath</span>(Path *path, List **subpaths, List **special_subpaths)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(path, AppendPath))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AppendPath *apath = (AppendPath *) path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!apath-&gt;path.parallel_aware || apath-&gt;first_partial_path == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *subpaths = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(*subpaths, apath-&gt;subpaths);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (special_subpaths != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *new_special_subpaths;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Split Parallel Append into partial and non-partial subpaths */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *subpaths = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(*subpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1613" title="nodes/list.c:1613">list_copy_tail</a>(apath-&gt;subpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; apath-&gt;first_partial_path));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_special_subpaths = <a href="../../nodes/list.c.html#L1593" title="nodes/list.c:1593">list_copy_head</a>(apath-&gt;subpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; apath-&gt;first_partial_path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *special_subpaths = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(*special_subpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_special_subpaths);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(path, MergeAppendPath))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MergeAppendPath *mpath = (MergeAppendPath *) path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *subpaths = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(*subpaths, mpath-&gt;subpaths);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *subpaths = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(*subpaths, path);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2132" title="optimizer/path/allpaths.c:2132">get_singleton_append_subpath</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the single subpath of an Append/MergeAppend, or just<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; return 'path' if it's not a single sub-path Append/MergeAppend.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: 'path' must not be a parallel-aware path.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Path *<br/></li>
<li><a id="L2132">&#x200c;</a><span class="linkable">get_singleton_append_subpath</span>(Path *path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!path-&gt;parallel_aware);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(path, AppendPath))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AppendPath *apath = (AppendPath *) path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(apath-&gt;subpaths) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Path *) linitial(apath-&gt;subpaths);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(path, MergeAppendPath))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MergeAppendPath *mpath = (MergeAppendPath *) path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(mpath-&gt;subpaths) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Path *) linitial(mpath-&gt;subpaths);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> path;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2166" title="optimizer/path/allpaths.c:2166">set_dummy_rel_pathlist</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Build a dummy path for a relation that's been excluded by constraints<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Rather than inventing a special &quot;dummy&quot; path type, we represent this as an<br/></li>
<li></span><span class="Comment"> * AppendPath with no members (see also IS_DUMMY_APPEND/IS_DUMMY_REL macros).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (See also <a href="joinrels.c.html#L1381" title="optimizer/path/joinrels.c:1381">mark_dummy_rel</a>, which does basically the same thing, but is<br/></li>
<li></span><span class="Comment"> * typically used to change a rel into dummy state after we already made<br/></li>
<li></span><span class="Comment"> * paths for it.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2166">&#x200c;</a></span><span class="linkable">set_dummy_rel_pathlist</span>(RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set dummy size estimates --- we leave attr_widths[] as zeroes */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;rows = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;reltarget-&gt;width = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Discard <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pre-existing paths; no further need for them */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;pathlist = NIL;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;partial_pathlist = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up the dummy path */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, (Path *) <a href="../util/pathnode.c.html#L1244" title="optimizer/util/pathnode.c:1244">create_append_path</a>(<span class="Constant">NULL</span>, rel, NIL, NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NIL, rel-&gt;lateral_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>, <span class="Constant">false</span>, -<span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We set the cheapest-path fields immediately, just in case they were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pointing at some discarded path.&nbsp; This is redundant in current usage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because <a href="#L469" title="optimizer/path/allpaths.c:469">set_rel_pathlist</a> will do it later, but it's cheap so we keep it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for safety and consistency with <a href="joinrels.c.html#L1381" title="optimizer/path/joinrels.c:1381">mark_dummy_rel</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/pathnode.c.html#L242" title="optimizer/util/pathnode.c:242">set_cheapest</a>(rel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2214" title="optimizer/path/allpaths.c:2214">find_window_run_conditions</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Determine if 'wfunc' is really a WindowFunc and call its prosupport<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; function to determine the function's monotonic properties.&nbsp; We then<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; see if 'opexpr' can be used to short-circuit execution.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For example row_number() over (order by ...) always produces a value one<br/></li>
<li></span><span class="Comment"> * higher than the previous.&nbsp; If someone has a window function in a subquery<br/></li>
<li></span><span class="Comment"> * and has a WHERE clause in the outer query to filter rows &lt;= 10, then we may<br/></li>
<li></span><span class="Comment"> * as well stop processing the windowagg once the row number reaches 11.&nbsp; Here<br/></li>
<li></span><span class="Comment"> * we check if 'opexpr' might <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> us to stop doing needless extra processing<br/></li>
<li></span><span class="Comment"> * in WindowAgg nodes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * '*keep_original' is set to true if the caller should also use 'opexpr' for<br/></li>
<li></span><span class="Comment"> * its original purpose.&nbsp; This is set to false if the caller can assume that<br/></li>
<li></span><span class="Comment"> * the run condition will handle all of the required filtering.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if 'opexpr' was found to be useful and was added to the<br/></li>
<li></span><span class="Comment"> * WindowClauses runCondition.&nbsp; We also set *keep_original accordingly and add<br/></li>
<li></span><span class="Comment"> * 'attno' to *run_cond_attrs offset by FirstLowInvalidHeapAttributeNumber.<br/></li>
<li></span><span class="Comment"> * If the 'opexpr' cannot be used then we set *keep_original to true and<br/></li>
<li></span><span class="Comment"> * return false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2214">&#x200c;</a></span><span class="linkable">find_window_run_conditions</span>(Query *subquery, RangeTblEntry *rte, Index rti,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AttrNumber attno, WindowFunc *wfunc, OpExpr *opexpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> wfunc_left, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *keep_original,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Bitmapset **run_cond_attrs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prosupport;<br/></li>
<li>&nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *otherexpr;<br/></li>
<li>&nbsp; &nbsp; SupportRequestWFuncMonotonic req;<br/></li>
<li>&nbsp; &nbsp; SupportRequestWFuncMonotonic *res;<br/></li>
<li>&nbsp; &nbsp; WindowClause *wclause;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *opinfos;<br/></li>
<li>&nbsp; &nbsp; OpExpr&nbsp; &nbsp; &nbsp;&nbsp; *runopexpr;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; runoperator;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *keep_original = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (IsA(wfunc, RelabelType))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; wfunc = (WindowFunc *) ((RelabelType *) wfunc)-&gt;arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we can only work with window <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IsA(wfunc, WindowFunc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* can't use it if there are subplans in the WindowFunc */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/clauses.c.html#L330" title="optimizer/util/clauses.c:330">contain_subplans</a>((Node *) wfunc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; prosupport = <a href="../../utils/cache/lsyscache.c.html#L1858" title="utils/cache/lsyscache.c:1858">get_func_support</a>(wfunc-&gt;winfnoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if there's a support function for 'wfunc' */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(prosupport))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* get the Expr from the other side of the OpExpr */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (wfunc_left)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; otherexpr = lsecond(opexpr-&gt;args);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; otherexpr = linitial(opexpr-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The value being compared must not change during the evaluation of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * window partition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../util/clauses.c.html#L2088" title="optimizer/util/clauses.c:2088">is_pseudo_constant_clause</a>((Node *) otherexpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the window clause belonging to the window function */<br/></li>
<li></span>&nbsp; &nbsp; wclause = (WindowClause *) list_nth(subquery-&gt;windowClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wfunc-&gt;winref - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; req.type = T_SupportRequestWFuncMonotonic;<br/></li>
<li>&nbsp; &nbsp; req.window_func = wfunc;<br/></li>
<li>&nbsp; &nbsp; req.window_clause = wclause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* call the support function */<br/></li>
<li></span>&nbsp; &nbsp; res = (SupportRequestWFuncMonotonic *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DatumGetPointer(OidFunctionCall1(prosupport,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(&amp;req)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Nothing to do if the function is neither monotonically increasing nor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * monotonically decreasing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (res == <span class="Constant">NULL</span> || res-&gt;monotonic == MONOTONICFUNC_NONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; runopexpr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; runoperator = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; opinfos = <a href="../../utils/cache/lsyscache.c.html#L601" title="utils/cache/lsyscache.c:601">get_op_btree_interpretation</a>(opexpr-&gt;opno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, opinfos)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OpBtreeInterpretation *opinfo = (OpBtreeInterpretation *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strategy = opinfo-&gt;strategy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* handle &lt; / &lt;= */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strategy == BTLessStrategyNumber ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strategy == BTLessEqualStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &lt; / &lt;= is supported for monotonically increasing <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the form &lt;wfunc&gt; op &lt;pseudoconst&gt; and &lt;pseudoconst&gt; op &lt;wfunc&gt;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for monotonically decreasing <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((wfunc_left &amp;&amp; (res-&gt;monotonic &amp; MONOTONICFUNC_INCREASING)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (!wfunc_left &amp;&amp; (res-&gt;monotonic &amp; MONOTONICFUNC_DECREASING)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *keep_original = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; runopexpr = opexpr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; runoperator = opexpr-&gt;opno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* handle &gt; / &gt;= */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strategy == BTGreaterStrategyNumber ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strategy == BTGreaterEqualStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &gt; / &gt;= is supported for monotonically decreasing <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the form &lt;wfunc&gt; op &lt;pseudoconst&gt; and &lt;pseudoconst&gt; op &lt;wfunc&gt;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for monotonically increasing <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((wfunc_left &amp;&amp; (res-&gt;monotonic &amp; MONOTONICFUNC_DECREASING)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (!wfunc_left &amp;&amp; (res-&gt;monotonic &amp; MONOTONICFUNC_INCREASING)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *keep_original = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; runopexpr = opexpr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; runoperator = opexpr-&gt;opno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* handle = */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strategy == BTEqualStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; newstrategy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When both monotonically increasing and decreasing then the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * return value of the window function will be the same each time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can simply use 'opexpr' as the run condition without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * modifying it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((res-&gt;monotonic &amp; MONOTONICFUNC_BOTH) == MONOTONICFUNC_BOTH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *keep_original = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; runopexpr = opexpr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; runoperator = opexpr-&gt;opno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When monotonically increasing we make a qual with &lt;wfunc&gt; &lt;=<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &lt;value&gt; or &lt;value&gt; &gt;= &lt;wfunc&gt; in order to filter out <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which are above the value in the equality condition.&nbsp; For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * monotonically decreasing <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> we want to filter <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * below the value in the equality condition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res-&gt;monotonic &amp; MONOTONICFUNC_INCREASING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newstrategy = wfunc_left ? BTLessEqualStrategyNumber : BTGreaterEqualStrategyNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newstrategy = wfunc_left ? BTGreaterEqualStrategyNumber : BTLessEqualStrategyNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We must keep the original equality qual */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *keep_original = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; runopexpr = opexpr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* determine the operator to use for the runCondition qual */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; runoperator = <a href="../../utils/cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opinfo-&gt;opfamily_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opinfo-&gt;oplefttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opinfo-&gt;oprighttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newstrategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (runopexpr != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *newexpr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Build the qual required for the run condition keeping the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WindowFunc on the same side as it was originally.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (wfunc_left)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newexpr = <a href="../../nodes/makefuncs.c.html#L628" title="nodes/makefuncs.c:628">make_opclause</a>(runoperator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; runopexpr-&gt;opresulttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; runopexpr-&gt;opretset, (Expr *) wfunc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherexpr, runopexpr-&gt;opcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; runopexpr-&gt;inputcollid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newexpr = <a href="../../nodes/makefuncs.c.html#L628" title="nodes/makefuncs.c:628">make_opclause</a>(runoperator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; runopexpr-&gt;opresulttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; runopexpr-&gt;opretset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherexpr, (Expr *) wfunc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; runopexpr-&gt;opcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; runopexpr-&gt;inputcollid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; wclause-&gt;runCondition = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(wclause-&gt;runCondition, newexpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* record that this attno was used in a run condition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *run_cond_attrs = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(*run_cond_attrs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attno - FirstLowInvalidHeapAttributeNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* unsupported OpExpr */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2419" title="optimizer/path/allpaths.c:2419">check_and_push_window_quals</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Check if 'clause' is a qual that can be pushed into a WindowFunc's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; WindowClause as a 'runCondition' qual.&nbsp; These, when present, allow<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; some unnecessary work to be skipped during execution.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'run_cond_attrs' will be populated with all targetlist resnos of subquery<br/></li>
<li></span><span class="Comment"> * targets (offset by FirstLowInvalidHeapAttributeNumber) that we pushed<br/></li>
<li></span><span class="Comment"> * window quals for.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if the caller still must keep the original qual or false if<br/></li>
<li></span><span class="Comment"> * the caller can safely ignore the original qual because the WindowAgg node<br/></li>
<li></span><span class="Comment"> * will use the runCondition to stop returning tuples.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2419">&#x200c;</a></span><span class="linkable">check_and_push_window_quals</span>(Query *subquery, RangeTblEntry *rte, Index rti,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *clause, Bitmapset **run_cond_attrs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; OpExpr&nbsp; &nbsp; &nbsp;&nbsp; *opexpr = (OpExpr *) clause;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; keep_original = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var1;<br/></li>
<li>&nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We're only able to use OpExprs with 2 operands */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IsA(opexpr, OpExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(opexpr-&gt;args) != <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Currently, we restrict this optimization to strict OpExprs.&nbsp; The reason<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for this is that during execution, once the runcondition becomes false,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we stop evaluating WindowFuncs.&nbsp; To avoid leaving around stale window<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function result <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, we set them to NULL.&nbsp; Having only strict<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OpExprs here ensures that we properly filter out the tuples with NULLs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the top-level WindowAgg.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L1868" title="nodes/nodeFuncs.c:1868">set_opfuncid</a>(opexpr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/cache/lsyscache.c.html#L1761" title="utils/cache/lsyscache.c:1761">func_strict</a>(opexpr-&gt;opfuncid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for plain Vars that reference window <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in the subquery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, we'll ask <a href="#L2214" title="optimizer/path/allpaths.c:2214">find_window_run_conditions</a>() if 'opexpr' can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be used as part of the run condition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check the left side of the OpExpr */<br/></li>
<li></span>&nbsp; &nbsp; var1 = linitial(opexpr-&gt;args);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(var1, Var) &amp;&amp; var1-&gt;varattno &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = list_nth(subquery-&gt;targetList, var1-&gt;varattno - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WindowFunc *wfunc = (WindowFunc *) tle-&gt;expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2214" title="optimizer/path/allpaths.c:2214">find_window_run_conditions</a>(subquery, rte, rti, tle-&gt;resno, wfunc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; opexpr, <span class="Constant">true</span>, &amp;keep_original,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; run_cond_attrs))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> keep_original;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and check the right side */<br/></li>
<li></span>&nbsp; &nbsp; var2 = lsecond(opexpr-&gt;args);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(var2, Var) &amp;&amp; var2-&gt;varattno &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = list_nth(subquery-&gt;targetList, var2-&gt;varattno - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WindowFunc *wfunc = (WindowFunc *) tle-&gt;expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2214" title="optimizer/path/allpaths.c:2214">find_window_run_conditions</a>(subquery, rte, rti, tle-&gt;resno, wfunc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; opexpr, <span class="Constant">false</span>, &amp;keep_original,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; run_cond_attrs))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> keep_original;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2494" title="optimizer/path/allpaths.c:2494">set_subquery_pathlist</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Generate SubqueryScan access paths for a subquery RTE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We don't currently support generating parameterized paths for subqueries<br/></li>
<li></span><span class="Comment"> * by pushing join clauses down into them; it seems too expensive to re-plan<br/></li>
<li></span><span class="Comment"> * the subquery multiple times to consider different alternatives.<br/></li>
<li></span><span class="Comment"> * (</span><span class="Todo">XXX</span><span class="Comment"> that could stand to be reconsidered, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that we use Paths.)<br/></li>
<li></span><span class="Comment"> * So the paths made here will be parameterized if the subquery contains<br/></li>
<li></span><span class="Comment"> * LATERAL references, otherwise not.&nbsp; As long as that's true, there's no need<br/></li>
<li></span><span class="Comment"> * for a separate set_subquery_size phase: just make the paths right away.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2494">&#x200c;</a></span><span class="linkable">set_subquery_pathlist</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index rti, RangeTblEntry *rte)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *subquery = rte-&gt;subquery;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; trivial_pathtarget;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; required_outer;<br/></li>
<li>&nbsp; &nbsp; <a href="#L60" title="optimizer/path/allpaths.c:60">pushdown_safety_info</a> safetyInfo;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; tuple_fraction;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *sub_final_rel;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *run_cond_attrs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must copy the Query so that planning doesn't mess up the RTE contents<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (really really need to fix the <a href="../plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> to not scribble on its input,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * someday ... but see <a href="#L4067" title="optimizer/path/allpaths.c:4067">remove_unused_subquery_outputs</a> to start with).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; subquery = copyObject(subquery);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's a LATERAL subquery, it might contain some Vars of the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * query level, requiring it to be treated as parameterized, even though<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we don't support pushing down join quals into subqueries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; required_outer = rel-&gt;lateral_relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Zero out result area for <a href="#L3594" title="optimizer/path/allpaths.c:3594">subquery_is_pushdown_safe</a>, so that it can set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * flags as needed while recursing.&nbsp; In particular, we need a workspace<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for keeping track of the reasons why columns are unsafe to reference.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * These reasons are stored in the bits inside unsafeFlags[i] when we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * discover reasons that column i of the subquery is unsafe to be used in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a pushed-down qual.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; memset(&amp;safetyInfo, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(safetyInfo));<br/></li>
<li>&nbsp; &nbsp; safetyInfo.unsafeFlags = (<span class="Type">unsigned</span> <span class="Type">char</span> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>((list_length(subquery-&gt;targetList) + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">unsigned</span> <span class="Type">char</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the subquery has the &quot;security_barrier&quot; flag, it means the subquery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * originated from a view that must enforce row-level security.&nbsp; Then we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must not <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> down quals that contain leaky <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; (Ideally this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would be checked inside <a href="#L3594" title="optimizer/path/allpaths.c:3594">subquery_is_pushdown_safe</a>, but since we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * currently pass the RTE to that function, we must do it here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; safetyInfo.unsafeLeaky = rte-&gt;security_barrier;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> restriction clauses that have been attached to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subquery relation, consider pushing them down to become WHERE or HAVING<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * quals of the subquery itself.&nbsp; This transformation is useful because it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * may allow us to generate a better plan for the subquery than evaluating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all the subquery output rows and then filtering them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There are several cases where we cannot <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> down clauses. Restrictions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * involving the subquery are checked by <a href="#L3594" title="optimizer/path/allpaths.c:3594">subquery_is_pushdown_safe</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Restrictions on individual clauses are checked by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L3867" title="optimizer/path/allpaths.c:3867">qual_is_pushdown_safe</a>().&nbsp; Also, we don't want to <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> down<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pseudoconstant clauses; better to have the gating node above the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subquery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Non-pushed-down clauses will get evaluated as qpquals of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SubqueryScan node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> Are there <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> cases where we want to make a policy decision not to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> down a pushable qual, because it'd result in a worse plan?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;baserestrictinfo != NIL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3594" title="optimizer/path/allpaths.c:3594">subquery_is_pushdown_safe</a>(subquery, subquery, &amp;safetyInfo))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK to consider pushing down individual quals */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *upperrestrictlist = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, rel-&gt;baserestrictinfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *clause = (Node *) rinfo-&gt;clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rinfo-&gt;pseudoconstant)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upperrestrictlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(upperrestrictlist, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L3867" title="optimizer/path/allpaths.c:3867">qual_is_pushdown_safe</a>(subquery, rti, rinfo, &amp;safetyInfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PUSHDOWN_SAFE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Push it down */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3968" title="optimizer/path/allpaths.c:3968">subquery_push_qual</a>(subquery, rte, rti, clause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PUSHDOWN_WINDOWCLAUSE_RUNCOND:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since we can't <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> the qual down into the subquery,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check if it happens to reference a window function.&nbsp; If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so then it might be useful to use for the WindowAgg's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * runCondition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!subquery-&gt;hasWindowFuncs ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2419" title="optimizer/path/allpaths.c:2419">check_and_push_window_quals</a>(subquery, rte, rti, clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;run_cond_attrs))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subquery has no window funcs or the clause is not a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * suitable window run condition qual or it is, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the original must also be kept in the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upperrestrictlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(upperrestrictlist, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PUSHDOWN_UNSAFE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upperrestrictlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(upperrestrictlist, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;baserestrictinfo = upperrestrictlist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't bother recomputing baserestrict_min_security */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(safetyInfo.unsafeFlags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> query might not use all the subquery's output columns; if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not, we can simplify.&nbsp; Pass the attributes that were pushed down into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WindowAgg run conditions to ensure we don't accidentally think those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are unused.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4067" title="optimizer/path/allpaths.c:4067">remove_unused_subquery_outputs</a>(subquery, rel, run_cond_attrs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can safely pass the outer tuple_fraction down to the subquery if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * outer level has no joining, aggregation, or sorting to do. Otherwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we'd better tell the subquery to plan for full retrieval. (</span><span class="Todo">XXX</span><span class="Comment"> This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * could probably be made more intelligent ...)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;hasAggs ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupClause ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;groupingSets ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;hasHavingQual ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;distinctClause ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;sortClause ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L781" title="nodes/bitmapset.c:781">bms_membership</a>(root-&gt;all_baserels) == BMS_MULTIPLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple_fraction = <span class="Constant">0.0</span>;&nbsp; &nbsp; <span class="Comment">/* default case */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tuple_fraction = root-&gt;tuple_fraction;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* plan_params should not be in use in current query level */<br/></li>
<li></span>&nbsp; &nbsp; Assert(root-&gt;plan_params == NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Generate a subroot and Paths for the subquery */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;subroot = <a href="../plan/planner.c.html#L628" title="optimizer/plan/planner.c:628">subquery_planner</a>(root-&gt;glob, subquery, root, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_fraction, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Isolate the params needed by this specific subplan */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;subplan_params = root-&gt;plan_params;<br/></li>
<li>&nbsp; &nbsp; root-&gt;plan_params = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's possible that constraint exclusion proved the subquery empty. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so, it's desirable to produce an unadorned dummy path so that we will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recognize appropriate optimizations at this query level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sub_final_rel = <a href="../util/relnode.c.html#L1470" title="optimizer/util/relnode.c:1470">fetch_upper_rel</a>(rel-&gt;subroot, UPPERREL_FINAL, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IS_DUMMY_REL(sub_final_rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2166" title="optimizer/path/allpaths.c:2166">set_dummy_rel_pathlist</a>(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark rel with estimated output rows, width, etc.&nbsp; Note that we have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> generating outer-query paths, else <a href="costsize.c.html#L1451" title="optimizer/path/costsize.c:1451">cost_subqueryscan</a> is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not happy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="costsize.c.html#L5792" title="optimizer/path/costsize.c:5792">set_subquery_size_estimates</a>(root, rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also detect whether the reltarget is trivial, so that we can pass that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * info to <a href="costsize.c.html#L1451" title="optimizer/path/costsize.c:1451">cost_subqueryscan</a> (rather than re-deriving it multiple times).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's trivial if it fetches all the subplan output columns in order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(rel-&gt;reltarget-&gt;exprs) != list_length(subquery-&gt;targetList))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trivial_pathtarget = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trivial_pathtarget = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, rel-&gt;reltarget-&gt;exprs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *node = (Node *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trivial_pathtarget = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var = (Var *) node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varno != rti ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varattno != foreach_current_index(lc) + <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trivial_pathtarget = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For each Path that <a href="../plan/planner.c.html#L628" title="optimizer/plan/planner.c:628">subquery_planner</a> produced, make a SubqueryScanPath<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the outer query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, sub_final_rel-&gt;pathlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *subpath = (Path *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Convert subpath's pathkeys to outer representation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pathkeys = <a href="pathkeys.c.html#L1069" title="optimizer/path/pathkeys.c:1069">convert_subquery_pathkeys</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subpath-&gt;pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/tlist.c.html#L624" title="optimizer/util/tlist.c:624">make_tlist_from_pathtarget</a>(subpath-&gt;pathtarget));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Generate outer path using this subpath */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/pathnode.c.html#L2016" title="optimizer/util/pathnode.c:2016">create_subqueryscan_path</a>(root, rel, subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trivial_pathtarget,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkeys, required_outer));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If outer rel allows parallelism, do same for partial paths. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;consider_parallel &amp;&amp; bms_is_empty(required_outer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If consider_parallel is false, there should be no partial paths. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(sub_final_rel-&gt;consider_parallel ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sub_final_rel-&gt;partial_pathlist == NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Same for partial paths. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, sub_final_rel-&gt;partial_pathlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *subpath = (Path *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Convert subpath's pathkeys to outer representation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkeys = <a href="pathkeys.c.html#L1069" title="optimizer/path/pathkeys.c:1069">convert_subquery_pathkeys</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subpath-&gt;pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/tlist.c.html#L624" title="optimizer/util/tlist.c:624">make_tlist_from_pathtarget</a>(subpath-&gt;pathtarget));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Generate outer path using this subpath */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L747" title="optimizer/util/pathnode.c:747">add_partial_path</a>(rel, (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../util/pathnode.c.html#L2016" title="optimizer/util/pathnode.c:2016">create_subqueryscan_path</a>(root, rel, subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trivial_pathtarget,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2761" title="optimizer/path/allpaths.c:2761">set_function_pathlist</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Build the (single) access path for a function RTE<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2761">&#x200c;</a></span><span class="linkable">set_function_pathlist</span>(PlannerInfo *root, RelOptInfo *rel, RangeTblEntry *rte)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; required_outer;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pathkeys = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't support pushing join clauses into the quals of a function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan, but it could still have required parameterization due to LATERAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * refs in the function expression.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; required_outer = rel-&gt;lateral_relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The result is considered unordered unless ORDINALITY was used, in which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case it is ordered by the ordinal column (the last one).&nbsp; See if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * care, by checking for uses of that Var in equivalence classes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;funcordinality)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; ordattno = rel-&gt;max_attr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Is there a Var for it in rel's targetlist?&nbsp; If not, the query did<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not reference the ordinality column, or at least not in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> way<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that would be interesting for sorting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, rel-&gt;reltarget-&gt;exprs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *node = (Var *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* checking varno/varlevelsup is just paranoia */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;varattno == ordattno &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;varno == rel-&gt;relid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;varlevelsup == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var = node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to build pathkeys for this Var with int8 sorting.&nbsp; We tell<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="pathkeys.c.html#L1015" title="optimizer/path/pathkeys.c:1015">build_expression_pathkey</a> not to build <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> new equivalence class; if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the Var isn't already mentioned in some EC, it means that nothing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cares about the ordering.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkeys = <a href="pathkeys.c.html#L1015" title="optimizer/path/pathkeys.c:1015">build_expression_pathkey</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Expr *) var,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int8LessOperator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Generate appropriate path */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, <a href="../util/pathnode.c.html#L2046" title="optimizer/util/pathnode.c:2046">create_functionscan_path</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pathkeys, required_outer));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2828" title="optimizer/path/allpaths.c:2828">set_values_pathlist</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Build the (single) access path for a VALUES RTE<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2828">&#x200c;</a></span><span class="linkable">set_values_pathlist</span>(PlannerInfo *root, RelOptInfo *rel, RangeTblEntry *rte)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; required_outer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't support pushing join clauses into the quals of a <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> scan,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but it could still have required parameterization due to LATERAL refs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> expressions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; required_outer = rel-&gt;lateral_relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Generate appropriate path */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, <a href="../util/pathnode.c.html#L2098" title="optimizer/util/pathnode.c:2098">create_valuesscan_path</a>(root, rel, required_outer));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2848" title="optimizer/path/allpaths.c:2848">set_tablefunc_pathlist</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Build the (single) access path for a table func RTE<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2848">&#x200c;</a></span><span class="linkable">set_tablefunc_pathlist</span>(PlannerInfo *root, RelOptInfo *rel, RangeTblEntry *rte)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; required_outer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't support pushing join clauses into the quals of a tablefunc<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan, but it could still have required parameterization due to LATERAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * refs in the function expression.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; required_outer = rel-&gt;lateral_relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Generate appropriate path */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, <a href="../util/pathnode.c.html#L2072" title="optimizer/util/pathnode.c:2072">create_tablefuncscan_path</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2872" title="optimizer/path/allpaths.c:2872">set_cte_pathlist</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Build the (single) access path for a non-self-reference CTE RTE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There's no need for a separate set_cte_size phase, since we don't<br/></li>
<li></span><span class="Comment"> * support join-qual-parameterized paths for CTEs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2872">&#x200c;</a></span><span class="linkable">set_cte_pathlist</span>(PlannerInfo *root, RelOptInfo *rel, RangeTblEntry *rte)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *ctepath;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *cteplan;<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *cteroot;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; levelsup;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pathkeys;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndx;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan_id;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; required_outer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find the referenced CTE, and locate the path and plan previously made<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; levelsup = rte-&gt;ctelevelsup;<br/></li>
<li>&nbsp; &nbsp; cteroot = root;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (levelsup-- &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cteroot = cteroot-&gt;parent_root;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!cteroot)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;bad levelsup for CTE </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, rte-&gt;ctename);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: cte_plan_ids can be shorter than cteList, if we are still working<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on planning the CTEs (ie, this is a side-reference from another CTE).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * So we mustn't use forboth here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ndx = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, cteroot-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;cteList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CommonTableExpr *cte = (CommonTableExpr *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(cte-&gt;ctename, rte-&gt;ctename) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ndx++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lc == <span class="Constant">NULL</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> CTE </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, rte-&gt;ctename);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndx &gt;= list_length(cteroot-&gt;cte_plan_ids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> plan for CTE </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, rte-&gt;ctename);<br/></li>
<li>&nbsp; &nbsp; plan_id = list_nth_int(cteroot-&gt;cte_plan_ids, ndx);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plan_id &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;no plan was made for CTE </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, rte-&gt;ctename);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(list_length(root-&gt;glob-&gt;subpaths) == list_length(root-&gt;glob-&gt;subplans));<br/></li>
<li>&nbsp; &nbsp; ctepath = (Path *) list_nth(root-&gt;glob-&gt;subpaths, plan_id - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; cteplan = (Plan *) list_nth(root-&gt;glob-&gt;subplans, plan_id - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark rel with estimated output rows, width, etc */<br/></li>
<li></span>&nbsp; &nbsp; <a href="costsize.c.html#L5964" title="optimizer/path/costsize.c:5964">set_cte_size_estimates</a>(root, rel, cteplan-&gt;plan_rows);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert the ctepath's pathkeys to outer query's representation */<br/></li>
<li></span>&nbsp; &nbsp; pathkeys = <a href="pathkeys.c.html#L1069" title="optimizer/path/pathkeys.c:1069">convert_subquery_pathkeys</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ctepath-&gt;pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cteplan-&gt;targetlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't support pushing join clauses into the quals of a CTE scan, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it could still have required parameterization due to LATERAL refs in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its tlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; required_outer = rel-&gt;lateral_relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Generate appropriate path */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, <a href="../util/pathnode.c.html#L2124" title="optimizer/util/pathnode.c:2124">create_ctescan_path</a>(root, rel, pathkeys, required_outer));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2951" title="optimizer/path/allpaths.c:2951">set_namedtuplestore_pathlist</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Build the (single) access path for a named tuplestore RTE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There's no need for a separate set_namedtuplestore_size phase, since we<br/></li>
<li></span><span class="Comment"> * don't support join-qual-parameterized paths for tuplestores.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2951">&#x200c;</a></span><span class="linkable">set_namedtuplestore_pathlist</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RangeTblEntry *rte)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; required_outer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark rel with estimated output rows, width, etc */<br/></li>
<li></span>&nbsp; &nbsp; <a href="costsize.c.html#L6002" title="optimizer/path/costsize.c:6002">set_namedtuplestore_size_estimates</a>(root, rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't support pushing join clauses into the quals of a tuplestore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan, but it could still have required parameterization due to LATERAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * refs in its tlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; required_outer = rel-&gt;lateral_relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Generate appropriate path */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, <a href="../util/pathnode.c.html#L2150" title="optimizer/util/pathnode.c:2150">create_namedtuplestorescan_path</a>(root, rel, required_outer));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2978" title="optimizer/path/allpaths.c:2978">set_result_pathlist</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Build the (single) access path for an RTE_RESULT RTE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There's no need for a separate set_result_size phase, since we<br/></li>
<li></span><span class="Comment"> * don't support join-qual-parameterized paths for these RTEs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2978">&#x200c;</a></span><span class="linkable">set_result_pathlist</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; required_outer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark rel with estimated output rows, width, etc */<br/></li>
<li></span>&nbsp; &nbsp; <a href="costsize.c.html#L6035" title="optimizer/path/costsize.c:6035">set_result_size_estimates</a>(root, rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't support pushing join clauses into the quals of a Result scan,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but it could still have required parameterization due to LATERAL refs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in its tlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; required_outer = rel-&gt;lateral_relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Generate appropriate path */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, <a href="../util/pathnode.c.html#L2176" title="optimizer/util/pathnode.c:2176">create_resultscan_path</a>(root, rel, required_outer));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3005" title="optimizer/path/allpaths.c:3005">set_worktable_pathlist</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Build the (single) access path for a self-reference CTE RTE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There's no need for a separate set_worktable_size phase, since we don't<br/></li>
<li></span><span class="Comment"> * support join-qual-parameterized paths for CTEs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3005">&#x200c;</a></span><span class="linkable">set_worktable_pathlist</span>(PlannerInfo *root, RelOptInfo *rel, RangeTblEntry *rte)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *ctepath;<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *cteroot;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; levelsup;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; required_outer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the non-recursive term's path, which is in the plan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * level that's processing the recursive UNION, which is one level *below*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * where the CTE comes from.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; levelsup = rte-&gt;ctelevelsup;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (levelsup == <span class="Constant">0</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;bad levelsup for CTE </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, rte-&gt;ctename);<br/></li>
<li>&nbsp; &nbsp; levelsup--;<br/></li>
<li>&nbsp; &nbsp; cteroot = root;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (levelsup-- &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cteroot = cteroot-&gt;parent_root;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!cteroot)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;bad levelsup for CTE </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, rte-&gt;ctename);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; ctepath = cteroot-&gt;non_recursive_path;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!ctepath)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> path for CTE </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, rte-&gt;ctename);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark rel with estimated output rows, width, etc */<br/></li>
<li></span>&nbsp; &nbsp; <a href="costsize.c.html#L5964" title="optimizer/path/costsize.c:5964">set_cte_size_estimates</a>(root, rel, ctepath-&gt;rows);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't support pushing join clauses into the quals of a worktable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan, but it could still have required parameterization due to LATERAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * refs in its tlist.&nbsp; (I'm not sure this is actually possible given the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restrictions on recursive references, but it's easy enough to support.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; required_outer = rel-&gt;lateral_relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Generate appropriate path */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, <a href="../util/pathnode.c.html#L2202" title="optimizer/util/pathnode.c:2202">create_worktablescan_path</a>(root, rel, required_outer));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3064" title="optimizer/path/allpaths.c:3064">generate_gather_paths</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Generate parallel access paths for a relation by pushing a Gather or<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Gather Merge on top of a partial path.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This must not be called until after we're done creating all partial paths<br/></li>
<li></span><span class="Comment"> * for the specified relation.&nbsp; (Otherwise, <a href="../util/pathnode.c.html#L747" title="optimizer/util/pathnode.c:747">add_partial_path</a> might delete a<br/></li>
<li></span><span class="Comment"> * path that some GatherPath or GatherMergePath has a reference to.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If we're generating paths for a scan or join relation, override_rows will<br/></li>
<li></span><span class="Comment"> * be false, and we'll just use the relation's size estimate.&nbsp; When we're<br/></li>
<li></span><span class="Comment"> * being called for a partially-grouped or partially-distinct path, though, we<br/></li>
<li></span><span class="Comment"> * need to override the rowcount estimate.&nbsp; (It's not clear that the<br/></li>
<li></span><span class="Comment"> * particular value we're using here is actually best, but the underlying rel<br/></li>
<li></span><span class="Comment"> * has no estimate so we must do something.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3064">&#x200c;</a></span><span class="linkable">generate_gather_paths</span>(PlannerInfo *root, RelOptInfo *rel, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> override_rows)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *cheapest_partial_path;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *simple_gather_path;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp;&nbsp; *rowsp = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there are no partial paths, there's nothing to do here. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;partial_pathlist == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should we override the rel's rowcount estimate? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (override_rows)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rowsp = &amp;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The output of Gather is always unsorted, so there's only one partial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * path of interest: the cheapest one.&nbsp; That will be the one at the front<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of partial_pathlist because of the way <a href="../util/pathnode.c.html#L747" title="optimizer/util/pathnode.c:747">add_partial_path</a> works.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cheapest_partial_path = linitial(rel-&gt;partial_pathlist);<br/></li>
<li>&nbsp; &nbsp; rows =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cheapest_partial_path-&gt;rows * cheapest_partial_path-&gt;parallel_workers;<br/></li>
<li>&nbsp; &nbsp; simple_gather_path = (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L1972" title="optimizer/util/pathnode.c:1972">create_gather_path</a>(root, rel, cheapest_partial_path, rel-&gt;reltarget,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, rowsp);<br/></li>
<li>&nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, simple_gather_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For each useful ordering, we can consider an order-preserving Gather<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Merge.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, rel-&gt;partial_pathlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *subpath = (Path *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GatherMergePath *path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subpath-&gt;pathkeys == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rows = subpath-&gt;rows * subpath-&gt;parallel_workers;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path = <a href="../util/pathnode.c.html#L1881" title="optimizer/util/pathnode.c:1881">create_gather_merge_path</a>(root, rel, subpath, rel-&gt;reltarget,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;pathkeys, <span class="Constant">NULL</span>, rowsp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, &amp;path-&gt;path);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3134" title="optimizer/path/allpaths.c:3134">get_useful_pathkeys_for_relation</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Determine which orderings of a relation might be useful.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Getting data in sorted order can be useful either because the requested<br/></li>
<li></span><span class="Comment"> * order matches the final output ordering for the overall query we're<br/></li>
<li></span><span class="Comment"> * planning, or because it enables an efficient <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> join.&nbsp; Here, we try<br/></li>
<li></span><span class="Comment"> * to figure out which pathkeys to consider.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This allows us to do incremental sort on top of an index scan under a gather<br/></li>
<li></span><span class="Comment"> * <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> node, i.e. parallelized.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the require_parallel_safe is true, we also require the expressions to<br/></li>
<li></span><span class="Comment"> * be parallel safe (which allows pushing the sort below Gather Merge).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> At the moment this can only ever return a list with a single <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>,<br/></li>
<li></span><span class="Comment"> * because it looks at query_pathkeys only. So we might return the pathkeys<br/></li>
<li></span><span class="Comment"> * directly, but it seems plausible we'll want to consider other orderings<br/></li>
<li></span><span class="Comment"> * in the future. For example, we might want to consider pathkeys useful for<br/></li>
<li></span><span class="Comment"> * <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> joins.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L3134">&#x200c;</a><span class="linkable">get_useful_pathkeys_for_relation</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> require_parallel_safe)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *useful_pathkeys_list = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Considering query_pathkeys is always worth it, because it might allow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * us to avoid a total sort when we have a partially presorted path<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * available or to <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> the total sort into the parallel portion of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;query_pathkeys)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npathkeys = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* useful pathkeys */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, root-&gt;query_pathkeys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathKey&nbsp; &nbsp; *pathkey = (PathKey *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EquivalenceClass *pathkey_ec = pathkey-&gt;pk_eclass;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can only build a sort for pathkeys that contain a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * safe-to-compute-early EC member computable from the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation's reltarget, so ignore the remainder of the list as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * soon as we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a pathkey without such a member.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's still worthwhile to return <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> prefix of the pathkeys list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that meets this requirement, as we may be able to do an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * incremental sort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If requested, ensure the sort expression is parallel-safe too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="equivclass.c.html#L933" title="optimizer/path/equivclass.c:933">relation_can_be_sorted_early</a>(root, rel, pathkey_ec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; require_parallel_safe))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npathkeys++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The whole query_pathkeys list matches, so append it directly, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allow comparing pathkeys easily by comparing list pointer. If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have to truncate the pathkeys, we gotta do a copy though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (npathkeys == list_length(root-&gt;query_pathkeys))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; useful_pathkeys_list = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(useful_pathkeys_list,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;query_pathkeys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (npathkeys &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; useful_pathkeys_list = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(useful_pathkeys_list,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/list.c.html#L1593" title="nodes/list.c:1593">list_copy_head</a>(root-&gt;query_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npathkeys));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> useful_pathkeys_list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3202" title="optimizer/path/allpaths.c:3202">generate_useful_gather_paths</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Generate parallel access paths for a relation by pushing a Gather or<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Gather Merge on top of a partial path.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike plain <a href="#L3064" title="optimizer/path/allpaths.c:3064">generate_gather_paths</a>, this looks both at pathkeys of input<br/></li>
<li></span><span class="Comment"> * paths (aiming to preserve the ordering), but also considers ordering that<br/></li>
<li></span><span class="Comment"> * might be useful for nodes above the gather <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> node, and tries to add<br/></li>
<li></span><span class="Comment"> * a sort (regular or incremental) to provide that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3202">&#x200c;</a></span><span class="linkable">generate_useful_gather_paths</span>(PlannerInfo *root, RelOptInfo *rel, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> override_rows)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; rows;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp;&nbsp; *rowsp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *useful_pathkeys_list = NIL;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *cheapest_partial_path = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there are no partial paths, there's nothing to do here. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;partial_pathlist == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should we override the rel's rowcount estimate? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (override_rows)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rowsp = &amp;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* generate the regular gather (<a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>) paths */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3064" title="optimizer/path/allpaths.c:3064">generate_gather_paths</a>(root, rel, override_rows);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* consider incremental sort for interesting orderings */<br/></li>
<li></span>&nbsp; &nbsp; useful_pathkeys_list = <a href="#L3134" title="optimizer/path/allpaths.c:3134">get_useful_pathkeys_for_relation</a>(root, rel, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* used for explicit (full) sort paths */<br/></li>
<li></span>&nbsp; &nbsp; cheapest_partial_path = linitial(rel-&gt;partial_pathlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Consider sorted paths for each interesting ordering. We generate both<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * incremental and full sort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, useful_pathkeys_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *useful_pathkeys = lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_sorted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; presorted_keys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, rel-&gt;partial_pathlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *subpath = (Path *) lfirst(lc2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GatherMergePath *path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_sorted = <a href="pathkeys.c.html#L573" title="optimizer/path/pathkeys.c:573">pathkeys_count_contained_in</a>(useful_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;presorted_keys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't need to consider the case where a subpath is already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fully sorted because <a href="#L3064" title="optimizer/path/allpaths.c:3064">generate_gather_paths</a> already creates a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * gather <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> path for every subpath that has pathkeys present.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * But since the subpath is already sorted, we know we don't need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to consider adding a sort (full or incremental) on top of it,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so we can continue here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_sorted)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try at least sorting the cheapest path and also try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * incrementally sorting <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> path which is partially sorted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already (no need to deal with paths which have presorted keys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when incremental sort is disabled unless it's the cheapest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * input path).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subpath != cheapest_partial_path &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (presorted_keys == <span class="Constant">0</span> || !<a href="costsize.c.html#L140" title="optimizer/path/costsize.c:140">enable_incremental_sort</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Consider regular sort for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> path that's not presorted or if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * incremental sort is disabled.&nbsp; We've no need to consider both<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sort and incremental sort on the same path.&nbsp; We assume that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * incremental sort is always faster when there are presorted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is not redundant with the gather paths created in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L3064" title="optimizer/path/allpaths.c:3064">generate_gather_paths</a>, because that doesn't generate ordered<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * output. Here we add an explicit sort to match the useful<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ordering.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (presorted_keys == <span class="Constant">0</span> || !<a href="costsize.c.html#L140" title="optimizer/path/costsize.c:140">enable_incremental_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath = (Path *) <a href="../util/pathnode.c.html#L3000" title="optimizer/util/pathnode.c:3000">create_sort_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; useful_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rows = subpath-&gt;rows * subpath-&gt;parallel_workers;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath = (Path *) <a href="../util/pathnode.c.html#L2951" title="optimizer/util/pathnode.c:2951">create_incremental_sort_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; useful_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; presorted_keys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path = <a href="../util/pathnode.c.html#L1881" title="optimizer/util/pathnode.c:1881">create_gather_merge_path</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;reltarget,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowsp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, &amp;path-&gt;path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3318" title="optimizer/path/allpaths.c:3318">make_rel_from_joinlist</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Build access paths using a &quot;joinlist&quot; to guide the join path search.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See comments for <a href="../plan/initsplan.c.html#L740" title="optimizer/plan/initsplan.c:740">deconstruct_jointree</a>() for definition of the joinlist<br/></li>
<li></span><span class="Comment"> * data structure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> RelOptInfo *<br/></li>
<li><a id="L3318">&#x200c;</a><span class="linkable">make_rel_from_joinlist</span>(PlannerInfo *root, List *joinlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; levels_needed;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *initial_rels;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *jl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Count the number of child joinlist nodes.&nbsp; This is the depth of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dynamic-programming algorithm we must employ to consider all ways of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * joining the child nodes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; levels_needed = list_length(joinlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (levels_needed &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do? */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Construct a list of rels corresponding to the child joinlist nodes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This may contain both base rels and rels constructed according to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sub-joinlists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; initial_rels = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(jl, joinlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *jlnode = (Node *) lfirst(jl);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *thisrel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(jlnode, RangeTblRef))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varno = ((RangeTblRef *) jlnode)-&gt;rtindex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisrel = <a href="../util/relnode.c.html#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(root, varno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(jlnode, List))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse to handle subproblem */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisrel = <a href="#L3318" title="optimizer/path/allpaths.c:3318">make_rel_from_joinlist</a>(root, (List *) jlnode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized joinlist node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) nodeTag(jlnode));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisrel = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initial_rels = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(initial_rels, thisrel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (levels_needed == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Single joinlist node, so we're done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (RelOptInfo *) linitial(initial_rels);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Consider the different orders in which we could join the rels,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * using a plugin, GEQO, or the regular join search code.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We put the initial_rels list into a PlannerInfo field because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="joinrels.c.html#L1240" title="optimizer/path/joinrels.c:1240">has_legal_joinclause</a>() needs to look at it (ugly :-().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;initial_rels = initial_rels;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L88" title="optimizer/path/allpaths.c:88">join_search_hook</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (*<a href="#L88" title="optimizer/path/allpaths.c:88">join_search_hook</a>) (root, levels_needed, initial_rels);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L79" title="optimizer/path/allpaths.c:79">enable_geqo</a> &amp;&amp; levels_needed &gt;= <a href="#L80" title="optimizer/path/allpaths.c:80">geqo_threshold</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../geqo/geqo_main.c.html#L72" title="optimizer/geqo/geqo_main.c:72">geqo</a>(root, levels_needed, initial_rels);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3423" title="optimizer/path/allpaths.c:3423">standard_join_search</a>(root, levels_needed, initial_rels);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3423" title="optimizer/path/allpaths.c:3423">standard_join_search</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Find possible joinpaths for a query by successively finding ways<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; to join component relations into join relations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'levels_needed' is the number of iterations needed, ie, the number of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; independent jointree items in the query.&nbsp; This is &gt; 1.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'initial_rels' is a list of RelOptInfo nodes for each independent<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; jointree item.&nbsp; These are the components to be joined together.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Note that levels_needed == list_length(initial_rels).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the final level of join relations, i.e., the relation that is<br/></li>
<li></span><span class="Comment"> * the result of joining all the original relations together.<br/></li>
<li></span><span class="Comment"> * At least one implementation path must be provided for this relation and<br/></li>
<li></span><span class="Comment"> * all required sub-relations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To support loadable plugins that modify <a href="../plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> behavior by changing the<br/></li>
<li></span><span class="Comment"> * join searching algorithm, we provide a hook variable that lets a plugin<br/></li>
<li></span><span class="Comment"> * replace or supplement this function.&nbsp; Any such hook must return the same<br/></li>
<li></span><span class="Comment"> * final join relation as the standard code would, but it might have a<br/></li>
<li></span><span class="Comment"> * different set of implementation paths attached, and only the sub-joinrels<br/></li>
<li></span><span class="Comment"> * needed for these paths need have been instantiated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note to plugin authors: the <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> invoked during <a href="#L3423" title="optimizer/path/allpaths.c:3423">standard_join_search</a>()<br/></li>
<li></span><span class="Comment"> * modify root-&gt;join_rel_list and root-&gt;join_rel_hash.&nbsp; If you want to do more<br/></li>
<li></span><span class="Comment"> * than one join-order search, you'll probably need to save and restore the<br/></li>
<li></span><span class="Comment"> * original states of those data structures.&nbsp; See <a href="../geqo/geqo_eval.c.html#L57" title="optimizer/geqo/geqo_eval.c:57">geqo_eval</a>() for an example.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RelOptInfo *<br/></li>
<li><a id="L3423">&#x200c;</a><span class="linkable">standard_join_search</span>(PlannerInfo *root, <span class="Type">int</span> levels_needed, List *initial_rels)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lev;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This function cannot be invoked recursively within <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one planning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * problem, so join_rel_level[] can't be in use already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(root-&gt;join_rel_level == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We employ a simple &quot;dynamic programming&quot; algorithm: we first <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ways to build joins of two jointree items, then all ways to build joins<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of three items (from two-item joins and single items), then four-item<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * joins, and so on until we have considered all ways to join all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * items into one rel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * root-&gt;join_rel_level[j] is a list of all the j-item rels.&nbsp; Initially we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set root-&gt;join_rel_level[1] to represent all the single-jointree-item<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;join_rel_level = (List **) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>((levels_needed + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(List *));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; root-&gt;join_rel_level[<span class="Constant">1</span>] = initial_rels;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (lev = <span class="Constant">2</span>; lev &lt;= levels_needed; lev++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Determine all possible pairs of relations to be joined at this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * level, and build paths for making each one from every available<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pair of <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-level relations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="joinrels.c.html#L72" title="optimizer/path/joinrels.c:72">join_search_one_level</a>(root, lev);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Run <a href="#L4303" title="optimizer/path/allpaths.c:4303">generate_partitionwise_join_paths</a>() and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L3202" title="optimizer/path/allpaths.c:3202">generate_useful_gather_paths</a>() for each just-processed joinrel.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could not do this earlier because both regular and partial paths<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can get added to a particular joinrel at multiple times within<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="joinrels.c.html#L72" title="optimizer/path/joinrels.c:72">join_search_one_level</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * After that, we're done creating paths for the joinrel, so run<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../util/pathnode.c.html#L242" title="optimizer/util/pathnode.c:242">set_cheapest</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, root-&gt;join_rel_level[lev])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel = (RelOptInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create paths for partitionwise joins. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4303" title="optimizer/path/allpaths.c:4303">generate_partitionwise_join_paths</a>(root, rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Except for the topmost scan/join rel, consider gathering<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partial paths.&nbsp; We'll do the same for the topmost scan/join rel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * once we know the final targetlist (see <a href="../plan/planner.c.html#L1305" title="optimizer/plan/planner.c:1305">grouping_planner</a>'s and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * its call to <a href="../plan/planner.c.html#L7503" title="optimizer/plan/planner.c:7503">apply_scanjoin_target_to_paths</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(rel-&gt;relids, root-&gt;all_query_rels))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3202" title="optimizer/path/allpaths.c:3202">generate_useful_gather_paths</a>(root, rel, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find and save the cheapest paths for this rel */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L242" title="optimizer/util/pathnode.c:242">set_cheapest</a>(rel);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef OPTIMIZER_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/print.c.html#L54" title="nodes/print.c:54">pprint</a>(rel);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We should have a single rel at the final level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;join_rel_level[levels_needed] == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to build <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> </span><span class="Special">%d</span><span class="Constant">-way joins&quot;</span>, levels_needed);<br/></li>
<li>&nbsp; &nbsp; Assert(list_length(root-&gt;join_rel_level[levels_needed]) == <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel = (RelOptInfo *) linitial(root-&gt;join_rel_level[levels_needed]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; root-&gt;join_rel_level = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PUSHING QUALS DOWN INTO SUBQUERIES<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3594" title="optimizer/path/allpaths.c:3594">subquery_is_pushdown_safe</a> - is a subquery safe for pushing down quals?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * subquery is the particular component query being checked.&nbsp; topquery<br/></li>
<li></span><span class="Comment"> * is the top component of a set-operations tree (the same Query if no<br/></li>
<li></span><span class="Comment"> * set-op is involved).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Conditions checked here:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 1. If the subquery has a LIMIT clause, we must not <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> down <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> quals,<br/></li>
<li></span><span class="Comment"> * since that could change the set of rows returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 2. If the subquery contains EXCEPT or EXCEPT ALL set ops we cannot <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a><br/></li>
<li></span><span class="Comment"> * quals into it, because that could change the results.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 3. If the subquery uses DISTINCT, we cannot <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> volatile quals into it.<br/></li>
<li></span><span class="Comment"> * This is because <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level quals should semantically be evaluated only<br/></li>
<li></span><span class="Comment"> * once per distinct row, not once per original row, and if the qual is<br/></li>
<li></span><span class="Comment"> * volatile then extra evaluations could change the results.&nbsp; (This issue<br/></li>
<li></span><span class="Comment"> * does not apply to other forms of aggregation such as GROUP BY, because<br/></li>
<li></span><span class="Comment"> * when those are present we <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> into HAVING not WHERE, so that the quals<br/></li>
<li></span><span class="Comment"> * are still applied after aggregation.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 4. If the subquery contains window <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, we cannot <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> volatile quals<br/></li>
<li></span><span class="Comment"> * into it.&nbsp; The issue here is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> different from DISTINCT: a volatile qual<br/></li>
<li></span><span class="Comment"> * might succeed for some rows of a window partition and fail for others,<br/></li>
<li></span><span class="Comment"> * thereby changing the partition contents and thus the window <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>'<br/></li>
<li></span><span class="Comment"> * results for rows that remain.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 5. If the subquery contains <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> set-returning <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in its targetlist,<br/></li>
<li></span><span class="Comment"> * we cannot <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> volatile quals into it.&nbsp; That would <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> them below the SRFs<br/></li>
<li></span><span class="Comment"> * and thereby change the number of times they are evaluated.&nbsp; Also, a<br/></li>
<li></span><span class="Comment"> * volatile qual could succeed for some SRF output rows and fail for others,<br/></li>
<li></span><span class="Comment"> * a behavior that cannot occur if it's evaluated <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> SRF expansion.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 6. If the subquery has nonempty grouping sets, we cannot <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> down <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * quals.&nbsp; The concern here is that a qual referencing a &quot;constant&quot; grouping<br/></li>
<li></span><span class="Comment"> * column could get constant-folded, which would be improper because the value<br/></li>
<li></span><span class="Comment"> * is potentially nullable by grouping-set expansion.&nbsp; This restriction could<br/></li>
<li></span><span class="Comment"> * be removed if we had a parsetree representation that shows that such<br/></li>
<li></span><span class="Comment"> * grouping columns are not really constant.&nbsp; (There are other ideas that<br/></li>
<li></span><span class="Comment"> * could be used to relax this restriction, but that's the approach most<br/></li>
<li></span><span class="Comment"> * likely to get taken in the future.&nbsp; Note that there's not much to be gained<br/></li>
<li></span><span class="Comment"> * so long as <a href="../plan/planner.c.html#L628" title="optimizer/plan/planner.c:628">subquery_planner</a> can't move HAVING clauses to WHERE within such<br/></li>
<li></span><span class="Comment"> * a subquery.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In addition, we make several checks on the subquery's output columns to see<br/></li>
<li></span><span class="Comment"> * if it is safe to reference them in pushed-down quals.&nbsp; If output column k<br/></li>
<li></span><span class="Comment"> * is found to be unsafe to reference, we set the reason for that inside<br/></li>
<li></span><span class="Comment"> * safetyInfo-&gt;unsafeFlags[k], but we don't reject the subquery overall since<br/></li>
<li></span><span class="Comment"> * column k might not be referenced by some/all quals.&nbsp; The unsafeFlags[]<br/></li>
<li></span><span class="Comment"> * array will be consulted later by <a href="#L3867" title="optimizer/path/allpaths.c:3867">qual_is_pushdown_safe</a>().&nbsp; It's better to<br/></li>
<li></span><span class="Comment"> * do it this way than to make the checks directly in <a href="#L3867" title="optimizer/path/allpaths.c:3867">qual_is_pushdown_safe</a>(),<br/></li>
<li></span><span class="Comment"> * because when the subquery involves set operations we have to check the<br/></li>
<li></span><span class="Comment"> * output expressions in each arm of the set op.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: pushing quals into a DISTINCT subquery is theoretically dubious:<br/></li>
<li></span><span class="Comment"> * we're effectively assuming that the quals cannot distinguish <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that<br/></li>
<li></span><span class="Comment"> * the DISTINCT's equality operator sees as <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, yet there are many<br/></li>
<li></span><span class="Comment"> * counterexamples to that assumption.&nbsp; However use of such a qual with a<br/></li>
<li></span><span class="Comment"> * DISTINCT subquery would be unsafe anyway, since there's no guarantee which<br/></li>
<li></span><span class="Comment"> * &quot;<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>&quot; value will be chosen as the output value by the DISTINCT operation.<br/></li>
<li></span><span class="Comment"> * So we don't worry too much about that.&nbsp; Another objection is that if the<br/></li>
<li></span><span class="Comment"> * qual is expensive to evaluate, running it for each original row might cost<br/></li>
<li></span><span class="Comment"> * more than we save by eliminating rows <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the DISTINCT step.&nbsp; But it<br/></li>
<li></span><span class="Comment"> * would be very hard to estimate that at this stage, and in practice pushdown<br/></li>
<li></span><span class="Comment"> * seldom seems to make things worse, so we ignore that problem too.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: likewise, pushing quals into a subquery with window <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> is a<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> dubious: the quals might remove some rows of a window partition while<br/></li>
<li></span><span class="Comment"> * leaving others, causing changes in the window <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>' results for the<br/></li>
<li></span><span class="Comment"> * surviving rows.&nbsp; We insist that such a qual reference only partitioning<br/></li>
<li></span><span class="Comment"> * columns, but again that only protects us if the qual does not distinguish<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that the partitioning equality operator sees as <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>.&nbsp; The risks<br/></li>
<li></span><span class="Comment"> * here are perhaps larger than for DISTINCT, since no de-duplication of rows<br/></li>
<li></span><span class="Comment"> * occurs and thus there is no theoretical problem with such a qual.&nbsp; But<br/></li>
<li></span><span class="Comment"> * we'll do this anyway because the potential performance benefits are very<br/></li>
<li></span><span class="Comment"> * large, and we've seen no field complaints about the longstanding comparable<br/></li>
<li></span><span class="Comment"> * behavior with DISTINCT.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3594">&#x200c;</a></span><span class="linkable">subquery_is_pushdown_safe</span>(Query *subquery, Query *topquery,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L60" title="optimizer/path/allpaths.c:60">pushdown_safety_info</a> *safetyInfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SetOperationStmt *topop;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check point 1 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (subquery-&gt;limitOffset != <span class="Constant">NULL</span> || subquery-&gt;limitCount != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check point 6 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (subquery-&gt;groupClause &amp;&amp; subquery-&gt;groupingSets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check points 3, 4, and 5 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (subquery-&gt;distinctClause ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subquery-&gt;hasWindowFuncs ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subquery-&gt;hasTargetSRFs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; safetyInfo-&gt;unsafeVolatile = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're at a leaf query, check for unsafe expressions in its target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list, and mark <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> reasons why they're unsafe in unsafeFlags[].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Non-leaf nodes in setop trees have only simple Vars in their tlists,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so no need to check them.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (subquery-&gt;setOperations == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3719" title="optimizer/path/allpaths.c:3719">check_output_expressions</a>(subquery, safetyInfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Are we at top level, or looking at a setop component? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (subquery == topquery)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Top level, so check <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> component queries */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subquery-&gt;setOperations != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3650" title="optimizer/path/allpaths.c:3650">recurse_pushdown_safe</a>(subquery-&gt;setOperations, topquery,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; safetyInfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Setop component must not have more components (too weird) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subquery-&gt;setOperations != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check whether setop component output types match top level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; topop = castNode(SetOperationStmt, topquery-&gt;setOperations);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(topop);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3791" title="optimizer/path/allpaths.c:3791">compare_tlist_datatypes</a>(subquery-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; topop-&gt;colTypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; safetyInfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper routine to recurse through setOperations tree<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3650">&#x200c;</a></span><span class="linkable">recurse_pushdown_safe</span>(Node *setOp, Query *topquery,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L60" title="optimizer/path/allpaths.c:60">pushdown_safety_info</a> *safetyInfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(setOp, RangeTblRef))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblRef *rtr = (RangeTblRef *) setOp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = rt_fetch(rtr-&gt;rtindex, topquery-&gt;rtable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *subquery = rte-&gt;subquery;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(subquery != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3594" title="optimizer/path/allpaths.c:3594">subquery_is_pushdown_safe</a>(subquery, topquery, safetyInfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(setOp, SetOperationStmt))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SetOperationStmt *op = (SetOperationStmt *) setOp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* EXCEPT is no good (point 2 for <a href="#L3594" title="optimizer/path/allpaths.c:3594">subquery_is_pushdown_safe</a>) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op-&gt;op == SETOP_EXCEPT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Else recurse */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3650" title="optimizer/path/allpaths.c:3650">recurse_pushdown_safe</a>(op-&gt;larg, topquery, safetyInfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3650" title="optimizer/path/allpaths.c:3650">recurse_pushdown_safe</a>(op-&gt;rarg, topquery, safetyInfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) nodeTag(setOp));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3719" title="optimizer/path/allpaths.c:3719">check_output_expressions</a> - check subquery's output expressions for safety<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There are several cases in which it's unsafe to <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> down an <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level<br/></li>
<li></span><span class="Comment"> * qual if it references a particular output column of a subquery.&nbsp; We check<br/></li>
<li></span><span class="Comment"> * each output column of the subquery and set flags in unsafeFlags[k] when we<br/></li>
<li></span><span class="Comment"> * see that column is unsafe for a pushed-down qual to reference.&nbsp; The<br/></li>
<li></span><span class="Comment"> * conditions checked here are:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 1. We must not <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> down <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> quals that refer to subselect outputs that<br/></li>
<li></span><span class="Comment"> * return sets, else we'd introduce <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>-returning-sets into the<br/></li>
<li></span><span class="Comment"> * subquery's WHERE/HAVING quals.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 2. We must not <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> down <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> quals that refer to subselect outputs that<br/></li>
<li></span><span class="Comment"> * contain volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, for fear of introducing strange results due<br/></li>
<li></span><span class="Comment"> * to multiple evaluation of a volatile function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 3. If the subquery uses DISTINCT ON, we must not <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> down <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> quals that<br/></li>
<li></span><span class="Comment"> * refer to non-DISTINCT output columns, because that could change the set<br/></li>
<li></span><span class="Comment"> * of rows returned.&nbsp; (This condition is vacuous for DISTINCT, because then<br/></li>
<li></span><span class="Comment"> * there are no non-DISTINCT output columns, so we needn't check.&nbsp; Note that<br/></li>
<li></span><span class="Comment"> * <a href="#L3594" title="optimizer/path/allpaths.c:3594">subquery_is_pushdown_safe</a> already reported that we can't use volatile<br/></li>
<li></span><span class="Comment"> * quals if there's DISTINCT or DISTINCT ON.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 4. If the subquery has <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> window <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, we must not <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> down quals<br/></li>
<li></span><span class="Comment"> * that reference <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> output columns that are not listed in all the subquery's<br/></li>
<li></span><span class="Comment"> * window PARTITION BY clauses.&nbsp; We can <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> down quals that use only<br/></li>
<li></span><span class="Comment"> * partitioning columns because they should succeed or fail identically for<br/></li>
<li></span><span class="Comment"> * every row of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one window partition, and totally excluding some<br/></li>
<li></span><span class="Comment"> * partitions will not change a window function's results for remaining<br/></li>
<li></span><span class="Comment"> * partitions.&nbsp; (Again, this also requires nonvolatile quals, but<br/></li>
<li></span><span class="Comment"> * <a href="#L3594" title="optimizer/path/allpaths.c:3594">subquery_is_pushdown_safe</a> handles that.).&nbsp; Subquery columns marked as<br/></li>
<li></span><span class="Comment"> * unsafe for this reason can still have WindowClause run conditions pushed<br/></li>
<li></span><span class="Comment"> * down.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3719">&#x200c;</a></span><span class="linkable">check_output_expressions</span>(Query *subquery, <a href="#L60" title="optimizer/path/allpaths.c:60">pushdown_safety_info</a> *safetyInfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, subquery-&gt;targetList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore resjunk columns */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Functions returning sets are unsafe (point 1) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subquery-&gt;hasTargetSRFs &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (safetyInfo-&gt;unsafeFlags[tle-&gt;resno] &amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L54" title="optimizer/path/allpaths.c:54">UNSAFE_HAS_SET_FUNC</a>) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L758" title="nodes/nodeFuncs.c:758">expression_returns_set</a>((Node *) tle-&gt;expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; safetyInfo-&gt;unsafeFlags[tle-&gt;resno] |= <a href="#L54" title="optimizer/path/allpaths.c:54">UNSAFE_HAS_SET_FUNC</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are unsafe (point 2) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((safetyInfo-&gt;unsafeFlags[tle-&gt;resno] &amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L53" title="optimizer/path/allpaths.c:53">UNSAFE_HAS_VOLATILE_FUNC</a>) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>((Node *) tle-&gt;expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; safetyInfo-&gt;unsafeFlags[tle-&gt;resno] |= <a href="#L53" title="optimizer/path/allpaths.c:53">UNSAFE_HAS_VOLATILE_FUNC</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If subquery uses DISTINCT ON, check point 3 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subquery-&gt;hasDistinctOn &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (safetyInfo-&gt;unsafeFlags[tle-&gt;resno] &amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L55" title="optimizer/path/allpaths.c:55">UNSAFE_NOTIN_DISTINCTON_CLAUSE</a>) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../parser/parse_clause.c.html#L3633" title="parser/parse_clause.c:3633">targetIsInSortList</a>(tle, InvalidOid, subquery-&gt;distinctClause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* non-DISTINCT column, so mark it unsafe */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; safetyInfo-&gt;unsafeFlags[tle-&gt;resno] |= <a href="#L55" title="optimizer/path/allpaths.c:55">UNSAFE_NOTIN_DISTINCTON_CLAUSE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If subquery uses window <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, check point 4 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subquery-&gt;hasWindowFuncs &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (safetyInfo-&gt;unsafeFlags[tle-&gt;resno] &amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L55" title="optimizer/path/allpaths.c:55">UNSAFE_NOTIN_DISTINCTON_CLAUSE</a>) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L3824" title="optimizer/path/allpaths.c:3824">targetIsInAllPartitionLists</a>(tle, subquery))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not present in all PARTITION BY clauses, so mark it unsafe */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; safetyInfo-&gt;unsafeFlags[tle-&gt;resno] |= <a href="#L56" title="optimizer/path/allpaths.c:56">UNSAFE_NOTIN_PARTITIONBY_CLAUSE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * For subqueries using UNION/UNION ALL/INTERSECT/INTERSECT ALL, we can<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> quals into each component query, but the quals can only reference<br/></li>
<li></span><span class="Comment"> * subquery columns that suffer no type coercions in the set operation.<br/></li>
<li></span><span class="Comment"> * Otherwise there are possible semantic gotchas.&nbsp; So, we check the<br/></li>
<li></span><span class="Comment"> * component queries to see if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of them have output types different from<br/></li>
<li></span><span class="Comment"> * the top-level setop outputs.&nbsp; We set the <a href="#L57" title="optimizer/path/allpaths.c:57">UNSAFE_TYPE_MISMATCH</a> <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> in<br/></li>
<li></span><span class="Comment"> * unsafeFlags[k] if column k has different type in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> component.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We don't have to care about typmods here: the only allowed difference<br/></li>
<li></span><span class="Comment"> * between set-op input and output typmods is input is a specific typmod<br/></li>
<li></span><span class="Comment"> * and output is -1, and that does not require a coercion.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * tlist is a subquery tlist.<br/></li>
<li></span><span class="Comment"> * colTypes is an OID list of the top-level setop's output column types.<br/></li>
<li></span><span class="Comment"> * safetyInfo is the <a href="#L60" title="optimizer/path/allpaths.c:60">pushdown_safety_info</a> to set unsafeFlags[] for.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3791">&#x200c;</a></span><span class="linkable">compare_tlist_datatypes</span>(List *tlist, List *colTypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L60" title="optimizer/path/allpaths.c:60">pushdown_safety_info</a> *safetyInfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *colType = list_head(colTypes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, tlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore resjunk columns */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (colType == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;wrong number of tlist entries&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) tle-&gt;expr) != lfirst_oid(colType))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; safetyInfo-&gt;unsafeFlags[tle-&gt;resno] |= <a href="#L57" title="optimizer/path/allpaths.c:57">UNSAFE_TYPE_MISMATCH</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; colType = lnext(colTypes, colType);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (colType != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;wrong number of tlist entries&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3824" title="optimizer/path/allpaths.c:3824">targetIsInAllPartitionLists</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; True if the TargetEntry is listed in the PARTITION BY clause<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; of every window defined in the query.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It would be safe to ignore windows not actually used by <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> window<br/></li>
<li></span><span class="Comment"> * function, but it's not easy to get that info at this stage; and it's<br/></li>
<li></span><span class="Comment"> * unlikely to be useful to spend <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> extra cycles getting it, since<br/></li>
<li></span><span class="Comment"> * unreferenced window definitions are probably infrequent in practice.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3824">&#x200c;</a></span><span class="linkable">targetIsInAllPartitionLists</span>(TargetEntry *tle, Query *query)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, query-&gt;windowClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WindowClause *wc = (WindowClause *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../parser/parse_clause.c.html#L3633" title="parser/parse_clause.c:3633">targetIsInSortList</a>(tle, InvalidOid, wc-&gt;partitionClause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3867" title="optimizer/path/allpaths.c:3867">qual_is_pushdown_safe</a> - is a particular rinfo safe to <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> down?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * rinfo is a restriction clause applying to the given subquery (whose RTE<br/></li>
<li></span><span class="Comment"> * has index rti in the parent query).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Conditions checked here:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 1. rinfo's clause must not contain <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SubPlans (mainly because it's<br/></li>
<li></span><span class="Comment"> * unclear that it will work correctly: SubLinks will already have been<br/></li>
<li></span><span class="Comment"> * transformed into SubPlans in the qual, but not in the subquery).&nbsp; Note that<br/></li>
<li></span><span class="Comment"> * SubLinks that transform to initplans are safe, and will be accepted here<br/></li>
<li></span><span class="Comment"> * because what we'll see in the qual is just a Param referencing the initplan<br/></li>
<li></span><span class="Comment"> * output.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 2. If unsafeVolatile is set, rinfo's clause must not contain <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> volatile<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 3. If unsafeLeaky is set, rinfo's clause must not contain <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> leaky<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that are passed Var nodes, and therefore might reveal <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> from<br/></li>
<li></span><span class="Comment"> * the subquery as side effects.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 4. rinfo's clause must not refer to the whole-row output of the subquery<br/></li>
<li></span><span class="Comment"> * (since there is no easy way to name that within the subquery itself).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 5. rinfo's clause must not refer to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subquery output columns that were<br/></li>
<li></span><span class="Comment"> * found to be unsafe to reference by <a href="#L3594" title="optimizer/path/allpaths.c:3594">subquery_is_pushdown_safe</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L70" title="optimizer/path/allpaths.c:70">pushdown_safe_type</a><br/></li>
<li><a id="L3867">&#x200c;</a><span class="linkable">qual_is_pushdown_safe</span>(Query *subquery, Index rti, RestrictInfo *rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L60" title="optimizer/path/allpaths.c:60">pushdown_safety_info</a> *safetyInfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L70" title="optimizer/path/allpaths.c:70">pushdown_safe_type</a> safe = PUSHDOWN_SAFE;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *qual = (Node *) rinfo-&gt;clause;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *vl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Refuse subselects (point 1) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/clauses.c.html#L330" title="optimizer/util/clauses.c:330">contain_subplans</a>(qual))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PUSHDOWN_UNSAFE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Refuse volatile quals if we found they'd be unsafe (point 2) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (safetyInfo-&gt;unsafeVolatile &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>((Node *) rinfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PUSHDOWN_UNSAFE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Refuse leaky quals if told to (point 3) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (safetyInfo-&gt;unsafeLeaky &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/clauses.c.html#L1263" title="optimizer/util/clauses.c:1263">contain_leaked_vars</a>(qual))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PUSHDOWN_UNSAFE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Examine all Vars used in clause.&nbsp; Since it's a restriction clause, all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * such Vars must refer to subselect output columns ... unless this is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * part of a LATERAL subquery, in which case there could be lateral<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * references.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * By omitting the relevant flags, this also gives us a cheap sanity check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that no aggregates or window <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> appear in the qual.&nbsp; Those would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be unsafe to <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> down, but at least for the moment we could never see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> in a qual anyhow.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> = <a href="../util/var.c.html#L607" title="optimizer/util/var.c:607">pull_var_clause</a>(qual, PVC_INCLUDE_PLACEHOLDERS);<br/></li>
<li>&nbsp; &nbsp; foreach(vl, <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) lfirst(vl);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> Punt if we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> PlaceHolderVars in the restriction clause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's not clear whether a PHV could safely be pushed down, and even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * less clear whether such a situation could arise in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> cases of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * practical interest anyway.&nbsp; So for the moment, just refuse to <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * down.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsA(var, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; safe = PUSHDOWN_UNSAFE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Punt if we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> lateral references.&nbsp; It would be safe to <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * these down, but we'd have to convert them into outer references,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which <a href="#L3968" title="optimizer/path/allpaths.c:3968">subquery_push_qual</a> lacks the infrastructure to do.&nbsp; The case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * arises so seldom that it doesn't seem worth working hard on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varno != rti)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; safe = PUSHDOWN_UNSAFE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Subqueries have no system columns */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(var-&gt;varattno &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check point 4 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varattno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; safe = PUSHDOWN_UNSAFE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check point 5 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (safetyInfo-&gt;unsafeFlags[var-&gt;varattno] != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (safetyInfo-&gt;unsafeFlags[var-&gt;varattno] &amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L53" title="optimizer/path/allpaths.c:53">UNSAFE_HAS_VOLATILE_FUNC</a> | <a href="#L54" title="optimizer/path/allpaths.c:54">UNSAFE_HAS_SET_FUNC</a> |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L55" title="optimizer/path/allpaths.c:55">UNSAFE_NOTIN_DISTINCTON_CLAUSE</a> | <a href="#L57" title="optimizer/path/allpaths.c:57">UNSAFE_TYPE_MISMATCH</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; safe = PUSHDOWN_UNSAFE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L56" title="optimizer/path/allpaths.c:56">UNSAFE_NOTIN_PARTITIONBY_CLAUSE</a> is ok for run conditions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; safe = PUSHDOWN_WINDOWCLAUSE_RUNCOND;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't break, we might <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> another Var that's unsafe */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> safe;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3968" title="optimizer/path/allpaths.c:3968">subquery_push_qual</a> - <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> down a qual that we have determined is safe<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3968">&#x200c;</a></span><span class="linkable">subquery_push_qual</span>(Query *subquery, RangeTblEntry *rte, Index rti, Node *qual)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (subquery-&gt;setOperations != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse to <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> it separately to each component query */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4015" title="optimizer/path/allpaths.c:4015">recurse_push_qual</a>(subquery-&gt;setOperations, subquery,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte, rti, qual);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need to replace Vars in the qual (which must refer to outputs of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the subquery) with copies of the subquery's targetlist expressions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that at this point, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> uplevel Vars in the qual should have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * been replaced with Params, so they need no work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This step also ensures that when we are pushing into a setop tree,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * each component query gets its own copy of the qual.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qual = <a href="../../rewrite/rewriteManip.c.html#L1769" title="rewrite/rewriteManip.c:1769">ReplaceVarsFromTargetList</a>(qual, rti, <span class="Constant">0</span>, rte,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subquery-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; REPLACEVARS_REPORT_ERROR, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;subquery-&gt;hasSubLinks);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now attach the qual to the proper place: normally WHERE, but if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subquery uses grouping or aggregation, put it in HAVING (since the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * qual really refers to the group-result rows).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subquery-&gt;hasAggs || subquery-&gt;groupClause || subquery-&gt;groupingSets || subquery-&gt;havingQual)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subquery-&gt;havingQual = <a href="../../nodes/makefuncs.c.html#L707" title="nodes/makefuncs.c:707">make_and_qual</a>(subquery-&gt;havingQual, qual);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subquery-&gt;jointree-&gt;quals =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/makefuncs.c.html#L707" title="nodes/makefuncs.c:707">make_and_qual</a>(subquery-&gt;jointree-&gt;quals, qual);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need not change the subquery's hasAggs or hasSubLinks flags,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since we can't be pushing down <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> aggregates that weren't there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>, and we don't <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> down subselects at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper routine to recurse through setOperations tree<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4015">&#x200c;</a></span><span class="linkable">recurse_push_qual</span>(Node *setOp, Query *topquery,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte, Index rti, Node *qual)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(setOp, RangeTblRef))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblRef *rtr = (RangeTblRef *) setOp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *subrte = rt_fetch(rtr-&gt;rtindex, topquery-&gt;rtable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *subquery = subrte-&gt;subquery;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(subquery != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3968" title="optimizer/path/allpaths.c:3968">subquery_push_qual</a>(subquery, rte, rti, qual);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(setOp, SetOperationStmt))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SetOperationStmt *op = (SetOperationStmt *) setOp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4015" title="optimizer/path/allpaths.c:4015">recurse_push_qual</a>(op-&gt;larg, topquery, rte, rti, qual);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4015" title="optimizer/path/allpaths.c:4015">recurse_push_qual</a>(op-&gt;rarg, topquery, rte, rti, qual);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) nodeTag(setOp));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SIMPLIFYING SUBQUERY TARGETLISTS<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4067" title="optimizer/path/allpaths.c:4067">remove_unused_subquery_outputs</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Remove subquery targetlist items we don't need<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It's possible, even likely, that the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> query does not read all the<br/></li>
<li></span><span class="Comment"> * output columns of the subquery.&nbsp; We can remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such outputs that are<br/></li>
<li></span><span class="Comment"> * not needed by the subquery itself (e.g., as sort/group columns) and do not<br/></li>
<li></span><span class="Comment"> * affect semantics otherwise (e.g., volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> can't be removed).<br/></li>
<li></span><span class="Comment"> * This is useful not only because we might be able to remove expensive-to-<br/></li>
<li></span><span class="Comment"> * compute expressions, but because deletion of output columns might allow<br/></li>
<li></span><span class="Comment"> * optimizations such as join removal to occur within the subquery.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * extra_used_attrs can be passed as non-NULL to mark <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> columns (offset by<br/></li>
<li></span><span class="Comment"> * FirstLowInvalidHeapAttributeNumber) that we should not remove.&nbsp; This<br/></li>
<li></span><span class="Comment"> * parameter is modified by the function, so callers must make a copy if they<br/></li>
<li></span><span class="Comment"> * need to use the passed in Bitmapset after calling this function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To avoid affecting column numbering in the targetlist, we don't physically<br/></li>
<li></span><span class="Comment"> * remove unused tlist entries, but rather replace their expressions with NULL<br/></li>
<li></span><span class="Comment"> * constants.&nbsp; This is implemented by modifying subquery-&gt;targetList.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4067">&#x200c;</a></span><span class="linkable">remove_unused_subquery_outputs</span>(Query *subquery, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Bitmapset *extra_used_attrs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *attrs_used;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Just point directly to extra_used_attrs. No need to <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a> as <a href="../util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the current callers use the Bitmapset after calling this function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; attrs_used = extra_used_attrs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do nothing if subquery has UNION/INTERSECT/EXCEPT: in principle we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * could update all the child SELECTs' tlists, but it seems not worth the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trouble presently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (subquery-&gt;setOperations)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If subquery has regular DISTINCT (not DISTINCT ON), we're wasting our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * time: all its output columns must be used in the distinctClause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (subquery-&gt;distinctClause &amp;&amp; !subquery-&gt;hasDistinctOn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Collect a bitmap of all the output column numbers used by the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add all the attributes needed for joins or final output.&nbsp; Note: we must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * look at rel's targetlist, not the attr_needed data, because attr_needed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * isn't computed for inheritance child rels, cf <a href="#L944" title="optimizer/path/allpaths.c:944">set_append_rel_size</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (</span><span class="Todo">XXX</span><span class="Comment"> might be worth changing that sometime.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../util/var.c.html#L291" title="optimizer/util/var.c:291">pull_varattnos</a>((Node *) rel-&gt;reltarget-&gt;exprs, rel-&gt;relid, &amp;attrs_used);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add all the attributes used by un-pushed-down restriction clauses. */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, rel-&gt;baserestrictinfo)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/var.c.html#L291" title="optimizer/util/var.c:291">pull_varattnos</a>((Node *) rinfo-&gt;clause, rel-&gt;relid, &amp;attrs_used);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there's a whole-row reference to the subquery, we can't remove<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anything.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(<span class="Constant">0</span> - FirstLowInvalidHeapAttributeNumber, attrs_used))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Run through the tlist and zap entries we don't need.&nbsp; It's okay to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * modify the tlist items in-place because <a href="#L2494" title="optimizer/path/allpaths.c:2494">set_subquery_pathlist</a> made a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * copy of the subquery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, subquery-&gt;targetList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *texpr = (Node *) tle-&gt;expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it has a sortgroupref number, it's used in some sort/group<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clause so we'd better not remove it.&nbsp; Also, don't remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * resjunk columns, since their reason for being has nothing to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with anybody reading the subquery's output.&nbsp; (It's likely that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * resjunk columns in a sub-SELECT would always have ressortgroupref<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set, but even if they don't, it seems imprudent to remove them.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;ressortgroupref || tle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's used by the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> query, we can't remove it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(tle-&gt;resno - FirstLowInvalidHeapAttributeNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrs_used))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it contains a set-returning function, we can't remove it since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that could change the number of rows returned by the subquery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subquery-&gt;hasTargetSRFs &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L758" title="nodes/nodeFuncs.c:758">expression_returns_set</a>(texpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it contains volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, we daren't remove it for fear<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that the user is expecting their side-effects to happen.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>(texpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OK, we don't need it.&nbsp; Replace the expression with a NULL constant.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Preserve the exposed type of the expression, in case something<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * looks at the rowtype of the subquery's result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tle-&gt;expr = (Expr *) <a href="../../nodes/makefuncs.c.html#L339" title="nodes/makefuncs.c:339">makeNullConst</a>(<a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(texpr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>(texpr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>(texpr));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4179" title="optimizer/path/allpaths.c:4179">create_partial_bitmap_paths</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Build partial bitmap heap path for the relation<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4179">&#x200c;</a></span><span class="linkable">create_partial_bitmap_paths</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path *bitmapqual)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parallel_workers;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; pages_fetched;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute heap pages for bitmap heap scan */<br/></li>
<li></span>&nbsp; &nbsp; pages_fetched = <a href="costsize.c.html#L6403" title="optimizer/path/costsize.c:6403">compute_bitmap_pages</a>(root, rel, bitmapqual, <span class="Constant">1.0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; parallel_workers = <a href="#L4215" title="optimizer/path/allpaths.c:4215">compute_parallel_worker</a>(rel, pages_fetched, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="costsize.c.html#L132" title="optimizer/path/costsize.c:132">max_parallel_workers_per_gather</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (parallel_workers &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../util/pathnode.c.html#L747" title="optimizer/util/pathnode.c:747">add_partial_path</a>(rel, (Path *) <a href="../util/pathnode.c.html#L1042" title="optimizer/util/pathnode.c:1042">create_bitmap_heap_path</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bitmapqual, rel-&gt;lateral_relids, <span class="Constant">1.0</span>, parallel_workers));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the number of parallel workers that should be used to scan a<br/></li>
<li></span><span class="Comment"> * relation.&nbsp; We compute the parallel workers based on the size of the heap to<br/></li>
<li></span><span class="Comment"> * be scanned and the size of the index to be scanned, then choose a minimum<br/></li>
<li></span><span class="Comment"> * of those.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;heap_pages&quot; is the number of pages from the table that we expect to scan, or<br/></li>
<li></span><span class="Comment"> * -1 if we don't expect to scan <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;index_pages&quot; is the number of pages from the index that we expect to scan, or<br/></li>
<li></span><span class="Comment"> * -1 if we don't expect to scan <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;max_workers&quot; is caller's limit on the number of workers.&nbsp; This typically<br/></li>
<li></span><span class="Comment"> * comes from a GUC.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L4215">&#x200c;</a></span><span class="linkable">compute_parallel_worker</span>(RelOptInfo *rel, <span class="Type">double</span> heap_pages, <span class="Type">double</span> index_pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> max_workers)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parallel_workers = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the user has set the parallel_workers reloption, use that; otherwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> a default number of workers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rel_parallel_workers != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parallel_workers = rel-&gt;rel_parallel_workers;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the number of pages being scanned is insufficient to justify a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parallel scan, just return zero ... unless it's an inheritance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * child. In that case, we want to generate a parallel path here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anyway.&nbsp; It might not be worthwhile just for this relation, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when combined with all of its inheritance siblings it may well pay<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * off.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;reloptkind == RELOPT_BASEREL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((heap_pages &gt;= <span class="Constant">0</span> &amp;&amp; heap_pages &lt; <a href="#L81" title="optimizer/path/allpaths.c:81">min_parallel_table_scan_size</a>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (index_pages &gt;= <span class="Constant">0</span> &amp;&amp; index_pages &lt; <a href="#L82" title="optimizer/path/allpaths.c:82">min_parallel_index_scan_size</a>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (heap_pages &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heap_parallel_threshold;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heap_parallel_workers = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Select the number of workers based on the log of the size of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the relation.&nbsp; This probably needs to be a good deal more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sophisticated, but we need something here for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> limit of the <a href="#L81" title="optimizer/path/allpaths.c:81">min_parallel_table_scan_size</a> GUC is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * chosen to prevent overflow here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heap_parallel_threshold = Max(<a href="#L81" title="optimizer/path/allpaths.c:81">min_parallel_table_scan_size</a>, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (heap_pages &gt;= (BlockNumber) (heap_parallel_threshold * <span class="Constant">3</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heap_parallel_workers++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heap_parallel_threshold *= <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (heap_parallel_threshold &gt; <span class="Constant">INT_MAX</span> / <span class="Constant">3</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* avoid overflow */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parallel_workers = heap_parallel_workers;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index_pages &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_parallel_workers = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_parallel_threshold;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* same calculation as for heap_pages above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_parallel_threshold = Max(<a href="#L82" title="optimizer/path/allpaths.c:82">min_parallel_index_scan_size</a>, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (index_pages &gt;= (BlockNumber) (index_parallel_threshold * <span class="Constant">3</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_parallel_workers++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_parallel_threshold *= <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index_parallel_threshold &gt; <span class="Constant">INT_MAX</span> / <span class="Constant">3</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* avoid overflow */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parallel_workers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parallel_workers = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(parallel_workers, index_parallel_workers);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parallel_workers = index_parallel_workers;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* In no case use more than caller supplied maximum number of workers */<br/></li>
<li></span>&nbsp; &nbsp; parallel_workers = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(parallel_workers, max_workers);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> parallel_workers;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4303" title="optimizer/path/allpaths.c:4303">generate_partitionwise_join_paths</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Create paths representing partitionwise join for given partitioned<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; join relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This must not be called until after we are done adding paths for all<br/></li>
<li></span><span class="Comment"> * child-joins. Otherwise, <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a> might delete a path to which some path<br/></li>
<li></span><span class="Comment"> * generated here has a reference.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4303">&#x200c;</a></span><span class="linkable">generate_partitionwise_join_paths</span>(PlannerInfo *root, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *live_children = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt_parts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_parts;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo **part_rels;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle only join relations here. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IS_JOIN_REL(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We've nothing to do if the relation is not partitioned. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IS_PARTITIONED_REL(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The relation should have consider_partitionwise_join set. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(rel-&gt;consider_partitionwise_join);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Guard against stack overflow due to overly deep partition hierarchy. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; num_parts = rel-&gt;nparts;<br/></li>
<li>&nbsp; &nbsp; part_rels = rel-&gt;part_rels;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Collect non-dummy child-joins. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (cnt_parts = <span class="Constant">0</span>; cnt_parts &lt; num_parts; cnt_parts++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *child_rel = part_rels[cnt_parts];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's been pruned entirely, it's certainly dummy. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (child_rel == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make partitionwise join paths for this partitioned child-join. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4303" title="optimizer/path/allpaths.c:4303">generate_partitionwise_join_paths</a>(root, child_rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we failed to make <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> path for this child, we must give up. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (child_rel-&gt;pathlist == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Mark the parent joinrel as unpartitioned so that later<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> treat it correctly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;nparts = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Else, identify the cheapest path for it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L242" title="optimizer/util/pathnode.c:242">set_cheapest</a>(child_rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Dummy children need not be scanned, so ignore those. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IS_DUMMY_REL(child_rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef OPTIMIZER_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/print.c.html#L54" title="nodes/print.c:54">pprint</a>(child_rel);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; live_children = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(live_children, child_rel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If all child-joins are dummy, parent join is also dummy. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!live_children)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="joinrels.c.html#L1381" title="optimizer/path/joinrels.c:1381">mark_dummy_rel</a>(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build additional paths for this rel from child-join paths. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1302" title="optimizer/path/allpaths.c:1302">add_paths_to_append_rel</a>(root, rel, live_children);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(live_children);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
