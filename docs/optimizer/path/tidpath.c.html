<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>optimizer/path/tidpath.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>optimizer/path/tidpath.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L387">BuildParameterizedTidPaths</a></li>
<li><a href="#L76">IsBinaryTidClause</a></li>
<li><a href="#L55">IsCTIDVar</a></li>
<li><a href="#L211">IsCurrentOfClause</a></li>
<li><a href="#L172">IsTidEqualAnyClause</a></li>
<li><a href="#L130">IsTidEqualClause</a></li>
<li><a href="#L150">IsTidRangeClause</a></li>
<li><a href="#L239">TidQualFromRestrictInfo</a></li>
<li><a href="#L276">TidQualFromRestrictInfoList</a></li>
<li><a href="#L359">TidRangeQualFromRestrictInfoList</a></li>
<li><a href="#L459">create_tidscan_paths</a></li>
<li><a href="#L442">ec_member_matches_ctid</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * tidpath.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Routines to determine which TID conditions are usable for scanning<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; a given relation, and create TidPaths and TidRangePaths accordingly.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For TidPaths, we look for WHERE conditions of the form<br/></li>
<li></span><span class="Comment"> * &quot;CTID = pseudoconstant&quot;, which can be implemented by just fetching<br/></li>
<li></span><span class="Comment"> * the tuple directly via <a href="../../access/heap/heapam.c.html#L1507" title="access/heap/heapam.c:1507">heap_fetch</a>().&nbsp; We can also handle OR'd conditions<br/></li>
<li></span><span class="Comment"> * such as (CTID = const1) OR (CTID = const2), as well as ScalarArrayOpExpr<br/></li>
<li></span><span class="Comment"> * conditions of the form CTID = ANY(pseudoconstant_array).&nbsp; In particular<br/></li>
<li></span><span class="Comment"> * this allows<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; WHERE ctid IN (tid1, tid2, ...)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As with indexscans, our definition of &quot;pseudoconstant&quot; is pretty liberal:<br/></li>
<li></span><span class="Comment"> * we allow anything that doesn't involve a volatile function or a Var of<br/></li>
<li></span><span class="Comment"> * the relation under consideration.&nbsp; Vars belonging to other relations of<br/></li>
<li></span><span class="Comment"> * the query are allowed, giving rise to parameterized TID scans.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also support &quot;WHERE CURRENT OF cursor&quot; conditions (CurrentOfExpr),<br/></li>
<li></span><span class="Comment"> * which amount to &quot;CTID = run-time-determined-TID&quot;.&nbsp; These could in<br/></li>
<li></span><span class="Comment"> * theory be translated to a simple comparison of CTID to the result of<br/></li>
<li></span><span class="Comment"> * a function, but in practice it works better to keep the special node<br/></li>
<li></span><span class="Comment"> * representation all the way through to execution.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Additionally, TidRangePaths may be created for conditions of the form<br/></li>
<li></span><span class="Comment"> * &quot;CTID relop pseudoconstant&quot;, where relop is one of &gt;,&gt;=,&lt;,&lt;=, and<br/></li>
<li></span><span class="Comment"> * AND-clauses composed of such conditions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/optimizer/path/tidpath.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/sysattr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_operator.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/pathnode.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/paths.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/restrictinfo.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Does this Var represent the CTID column of the specified baserel?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L55">&#x200c;</a></span><span class="linkable">IsCTIDVar</span>(Var *var, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The vartype check is strictly paranoia */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varattno == SelfItemPointerAttributeNumber &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var-&gt;vartype == TIDOID &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varno == rel-&gt;relid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varnullingrels == <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varlevelsup == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check to see if a RestrictInfo is of the form<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; CTID OP pseudoconstant<br/></li>
<li></span><span class="Comment"> * or<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; pseudoconstant OP CTID<br/></li>
<li></span><span class="Comment"> * where OP is a binary operation, the CTID Var belongs to relation &quot;rel&quot;,<br/></li>
<li></span><span class="Comment"> * and nothing on the other side of the clause does.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L76">&#x200c;</a></span><span class="linkable">IsBinaryTidClause</span>(RestrictInfo *rinfo, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; OpExpr&nbsp; &nbsp; &nbsp;&nbsp; *node;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *arg1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *arg2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *other;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; other_relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must be an OpExpr */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!is_opclause(rinfo-&gt;clause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; node = (OpExpr *) rinfo-&gt;clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OpExpr must have two arguments */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(node-&gt;args) != <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; arg1 = linitial(node-&gt;args);<br/></li>
<li>&nbsp; &nbsp; arg2 = lsecond(node-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look for CTID as either argument */<br/></li>
<li></span>&nbsp; &nbsp; other = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; other_relids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &amp;&amp; IsA(arg1, Var) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/nodeTidrangescan.c.html#L33" title="executor/nodeTidrangescan.c:33">IsCTIDVar</a>((Var *) arg1, rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; other = arg2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; other_relids = rinfo-&gt;right_relids;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!other &amp;&amp; arg2 &amp;&amp; IsA(arg2, Var) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/nodeTidrangescan.c.html#L33" title="executor/nodeTidrangescan.c:33">IsCTIDVar</a>((Var *) arg2, rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; other = arg1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; other_relids = rinfo-&gt;left_relids;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!other)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The other argument must be a pseudoconstant */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(rel-&gt;relid, other_relids) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>(other))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* success */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check to see if a RestrictInfo is of the form<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; CTID = pseudoconstant<br/></li>
<li></span><span class="Comment"> * or<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; pseudoconstant = CTID<br/></li>
<li></span><span class="Comment"> * where the CTID Var belongs to relation &quot;rel&quot;, and nothing on the<br/></li>
<li></span><span class="Comment"> * other side of the clause does.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L130">&#x200c;</a></span><span class="linkable">IsTidEqualClause</span>(RestrictInfo *rinfo, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L76" title="optimizer/path/tidpath.c:76">IsBinaryTidClause</a>(rinfo, rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (((OpExpr *) rinfo-&gt;clause)-&gt;opno == TIDEqualOperator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check to see if a RestrictInfo is of the form<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; CTID OP pseudoconstant<br/></li>
<li></span><span class="Comment"> * or<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; pseudoconstant OP CTID<br/></li>
<li></span><span class="Comment"> * where OP is a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> operator such as &lt;, &lt;=, &gt;, or &gt;=, the CTID Var belongs<br/></li>
<li></span><span class="Comment"> * to relation &quot;rel&quot;, and nothing on the other side of the clause does.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L150">&#x200c;</a></span><span class="linkable">IsTidRangeClause</span>(RestrictInfo *rinfo, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L76" title="optimizer/path/tidpath.c:76">IsBinaryTidClause</a>(rinfo, rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; opno = ((OpExpr *) rinfo-&gt;clause)-&gt;opno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (opno == TIDLessOperator || opno == TIDLessEqOperator ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opno == TIDGreaterOperator || opno == TIDGreaterEqOperator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check to see if a RestrictInfo is of the form<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; CTID = ANY (pseudoconstant_array)<br/></li>
<li></span><span class="Comment"> * where the CTID Var belongs to relation &quot;rel&quot;, and nothing on the<br/></li>
<li></span><span class="Comment"> * other side of the clause does.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L172">&#x200c;</a></span><span class="linkable">IsTidEqualAnyClause</span>(PlannerInfo *root, RestrictInfo *rinfo, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ScalarArrayOpExpr *node;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *arg1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *arg2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must be a ScalarArrayOpExpr */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(rinfo-&gt;clause &amp;&amp; IsA(rinfo-&gt;clause, ScalarArrayOpExpr)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; node = (ScalarArrayOpExpr *) rinfo-&gt;clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Operator must be <a href="../../utils/adt/tid.c.html#L176" title="utils/adt/tid.c:176">tideq</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;opno != TIDEqualOperator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!node-&gt;useOr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; Assert(list_length(node-&gt;args) == <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; arg1 = linitial(node-&gt;args);<br/></li>
<li>&nbsp; &nbsp; arg2 = lsecond(node-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* CTID must be first argument */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 &amp;&amp; IsA(arg1, Var) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/nodeTidrangescan.c.html#L33" title="executor/nodeTidrangescan.c:33">IsCTIDVar</a>((Var *) arg1, rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The other argument must be a pseudoconstant */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(rel-&gt;relid, <a href="../util/var.c.html#L108" title="optimizer/util/var.c:108">pull_varnos</a>(root, arg2)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>(arg2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* success */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check to see if a RestrictInfo is a CurrentOfExpr referencing &quot;rel&quot;.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L211">&#x200c;</a></span><span class="linkable">IsCurrentOfClause</span>(RestrictInfo *rinfo, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CurrentOfExpr *node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must be a CurrentOfExpr */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(rinfo-&gt;clause &amp;&amp; IsA(rinfo-&gt;clause, CurrentOfExpr)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; node = (CurrentOfExpr *) rinfo-&gt;clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If it references this rel, we're good */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;cvarno == rel-&gt;relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extract a set of CTID conditions from the given RestrictInfo<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a List of CTID qual RestrictInfos for the specified rel (with<br/></li>
<li></span><span class="Comment"> * implicit OR semantics across the list), or NIL if there are no usable<br/></li>
<li></span><span class="Comment"> * conditions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function considers only base cases; AND/OR combination is handled<br/></li>
<li></span><span class="Comment"> * below.&nbsp; Therefore the returned List never has more than one <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.<br/></li>
<li></span><span class="Comment"> * (Using a List may seem a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> weird, but it simplifies the caller.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L239">&#x200c;</a><span class="linkable">TidQualFromRestrictInfo</span>(PlannerInfo *root, RestrictInfo *rinfo, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We may ignore pseudoconstant clauses (they can't contain Vars, so could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not match anyway).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rinfo-&gt;pseudoconstant)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If clause must wait till after some <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-security-level restriction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clause, reject it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../util/restrictinfo.c.html#L431" title="optimizer/util/restrictinfo.c:431">restriction_is_securely_promotable</a>(rinfo, rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check all base cases.&nbsp; If we get a match, return the clause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L130" title="optimizer/path/tidpath.c:130">IsTidEqualClause</a>(rinfo, rel) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L172" title="optimizer/path/tidpath.c:172">IsTidEqualAnyClause</a>(root, rinfo, rel) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L211" title="optimizer/path/tidpath.c:211">IsCurrentOfClause</a>(rinfo, rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> list_make1(rinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extract a set of CTID conditions from implicit-AND List of RestrictInfos<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a List of CTID qual RestrictInfos for the specified rel (with<br/></li>
<li></span><span class="Comment"> * implicit OR semantics across the list), or NIL if there are no usable<br/></li>
<li></span><span class="Comment"> * equality conditions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is just concerned with handling AND/OR recursion.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L276">&#x200c;</a><span class="linkable">TidQualFromRestrictInfoList</span>(PlannerInfo *root, List *rlist, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *rlst = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, rlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../util/restrictinfo.c.html#L416" title="optimizer/util/restrictinfo.c:416">restriction_is_or_clause</a>(rinfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must be able to extract a CTID condition from every<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sub-clause of an OR, or we can't use it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(j, ((BoolExpr *) rinfo-&gt;orclause)-&gt;args)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *orarg = (Node *) lfirst(j);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sublist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OR arguments should be ANDs or sub-RestrictInfos */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_andclause(orarg))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *andargs = ((BoolExpr *) orarg)-&gt;args;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse in case there are sub-ORs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublist = <a href="#L276" title="optimizer/path/tidpath.c:276">TidQualFromRestrictInfoList</a>(root, andargs, rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *ri = castNode(RestrictInfo, orarg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../util/restrictinfo.c.html#L416" title="optimizer/util/restrictinfo.c:416">restriction_is_or_clause</a>(ri));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublist = <a href="#L239" title="optimizer/path/tidpath.c:239">TidQualFromRestrictInfo</a>(root, ri, rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If nothing found in this arm, we can't do anything with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this OR clause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sublist == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlst = NIL; <span class="Comment">/* forget anything we had */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* out of loop over OR args */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OK, continue constructing implicitly-OR'ed result list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlst = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(rlst, sublist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not an OR clause, so handle base cases */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlst = <a href="#L239" title="optimizer/path/tidpath.c:239">TidQualFromRestrictInfo</a>(root, rinfo, rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Stop as soon as we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> usable CTID condition.&nbsp; In theory we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could get CTID equality conditions from different AND'ed clauses,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in which case we could try to pick the most efficient one.&nbsp; In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * practice, such usage seems very unlikely, so we don't bother; we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just exit as soon as we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the first candidate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rlst)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rlst;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extract a set of CTID <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> conditions from implicit-AND List of RestrictInfos<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a List of CTID <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> qual RestrictInfos for the specified rel<br/></li>
<li></span><span class="Comment"> * (with implicit AND semantics across the list), or NIL if there are no<br/></li>
<li></span><span class="Comment"> * usable <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> conditions or if the rel's table AM does not support TID <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment"> * scans.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L359">&#x200c;</a><span class="linkable">TidRangeQualFromRestrictInfoList</span>(List *rlist, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *rlst = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((rel-&gt;amflags &amp; AMFLAG_HAS_TID_RANGE) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, rlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L150" title="optimizer/path/tidpath.c:150">IsTidRangeClause</a>(rinfo, rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlst = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rlst, rinfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rlst;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a list of join clauses involving our rel, create a parameterized<br/></li>
<li></span><span class="Comment"> * TidPath for each one that is a suitable TidEqual clause.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In principle we could <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> clauses that reference the same outer rels,<br/></li>
<li></span><span class="Comment"> * but it doesn't seem like such cases would arise often enough to be worth<br/></li>
<li></span><span class="Comment"> * troubling over.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L387">&#x200c;</a></span><span class="linkable">BuildParameterizedTidPaths</span>(PlannerInfo *root, RelOptInfo *rel, List *clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, clauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tidquals;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; required_outer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Validate whether each clause is actually usable; we must check this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * even when examining clauses generated from an EquivalenceClass,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since they might not satisfy the restriction on not having Vars of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * our rel on the other side, or somebody might've built an operator<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * class that accepts type &quot;tid&quot; but has other operators in it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We currently consider only TidEqual join clauses.&nbsp; In principle we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a suitable ScalarArrayOpExpr in the rel's joininfo list,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but it seems unlikely to be worth expending the cycles to check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * And we definitely won't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a CurrentOfExpr here.&nbsp; Hence, we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * use <a href="#L239" title="optimizer/path/tidpath.c:239">TidQualFromRestrictInfo</a>; but this must match that function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rinfo-&gt;pseudoconstant ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../util/restrictinfo.c.html#L431" title="optimizer/util/restrictinfo.c:431">restriction_is_securely_promotable</a>(rinfo, rel) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L130" title="optimizer/path/tidpath.c:130">IsTidEqualClause</a>(rinfo, rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if clause can be moved to this rel; this is probably<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * redundant when considering EC-derived clauses, but we must check it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for &quot;loose&quot; join clauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../util/restrictinfo.c.html#L584" title="optimizer/util/restrictinfo.c:584">join_clause_is_movable_to</a>(rinfo, rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, make list of clauses for this path */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tidquals = list_make1(rinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute required outer rels for this path */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; required_outer = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(rinfo-&gt;required_relids, rel-&gt;lateral_relids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; required_outer = <a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(required_outer, rel-&gt;relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, (Path *) <a href="../util/pathnode.c.html#L1179" title="optimizer/util/pathnode.c:1179">create_tidscan_path</a>(root, rel, tidquals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; required_outer));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Test whether an EquivalenceClass member matches our rel's CTID Var.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a callback for use by <a href="equivclass.c.html#L2971" title="optimizer/path/equivclass.c:2971">generate_implied_equalities_for_column</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L442">&#x200c;</a></span><span class="linkable">ec_member_matches_ctid</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EquivalenceClass *ec, EquivalenceMember *em,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (em-&gt;em_expr &amp;&amp; IsA(em-&gt;em_expr, Var) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/nodeTidrangescan.c.html#L33" title="executor/nodeTidrangescan.c:33">IsCTIDVar</a>((Var *) em-&gt;em_expr, rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L459" title="optimizer/path/tidpath.c:459">create_tidscan_paths</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create paths corresponding to direct TID scans of the given rel.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Candidate paths are added to the rel's pathlist (using <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L459">&#x200c;</a></span><span class="linkable">create_tidscan_paths</span>(PlannerInfo *root, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tidquals;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tidrangequals;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> suitable quals exist in the rel's baserestrict list, generate a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plain (unparameterized) TidPath with them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tidquals = <a href="#L276" title="optimizer/path/tidpath.c:276">TidQualFromRestrictInfoList</a>(root, rel-&gt;baserestrictinfo, rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tidquals != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This path uses no join clauses, but it could still have required<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parameterization due to LATERAL refs in its tlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; required_outer = rel-&gt;lateral_relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, (Path *) <a href="../util/pathnode.c.html#L1179" title="optimizer/util/pathnode.c:1179">create_tidscan_path</a>(root, rel, tidquals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; required_outer));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> quals in the baserestrict list, generate a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * TidRangePath.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tidrangequals = <a href="#L359" title="optimizer/path/tidpath.c:359">TidRangeQualFromRestrictInfoList</a>(rel-&gt;baserestrictinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tidrangequals != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This path uses no join clauses, but it could still have required<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parameterization due to LATERAL refs in its tlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; required_outer = rel-&gt;lateral_relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../util/pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>(rel, (Path *) <a href="../util/pathnode.c.html#L1208" title="optimizer/util/pathnode.c:1208">create_tidrangescan_path</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tidrangequals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to generate parameterized TidPaths using equality clauses extracted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from EquivalenceClasses.&nbsp; (This is important since simple &quot;t1.ctid =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * t2.ctid&quot; clauses will turn into ECs.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;has_eclass_joins)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *clauses;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Generate clauses, skipping <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> that join to lateral_referencers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; clauses = <a href="equivclass.c.html#L2971" title="optimizer/path/equivclass.c:2971">generate_implied_equalities_for_column</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L442" title="optimizer/path/tidpath.c:442">ec_member_matches_ctid</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;lateral_referencers);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Generate a path for each usable join clause */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L387" title="optimizer/path/tidpath.c:387">BuildParameterizedTidPaths</a>(root, rel, clauses);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also consider parameterized TidPaths using &quot;loose&quot; join quals.&nbsp; Quals<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the form &quot;t1.ctid = t2.ctid&quot; would turn into these if they are outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * join quals, for example.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L387" title="optimizer/path/tidpath.c:387">BuildParameterizedTidPaths</a>(root, rel, rel-&gt;joininfo);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
