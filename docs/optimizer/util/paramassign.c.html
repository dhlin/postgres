<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>optimizer/util/paramassign.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>optimizer/util/paramassign.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L149">assign_param_for_placeholdervar</a></li>
<li><a href="#L66">assign_param_for_var</a></li>
<li><a href="#L664">assign_special_exec_param</a></li>
<li><a href="#L637">generate_new_exec_param</a></li>
<li><a href="#L582">identify_current_nestloop_params</a></li>
<li><a href="#L480">process_subquery_nestloop_params</a></li>
<li><a href="#L416">replace_nestloop_param_placeholdervar</a></li>
<li><a href="#L367">replace_nestloop_param_var</a></li>
<li><a href="#L224">replace_outer_agg</a></li>
<li><a href="#L270">replace_outer_grouping</a></li>
<li><a href="#L317">replace_outer_merge_support</a></li>
<li><a href="#L197">replace_outer_placeholdervar</a></li>
<li><a href="#L120">replace_outer_var</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * paramassign.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Functions for assigning PARAM_EXEC slots during planning.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This module is responsible for managing three <a href="../plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> data structures:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * root-&gt;glob-&gt;paramExecTypes: <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> actual assignments of PARAM_EXEC slots.<br/></li>
<li></span><span class="Comment"> * The i'th list <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> holds the data type OID of the i'th parameter slot.<br/></li>
<li></span><span class="Comment"> * (Elements can be InvalidOid if they represent slots that are needed for<br/></li>
<li></span><span class="Comment"> * chgParam signaling, but will never hold a value at runtime.)&nbsp; This list is<br/></li>
<li></span><span class="Comment"> * global to the whole plan since the executor has only one PARAM_EXEC array.<br/></li>
<li></span><span class="Comment"> * Assignments are permanent for the plan: we never remove entries once added.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * root-&gt;plan_params: a list of PlannerParamItem nodes, recording Vars and<br/></li>
<li></span><span class="Comment"> * PlaceHolderVars that the root's query level needs to supply to <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-level<br/></li>
<li></span><span class="Comment"> * subqueries, along with the PARAM_EXEC number to use for each such value.<br/></li>
<li></span><span class="Comment"> * Elements are added to this list while planning a subquery, and the list<br/></li>
<li></span><span class="Comment"> * is reset to empty after completion of each subquery.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * root-&gt;curOuterParams: a list of NestLoopParam nodes, recording Vars and<br/></li>
<li></span><span class="Comment"> * PlaceHolderVars that some outer level of nestloop needs to pass down to<br/></li>
<li></span><span class="Comment"> * a <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-level plan node in its righthand side.&nbsp; Elements are added to this<br/></li>
<li></span><span class="Comment"> * list as createplan.c creates <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> Plan nodes that need such Params, and<br/></li>
<li></span><span class="Comment"> * are removed when it creates a NestLoop Plan node that will supply those<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The latter two data structures are used to prevent creating multiple<br/></li>
<li></span><span class="Comment"> * PARAM_EXEC slots (each requiring work to fill) when the same <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a><br/></li>
<li></span><span class="Comment"> * SubPlan or NestLoop supplies a value that is referenced in more than<br/></li>
<li></span><span class="Comment"> * one place in its child plan nodes.&nbsp; However, when the same Var has to<br/></li>
<li></span><span class="Comment"> * be supplied to different subplan trees by different SubPlan or NestLoop<br/></li>
<li></span><span class="Comment"> * parent nodes, we don't recognize <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> commonality; a fresh plan_params or<br/></li>
<li></span><span class="Comment"> * curOuterParams entry will be made (since the old one has been removed<br/></li>
<li></span><span class="Comment"> * when we finished processing the earlier SubPlan or NestLoop) and a fresh<br/></li>
<li></span><span class="Comment"> * PARAM_EXEC number will be assigned.&nbsp; At one time we tried to avoid<br/></li>
<li></span><span class="Comment"> * allocating duplicate PARAM_EXEC numbers in such cases, but it's harder<br/></li>
<li></span><span class="Comment"> * than it seems to avoid bugs due to overlapping Param lifetimes, so we<br/></li>
<li></span><span class="Comment"> * don't risk that anymore.&nbsp; Minimizing the number of PARAM_EXEC slots<br/></li>
<li></span><span class="Comment"> * doesn't really save much executor work anyway.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/optimizer/util/paramassign.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/plannodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/paramassign.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/placeholder.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;rewrite/rewriteManip.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Select a PARAM_EXEC number to identify the given Var as a parameter for<br/></li>
<li></span><span class="Comment"> * the current subquery.&nbsp; (It might already have one.)<br/></li>
<li></span><span class="Comment"> * Record the need for the Var in the proper <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level root-&gt;plan_params.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L66">&#x200c;</a></span><span class="linkable">assign_param_for_var</span>(PlannerInfo *root, Var *var)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *ppl;<br/></li>
<li>&nbsp; &nbsp; PlannerParamItem *pitem;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; levelsup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find the query level the Var belongs to */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (levelsup = var-&gt;varlevelsup; levelsup &gt; <span class="Constant">0</span>; levelsup--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root = root-&gt;parent_root;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there's already a matching PlannerParamItem there, just use it */<br/></li>
<li></span>&nbsp; &nbsp; foreach(ppl, root-&gt;plan_params)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pitem = (PlannerParamItem *) lfirst(ppl);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(pitem-&gt;item, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *pvar = (Var *) pitem-&gt;item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This comparison must match _equalVar(), except for ignoring<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * varlevelsup.&nbsp; Note that _equalVar() ignores varnosyn,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * varattnosyn, and location, so this does too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pvar-&gt;varno == var-&gt;varno &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pvar-&gt;varattno == var-&gt;varattno &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pvar-&gt;vartype == var-&gt;vartype &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pvar-&gt;vartypmod == var-&gt;vartypmod &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pvar-&gt;varcollid == var-&gt;varcollid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(pvar-&gt;varnullingrels, var-&gt;varnullingrels))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> pitem-&gt;paramId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nope, so make a new one */<br/></li>
<li></span>&nbsp; &nbsp; var = copyObject(var);<br/></li>
<li>&nbsp; &nbsp; var-&gt;varlevelsup = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pitem = makeNode(PlannerParamItem);<br/></li>
<li>&nbsp; &nbsp; pitem-&gt;item = (Node *) var;<br/></li>
<li>&nbsp; &nbsp; pitem-&gt;paramId = list_length(root-&gt;glob-&gt;paramExecTypes);<br/></li>
<li>&nbsp; &nbsp; root-&gt;glob-&gt;paramExecTypes = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(root-&gt;glob-&gt;paramExecTypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var-&gt;vartype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; root-&gt;plan_params = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;plan_params, pitem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pitem-&gt;paramId;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generate a Param node to replace the given Var,<br/></li>
<li></span><span class="Comment"> * which is expected to have varlevelsup &gt; 0 (ie, it is not local).<br/></li>
<li></span><span class="Comment"> * Record the need for the Var in the proper <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level root-&gt;plan_params.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Param *<br/></li>
<li><a id="L120">&#x200c;</a><span class="linkable">replace_outer_var</span>(PlannerInfo *root, Var *var)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Param&nbsp; &nbsp; &nbsp;&nbsp; *retval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(var-&gt;varlevelsup &gt; <span class="Constant">0</span> &amp;&amp; var-&gt;varlevelsup &lt; root-&gt;query_level);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find the Var in the appropriate plan_params, or add it if not present */<br/></li>
<li></span>&nbsp; &nbsp; i = <a href="#L66" title="optimizer/util/paramassign.c:66">assign_param_for_var</a>(root, var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; retval = makeNode(Param);<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramkind = PARAM_EXEC;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramid = i;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramtype = var-&gt;vartype;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramtypmod = var-&gt;vartypmod;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramcollid = var-&gt;varcollid;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;location = var-&gt;location;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> retval;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Select a PARAM_EXEC number to identify the given PlaceHolderVar as a<br/></li>
<li></span><span class="Comment"> * parameter for the current subquery.&nbsp; (It might already have one.)<br/></li>
<li></span><span class="Comment"> * Record the need for the PHV in the proper <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level root-&gt;plan_params.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is just like <a href="#L66" title="optimizer/util/paramassign.c:66">assign_param_for_var</a>, except for PlaceHolderVars.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L149">&#x200c;</a></span><span class="linkable">assign_param_for_placeholdervar</span>(PlannerInfo *root, PlaceHolderVar *phv)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *ppl;<br/></li>
<li>&nbsp; &nbsp; PlannerParamItem *pitem;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; levelsup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find the query level the PHV belongs to */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (levelsup = phv-&gt;phlevelsup; levelsup &gt; <span class="Constant">0</span>; levelsup--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root = root-&gt;parent_root;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there's already a matching PlannerParamItem there, just use it */<br/></li>
<li></span>&nbsp; &nbsp; foreach(ppl, root-&gt;plan_params)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pitem = (PlannerParamItem *) lfirst(ppl);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(pitem-&gt;item, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *pphv = (PlaceHolderVar *) pitem-&gt;item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We assume comparing the PHIDs is sufficient */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pphv-&gt;phid == phv-&gt;phid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> pitem-&gt;paramId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nope, so make a new one */<br/></li>
<li></span>&nbsp; &nbsp; phv = copyObject(phv);<br/></li>
<li>&nbsp; &nbsp; <a href="../../rewrite/rewriteManip.c.html#L849" title="rewrite/rewriteManip.c:849">IncrementVarSublevelsUp</a>((Node *) phv, -((<span class="Type">int</span>) phv-&gt;phlevelsup), <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(phv-&gt;phlevelsup == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pitem = makeNode(PlannerParamItem);<br/></li>
<li>&nbsp; &nbsp; pitem-&gt;item = (Node *) phv;<br/></li>
<li>&nbsp; &nbsp; pitem-&gt;paramId = list_length(root-&gt;glob-&gt;paramExecTypes);<br/></li>
<li>&nbsp; &nbsp; root-&gt;glob-&gt;paramExecTypes = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(root-&gt;glob-&gt;paramExecTypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) phv-&gt;phexpr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; root-&gt;plan_params = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;plan_params, pitem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pitem-&gt;paramId;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generate a Param node to replace the given PlaceHolderVar,<br/></li>
<li></span><span class="Comment"> * which is expected to have phlevelsup &gt; 0 (ie, it is not local).<br/></li>
<li></span><span class="Comment"> * Record the need for the PHV in the proper <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level root-&gt;plan_params.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is just like <a href="#L120" title="optimizer/util/paramassign.c:120">replace_outer_var</a>, except for PlaceHolderVars.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Param *<br/></li>
<li><a id="L197">&#x200c;</a><span class="linkable">replace_outer_placeholdervar</span>(PlannerInfo *root, PlaceHolderVar *phv)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Param&nbsp; &nbsp; &nbsp;&nbsp; *retval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(phv-&gt;phlevelsup &gt; <span class="Constant">0</span> &amp;&amp; phv-&gt;phlevelsup &lt; root-&gt;query_level);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find the PHV in the appropriate plan_params, or add it if not present */<br/></li>
<li></span>&nbsp; &nbsp; i = <a href="#L149" title="optimizer/util/paramassign.c:149">assign_param_for_placeholdervar</a>(root, phv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; retval = makeNode(Param);<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramkind = PARAM_EXEC;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramid = i;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramtype = <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) phv-&gt;phexpr);<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramtypmod = <a href="../../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>((Node *) phv-&gt;phexpr);<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramcollid = <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) phv-&gt;phexpr);<br/></li>
<li>&nbsp; &nbsp; retval-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> retval;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generate a Param node to replace the given Aggref<br/></li>
<li></span><span class="Comment"> * which is expected to have agglevelsup &gt; 0 (ie, it is not local).<br/></li>
<li></span><span class="Comment"> * Record the need for the Aggref in the proper <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level root-&gt;plan_params.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Param *<br/></li>
<li><a id="L224">&#x200c;</a><span class="linkable">replace_outer_agg</span>(PlannerInfo *root, Aggref *agg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Param&nbsp; &nbsp; &nbsp;&nbsp; *retval;<br/></li>
<li>&nbsp; &nbsp; PlannerParamItem *pitem;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; levelsup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(agg-&gt;agglevelsup &gt; <span class="Constant">0</span> &amp;&amp; agg-&gt;agglevelsup &lt; root-&gt;query_level);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find the query level the Aggref belongs to */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (levelsup = agg-&gt;agglevelsup; levelsup &gt; <span class="Constant">0</span>; levelsup--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root = root-&gt;parent_root;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It does not seem worthwhile to try to de-duplicate references to outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggs.&nbsp; Just make a new slot every time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; agg = copyObject(agg);<br/></li>
<li>&nbsp; &nbsp; <a href="../../rewrite/rewriteManip.c.html#L849" title="rewrite/rewriteManip.c:849">IncrementVarSublevelsUp</a>((Node *) agg, -((<span class="Type">int</span>) agg-&gt;agglevelsup), <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(agg-&gt;agglevelsup == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pitem = makeNode(PlannerParamItem);<br/></li>
<li>&nbsp; &nbsp; pitem-&gt;item = (Node *) agg;<br/></li>
<li>&nbsp; &nbsp; pitem-&gt;paramId = list_length(root-&gt;glob-&gt;paramExecTypes);<br/></li>
<li>&nbsp; &nbsp; root-&gt;glob-&gt;paramExecTypes = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(root-&gt;glob-&gt;paramExecTypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; agg-&gt;aggtype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; root-&gt;plan_params = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;plan_params, pitem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; retval = makeNode(Param);<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramkind = PARAM_EXEC;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramid = pitem-&gt;paramId;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramtype = agg-&gt;aggtype;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramtypmod = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramcollid = agg-&gt;aggcollid;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;location = agg-&gt;location;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> retval;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generate a Param node to replace the given GroupingFunc expression which is<br/></li>
<li></span><span class="Comment"> * expected to have agglevelsup &gt; 0 (ie, it is not local).<br/></li>
<li></span><span class="Comment"> * Record the need for the GroupingFunc in the proper <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level<br/></li>
<li></span><span class="Comment"> * root-&gt;plan_params.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Param *<br/></li>
<li><a id="L270">&#x200c;</a><span class="linkable">replace_outer_grouping</span>(PlannerInfo *root, GroupingFunc *grp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Param&nbsp; &nbsp; &nbsp;&nbsp; *retval;<br/></li>
<li>&nbsp; &nbsp; PlannerParamItem *pitem;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; levelsup;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptype = <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) grp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(grp-&gt;agglevelsup &gt; <span class="Constant">0</span> &amp;&amp; grp-&gt;agglevelsup &lt; root-&gt;query_level);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find the query level the GroupingFunc belongs to */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (levelsup = grp-&gt;agglevelsup; levelsup &gt; <span class="Constant">0</span>; levelsup--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root = root-&gt;parent_root;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It does not seem worthwhile to try to de-duplicate references to outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggs.&nbsp; Just make a new slot every time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; grp = copyObject(grp);<br/></li>
<li>&nbsp; &nbsp; <a href="../../rewrite/rewriteManip.c.html#L849" title="rewrite/rewriteManip.c:849">IncrementVarSublevelsUp</a>((Node *) grp, -((<span class="Type">int</span>) grp-&gt;agglevelsup), <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(grp-&gt;agglevelsup == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pitem = makeNode(PlannerParamItem);<br/></li>
<li>&nbsp; &nbsp; pitem-&gt;item = (Node *) grp;<br/></li>
<li>&nbsp; &nbsp; pitem-&gt;paramId = list_length(root-&gt;glob-&gt;paramExecTypes);<br/></li>
<li>&nbsp; &nbsp; root-&gt;glob-&gt;paramExecTypes = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(root-&gt;glob-&gt;paramExecTypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ptype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; root-&gt;plan_params = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;plan_params, pitem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; retval = makeNode(Param);<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramkind = PARAM_EXEC;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramid = pitem-&gt;paramId;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramtype = ptype;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramtypmod = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramcollid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;location = grp-&gt;location;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> retval;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generate a Param node to replace the given MergeSupportFunc expression<br/></li>
<li></span><span class="Comment"> * which is expected to be in the RETURNING list of an <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level MERGE<br/></li>
<li></span><span class="Comment"> * query.&nbsp; Record the need for the MergeSupportFunc in the proper <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level<br/></li>
<li></span><span class="Comment"> * root-&gt;plan_params.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Param *<br/></li>
<li><a id="L317">&#x200c;</a><span class="linkable">replace_outer_merge_support</span>(PlannerInfo *root, MergeSupportFunc *msf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Param&nbsp; &nbsp; &nbsp;&nbsp; *retval;<br/></li>
<li>&nbsp; &nbsp; PlannerParamItem *pitem;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptype = <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) msf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;commandType != CMD_MERGE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The parser should have ensured that the MergeSupportFunc is in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * RETURNING list of an <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level MERGE query, so <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> that query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root = root-&gt;parent_root;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (root == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;MergeSupportFunc found outside MERGE&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;commandType != CMD_MERGE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It does not seem worthwhile to try to de-duplicate references to outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * MergeSupportFunc expressions.&nbsp; Just make a new slot every time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; msf = copyObject(msf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pitem = makeNode(PlannerParamItem);<br/></li>
<li>&nbsp; &nbsp; pitem-&gt;item = (Node *) msf;<br/></li>
<li>&nbsp; &nbsp; pitem-&gt;paramId = list_length(root-&gt;glob-&gt;paramExecTypes);<br/></li>
<li>&nbsp; &nbsp; root-&gt;glob-&gt;paramExecTypes = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(root-&gt;glob-&gt;paramExecTypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ptype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; root-&gt;plan_params = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;plan_params, pitem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; retval = makeNode(Param);<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramkind = PARAM_EXEC;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramid = pitem-&gt;paramId;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramtype = ptype;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramtypmod = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramcollid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;location = msf-&gt;location;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> retval;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generate a Param node to replace the given Var,<br/></li>
<li></span><span class="Comment"> * which is expected to come from some <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> NestLoop plan node.<br/></li>
<li></span><span class="Comment"> * Record the need for the Var in root-&gt;curOuterParams.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Param *<br/></li>
<li><a id="L367">&#x200c;</a><span class="linkable">replace_nestloop_param_var</span>(PlannerInfo *root, Var *var)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Param&nbsp; &nbsp; &nbsp;&nbsp; *param;<br/></li>
<li>&nbsp; &nbsp; NestLoopParam *nlp;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Is this Var already listed in root-&gt;curOuterParams? */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, root-&gt;curOuterParams)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nlp = (NestLoopParam *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(var, nlp-&gt;paramval))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Yes, so just make a Param referencing this NLP's slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; param = makeNode(Param);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; param-&gt;paramkind = PARAM_EXEC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; param-&gt;paramid = nlp-&gt;paramno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; param-&gt;paramtype = var-&gt;vartype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; param-&gt;paramtypmod = var-&gt;vartypmod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; param-&gt;paramcollid = var-&gt;varcollid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; param-&gt;location = var-&gt;location;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> param;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No, so assign a PARAM_EXEC slot for a new NLP */<br/></li>
<li></span>&nbsp; &nbsp; param = <a href="#L637" title="optimizer/util/paramassign.c:637">generate_new_exec_param</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;vartype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;vartypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varcollid);<br/></li>
<li>&nbsp; &nbsp; param-&gt;location = var-&gt;location;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add it to the list of required NLPs */<br/></li>
<li></span>&nbsp; &nbsp; nlp = makeNode(NestLoopParam);<br/></li>
<li>&nbsp; &nbsp; nlp-&gt;paramno = param-&gt;paramid;<br/></li>
<li>&nbsp; &nbsp; nlp-&gt;paramval = copyObject(var);<br/></li>
<li>&nbsp; &nbsp; root-&gt;curOuterParams = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;curOuterParams, nlp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And return the replacement Param */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> param;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generate a Param node to replace the given PlaceHolderVar,<br/></li>
<li></span><span class="Comment"> * which is expected to come from some <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> NestLoop plan node.<br/></li>
<li></span><span class="Comment"> * Record the need for the PHV in root-&gt;curOuterParams.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is just like <a href="#L367" title="optimizer/util/paramassign.c:367">replace_nestloop_param_var</a>, except for PlaceHolderVars.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Param *<br/></li>
<li><a id="L416">&#x200c;</a><span class="linkable">replace_nestloop_param_placeholdervar</span>(PlannerInfo *root, PlaceHolderVar *phv)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Param&nbsp; &nbsp; &nbsp;&nbsp; *param;<br/></li>
<li>&nbsp; &nbsp; NestLoopParam *nlp;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Is this PHV already listed in root-&gt;curOuterParams? */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, root-&gt;curOuterParams)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nlp = (NestLoopParam *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(phv, nlp-&gt;paramval))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Yes, so just make a Param referencing this NLP's slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; param = makeNode(Param);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; param-&gt;paramkind = PARAM_EXEC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; param-&gt;paramid = nlp-&gt;paramno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; param-&gt;paramtype = <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) phv-&gt;phexpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; param-&gt;paramtypmod = <a href="../../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>((Node *) phv-&gt;phexpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; param-&gt;paramcollid = <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) phv-&gt;phexpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; param-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> param;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No, so assign a PARAM_EXEC slot for a new NLP */<br/></li>
<li></span>&nbsp; &nbsp; param = <a href="#L637" title="optimizer/util/paramassign.c:637">generate_new_exec_param</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) phv-&gt;phexpr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>((Node *) phv-&gt;phexpr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) phv-&gt;phexpr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add it to the list of required NLPs */<br/></li>
<li></span>&nbsp; &nbsp; nlp = makeNode(NestLoopParam);<br/></li>
<li>&nbsp; &nbsp; nlp-&gt;paramno = param-&gt;paramid;<br/></li>
<li>&nbsp; &nbsp; nlp-&gt;paramval = (Var *) copyObject(phv);<br/></li>
<li>&nbsp; &nbsp; root-&gt;curOuterParams = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;curOuterParams, nlp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And return the replacement Param */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> param;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L480" title="optimizer/util/paramassign.c:480">process_subquery_nestloop_params</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Handle params of a parameterized subquery that need to be fed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; from an outer nestloop.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently, that would be *all* params that a subquery in FROM has demanded<br/></li>
<li></span><span class="Comment"> * from the current query level, since they must be LATERAL references.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * subplan_params is a list of PlannerParamItems that we intend to pass to<br/></li>
<li></span><span class="Comment"> * a subquery-in-FROM.&nbsp; (This was constructed in root-&gt;plan_params while<br/></li>
<li></span><span class="Comment"> * planning the subquery, but isn't there anymore when this is called.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The subplan's references to the outer variables are already represented<br/></li>
<li></span><span class="Comment"> * as PARAM_EXEC Params, since that conversion was done by the routines above<br/></li>
<li></span><span class="Comment"> * while planning the subquery.&nbsp; So we need not modify the subplan or the<br/></li>
<li></span><span class="Comment"> * PlannerParamItems here.&nbsp; What we do need to do is add entries to<br/></li>
<li></span><span class="Comment"> * root-&gt;curOuterParams to signal the parent nestloop plan node that it must<br/></li>
<li></span><span class="Comment"> * provide these <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; This differs from <a href="#L367" title="optimizer/util/paramassign.c:367">replace_nestloop_param_var</a> in<br/></li>
<li></span><span class="Comment"> * that the PARAM_EXEC slots to use have already been determined.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we also use root-&gt;curOuterRels as an implicit parameter for<br/></li>
<li></span><span class="Comment"> * sanity checks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L480">&#x200c;</a></span><span class="linkable">process_subquery_nestloop_params</span>(PlannerInfo *root, List *subplan_params)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, subplan_params)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlannerParamItem *pitem = lfirst_node(PlannerParamItem, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(pitem-&gt;item, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) pitem-&gt;item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NestLoopParam *nlp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If not from a nestloop outer rel, complain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(var-&gt;varno, root-&gt;curOuterRels))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;non-LATERAL parameter required by subquery&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Is this param already listed in root-&gt;curOuterParams? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, root-&gt;curOuterParams)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nlp = (NestLoopParam *) lfirst(lc2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nlp-&gt;paramno == pitem-&gt;paramId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(var, nlp-&gt;paramval));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Present, so nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lc2 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No, so add it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nlp = makeNode(NestLoopParam);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nlp-&gt;paramno = pitem-&gt;paramId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nlp-&gt;paramval = copyObject(var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;curOuterParams = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;curOuterParams, nlp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(pitem-&gt;item, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *phv = (PlaceHolderVar *) pitem-&gt;item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NestLoopParam *nlp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If not from a nestloop outer rel, complain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(<a href="placeholder.c.html#L83" title="optimizer/util/placeholder.c:83">find_placeholder_info</a>(root, phv)-&gt;ph_eval_at,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;curOuterRels))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;non-LATERAL parameter required by subquery&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Is this param already listed in root-&gt;curOuterParams? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, root-&gt;curOuterParams)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nlp = (NestLoopParam *) lfirst(lc2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nlp-&gt;paramno == pitem-&gt;paramId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(phv, nlp-&gt;paramval));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Present, so nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lc2 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No, so add it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nlp = makeNode(NestLoopParam);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nlp-&gt;paramno = pitem-&gt;paramId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nlp-&gt;paramval = (Var *) copyObject(phv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;curOuterParams = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;curOuterParams, nlp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected type of subquery parameter&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Identify <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> NestLoopParams that should be supplied by a NestLoop plan<br/></li>
<li></span><span class="Comment"> * node with the specified lefthand rels.&nbsp; Remove them from the active<br/></li>
<li></span><span class="Comment"> * root-&gt;curOuterParams list and return them as the result list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> Here we also hack up the returned Vars and PHVs so that they do not<br/></li>
<li></span><span class="Comment"> * contain nullingrel sets exceeding what is available from the outer side.<br/></li>
<li></span><span class="Comment"> * This is needed if we have applied outer join identity 3,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (A leftjoin B on (Pab)) leftjoin C on (Pb*c)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; = A leftjoin (B leftjoin C on (Pbc)) on (Pab)<br/></li>
<li></span><span class="Comment"> * and C contains lateral references to B.&nbsp; It's still safe to apply the<br/></li>
<li></span><span class="Comment"> * identity, but the parser will have created those references in the form<br/></li>
<li></span><span class="Comment"> * &quot;b*&quot; (i.e., with varnullingrels listing the A/B join), while what we will<br/></li>
<li></span><span class="Comment"> * have available from the nestloop's outer side is just &quot;b&quot;.&nbsp; We deal with<br/></li>
<li></span><span class="Comment"> * that here by stripping the nullingrels down to what is available from the<br/></li>
<li></span><span class="Comment"> * outer side according to leftrelids.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * That fixes matters for the case of forward application of identity 3.<br/></li>
<li></span><span class="Comment"> * If the identity was applied in the reverse direction, we will have<br/></li>
<li></span><span class="Comment"> * parameter Vars containing too few nullingrel bits rather than too many.<br/></li>
<li></span><span class="Comment"> * Currently, that causes no problems because setrefs.c applies only a<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> check to nullingrels in NestLoopParams, but we'd have to work<br/></li>
<li></span><span class="Comment"> * harder if we ever want to tighten that check.&nbsp; This is all pretty annoying<br/></li>
<li></span><span class="Comment"> * because it greatly weakens setrefs.c's cross-check, but the alternative<br/></li>
<li></span><span class="Comment"> * seems to be to generate multiple versions of each laterally-parameterized<br/></li>
<li></span><span class="Comment"> * subquery, which'd be unduly expensive.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L582">&#x200c;</a><span class="linkable">identify_current_nestloop_params</span>(PlannerInfo *root, Relids leftrelids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(cell, root-&gt;curOuterParams)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; NestLoopParam *nlp = (NestLoopParam *) lfirst(cell);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are looking for Vars and PHVs that can be supplied by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lefthand rels.&nbsp; When we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one, it's okay to modify it in-place<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because all the routines above make a fresh copy to put into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * curOuterParams.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(nlp-&gt;paramval, Var) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(nlp-&gt;paramval-&gt;varno, leftrelids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) nlp-&gt;paramval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;curOuterParams = foreach_delete_current(root-&gt;curOuterParams,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varnullingrels = <a href="../../nodes/bitmapset.c.html#L292" title="nodes/bitmapset.c:292">bms_intersect</a>(var-&gt;varnullingrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftrelids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, nlp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(nlp-&gt;paramval, PlaceHolderVar) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(<a href="placeholder.c.html#L83" title="optimizer/util/placeholder.c:83">find_placeholder_info</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (PlaceHolderVar *) nlp-&gt;paramval)-&gt;ph_eval_at,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; leftrelids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *phv = (PlaceHolderVar *) nlp-&gt;paramval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;curOuterParams = foreach_delete_current(root-&gt;curOuterParams,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phv-&gt;phnullingrels = <a href="../../nodes/bitmapset.c.html#L292" title="nodes/bitmapset.c:292">bms_intersect</a>(phv-&gt;phnullingrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; leftrelids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, nlp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generate a new Param node that will not conflict with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used to create Params representing subplan outputs or<br/></li>
<li></span><span class="Comment"> * NestLoop parameters.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We don't need to build a PlannerParamItem for such a Param, but we do<br/></li>
<li></span><span class="Comment"> * need to make sure we record the type in paramExecTypes (otherwise,<br/></li>
<li></span><span class="Comment"> * there won't be a slot allocated for it).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Param *<br/></li>
<li><a id="L637">&#x200c;</a><span class="linkable">generate_new_exec_param</span>(PlannerInfo *root, Oid paramtype, int32 paramtypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid paramcollation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Param&nbsp; &nbsp; &nbsp;&nbsp; *retval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; retval = makeNode(Param);<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramkind = PARAM_EXEC;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramid = list_length(root-&gt;glob-&gt;paramExecTypes);<br/></li>
<li>&nbsp; &nbsp; root-&gt;glob-&gt;paramExecTypes = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(root-&gt;glob-&gt;paramExecTypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; paramtype);<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramtype = paramtype;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramtypmod = paramtypmod;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;paramcollid = paramcollation;<br/></li>
<li>&nbsp; &nbsp; retval-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> retval;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Assign a (nonnegative) PARAM_EXEC ID for a special parameter (one that<br/></li>
<li></span><span class="Comment"> * is not actually used to carry a value at runtime).&nbsp; Such parameters are<br/></li>
<li></span><span class="Comment"> * used for special runtime signaling purposes, such as connecting a<br/></li>
<li></span><span class="Comment"> * recursive union node to its worktable scan node or forcing plan<br/></li>
<li></span><span class="Comment"> * re-evaluation within the <a href="../../executor/execMain.c.html#L2470" title="executor/execMain.c:2470">EvalPlanQual</a> mechanism.&nbsp; No actual Param node<br/></li>
<li></span><span class="Comment"> * exists with this ID, however.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L664">&#x200c;</a></span><span class="linkable">assign_special_exec_param</span>(PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramId = list_length(root-&gt;glob-&gt;paramExecTypes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; root-&gt;glob-&gt;paramExecTypes = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(root-&gt;glob-&gt;paramExecTypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> paramId;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
