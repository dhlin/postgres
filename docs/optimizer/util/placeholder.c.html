<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>optimizer/util/placeholder.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>optimizer/util/placeholder.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L27">contain_placeholder_references_context</a></li>
<li><a href="#L31">contain_placeholder_references_context</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L329">add_placeholders_to_base_rels</a></li>
<li><a href="#L373">add_placeholders_to_joinrel</a></li>
<li><a href="#L464">contain_placeholder_references_to</a></li>
<li><a href="#L479">contain_placeholder_references_walker</a></li>
<li><a href="#L83">find_placeholder_info</a></li>
<li><a href="#L257">find_placeholders_in_expr</a></li>
<li><a href="#L185">find_placeholders_in_jointree</a></li>
<li><a href="#L207">find_placeholders_recurse</a></li>
<li><a href="#L300">fix_placeholder_input_needed_levels</a></li>
<li><a href="#L54">make_placeholder_expr</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * placeholder.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; PlaceHolderVar and PlaceHolderInfo manipulation routines<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/optimizer/util/placeholder.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/cost.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/pathnode.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/placeholder.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/planmain.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L27">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">contain_placeholder_references_context</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublevels_up;<br/></li>
<li><a id="L31">&#x200c;</a>} <span class="linkable">contain_placeholder_references_context</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Local <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L207" title="optimizer/util/placeholder.c:207">find_placeholders_recurse</a>(PlannerInfo *root, Node *jtnode);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L257" title="optimizer/util/placeholder.c:257">find_placeholders_in_expr</a>(PlannerInfo *root, Node *expr);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L479" title="optimizer/util/placeholder.c:479">contain_placeholder_references_walker</a>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L27" title="optimizer/util/placeholder.c:27">contain_placeholder_references_context</a> *context);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L54" title="optimizer/util/placeholder.c:54">make_placeholder_expr</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Make a PlaceHolderVar for the given expression.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * phrels is the syntactic location (as a set of relids) to attribute<br/></li>
<li></span><span class="Comment"> * to the expression.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller is responsible for adjusting phlevelsup and phnullingrels<br/></li>
<li></span><span class="Comment"> * as needed.&nbsp; Because we do not know here which query level the PHV<br/></li>
<li></span><span class="Comment"> * will be associated with, it's important that this function touches<br/></li>
<li></span><span class="Comment"> * only root-&gt;glob; messing with other parts of PlannerInfo would be<br/></li>
<li></span><span class="Comment"> * likely to do the wrong thing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PlaceHolderVar *<br/></li>
<li><a id="L54">&#x200c;</a><span class="linkable">make_placeholder_expr</span>(PlannerInfo *root, Expr *expr, Relids phrels)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlaceHolderVar *phv = makeNode(PlaceHolderVar);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; phv-&gt;phexpr = expr;<br/></li>
<li>&nbsp; &nbsp; phv-&gt;phrels = phrels;<br/></li>
<li>&nbsp; &nbsp; phv-&gt;phnullingrels = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* caller may change this later */<br/></li>
<li></span>&nbsp; &nbsp; phv-&gt;phid = ++(root-&gt;glob-&gt;lastPHId);<br/></li>
<li>&nbsp; &nbsp; phv-&gt;phlevelsup = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* caller may change this later */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> phv;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L83" title="optimizer/util/placeholder.c:83">find_placeholder_info</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Fetch the PlaceHolderInfo for the given PHV<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the PlaceHolderInfo doesn't exist yet, create it if we haven't yet<br/></li>
<li></span><span class="Comment"> * frozen the set of PlaceHolderInfos for the query; else throw an error.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is separate from <a href="#L54" title="optimizer/util/placeholder.c:54">make_placeholder_expr</a> because subquery pullup has<br/></li>
<li></span><span class="Comment"> * to make PlaceHolderVars for expressions that might not be used at all in<br/></li>
<li></span><span class="Comment"> * the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> query, or might not remain after const-expression simplification.<br/></li>
<li></span><span class="Comment"> * We build PlaceHolderInfos only for PHVs that are still present in the<br/></li>
<li></span><span class="Comment"> * simplified query passed to <a href="../plan/planmain.c.html#L54" title="optimizer/plan/planmain.c:54">query_planner</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this should only be called after <a href="../plan/planmain.c.html#L54" title="optimizer/plan/planmain.c:54">query_planner</a>() has started.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PlaceHolderInfo *<br/></li>
<li><a id="L83">&#x200c;</a><span class="linkable">find_placeholder_info</span>(PlannerInfo *root, PlaceHolderVar *phv)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlaceHolderInfo *phinfo;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; rels_used;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if this ever isn't true, we'd need to be able to look in parent lists */<br/></li>
<li></span>&nbsp; &nbsp; Assert(phv-&gt;phlevelsup == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use placeholder_array to look up existing PlaceHolderInfo quickly */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (phv-&gt;phid &lt; root-&gt;placeholder_array_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; phinfo = root-&gt;placeholder_array[phv-&gt;phid];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; phinfo = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (phinfo != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(phinfo-&gt;phid == phv-&gt;phid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> phinfo;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Not found, so create it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;placeholdersFrozen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;too late to create a new PlaceHolderInfo&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; phinfo = makeNode(PlaceHolderInfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; phinfo-&gt;phid = phv-&gt;phid;<br/></li>
<li>&nbsp; &nbsp; phinfo-&gt;ph_var = copyObject(phv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * By convention, phinfo-&gt;ph_var-&gt;phnullingrels is always empty, since the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PlaceHolderInfo represents the initially-calculated state of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PlaceHolderVar.&nbsp; PlaceHolderVars appearing in the query tree might have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * varying <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of phnullingrels, reflecting outer joins applied above<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the calculation level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; phinfo-&gt;ph_var-&gt;phnullingrels = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Any referenced rels that are outside the PHV's syntactic scope are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LATERAL references, which should be included in ph_lateral but not in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ph_eval_at.&nbsp; If no referenced rels are within the syntactic scope,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * force evaluation at the syntactic location.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rels_used = <a href="var.c.html#L108" title="optimizer/util/var.c:108">pull_varnos</a>(root, (Node *) phv-&gt;phexpr);<br/></li>
<li>&nbsp; &nbsp; phinfo-&gt;ph_lateral = <a href="../../nodes/bitmapset.c.html#L346" title="nodes/bitmapset.c:346">bms_difference</a>(rels_used, phv-&gt;phrels);<br/></li>
<li>&nbsp; &nbsp; phinfo-&gt;ph_eval_at = <a href="../../nodes/bitmapset.c.html#L1109" title="nodes/bitmapset.c:1109">bms_int_members</a>(rels_used, phv-&gt;phrels);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If no contained <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>, force evaluation at syntactic location */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bms_is_empty(phinfo-&gt;ph_eval_at))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; phinfo-&gt;ph_eval_at = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(phv-&gt;phrels);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!bms_is_empty(phinfo-&gt;ph_eval_at));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; phinfo-&gt;ph_needed = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* initially it's unused */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* for the moment, estimate width using just the datatype info */<br/></li>
<li></span>&nbsp; &nbsp; phinfo-&gt;ph_width = <a href="../../utils/cache/lsyscache.c.html#L2578" title="utils/cache/lsyscache.c:2578">get_typavgwidth</a>(<a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) phv-&gt;phexpr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>((Node *) phv-&gt;phexpr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add to both placeholder_list and placeholder_array.&nbsp; Note: because we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * store pointers to the PlaceHolderInfos in two data structures, it'd be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unsafe to pass the whole placeholder_list structure through<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expression_tree_mutator or the like --- or at least, you'd have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rebuild the placeholder_array afterwards.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;placeholder_list = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;placeholder_list, phinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (phinfo-&gt;phid &gt;= root-&gt;placeholder_array_size)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must allocate or enlarge placeholder_array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_size = root-&gt;placeholder_array_size ? root-&gt;placeholder_array_size * <span class="Constant">2</span> : <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (phinfo-&gt;phid &gt;= new_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_size *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;placeholder_array)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;placeholder_array =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; repalloc0_array(root-&gt;placeholder_array, PlaceHolderInfo *, root-&gt;placeholder_array_size, new_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;placeholder_array =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; palloc0_array(PlaceHolderInfo *, new_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;placeholder_array_size = new_size;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; root-&gt;placeholder_array[phinfo-&gt;phid] = phinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The PHV's contained expression may contain other, <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-level PHVs.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> know we need to get those into the PlaceHolderInfo list, too, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * may as well do that immediately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L257" title="optimizer/util/placeholder.c:257">find_placeholders_in_expr</a>(root, (Node *) phinfo-&gt;ph_var-&gt;phexpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> phinfo;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L185" title="optimizer/util/placeholder.c:185">find_placeholders_in_jointree</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Search the jointree for PlaceHolderVars, and build PlaceHolderInfos<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We don't need to look at the targetlist because <a href="../plan/initsplan.c.html#L234" title="optimizer/plan/initsplan.c:234">build_base_rel_tlists</a>()<br/></li>
<li></span><span class="Comment"> * will already have made entries for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> PHVs in the tlist.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L185">&#x200c;</a></span><span class="linkable">find_placeholders_in_jointree</span>(PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This must be done <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> freezing the set of PHIs */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!root-&gt;placeholdersFrozen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We need do nothing if the query contains no PlaceHolderVars */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;glob-&gt;lastPHId != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Start recursion at top of jointree */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;jointree != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IsA(root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;jointree, FromExpr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L207" title="optimizer/util/placeholder.c:207">find_placeholders_recurse</a>(root, (Node *) root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;jointree);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L207" title="optimizer/util/placeholder.c:207">find_placeholders_recurse</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; One recursion level of <a href="#L185" title="optimizer/util/placeholder.c:185">find_placeholders_in_jointree</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * jtnode is the current jointree node to examine.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L207">&#x200c;</a></span><span class="linkable">find_placeholders_recurse</span>(PlannerInfo *root, Node *jtnode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (jtnode == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(jtnode, RangeTblRef))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No quals to deal with here */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(jtnode, FromExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FromExpr&nbsp;&nbsp; *f = (FromExpr *) jtnode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First, recurse to handle child joins.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, f-&gt;fromlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L207" title="optimizer/util/placeholder.c:207">find_placeholders_recurse</a>(root, lfirst(l));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now process the top-level quals.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L257" title="optimizer/util/placeholder.c:257">find_placeholders_in_expr</a>(root, f-&gt;quals);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(jtnode, JoinExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JoinExpr&nbsp;&nbsp; *j = (JoinExpr *) jtnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First, recurse to handle child joins.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L207" title="optimizer/util/placeholder.c:207">find_placeholders_recurse</a>(root, j-&gt;larg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L207" title="optimizer/util/placeholder.c:207">find_placeholders_recurse</a>(root, j-&gt;rarg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Process the qual clauses */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L257" title="optimizer/util/placeholder.c:257">find_placeholders_in_expr</a>(root, j-&gt;quals);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) nodeTag(jtnode));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L257" title="optimizer/util/placeholder.c:257">find_placeholders_in_expr</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Find all PlaceHolderVars in the given expression, and create<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderInfo entries for them.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L257">&#x200c;</a></span><span class="linkable">find_placeholders_in_expr</span>(PlannerInfo *root, Node *expr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *vl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="var.c.html#L607" title="optimizer/util/var.c:607">pull_var_clause</a> does more than we need here, but it'll do and it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * convenient to use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> = <a href="var.c.html#L607" title="optimizer/util/var.c:607">pull_var_clause</a>(expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PVC_RECURSE_AGGREGATES |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PVC_RECURSE_WINDOWFUNCS |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PVC_INCLUDE_PLACEHOLDERS);<br/></li>
<li>&nbsp; &nbsp; foreach(vl, <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *phv = (PlaceHolderVar *) lfirst(vl);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> plain Vars */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsA(phv, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create a PlaceHolderInfo entry if there's not one already */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L83" title="optimizer/util/placeholder.c:83">find_placeholder_info</a>(root, phv);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L300" title="optimizer/util/placeholder.c:300">fix_placeholder_input_needed_levels</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Adjust the &quot;needed at&quot; levels for placeholder inputs<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called after we've finished determining the eval_at levels for<br/></li>
<li></span><span class="Comment"> * all placeholders.&nbsp; We need to make sure that all <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> and placeholders<br/></li>
<li></span><span class="Comment"> * needed to evaluate each placeholder will be available at the scan or join<br/></li>
<li></span><span class="Comment"> * level where the evaluation will be done.&nbsp; (It might seem that scan-level<br/></li>
<li></span><span class="Comment"> * evaluations aren't interesting, but that's not so: a LATERAL reference<br/></li>
<li></span><span class="Comment"> * within a placeholder's expression needs to cause the referenced var or<br/></li>
<li></span><span class="Comment"> * placeholder to be marked as needed in the scan where it's evaluated.)<br/></li>
<li></span><span class="Comment"> * Note that this loop can have side-effects on the ph_needed sets of other<br/></li>
<li></span><span class="Comment"> * PlaceHolderInfos; that's okay because we don't examine ph_needed here, so<br/></li>
<li></span><span class="Comment"> * there are no ordering issues to worry about.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L300">&#x200c;</a></span><span class="linkable">fix_placeholder_input_needed_levels</span>(PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, root-&gt;placeholder_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderInfo *phinfo = (PlaceHolderInfo *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> = <a href="var.c.html#L607" title="optimizer/util/var.c:607">pull_var_clause</a>((Node *) phinfo-&gt;ph_var-&gt;phexpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PVC_RECURSE_AGGREGATES |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PVC_RECURSE_WINDOWFUNCS |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PVC_INCLUDE_PLACEHOLDERS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../plan/initsplan.c.html#L279" title="optimizer/plan/initsplan.c:279">add_vars_to_targetlist</a>(root, <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>, phinfo-&gt;ph_eval_at);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L329" title="optimizer/util/placeholder.c:329">add_placeholders_to_base_rels</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Add <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> required PlaceHolderVars to base rels' targetlists.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> placeholder can be computed at a base rel and is needed above it,<br/></li>
<li></span><span class="Comment"> * add it to that rel's targetlist.&nbsp; This might look like it could be merged<br/></li>
<li></span><span class="Comment"> * with <a href="#L300" title="optimizer/util/placeholder.c:300">fix_placeholder_input_needed_levels</a>, but it must be separate because<br/></li>
<li></span><span class="Comment"> * join removal happens in between, and can change the ph_eval_at sets.&nbsp; There<br/></li>
<li></span><span class="Comment"> * is essentially the same logic in <a href="#L373" title="optimizer/util/placeholder.c:373">add_placeholders_to_joinrel</a>, but we can't<br/></li>
<li></span><span class="Comment"> * do that part until joinrels are formed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L329">&#x200c;</a></span><span class="linkable">add_placeholders_to_base_rels</span>(PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, root-&gt;placeholder_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderInfo *phinfo = (PlaceHolderInfo *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; eval_at = phinfo-&gt;ph_eval_at;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L715" title="nodes/bitmapset.c:715">bms_get_singleton_member</a>(eval_at, &amp;varno) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L641" title="nodes/bitmapset.c:641">bms_nonempty_difference</a>(phinfo-&gt;ph_needed, eval_at))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel = <a href="relnode.c.html#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(root, varno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As in <a href="../plan/initsplan.c.html#L279" title="optimizer/plan/initsplan.c:279">add_vars_to_targetlist</a>(), a value computed at scan level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * has not yet been nulled by <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer join, so its phnullingrels<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should be empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(phinfo-&gt;ph_var-&gt;phnullingrels == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copying the PHV might be unnecessary here, but be safe */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;reltarget-&gt;exprs = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rel-&gt;reltarget-&gt;exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; copyObject(phinfo-&gt;ph_var));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reltarget's cost and width fields will be updated later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L373" title="optimizer/util/placeholder.c:373">add_placeholders_to_joinrel</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Add <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> newly-computable PlaceHolderVars to a join rel's targetlist;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and if computable PHVs contain lateral references, add those<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; references to the joinrel's direct_lateral_relids.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A join rel should emit a PlaceHolderVar if (a) the PHV can be computed<br/></li>
<li></span><span class="Comment"> * at or below this join level and (b) the PHV is needed above this level.<br/></li>
<li></span><span class="Comment"> * Our caller <a href="relnode.c.html#L665" title="optimizer/util/relnode.c:665">build_join_rel</a>() has already added <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> PHVs that were computed<br/></li>
<li></span><span class="Comment"> * in either join input rel, so we need add only newly-computable ones to<br/></li>
<li></span><span class="Comment"> * the targetlist.&nbsp; However, direct_lateral_relids must be updated for every<br/></li>
<li></span><span class="Comment"> * PHV computable at or below this join, as explained below.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L373">&#x200c;</a></span><span class="linkable">add_placeholders_to_joinrel</span>(PlannerInfo *root, RelOptInfo *joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *outer_rel, RelOptInfo *inner_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpecialJoinInfo *sjinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; relids = joinrel-&gt;relids;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; tuple_width = joinrel-&gt;reltarget-&gt;width;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, root-&gt;placeholder_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderInfo *phinfo = (PlaceHolderInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Is it computable here? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(phinfo-&gt;ph_eval_at, relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Is it still needed above this joinrel? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L641" title="nodes/bitmapset.c:641">bms_nonempty_difference</a>(phinfo-&gt;ph_needed, relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Yes, but only add to tlist if it wasn't computed in either<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * input; otherwise it should be there already.&nbsp; Also, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> the cost of evaluating the contained expression if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the PHV can be computed here but not in either input.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> bogus because we make the decision based on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first pair of possible input relations considered for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * joinrel.&nbsp; With other pairs, it might be possible to compute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the PHV in one input or the other, and then we'd be double<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * charging the PHV's cost for some join paths.&nbsp; For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, live<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with that; but we might want to improve it later by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * refiguring the reltarget costs for each pair of inputs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(phinfo-&gt;ph_eval_at, outer_rel-&gt;relids) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(phinfo-&gt;ph_eval_at, inner_rel-&gt;relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copying might be unnecessary here, but be safe */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *phv = copyObject(phinfo-&gt;ph_var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QualCost&nbsp; &nbsp; cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It'll start out not nulled by anything.&nbsp; Joins above<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this one might add to its phnullingrels later, in much<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the same way as for Vars.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(phv-&gt;phnullingrels == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrel-&gt;reltarget-&gt;exprs = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(joinrel-&gt;reltarget-&gt;exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L4666" title="optimizer/path/costsize.c:4666">cost_qual_eval_node</a>(&amp;cost, (Node *) phv-&gt;phexpr, root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrel-&gt;reltarget-&gt;cost.startup += cost.startup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrel-&gt;reltarget-&gt;cost.per_tuple += cost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_width += phinfo-&gt;ph_width;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also adjust joinrel's direct_lateral_relids to include the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PHV's source rel(s).&nbsp; We must do this even if we're not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * actually going to emit the PHV, otherwise <a href="../path/joinrels.c.html#L349" title="optimizer/path/joinrels.c:349">join_is_legal</a>() will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reject valid join orderings.&nbsp; (In principle maybe we could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * instead remove the joinrel's lateral_relids dependency; but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that's complicated to get right, and cases where we're not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * going to emit the PHV are too rare to justify the work.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In principle we should only do this if the join doesn't yet<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * include the PHV's source rel(s).&nbsp; But our caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="relnode.c.html#L665" title="optimizer/util/relnode.c:665">build_join_rel</a>() will clean things up by removing the join's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * own relids from its direct_lateral_relids, so we needn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * account for that here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrel-&gt;direct_lateral_relids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(joinrel-&gt;direct_lateral_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phinfo-&gt;ph_lateral);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;reltarget-&gt;width = <a href="../path/costsize.c.html#L231" title="optimizer/path/costsize.c:231">clamp_width_est</a>(tuple_width);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L464" title="optimizer/util/placeholder.c:464">contain_placeholder_references_to</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Detect whether <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> PlaceHolderVars in the given clause contain<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; references to the given relid (typically an OJ relid).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;Contain&quot; means that there's a use of the relid inside the PHV's<br/></li>
<li></span><span class="Comment"> * contained expression, so that changing the nullability status of<br/></li>
<li></span><span class="Comment"> * the rel might change what the PHV computes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The code here to cope with <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level PHVs is likely dead, but keep it<br/></li>
<li></span><span class="Comment"> * anyway just in case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L464">&#x200c;</a></span><span class="linkable">contain_placeholder_references_to</span>(PlannerInfo *root, Node *clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L27" title="optimizer/util/placeholder.c:27">contain_placeholder_references_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can answer quickly in the common case that there's no PHVs at all */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;glob-&gt;lastPHId == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Else run the recursive search */<br/></li>
<li></span>&nbsp; &nbsp; context.relid = relid;<br/></li>
<li>&nbsp; &nbsp; context.sublevels_up = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L479" title="optimizer/util/placeholder.c:479">contain_placeholder_references_walker</a>(clause, &amp;context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L479">&#x200c;</a></span><span class="linkable">contain_placeholder_references_walker</span>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L27" title="optimizer/util/placeholder.c:27">contain_placeholder_references_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *phv = (PlaceHolderVar *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We should just look through PHVs of other query levels */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (phv-&gt;phlevelsup == context-&gt;sublevels_up)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If phrels matches, we found what we came for */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(context-&gt;relid, phv-&gt;phrels))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We should not examine phnullingrels: what we are looking for is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * references in the contained expression, not OJs that might null<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the result afterwards.&nbsp; Also, we don't need to recurse into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contained expression, because phrels should adequately<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * summarize what's in there.&nbsp; So we're done here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, Query))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse into RTE subquery or not-yet-planned sublink subquery */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = query_tree_walker((Query *) node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L479" title="optimizer/util/placeholder.c:479">contain_placeholder_references_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L479" title="optimizer/util/placeholder.c:479">contain_placeholder_references_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
