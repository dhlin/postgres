<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>optimizer/util/predtest.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>optimizer/util/predtest.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L1698">BT_implic_table</a></li>
<li><a href="#L1672">BT_implies_table</a></li>
<li><a href="#L1711">BT_refute_table</a></li>
<li><a href="#L1685">BT_refutes_table</a></li>
<li><a href="#L2093">OprProofCacheHash</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L956">ArrayConstIterState</a></li>
<li><a href="#L1039">ArrayExprIterState</a></li>
<li><a href="#L2080">OprProofCacheEntry</a></li>
<li><a href="#L2091">OprProofCacheEntry</a></li>
<li><a href="#L2074">OprProofCacheKey</a></li>
<li><a href="#L2078">OprProofCacheKey</a></li>
<li><a href="#L55">PredClass</a></li>
<li><a href="#L57">PredIterInfo</a></li>
<li><a href="#L59">PredIterInfoData</a></li>
<li><a href="#L70">PredIterInfoData</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L2346">InvalidateOprProofCacheCallBack</a></li>
<li><a href="#L1021">arrayconst_cleanup_fn</a></li>
<li><a href="#L1008">arrayconst_next_fn</a></li>
<li><a href="#L959">arrayconst_startup_fn</a></li>
<li><a href="#L1081">arrayexpr_cleanup_fn</a></li>
<li><a href="#L1069">arrayexpr_next_fn</a></li>
<li><a href="#L1042">arrayexpr_startup_fn</a></li>
<li><a href="#L938">boolexpr_startup_fn</a></li>
<li><a href="#L1460">clause_is_strict_for</a></li>
<li><a href="#L1386">extract_not_arg</a></li>
<li><a href="#L1414">extract_strong_not_arg</a></li>
<li><a href="#L2330">get_btree_test_op</a></li>
<li><a href="#L928">list_cleanup_fn</a></li>
<li><a href="#L915">list_next_fn</a></li>
<li><a href="#L908">list_startup_fn</a></li>
<li><a href="#L2101">lookup_proof_cache</a></li>
<li><a href="#L1779">operator_predicate_proof</a></li>
<li><a href="#L2305">operator_same_subexprs_lookup</a></li>
<li><a href="#L2032">operator_same_subexprs_proof</a></li>
<li><a href="#L826">predicate_classify</a></li>
<li><a href="#L152">predicate_implied_by</a></li>
<li><a href="#L290">predicate_implied_by_recurse</a></li>
<li><a href="#L1098">predicate_implied_by_simple_clause</a></li>
<li><a href="#L222">predicate_refuted_by</a></li>
<li><a href="#L531">predicate_refuted_by_recurse</a></li>
<li><a href="#L1225">predicate_refuted_by_simple_clause</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L1664">BTEQ</a></li>
<li><a href="#L1665">BTGE</a></li>
<li><a href="#L1666">BTGT</a></li>
<li><a href="#L1663">BTLE</a></li>
<li><a href="#L1662">BTLT</a></li>
<li><a href="#L1667">BTNE</a></li>
<li><a href="#L40">MAX_SAOP_ARRAY_SIZE</a></li>
<li><a href="#L72">iterate_begin</a></li>
<li><a href="#L78">iterate_end</a></li>
<li><a href="#L1670">none</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * predtest.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Routines to attempt to prove logical implications between predicate<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; expressions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/optimizer/util/predtest.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_operator.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/pathnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/array.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inval.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Proof attempts involving large arrays in ScalarArrayOpExpr nodes are<br/></li>
<li></span><span class="Comment"> * likely to require O(N^2) time, and more often than not fail anyway.<br/></li>
<li></span><span class="Comment"> * So we set an arbitrary limit on the number of array elements that<br/></li>
<li></span><span class="Comment"> * we will allow to be treated as an AND or OR clause.<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> is it worth exposing this as a GUC knob?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L40">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_SAOP_ARRAY_SIZE</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">100<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * To avoid redundant coding in <a href="#L290" title="optimizer/util/predtest.c:290">predicate_implied_by_recurse</a> and<br/></li>
<li></span><span class="Comment"> * <a href="#L531" title="optimizer/util/predtest.c:531">predicate_refuted_by_recurse</a>, we need to abstract out the notion of<br/></li>
<li></span><span class="Comment"> * iterating over the components of an expression that is logically an AND<br/></li>
<li></span><span class="Comment"> * or OR structure.&nbsp; There are multiple sorts of expression nodes that can<br/></li>
<li></span><span class="Comment"> * be treated as ANDs or ORs, and we don't want to code each one separately.<br/></li>
<li></span><span class="Comment"> * Hence, these types and support routines.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; CLASS_ATOM,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* expression that's not AND or OR */<br/></li>
<li></span>&nbsp; &nbsp; CLASS_AND,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* expression with AND semantics */<br/></li>
<li></span>&nbsp; &nbsp; CLASS_OR,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* expression with OR semantics */<br/></li>
<li><a id="L55">&#x200c;</a></span>} <span class="linkable">PredClass</span>;<br/></li>
<li><br/></li>
<li><a id="L57">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <a href="#L59" title="optimizer/util/predtest.c:59">PredIterInfoData</a> *<span class="linkable">PredIterInfo</span>;<br/></li>
<li><br/></li>
<li><a id="L59">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">PredIterInfoData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* node-type-specific iteration state */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *state;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *state_list;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> to do the iteration */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp; &nbsp; (*startup_fn) (Node *clause, <a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> info);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-component iteration function */<br/></li>
<li></span>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *(*next_fn) (<a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> info);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* release resources when done with iteration */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp; &nbsp; (*cleanup_fn) (<a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> info);<br/></li>
<li><a id="L70">&#x200c;</a>} <span class="linkable">PredIterInfoData</span>;<br/></li>
<li><br/></li>
<li><a id="L72">&#x200c;</a><span class="PreProc">#define <span class="linkable">iterate_begin</span>(item, clause, info)&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp;&nbsp; *item; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; (info).startup_fn((clause), &amp;(info)); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">while</span><span class="PreProc"> ((item = (info).next_fn(&amp;(info))) != </span><span class="Constant">NULL</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L78">&#x200c;</a><span class="PreProc">#define <span class="linkable">iterate_end</span>(info)&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; (info).cleanup_fn(&amp;(info)); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L290" title="optimizer/util/predtest.c:290">predicate_implied_by_recurse</a>(Node *clause, Node *predicate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> weak);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L531" title="optimizer/util/predtest.c:531">predicate_refuted_by_recurse</a>(Node *clause, Node *predicate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> weak);<br/></li>
<li><span class="Type">static</span> <a href="#L55" title="optimizer/util/predtest.c:55">PredClass</a> <a href="#L826" title="optimizer/util/predtest.c:826">predicate_classify</a>(Node *clause, <a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> info);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L908" title="optimizer/util/predtest.c:908">list_startup_fn</a>(Node *clause, <a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> info);<br/></li>
<li><span class="Type">static</span> Node *<a href="#L915" title="optimizer/util/predtest.c:915">list_next_fn</a>(<a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> info);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L928" title="optimizer/util/predtest.c:928">list_cleanup_fn</a>(<a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> info);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L938" title="optimizer/util/predtest.c:938">boolexpr_startup_fn</a>(Node *clause, <a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> info);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L959" title="optimizer/util/predtest.c:959">arrayconst_startup_fn</a>(Node *clause, <a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> info);<br/></li>
<li><span class="Type">static</span> Node *<a href="#L1008" title="optimizer/util/predtest.c:1008">arrayconst_next_fn</a>(<a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> info);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1021" title="optimizer/util/predtest.c:1021">arrayconst_cleanup_fn</a>(<a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> info);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1042" title="optimizer/util/predtest.c:1042">arrayexpr_startup_fn</a>(Node *clause, <a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> info);<br/></li>
<li><span class="Type">static</span> Node *<a href="#L1069" title="optimizer/util/predtest.c:1069">arrayexpr_next_fn</a>(<a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> info);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1081" title="optimizer/util/predtest.c:1081">arrayexpr_cleanup_fn</a>(<a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> info);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1098" title="optimizer/util/predtest.c:1098">predicate_implied_by_simple_clause</a>(Expr *predicate, Node *clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> weak);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1225" title="optimizer/util/predtest.c:1225">predicate_refuted_by_simple_clause</a>(Expr *predicate, Node *clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> weak);<br/></li>
<li><span class="Type">static</span> Node *<a href="#L1386" title="optimizer/util/predtest.c:1386">extract_not_arg</a>(Node *clause);<br/></li>
<li><span class="Type">static</span> Node *<a href="#L1414" title="optimizer/util/predtest.c:1414">extract_strong_not_arg</a>(Node *clause);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1460" title="optimizer/util/predtest.c:1460">clause_is_strict_for</a>(Node *clause, Node *subexpr, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> allow_false);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1779" title="optimizer/util/predtest.c:1779">operator_predicate_proof</a>(Expr *predicate, Node *clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> refute_it, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> weak);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2032" title="optimizer/util/predtest.c:2032">operator_same_subexprs_proof</a>(Oid pred_op, Oid clause_op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> refute_it);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2305" title="optimizer/util/predtest.c:2305">operator_same_subexprs_lookup</a>(Oid pred_op, Oid clause_op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> refute_it);<br/></li>
<li><span class="Type">static</span> Oid&nbsp; &nbsp; <a href="#L2330" title="optimizer/util/predtest.c:2330">get_btree_test_op</a>(Oid pred_op, Oid clause_op, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> refute_it);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2346" title="optimizer/util/predtest.c:2346">InvalidateOprProofCacheCallBack</a>(Datum arg, <span class="Type">int</span> cacheid, uint32 hashvalue);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L152" title="optimizer/util/predtest.c:152">predicate_implied_by</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Recursively checks whether the clauses in clause_list imply that the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; given predicate is true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We support two definitions of implication:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;Strong&quot; implication: A implies B means that truth of A implies truth of B.<br/></li>
<li></span><span class="Comment"> * We use this to prove that a row satisfying one WHERE clause or index<br/></li>
<li></span><span class="Comment"> * predicate must satisfy another one.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;Weak&quot; implication: A implies B means that non-falsity of A implies<br/></li>
<li></span><span class="Comment"> * non-falsity of B (&quot;non-false&quot; means &quot;either true or NULL&quot;).&nbsp; We use this to<br/></li>
<li></span><span class="Comment"> * prove that a row satisfying one CHECK constraint must satisfy another one.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Strong implication can also be used to prove that a WHERE clause implies a<br/></li>
<li></span><span class="Comment"> * CHECK constraint, although it will fail to prove a few cases where we could<br/></li>
<li></span><span class="Comment"> * safely conclude that the implication holds.&nbsp; There's no support for proving<br/></li>
<li></span><span class="Comment"> * the converse case, since only a few kinds of CHECK constraint would allow<br/></li>
<li></span><span class="Comment"> * deducing anything.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The top-level List structure of each list corresponds to an AND list.<br/></li>
<li></span><span class="Comment"> * We assume that <a href="clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a>() has been applied and so there<br/></li>
<li></span><span class="Comment"> * are no un-flattened ANDs or ORs (e.g., no AND immediately within an AND,<br/></li>
<li></span><span class="Comment"> * including AND just below the top-level List structure).<br/></li>
<li></span><span class="Comment"> * If this is not true we might fail to prove an implication that is<br/></li>
<li></span><span class="Comment"> * valid, but no worse consequences will ensue.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We assume the predicate has already been checked to contain only<br/></li>
<li></span><span class="Comment"> * immutable <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> and operators.&nbsp; (In many current uses this is known<br/></li>
<li></span><span class="Comment"> * true because the predicate is part of an index predicate that has passed<br/></li>
<li></span><span class="Comment"> * <a href="../../commands/indexcmds.c.html#L1831" title="commands/indexcmds.c:1831">CheckPredicate</a>(); otherwise, the caller must check it.)&nbsp; We dare not make<br/></li>
<li></span><span class="Comment"> * deductions based on non-immutable <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, because they might change<br/></li>
<li></span><span class="Comment"> * answers between the time we make the plan and the time we execute the plan.<br/></li>
<li></span><span class="Comment"> * Immutability of <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in the clause_list is checked here, if necessary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L152">&#x200c;</a></span><span class="linkable">predicate_implied_by</span>(List *predicate_list, List *clause_list,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> weak)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *c;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (predicate_list == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no predicate: implication is vacuous */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (clause_list == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no restriction: implication must fail */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If either input is a single-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> list, replace it with its lone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * member; this avoids one useless level of AND-recursion.&nbsp; We only need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to worry about this at top level, since <a href="clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a> should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have gotten rid of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> trivial ANDs or ORs below that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(predicate_list) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p = (Node *) linitial(predicate_list);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; p = (Node *) predicate_list;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(clause_list) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; c = (Node *) linitial(clause_list);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; c = (Node *) clause_list;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And away we go ... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L290" title="optimizer/util/predtest.c:290">predicate_implied_by_recurse</a>(c, p, weak);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L222" title="optimizer/util/predtest.c:222">predicate_refuted_by</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Recursively checks whether the clauses in clause_list refute the given<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; predicate (that is, prove it false).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is NOT the same as !(<a href="#L152" title="optimizer/util/predtest.c:152">predicate_implied_by</a>), though it is similar<br/></li>
<li></span><span class="Comment"> * in the technique and structure of the code.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We support two definitions of refutation:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;Strong&quot; refutation: A refutes B means truth of A implies falsity of B.<br/></li>
<li></span><span class="Comment"> * We use this to disprove a CHECK constraint given a WHERE clause, i.e.,<br/></li>
<li></span><span class="Comment"> * prove that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> row satisfying the WHERE clause would violate the CHECK<br/></li>
<li></span><span class="Comment"> * constraint.&nbsp; (Observe we must prove B yields false, not just not-true.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;Weak&quot; refutation: A refutes B means truth of A implies non-truth of B<br/></li>
<li></span><span class="Comment"> * (i.e., B must yield false or NULL).&nbsp; We use this to detect mutually<br/></li>
<li></span><span class="Comment"> * contradictory WHERE clauses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Weak refutation can be proven in some cases where strong refutation doesn't<br/></li>
<li></span><span class="Comment"> * hold, so it's useful to use it when possible.&nbsp; We don't currently have<br/></li>
<li></span><span class="Comment"> * support for disproving one CHECK constraint based on another one, nor for<br/></li>
<li></span><span class="Comment"> * disproving WHERE based on CHECK.&nbsp; (As with implication, the last case<br/></li>
<li></span><span class="Comment"> * doesn't seem very practical.&nbsp; CHECK-vs-CHECK might be useful, but isn't<br/></li>
<li></span><span class="Comment"> * currently needed anywhere.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The top-level List structure of each list corresponds to an AND list.<br/></li>
<li></span><span class="Comment"> * We assume that <a href="clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a>() has been applied and so there<br/></li>
<li></span><span class="Comment"> * are no un-flattened ANDs or ORs (e.g., no AND immediately within an AND,<br/></li>
<li></span><span class="Comment"> * including AND just below the top-level List structure).<br/></li>
<li></span><span class="Comment"> * If this is not true we might fail to prove an implication that is<br/></li>
<li></span><span class="Comment"> * valid, but no worse consequences will ensue.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We assume the predicate has already been checked to contain only<br/></li>
<li></span><span class="Comment"> * immutable <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> and operators.&nbsp; We dare not make deductions based on<br/></li>
<li></span><span class="Comment"> * non-immutable <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, because they might change answers between the<br/></li>
<li></span><span class="Comment"> * time we make the plan and the time we execute the plan.<br/></li>
<li></span><span class="Comment"> * Immutability of <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in the clause_list is checked here, if necessary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L222">&#x200c;</a></span><span class="linkable">predicate_refuted_by</span>(List *predicate_list, List *clause_list,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> weak)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *c;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (predicate_list == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no predicate: no refutation is possible */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (clause_list == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no restriction: refutation must fail */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If either input is a single-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> list, replace it with its lone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * member; this avoids one useless level of AND-recursion.&nbsp; We only need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to worry about this at top level, since <a href="clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a> should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have gotten rid of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> trivial ANDs or ORs below that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(predicate_list) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p = (Node *) linitial(predicate_list);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; p = (Node *) predicate_list;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(clause_list) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; c = (Node *) linitial(clause_list);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; c = (Node *) clause_list;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And away we go ... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L531" title="optimizer/util/predtest.c:531">predicate_refuted_by_recurse</a>(c, p, weak);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*----------<br/></li>
<li></span><span class="Comment"> * <a href="#L290" title="optimizer/util/predtest.c:290">predicate_implied_by_recurse</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Does the predicate implication test for non-NULL restriction and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; predicate clauses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The logic followed here is (&quot;=&gt;&quot; means &quot;implies&quot;):<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; atom A =&gt; atom B iff:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1098" title="optimizer/util/predtest.c:1098">predicate_implied_by_simple_clause</a> says so<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; atom A =&gt; AND-expr B iff:&nbsp; &nbsp; &nbsp; &nbsp; A =&gt; each of B's components<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; atom A =&gt; OR-expr B iff:&nbsp; &nbsp; &nbsp; &nbsp; A =&gt; <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of B's components<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; AND-expr A =&gt; atom B iff:&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of A's components =&gt; B<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; AND-expr A =&gt; AND-expr B iff:&nbsp; &nbsp; A =&gt; each of B's components<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; AND-expr A =&gt; OR-expr B iff:&nbsp; &nbsp; A =&gt; <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of B's components,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *or* <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of A's components =&gt; B<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; OR-expr A =&gt; atom B iff:&nbsp; &nbsp; &nbsp; &nbsp; each of A's components =&gt; B<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; OR-expr A =&gt; AND-expr B iff:&nbsp; &nbsp; A =&gt; each of B's components<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; OR-expr A =&gt; OR-expr B iff:&nbsp; &nbsp; &nbsp; &nbsp; each of A's components =&gt; <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of B's<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * An &quot;atom&quot; is anything other than an AND or OR node.&nbsp; Notice that we don't<br/></li>
<li></span><span class="Comment"> * have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> special logic to handle NOT nodes; these should have been pushed<br/></li>
<li></span><span class="Comment"> * down or eliminated where feasible during <a href="clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All of these rules apply equally to strong or weak implication.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We can't recursively expand either side first, but have to interleave<br/></li>
<li></span><span class="Comment"> * the expansions per the above rules, to be sure we handle all of these<br/></li>
<li></span><span class="Comment"> * examples:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (x OR y) =&gt; (x OR y OR z)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (x AND y AND z) =&gt; (x AND y)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (x AND y) =&gt; ((x AND y) OR z)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ((x OR y) AND z) =&gt; (x OR y)<br/></li>
<li></span><span class="Comment"> * This is still not an exhaustive test, but it handles most normal cases<br/></li>
<li></span><span class="Comment"> * under the assumption that both inputs have been AND/OR flattened.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We have to be prepared to handle RestrictInfo nodes in the restrictinfo<br/></li>
<li></span><span class="Comment"> * tree, though not in the predicate tree.<br/></li>
<li></span><span class="Comment"> *----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L290">&#x200c;</a></span><span class="linkable">predicate_implied_by_recurse</span>(Node *clause, Node *predicate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> weak)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L59" title="optimizer/util/predtest.c:59">PredIterInfoData</a> clause_info;<br/></li>
<li>&nbsp; &nbsp; <a href="#L59" title="optimizer/util/predtest.c:59">PredIterInfoData</a> pred_info;<br/></li>
<li>&nbsp; &nbsp; <a href="#L55" title="optimizer/util/predtest.c:55">PredClass</a>&nbsp; &nbsp; pclass;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> through RestrictInfo */<br/></li>
<li></span>&nbsp; &nbsp; Assert(clause != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(clause, RestrictInfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; clause = (Node *) ((RestrictInfo *) clause)-&gt;clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pclass = <a href="#L826" title="optimizer/util/predtest.c:826">predicate_classify</a>(predicate, &amp;pred_info);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L826" title="optimizer/util/predtest.c:826">predicate_classify</a>(clause, &amp;clause_info))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CLASS_AND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (pclass)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CLASS_AND:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * AND-clause =&gt; AND-clause if A implies each of B's items<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L72" title="optimizer/util/predtest.c:72">iterate_begin</a>(pitem, predicate, pred_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L290" title="optimizer/util/predtest.c:290">predicate_implied_by_recurse</a>(clause, pitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weak))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="optimizer/util/predtest.c:78">iterate_end</a>(pred_info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CLASS_OR:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * AND-clause =&gt; OR-clause if A implies <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of B's items<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Needed to handle (x AND y) =&gt; ((x AND y) OR z)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L72" title="optimizer/util/predtest.c:72">iterate_begin</a>(pitem, predicate, pred_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L290" title="optimizer/util/predtest.c:290">predicate_implied_by_recurse</a>(clause, pitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; weak))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="optimizer/util/predtest.c:78">iterate_end</a>(pred_info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also check if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of A's items implies B<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Needed to handle ((x OR y) AND z) =&gt; (x OR y)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L72" title="optimizer/util/predtest.c:72">iterate_begin</a>(citem, clause, clause_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L290" title="optimizer/util/predtest.c:290">predicate_implied_by_recurse</a>(citem, predicate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; weak))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="optimizer/util/predtest.c:78">iterate_end</a>(clause_info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CLASS_ATOM:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * AND-clause =&gt; atom if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of A's items implies B<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L72" title="optimizer/util/predtest.c:72">iterate_begin</a>(citem, clause, clause_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L290" title="optimizer/util/predtest.c:290">predicate_implied_by_recurse</a>(citem, predicate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; weak))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="optimizer/util/predtest.c:78">iterate_end</a>(clause_info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CLASS_OR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (pclass)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CLASS_OR:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OR-clause =&gt; OR-clause if each of A's items implies <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of B's items.&nbsp; Messy but can't do it <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more simply.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L72" title="optimizer/util/predtest.c:72">iterate_begin</a>(citem, clause, clause_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; presult = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L72" title="optimizer/util/predtest.c:72">iterate_begin</a>(pitem, predicate, pred_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L290" title="optimizer/util/predtest.c:290">predicate_implied_by_recurse</a>(citem, pitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; weak))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; presult = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="optimizer/util/predtest.c:78">iterate_end</a>(pred_info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!presult)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>; <span class="Comment">/* doesn't imply <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of B's */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="optimizer/util/predtest.c:78">iterate_end</a>(clause_info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CLASS_AND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CLASS_ATOM:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OR-clause =&gt; AND-clause if each of A's items implies B<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OR-clause =&gt; atom if each of A's items implies B<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L72" title="optimizer/util/predtest.c:72">iterate_begin</a>(citem, clause, clause_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L290" title="optimizer/util/predtest.c:290">predicate_implied_by_recurse</a>(citem, predicate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weak))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="optimizer/util/predtest.c:78">iterate_end</a>(clause_info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CLASS_ATOM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (pclass)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CLASS_AND:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * atom =&gt; AND-clause if A implies each of B's items<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L72" title="optimizer/util/predtest.c:72">iterate_begin</a>(pitem, predicate, pred_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L290" title="optimizer/util/predtest.c:290">predicate_implied_by_recurse</a>(clause, pitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weak))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="optimizer/util/predtest.c:78">iterate_end</a>(pred_info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CLASS_OR:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * atom =&gt; OR-clause if A implies <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of B's items<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L72" title="optimizer/util/predtest.c:72">iterate_begin</a>(pitem, predicate, pred_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L290" title="optimizer/util/predtest.c:290">predicate_implied_by_recurse</a>(clause, pitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; weak))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="optimizer/util/predtest.c:78">iterate_end</a>(pred_info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CLASS_ATOM:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * atom =&gt; atom is the base case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1098" title="optimizer/util/predtest.c:1098">predicate_implied_by_simple_clause</a>((Expr *) predicate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; weak);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* can't get here */<br/></li>
<li></span>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L826" title="optimizer/util/predtest.c:826">predicate_classify</a> returned a bogus value&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*----------<br/></li>
<li></span><span class="Comment"> * <a href="#L531" title="optimizer/util/predtest.c:531">predicate_refuted_by_recurse</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Does the predicate refutation test for non-NULL restriction and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; predicate clauses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The logic followed here is (&quot;R=&gt;&quot; means &quot;refutes&quot;):<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; atom A R=&gt; atom B iff:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1225" title="optimizer/util/predtest.c:1225">predicate_refuted_by_simple_clause</a> says so<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; atom A R=&gt; AND-expr B iff:&nbsp; &nbsp; &nbsp; &nbsp; A R=&gt; <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of B's components<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; atom A R=&gt; OR-expr B iff:&nbsp; &nbsp; &nbsp; &nbsp; A R=&gt; each of B's components<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; AND-expr A R=&gt; atom B iff:&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of A's components R=&gt; B<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; AND-expr A R=&gt; AND-expr B iff:&nbsp; &nbsp; A R=&gt; <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of B's components,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *or* <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of A's components R=&gt; B<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; AND-expr A R=&gt; OR-expr B iff:&nbsp; &nbsp; A R=&gt; each of B's components<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; OR-expr A R=&gt; atom B iff:&nbsp; &nbsp; &nbsp; &nbsp; each of A's components R=&gt; B<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; OR-expr A R=&gt; AND-expr B iff:&nbsp; &nbsp; each of A's components R=&gt; <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of B's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; OR-expr A R=&gt; OR-expr B iff:&nbsp; &nbsp; A R=&gt; each of B's components<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All of the above rules apply equally to strong or weak refutation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In addition, if the predicate is a NOT-clause then we can use<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; A R=&gt; NOT B if:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A =&gt; B<br/></li>
<li></span><span class="Comment"> * This works for several different SQL constructs that assert the non-truth<br/></li>
<li></span><span class="Comment"> * of their argument, ie NOT, IS FALSE, IS NOT TRUE, IS UNKNOWN, although some<br/></li>
<li></span><span class="Comment"> * of them require that we prove strong implication.&nbsp; Likewise, we can use<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; NOT A R=&gt; B if:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; B =&gt; A<br/></li>
<li></span><span class="Comment"> * but here we must be careful about strong vs. weak refutation and make<br/></li>
<li></span><span class="Comment"> * the appropriate type of implication proof (weak or strong respectively).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Other comments are as for <a href="#L290" title="optimizer/util/predtest.c:290">predicate_implied_by_recurse</a>().<br/></li>
<li></span><span class="Comment"> *----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L531">&#x200c;</a></span><span class="linkable">predicate_refuted_by_recurse</span>(Node *clause, Node *predicate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> weak)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L59" title="optimizer/util/predtest.c:59">PredIterInfoData</a> clause_info;<br/></li>
<li>&nbsp; &nbsp; <a href="#L59" title="optimizer/util/predtest.c:59">PredIterInfoData</a> pred_info;<br/></li>
<li>&nbsp; &nbsp; <a href="#L55" title="optimizer/util/predtest.c:55">PredClass</a>&nbsp; &nbsp; pclass;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *not_arg;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> through RestrictInfo */<br/></li>
<li></span>&nbsp; &nbsp; Assert(clause != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(clause, RestrictInfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; clause = (Node *) ((RestrictInfo *) clause)-&gt;clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pclass = <a href="#L826" title="optimizer/util/predtest.c:826">predicate_classify</a>(predicate, &amp;pred_info);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L826" title="optimizer/util/predtest.c:826">predicate_classify</a>(clause, &amp;clause_info))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CLASS_AND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (pclass)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CLASS_AND:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * AND-clause R=&gt; AND-clause if A refutes <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of B's items<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Needed to handle (x AND y) R=&gt; ((!x OR !y) AND z)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L72" title="optimizer/util/predtest.c:72">iterate_begin</a>(pitem, predicate, pred_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L531" title="optimizer/util/predtest.c:531">predicate_refuted_by_recurse</a>(clause, pitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; weak))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="optimizer/util/predtest.c:78">iterate_end</a>(pred_info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also check if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of A's items refutes B<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Needed to handle ((x OR y) AND z) R=&gt; (!x AND !y)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L72" title="optimizer/util/predtest.c:72">iterate_begin</a>(citem, clause, clause_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L531" title="optimizer/util/predtest.c:531">predicate_refuted_by_recurse</a>(citem, predicate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; weak))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="optimizer/util/predtest.c:78">iterate_end</a>(clause_info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CLASS_OR:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * AND-clause R=&gt; OR-clause if A refutes each of B's items<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L72" title="optimizer/util/predtest.c:72">iterate_begin</a>(pitem, predicate, pred_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L531" title="optimizer/util/predtest.c:531">predicate_refuted_by_recurse</a>(clause, pitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weak))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="optimizer/util/predtest.c:78">iterate_end</a>(pred_info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CLASS_ATOM:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If B is a NOT-type clause, A R=&gt; B if A =&gt; B's arg<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since, for either type of refutation, we are starting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with the premise that A is true, we can use a strong<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * implication test in all cases.&nbsp; That proves B's arg is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * true, which is more than we need for weak refutation if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * B is a simple NOT, but it allows not worrying about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exactly which kind of negation clause we have.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; not_arg = <a href="#L1386" title="optimizer/util/predtest.c:1386">extract_not_arg</a>(predicate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (not_arg &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L290" title="optimizer/util/predtest.c:290">predicate_implied_by_recurse</a>(clause, not_arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * AND-clause R=&gt; atom if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of A's items refutes B<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L72" title="optimizer/util/predtest.c:72">iterate_begin</a>(citem, clause, clause_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L531" title="optimizer/util/predtest.c:531">predicate_refuted_by_recurse</a>(citem, predicate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; weak))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="optimizer/util/predtest.c:78">iterate_end</a>(clause_info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CLASS_OR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (pclass)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CLASS_OR:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OR-clause R=&gt; OR-clause if A refutes each of B's items<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L72" title="optimizer/util/predtest.c:72">iterate_begin</a>(pitem, predicate, pred_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L531" title="optimizer/util/predtest.c:531">predicate_refuted_by_recurse</a>(clause, pitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weak))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="optimizer/util/predtest.c:78">iterate_end</a>(pred_info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CLASS_AND:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OR-clause R=&gt; AND-clause if each of A's items refutes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of B's items.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L72" title="optimizer/util/predtest.c:72">iterate_begin</a>(citem, clause, clause_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; presult = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L72" title="optimizer/util/predtest.c:72">iterate_begin</a>(pitem, predicate, pred_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L531" title="optimizer/util/predtest.c:531">predicate_refuted_by_recurse</a>(citem, pitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; weak))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; presult = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="optimizer/util/predtest.c:78">iterate_end</a>(pred_info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!presult)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>; <span class="Comment">/* citem refutes nothing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="optimizer/util/predtest.c:78">iterate_end</a>(clause_info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CLASS_ATOM:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If B is a NOT-type clause, A R=&gt; B if A =&gt; B's arg<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Same logic as for the AND-clause case above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; not_arg = <a href="#L1386" title="optimizer/util/predtest.c:1386">extract_not_arg</a>(predicate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (not_arg &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L290" title="optimizer/util/predtest.c:290">predicate_implied_by_recurse</a>(clause, not_arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OR-clause R=&gt; atom if each of A's items refutes B<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L72" title="optimizer/util/predtest.c:72">iterate_begin</a>(citem, clause, clause_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L531" title="optimizer/util/predtest.c:531">predicate_refuted_by_recurse</a>(citem, predicate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weak))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="optimizer/util/predtest.c:78">iterate_end</a>(clause_info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CLASS_ATOM:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If A is a strong NOT-clause, A R=&gt; B if B =&gt; A's arg<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since A is strong, we may assume A's arg is false (not just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not-true).&nbsp; If B weakly implies A's arg, then B can be neither<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * true nor null, so that strong refutation is proven.&nbsp; If B<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * strongly implies A's arg, then B cannot be true, so that weak<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * refutation is proven.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; not_arg = <a href="#L1414" title="optimizer/util/predtest.c:1414">extract_strong_not_arg</a>(clause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (not_arg &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L290" title="optimizer/util/predtest.c:290">predicate_implied_by_recurse</a>(predicate, not_arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !weak))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (pclass)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CLASS_AND:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * atom R=&gt; AND-clause if A refutes <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of B's items<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L72" title="optimizer/util/predtest.c:72">iterate_begin</a>(pitem, predicate, pred_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L531" title="optimizer/util/predtest.c:531">predicate_refuted_by_recurse</a>(clause, pitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; weak))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="optimizer/util/predtest.c:78">iterate_end</a>(pred_info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CLASS_OR:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * atom R=&gt; OR-clause if A refutes each of B's items<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L72" title="optimizer/util/predtest.c:72">iterate_begin</a>(pitem, predicate, pred_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L531" title="optimizer/util/predtest.c:531">predicate_refuted_by_recurse</a>(clause, pitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weak))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="optimizer/util/predtest.c:78">iterate_end</a>(pred_info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CLASS_ATOM:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If B is a NOT-type clause, A R=&gt; B if A =&gt; B's arg<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Same logic as for the AND-clause case above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; not_arg = <a href="#L1386" title="optimizer/util/predtest.c:1386">extract_not_arg</a>(predicate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (not_arg &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L290" title="optimizer/util/predtest.c:290">predicate_implied_by_recurse</a>(clause, not_arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * atom R=&gt; atom is the base case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1225" title="optimizer/util/predtest.c:1225">predicate_refuted_by_simple_clause</a>((Expr *) predicate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; weak);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* can't get here */<br/></li>
<li></span>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L826" title="optimizer/util/predtest.c:826">predicate_classify</a> returned a bogus value&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L826" title="optimizer/util/predtest.c:826">predicate_classify</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Classify an expression node as AND-type, OR-type, or neither (an atom).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the expression is classified as AND- or OR-type, then *info is filled<br/></li>
<li></span><span class="Comment"> * in with the <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> needed to iterate over its components.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function also implements enforcement of <a href="#L40" title="optimizer/util/predtest.c:40">MAX_SAOP_ARRAY_SIZE</a>: if a<br/></li>
<li></span><span class="Comment"> * ScalarArrayOpExpr's array has too many elements, we just classify it as an<br/></li>
<li></span><span class="Comment"> * atom.&nbsp; (This will result in its being passed as-is to the simple_clause<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, many of which will fail to prove anything about it.) Note that we<br/></li>
<li></span><span class="Comment"> * cannot just stop after considering <a href="#L40" title="optimizer/util/predtest.c:40">MAX_SAOP_ARRAY_SIZE</a> elements; in general<br/></li>
<li></span><span class="Comment"> * that would result in wrong proofs, rather than failing to prove anything.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L55" title="optimizer/util/predtest.c:55">PredClass</a><br/></li>
<li><a id="L826">&#x200c;</a><span class="linkable">predicate_classify</span>(Node *clause, <a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Caller should not pass us NULL, nor a RestrictInfo clause */<br/></li>
<li></span>&nbsp; &nbsp; Assert(clause != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(!IsA(clause, RestrictInfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we see a List, assume it's an implicit-AND list; this is the correct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * semantics for lists of RestrictInfo nodes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(clause, List))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; info-&gt;startup_fn = <a href="#L908" title="optimizer/util/predtest.c:908">list_startup_fn</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; info-&gt;next_fn = <a href="#L915" title="optimizer/util/predtest.c:915">list_next_fn</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; info-&gt;cleanup_fn = <a href="#L928" title="optimizer/util/predtest.c:928">list_cleanup_fn</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> CLASS_AND;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle normal AND and OR boolean clauses */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (is_andclause(clause))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; info-&gt;startup_fn = <a href="#L938" title="optimizer/util/predtest.c:938">boolexpr_startup_fn</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; info-&gt;next_fn = <a href="#L915" title="optimizer/util/predtest.c:915">list_next_fn</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; info-&gt;cleanup_fn = <a href="#L928" title="optimizer/util/predtest.c:928">list_cleanup_fn</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> CLASS_AND;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_orclause(clause))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; info-&gt;startup_fn = <a href="#L938" title="optimizer/util/predtest.c:938">boolexpr_startup_fn</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; info-&gt;next_fn = <a href="#L915" title="optimizer/util/predtest.c:915">list_next_fn</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; info-&gt;cleanup_fn = <a href="#L928" title="optimizer/util/predtest.c:928">list_cleanup_fn</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> CLASS_OR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle ScalarArrayOpExpr */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(clause, ScalarArrayOpExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) clause;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *arraynode = (Node *) lsecond(saop-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can break this down into an AND or OR structure, but only if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * know how to iterate through expressions for the array's elements.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can do that if the array operand is a non-null constant or a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * simple ArrayExpr.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arraynode &amp;&amp; IsA(arraynode, Const) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !((Const *) arraynode)-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ArrayType&nbsp; *arrayval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelems;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arrayval = DatumGetArrayTypeP(((Const *) arraynode)-&gt;constvalue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelems = <a href="../../utils/adt/arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ARR_NDIM(arrayval), ARR_DIMS(arrayval));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nelems &lt;= <a href="#L40" title="optimizer/util/predtest.c:40">MAX_SAOP_ARRAY_SIZE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info-&gt;startup_fn = <a href="#L959" title="optimizer/util/predtest.c:959">arrayconst_startup_fn</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info-&gt;next_fn = <a href="#L1008" title="optimizer/util/predtest.c:1008">arrayconst_next_fn</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info-&gt;cleanup_fn = <a href="#L1021" title="optimizer/util/predtest.c:1021">arrayconst_cleanup_fn</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> saop-&gt;useOr ? CLASS_OR : CLASS_AND;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (arraynode &amp;&amp; IsA(arraynode, ArrayExpr) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !((ArrayExpr *) arraynode)-&gt;multidims &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_length(((ArrayExpr *) arraynode)-&gt;elements) &lt;= <a href="#L40" title="optimizer/util/predtest.c:40">MAX_SAOP_ARRAY_SIZE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info-&gt;startup_fn = <a href="#L1042" title="optimizer/util/predtest.c:1042">arrayexpr_startup_fn</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info-&gt;next_fn = <a href="#L1069" title="optimizer/util/predtest.c:1069">arrayexpr_next_fn</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info-&gt;cleanup_fn = <a href="#L1081" title="optimizer/util/predtest.c:1081">arrayexpr_cleanup_fn</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> saop-&gt;useOr ? CLASS_OR : CLASS_AND;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* None of the above, so it's an atom */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> CLASS_ATOM;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> routines for iterating over regular Lists.&nbsp; The iteration<br/></li>
<li></span><span class="Comment"> * state variable is the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> ListCell to visit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L908">&#x200c;</a></span><span class="linkable">list_startup_fn</span>(Node *clause, <a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; info-&gt;state_list = (List *) clause;<br/></li>
<li>&nbsp; &nbsp; info-&gt;state = (<span class="Type">void</span> *) list_head(info-&gt;state_list);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Node *<br/></li>
<li><a id="L915">&#x200c;</a><span class="linkable">list_next_fn</span>(<a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l = (ListCell *) info-&gt;state;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (l == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; n = lfirst(l);<br/></li>
<li>&nbsp; &nbsp; info-&gt;state = (<span class="Type">void</span> *) lnext(info-&gt;state_list, l);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> n;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L928">&#x200c;</a></span><span class="linkable">list_cleanup_fn</span>(<a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to clean up */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * BoolExpr needs its own startup function, but can use <a href="#L915" title="optimizer/util/predtest.c:915">list_next_fn</a> and<br/></li>
<li></span><span class="Comment"> * <a href="#L928" title="optimizer/util/predtest.c:928">list_cleanup_fn</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L938">&#x200c;</a></span><span class="linkable">boolexpr_startup_fn</span>(Node *clause, <a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; info-&gt;state_list = ((BoolExpr *) clause)-&gt;args;<br/></li>
<li>&nbsp; &nbsp; info-&gt;state = (<span class="Type">void</span> *) list_head(info-&gt;state_list);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> routines for iterating over a ScalarArrayOpExpr with a<br/></li>
<li></span><span class="Comment"> * constant array operand.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; OpExpr&nbsp; &nbsp; &nbsp; &nbsp; opexpr;<br/></li>
<li>&nbsp; &nbsp; Const&nbsp; &nbsp; &nbsp; &nbsp; constexpr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_elem;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_elems;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *elem_values;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *elem_nulls;<br/></li>
<li><a id="L956">&#x200c;</a>} <span class="linkable">ArrayConstIterState</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L959">&#x200c;</a></span><span class="linkable">arrayconst_startup_fn</span>(Node *clause, <a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) clause;<br/></li>
<li>&nbsp; &nbsp; <a href="#L956" title="optimizer/util/predtest.c:956">ArrayConstIterState</a> *state;<br/></li>
<li>&nbsp; &nbsp; Const&nbsp; &nbsp; &nbsp;&nbsp; *arrayconst;<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *arrayval;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; elmlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; elmbyval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; elmalign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create working state struct */<br/></li>
<li></span>&nbsp; &nbsp; state = (<a href="#L956" title="optimizer/util/predtest.c:956">ArrayConstIterState</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L956" title="optimizer/util/predtest.c:956">ArrayConstIterState</a>));<br/></li>
<li>&nbsp; &nbsp; info-&gt;state = (<span class="Type">void</span> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Deconstruct the array literal */<br/></li>
<li></span>&nbsp; &nbsp; arrayconst = (Const *) lsecond(saop-&gt;args);<br/></li>
<li>&nbsp; &nbsp; arrayval = DatumGetArrayTypeP(arrayconst-&gt;constvalue);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/cache/lsyscache.c.html#L2271" title="utils/cache/lsyscache.c:2271">get_typlenbyvalalign</a>(ARR_ELEMTYPE(arrayval),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;elmlen, &amp;elmbyval, &amp;elmalign);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/adt/arrayfuncs.c.html#L3612" title="utils/adt/arrayfuncs.c:3612">deconstruct_array</a>(arrayval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ARR_ELEMTYPE(arrayval),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen, elmbyval, elmalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;state-&gt;elem_values, &amp;state-&gt;elem_nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;state-&gt;num_elems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up a dummy OpExpr to return as the per-item node */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;opexpr.xpr.type = T_OpExpr;<br/></li>
<li>&nbsp; &nbsp; state-&gt;opexpr.opno = saop-&gt;opno;<br/></li>
<li>&nbsp; &nbsp; state-&gt;opexpr.opfuncid = saop-&gt;opfuncid;<br/></li>
<li>&nbsp; &nbsp; state-&gt;opexpr.opresulttype = BOOLOID;<br/></li>
<li>&nbsp; &nbsp; state-&gt;opexpr.opretset = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;opexpr.opcollid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; state-&gt;opexpr.inputcollid = saop-&gt;inputcollid;<br/></li>
<li>&nbsp; &nbsp; state-&gt;opexpr.args = <a href="../../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(saop-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up a dummy Const node to hold the per-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;constexpr.xpr.type = T_Const;<br/></li>
<li>&nbsp; &nbsp; state-&gt;constexpr.consttype = ARR_ELEMTYPE(arrayval);<br/></li>
<li>&nbsp; &nbsp; state-&gt;constexpr.consttypmod = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;constexpr.constcollid = arrayconst-&gt;constcollid;<br/></li>
<li>&nbsp; &nbsp; state-&gt;constexpr.constlen = elmlen;<br/></li>
<li>&nbsp; &nbsp; state-&gt;constexpr.constbyval = elmbyval;<br/></li>
<li>&nbsp; &nbsp; lsecond(state-&gt;opexpr.args) = &amp;state-&gt;constexpr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize iteration state */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;next_elem = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Node *<br/></li>
<li><a id="L1008">&#x200c;</a><span class="linkable">arrayconst_next_fn</span>(<a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L956" title="optimizer/util/predtest.c:956">ArrayConstIterState</a> *state = (<a href="#L956" title="optimizer/util/predtest.c:956">ArrayConstIterState</a> *) info-&gt;state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;next_elem &gt;= state-&gt;num_elems)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;constexpr.constvalue = state-&gt;elem_values[state-&gt;next_elem];<br/></li>
<li>&nbsp; &nbsp; state-&gt;constexpr.constisnull = state-&gt;elem_nulls[state-&gt;next_elem];<br/></li>
<li>&nbsp; &nbsp; state-&gt;next_elem++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Node *) &amp;(state-&gt;opexpr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1021">&#x200c;</a></span><span class="linkable">arrayconst_cleanup_fn</span>(<a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L956" title="optimizer/util/predtest.c:956">ArrayConstIterState</a> *state = (<a href="#L956" title="optimizer/util/predtest.c:956">ArrayConstIterState</a> *) info-&gt;state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state-&gt;elem_values);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state-&gt;elem_nulls);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(state-&gt;opexpr.args);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> routines for iterating over a ScalarArrayOpExpr with a<br/></li>
<li></span><span class="Comment"> * one-dimensional ArrayExpr array operand.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; OpExpr&nbsp; &nbsp; &nbsp; &nbsp; opexpr;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><a id="L1039">&#x200c;</a>} <span class="linkable">ArrayExprIterState</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1042">&#x200c;</a></span><span class="linkable">arrayexpr_startup_fn</span>(Node *clause, <a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) clause;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1039" title="optimizer/util/predtest.c:1039">ArrayExprIterState</a> *state;<br/></li>
<li>&nbsp; &nbsp; ArrayExpr&nbsp; *arrayexpr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create working state struct */<br/></li>
<li></span>&nbsp; &nbsp; state = (<a href="#L1039" title="optimizer/util/predtest.c:1039">ArrayExprIterState</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L1039" title="optimizer/util/predtest.c:1039">ArrayExprIterState</a>));<br/></li>
<li>&nbsp; &nbsp; info-&gt;state = (<span class="Type">void</span> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up a dummy OpExpr to return as the per-item node */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;opexpr.xpr.type = T_OpExpr;<br/></li>
<li>&nbsp; &nbsp; state-&gt;opexpr.opno = saop-&gt;opno;<br/></li>
<li>&nbsp; &nbsp; state-&gt;opexpr.opfuncid = saop-&gt;opfuncid;<br/></li>
<li>&nbsp; &nbsp; state-&gt;opexpr.opresulttype = BOOLOID;<br/></li>
<li>&nbsp; &nbsp; state-&gt;opexpr.opretset = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;opexpr.opcollid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; state-&gt;opexpr.inputcollid = saop-&gt;inputcollid;<br/></li>
<li>&nbsp; &nbsp; state-&gt;opexpr.args = <a href="../../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(saop-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize iteration variable to first member of ArrayExpr */<br/></li>
<li></span>&nbsp; &nbsp; arrayexpr = (ArrayExpr *) lsecond(saop-&gt;args);<br/></li>
<li>&nbsp; &nbsp; info-&gt;state_list = arrayexpr-&gt;elements;<br/></li>
<li>&nbsp; &nbsp; state-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = list_head(arrayexpr-&gt;elements);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Node *<br/></li>
<li><a id="L1069">&#x200c;</a><span class="linkable">arrayexpr_next_fn</span>(<a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1039" title="optimizer/util/predtest.c:1039">ArrayExprIterState</a> *state = (<a href="#L1039" title="optimizer/util/predtest.c:1039">ArrayExprIterState</a> *) info-&gt;state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; lsecond(state-&gt;opexpr.args) = lfirst(state-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>);<br/></li>
<li>&nbsp; &nbsp; state-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = lnext(info-&gt;state_list, state-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Node *) &amp;(state-&gt;opexpr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1081">&#x200c;</a></span><span class="linkable">arrayexpr_cleanup_fn</span>(<a href="#L57" title="optimizer/util/predtest.c:57">PredIterInfo</a> info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1039" title="optimizer/util/predtest.c:1039">ArrayExprIterState</a> *state = (<a href="#L1039" title="optimizer/util/predtest.c:1039">ArrayExprIterState</a> *) info-&gt;state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(state-&gt;opexpr.args);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1098" title="optimizer/util/predtest.c:1098">predicate_implied_by_simple_clause</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Does the predicate implication test for a &quot;simple clause&quot; predicate<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; and a &quot;simple clause&quot; restriction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We return true if able to prove the implication, false if not.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1098">&#x200c;</a></span><span class="linkable">predicate_implied_by_simple_clause</span>(Expr *predicate, Node *clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> weak)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allow interrupting long proof attempts */<br/></li>
<li></span>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A simple and general rule is that a clause implies itself, hence we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check if they are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(); this works for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> kind of expression, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for either implication definition.&nbsp; (Actually, there is an implied<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assumption that the <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in the expression are immutable --- but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this was checked for the predicate by the caller.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>((Node *) predicate, clause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Next we have some clause-type-specific strategies */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (nodeTag(clause))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_OpExpr:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OpExpr&nbsp; &nbsp; &nbsp;&nbsp; *op = (OpExpr *) clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For boolean x, &quot;x = TRUE&quot; is equivalent to &quot;x&quot;, likewise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;x = FALSE&quot; is equivalent to &quot;NOT x&quot;.&nbsp; These can be worth<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checking because, while we preferentially simplify boolean<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * comparisons down to &quot;x&quot; and &quot;NOT x&quot;, the other form has to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be dealt with anyway in the context of index conditions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We could likewise check whether the predicate is boolean<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * equality to a constant; but there are no known use-cases<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for that at the moment, assuming that the predicate has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * been through constant-folding.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op-&gt;opno == BooleanEqualOperator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *rightop;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(op-&gt;args) == <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightop = lsecond(op-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We might never see null Consts here, but better check */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rightop &amp;&amp; IsA(rightop, Const) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !((Const *) rightop)-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *leftop = linitial(op-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(((Const *) rightop)-&gt;constvalue))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* X = true implies X */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(predicate, leftop))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* X = false implies NOT X */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_notclause(predicate) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(get_notclausearg(predicate), leftop))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... and some predicate-type-specific ones */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (nodeTag(predicate))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_NullTest:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NullTest&nbsp;&nbsp; *predntest = (NullTest *) predicate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (predntest-&gt;nulltesttype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_NOT_NULL:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the predicate is of the form &quot;foo IS NOT NULL&quot;,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and we are considering strong implication, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * conclude that the predicate is implied if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clause is strict for &quot;foo&quot;, i.e., it must yield<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * false or NULL when &quot;foo&quot; is NULL.&nbsp; In that case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * truth of the clause ensures that &quot;foo&quot; isn't NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (Again, this is a safe conclusion because &quot;foo&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must be immutable.)&nbsp; This doesn't work for weak<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * implication, though.&nbsp; Also, &quot;row IS NOT NULL&quot; does<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not act in the simple way we have in mind.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!weak &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !predntest-&gt;argisrow &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1460" title="optimizer/util/predtest.c:1460">clause_is_strict_for</a>(clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) predntest-&gt;arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_NULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Finally, if both clauses are binary operator expressions, we may be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * able to prove something using the system's knowledge about operators;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those proof rules are encapsulated in <a href="#L1779" title="optimizer/util/predtest.c:1779">operator_predicate_proof</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1779" title="optimizer/util/predtest.c:1779">operator_predicate_proof</a>(predicate, clause, <span class="Constant">false</span>, weak);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1225" title="optimizer/util/predtest.c:1225">predicate_refuted_by_simple_clause</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Does the predicate refutation test for a &quot;simple clause&quot; predicate<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; and a &quot;simple clause&quot; restriction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We return true if able to prove the refutation, false if not.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> motivation for covering IS [NOT] NULL cases is to support using<br/></li>
<li></span><span class="Comment"> * IS NULL/IS NOT NULL as partition-defining constraints.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1225">&#x200c;</a></span><span class="linkable">predicate_refuted_by_simple_clause</span>(Expr *predicate, Node *clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> weak)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allow interrupting long proof attempts */<br/></li>
<li></span>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A simple clause can't refute itself, so unlike the implication case,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checking for <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>() clauses isn't helpful.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * But <a href="plancat.c.html#L1557" title="optimizer/util/plancat.c:1557">relation_excluded_by_constraints</a>() checks for self-contradictions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in a list of clauses, so that we may get here with predicate and clause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * being actually pointer-<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, and that is worth eliminating quickly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((Node *) predicate == clause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Next we have some clause-type-specific strategies */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (nodeTag(clause))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_NullTest:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NullTest&nbsp;&nbsp; *clausentest = (NullTest *) clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* row IS NULL does not act in the simple way we have in mind */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (clausentest-&gt;argisrow)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (clausentest-&gt;nulltesttype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_NULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (nodeTag(predicate))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_NullTest:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NullTest&nbsp;&nbsp; *predntest = (NullTest *) predicate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * row IS NULL does not act in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * simple way we have in mind<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (predntest-&gt;argisrow)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * foo IS NULL refutes foo IS NOT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NULL, at least in the non-row case,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for both strong and weak refutation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (predntest-&gt;nulltesttype == IS_NOT_NULL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(predntest-&gt;arg, clausentest-&gt;arg))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * foo IS NULL weakly refutes <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> predicate that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is strict for foo, since then the predicate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must yield false or NULL (and since foo appears<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the predicate, it's known immutable).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (weak &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1460" title="optimizer/util/predtest.c:1460">clause_is_strict_for</a>((Node *) predicate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) clausentest-&gt;arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* we can't succeed below... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_NOT_NULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... and some predicate-type-specific ones */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (nodeTag(predicate))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_NullTest:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NullTest&nbsp;&nbsp; *predntest = (NullTest *) predicate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* row IS NULL does not act in the simple way we have in mind */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (predntest-&gt;argisrow)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (predntest-&gt;nulltesttype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_NULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (nodeTag(clause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_NullTest:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NullTest&nbsp;&nbsp; *clausentest = (NullTest *) clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * row IS NULL does not act in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * simple way we have in mind<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (clausentest-&gt;argisrow)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * foo IS NOT NULL refutes foo IS NULL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for both strong and weak refutation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (clausentest-&gt;nulltesttype == IS_NOT_NULL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(clausentest-&gt;arg, predntest-&gt;arg))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When the predicate is of the form &quot;foo IS<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NULL&quot;, we can conclude that the predicate is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * refuted if the clause is strict for &quot;foo&quot; (see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * notes for implication case).&nbsp; That works for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * either strong or weak refutation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1460" title="optimizer/util/predtest.c:1460">clause_is_strict_for</a>(clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) predntest-&gt;arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_NOT_NULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* we can't succeed below... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Finally, if both clauses are binary operator expressions, we may be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * able to prove something using the system's knowledge about operators.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1779" title="optimizer/util/predtest.c:1779">operator_predicate_proof</a>(predicate, clause, <span class="Constant">true</span>, weak);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * If clause asserts the non-truth of a subclause, return that subclause;<br/></li>
<li></span><span class="Comment"> * otherwise return NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Node *<br/></li>
<li><a id="L1386">&#x200c;</a><span class="linkable">extract_not_arg</span>(Node *clause)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (clause == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(clause, BoolExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BoolExpr&nbsp;&nbsp; *bexpr = (BoolExpr *) clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bexpr-&gt;boolop == NOT_EXPR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) linitial(bexpr-&gt;args);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(clause, BooleanTest))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BooleanTest *btest = (BooleanTest *) clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (btest-&gt;booltesttype == IS_NOT_TRUE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; btest-&gt;booltesttype == IS_FALSE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; btest-&gt;booltesttype == IS_UNKNOWN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) btest-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * If clause asserts the falsity of a subclause, return that subclause;<br/></li>
<li></span><span class="Comment"> * otherwise return NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Node *<br/></li>
<li><a id="L1414">&#x200c;</a><span class="linkable">extract_strong_not_arg</span>(Node *clause)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (clause == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(clause, BoolExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BoolExpr&nbsp;&nbsp; *bexpr = (BoolExpr *) clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bexpr-&gt;boolop == NOT_EXPR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) linitial(bexpr-&gt;args);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(clause, BooleanTest))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BooleanTest *btest = (BooleanTest *) clause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (btest-&gt;booltesttype == IS_FALSE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) btest-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Can we prove that &quot;clause&quot; returns NULL (or FALSE) if &quot;subexpr&quot; is<br/></li>
<li></span><span class="Comment"> * assumed to yield NULL?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In most places in the <a href="../plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>, &quot;strictness&quot; refers to a guarantee that<br/></li>
<li></span><span class="Comment"> * an expression yields NULL output for a NULL input, and that's mostly what<br/></li>
<li></span><span class="Comment"> * we're looking for here.&nbsp; However, at top level where the clause is known<br/></li>
<li></span><span class="Comment"> * to yield boolean, it may be sufficient to prove that it cannot return TRUE<br/></li>
<li></span><span class="Comment"> * when &quot;subexpr&quot; is NULL.&nbsp; The caller should pass allow_false = true when<br/></li>
<li></span><span class="Comment"> * this weaker property is acceptable.&nbsp; (When this function recurses<br/></li>
<li></span><span class="Comment"> * internally, we pass down allow_false = false since we need to prove actual<br/></li>
<li></span><span class="Comment"> * nullness of the subexpression.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We assume that the caller checked that least one of the input expressions<br/></li>
<li></span><span class="Comment"> * is immutable.&nbsp; All of the proof rules here involve matching &quot;subexpr&quot; to<br/></li>
<li></span><span class="Comment"> * some portion of &quot;clause&quot;, so that this allows assuming that &quot;subexpr&quot; is<br/></li>
<li></span><span class="Comment"> * immutable without a separate check.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The base case is that clause and subexpr are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We can also report success if the subexpr appears as a subexpression<br/></li>
<li></span><span class="Comment"> * of &quot;clause&quot; in a place where it'd force nullness of the overall result.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1460">&#x200c;</a></span><span class="linkable">clause_is_strict_for</span>(Node *clause, Node *subexpr, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> allow_false)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* safety checks */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (clause == <span class="Constant">NULL</span> || subexpr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look through <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> RelabelType nodes, so that we can match, say,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * varcharcol with <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>(varcharcol::text).&nbsp; (In general we could recurse<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * through <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> nullness-preserving, immutable operation.)&nbsp; We should not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * see stacked RelabelTypes here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(clause, RelabelType))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; clause = (Node *) ((RelabelType *) clause)-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(subexpr, RelabelType))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subexpr = (Node *) ((RelabelType *) subexpr)-&gt;arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Base case */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(clause, subexpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have a strict operator or function, a NULL result is guaranteed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> input is forced NULL by subexpr.&nbsp; This is OK even if the op or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * func isn't immutable, since it won't even be called on NULL input.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (is_opclause(clause) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/lsyscache.c.html#L1477" title="utils/cache/lsyscache.c:1477">op_strict</a>(((OpExpr *) clause)-&gt;opno))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, ((OpExpr *) clause)-&gt;args)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1460" title="optimizer/util/predtest.c:1460">clause_is_strict_for</a>((Node *) lfirst(lc), subexpr, <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_funcclause(clause) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/lsyscache.c.html#L1761" title="utils/cache/lsyscache.c:1761">func_strict</a>(((FuncExpr *) clause)-&gt;funcid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, ((FuncExpr *) clause)-&gt;args)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1460" title="optimizer/util/predtest.c:1460">clause_is_strict_for</a>((Node *) lfirst(lc), subexpr, <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CoerceViaIO is strict (whether or not the I/O <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> it calls are).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Likewise, ArrayCoerceExpr is strict for its array argument (regardless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of what the per-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> expression is), ConvertRowtypeExpr is strict at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the row level, and CoerceToDomain is strict too.&nbsp; These are worth<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checking mainly because it saves us having to explain to users why some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * type coercions are known strict and others aren't.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(clause, CoerceViaIO))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1460" title="optimizer/util/predtest.c:1460">clause_is_strict_for</a>((Node *) ((CoerceViaIO *) clause)-&gt;arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subexpr, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(clause, ArrayCoerceExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1460" title="optimizer/util/predtest.c:1460">clause_is_strict_for</a>((Node *) ((ArrayCoerceExpr *) clause)-&gt;arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subexpr, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(clause, ConvertRowtypeExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1460" title="optimizer/util/predtest.c:1460">clause_is_strict_for</a>((Node *) ((ConvertRowtypeExpr *) clause)-&gt;arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subexpr, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(clause, CoerceToDomain))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1460" title="optimizer/util/predtest.c:1460">clause_is_strict_for</a>((Node *) ((CoerceToDomain *) clause)-&gt;arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subexpr, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ScalarArrayOpExpr is a special case.&nbsp; Note that we'd only reach here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with a ScalarArrayOpExpr clause if we failed to deconstruct it into an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * AND or OR tree, as for example if it has too many array elements.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(clause, ScalarArrayOpExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) clause;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *scalarnode = (Node *) linitial(saop-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *arraynode = (Node *) lsecond(saop-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we can prove the scalar input to be null, and the operator is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * strict, then the SAOP result has to be null --- unless the array is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * empty.&nbsp; For an empty array, we'd get either false (for ANY) or true<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (for ALL).&nbsp; So if allow_false = true then the proof succeeds anyway<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for the ANY case; otherwise we can only make the proof if we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prove the array non-empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1460" title="optimizer/util/predtest.c:1460">clause_is_strict_for</a>(scalarnode, subexpr, <span class="Constant">false</span>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/lsyscache.c.html#L1477" title="utils/cache/lsyscache.c:1477">op_strict</a>(saop-&gt;opno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelems = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (allow_false &amp;&amp; saop-&gt;useOr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* can succeed even if array is empty */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arraynode &amp;&amp; IsA(arraynode, Const))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Const&nbsp; &nbsp; &nbsp;&nbsp; *arrayconst = (Const *) arraynode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ArrayType&nbsp; *arrval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If array is constant NULL then we can succeed, as in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arrayconst-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise, we can compute the number of elements. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arrval = DatumGetArrayTypeP(arrayconst-&gt;constvalue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelems = <a href="../../utils/adt/arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ARR_NDIM(arrval), ARR_DIMS(arrval));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (arraynode &amp;&amp; IsA(arraynode, ArrayExpr) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !((ArrayExpr *) arraynode)-&gt;multidims)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can also reliably count the number of array elements if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the input is a non-multidim ARRAY[] expression.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelems = list_length(((ArrayExpr *) arraynode)-&gt;elements);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Proof succeeds if array is definitely non-empty */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nelems &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we can prove the array input to be null, the proof succeeds in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all cases, since ScalarArrayOpExpr will always return NULL for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NULL array.&nbsp; Otherwise, we're done here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1460" title="optimizer/util/predtest.c:1460">clause_is_strict_for</a>(arraynode, subexpr, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When recursing into an expression, we might <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a NULL constant.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * That's certainly NULL, whether it matches subexpr or not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(clause, Const))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ((Const *) clause)-&gt;constisnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Define &quot;operator implication tables&quot; for btree operators (&quot;strategies&quot;),<br/></li>
<li></span><span class="Comment"> * and similar tables for refutation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The strategy numbers defined by btree indexes (see access/stratnum.h) are:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; 1 &lt;&nbsp; &nbsp; &nbsp; &nbsp; 2 &lt;=&nbsp; &nbsp; 3 =&nbsp; &nbsp; &nbsp; &nbsp; 4 &gt;=&nbsp; &nbsp; 5 &gt;<br/></li>
<li></span><span class="Comment"> * and in addition we use 6 to represent &lt;&gt;.&nbsp; &lt;&gt; is not a btree-indexable<br/></li>
<li></span><span class="Comment"> * operator, but we assume here that if an equality operator of a btree<br/></li>
<li></span><span class="Comment"> * opfamily has a negator operator, the negator behaves as &lt;&gt; for the opfamily.<br/></li>
<li></span><span class="Comment"> * (This convention is also known to <a href="../../utils/cache/lsyscache.c.html#L601" title="utils/cache/lsyscache.c:601">get_op_btree_interpretation</a>().)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L1672" title="optimizer/util/predtest.c:1672">BT_implies_table</a>[] and <a href="#L1685" title="optimizer/util/predtest.c:1685">BT_refutes_table</a>[] are used for cases where we have<br/></li>
<li></span><span class="Comment"> * two identical subexpressions and we want to know whether one operator<br/></li>
<li></span><span class="Comment"> * expression implies or refutes the other.&nbsp; That is, if the &quot;clause&quot; is<br/></li>
<li></span><span class="Comment"> * EXPR1 clause_op EXPR2 and the &quot;predicate&quot; is EXPR1 pred_op EXPR2 for the<br/></li>
<li></span><span class="Comment"> * same two (immutable) subexpressions:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1672" title="optimizer/util/predtest.c:1672">BT_implies_table</a>[clause_op-1][pred_op-1]<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is true if the clause implies the predicate<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1685" title="optimizer/util/predtest.c:1685">BT_refutes_table</a>[clause_op-1][pred_op-1]<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is true if the clause refutes the predicate<br/></li>
<li></span><span class="Comment"> * where clause_op and pred_op are strategy numbers (from 1 to 6) in the<br/></li>
<li></span><span class="Comment"> * same btree opfamily.&nbsp; For example, &quot;x &lt; y&quot; implies &quot;x &lt;= y&quot; and refutes<br/></li>
<li></span><span class="Comment"> * &quot;x &gt; y&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L1698" title="optimizer/util/predtest.c:1698">BT_implic_table</a>[] and <a href="#L1711" title="optimizer/util/predtest.c:1711">BT_refute_table</a>[] are used where we have two<br/></li>
<li></span><span class="Comment"> * constants that we need to <a href="../geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>.&nbsp; The interpretation of:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; test_op = <a href="#L1698" title="optimizer/util/predtest.c:1698">BT_implic_table</a>[clause_op-1][pred_op-1]<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * where test_op, clause_op and pred_op are strategy numbers (from 1 to 6)<br/></li>
<li></span><span class="Comment"> * of btree operators, is as follows:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; If you know, for some EXPR, that &quot;EXPR clause_op CONST1&quot; is true, and you<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; want to determine whether &quot;EXPR pred_op CONST2&quot; must also be true, then<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; you can use &quot;CONST2 test_op CONST1&quot; as a test.&nbsp; If this test returns true,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; then the predicate expression must be true; if the test returns false,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; then the predicate expression may be false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For example, if clause is &quot;Quantity &gt; 10&quot; and pred is &quot;Quantity &gt; 5&quot;<br/></li>
<li></span><span class="Comment"> * then we test &quot;5 &lt;= 10&quot; which evals to true, so clause implies pred.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Similarly, the interpretation of a <a href="#L1711" title="optimizer/util/predtest.c:1711">BT_refute_table</a> entry is:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; If you know, for some EXPR, that &quot;EXPR clause_op CONST1&quot; is true, and you<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; want to determine whether &quot;EXPR pred_op CONST2&quot; must be false, then<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; you can use &quot;CONST2 test_op CONST1&quot; as a test.&nbsp; If this test returns true,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; then the predicate expression must be false; if the test returns false,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; then the predicate expression may be true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For example, if clause is &quot;Quantity &gt; 10&quot; and pred is &quot;Quantity &lt; 5&quot;<br/></li>
<li></span><span class="Comment"> * then we test &quot;5 &lt;= 10&quot; which evals to true, so clause refutes pred.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * An entry where test_op == 0 means the implication cannot be determined.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L1662">&#x200c;</a><span class="PreProc">#define <span class="linkable">BTLT</span> BTLessStrategyNumber<br/></li>
<li><a id="L1663">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BTLE</span> BTLessEqualStrategyNumber<br/></li>
<li><a id="L1664">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BTEQ</span> BTEqualStrategyNumber<br/></li>
<li><a id="L1665">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BTGE</span> BTGreaterEqualStrategyNumber<br/></li>
<li><a id="L1666">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BTGT</span> BTGreaterStrategyNumber<br/></li>
<li><a id="L1667">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BTNE</span> ROWCOMPARE_NE<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* We use &quot;<a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>&quot; for 0/false to make the tables align nicely */<br/></li>
<li><a id="L1670">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">none</span> </span><span class="Constant">0<br/></li>
<li></span><br/></li>
<li><a id="L1672">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">BT_implies_table</span>[<span class="Constant">6</span>][<span class="Constant">6</span>] = {<br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The predicate operator:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; LT&nbsp; &nbsp; LE&nbsp; &nbsp;&nbsp; EQ&nbsp; &nbsp; GE&nbsp; &nbsp;&nbsp; GT&nbsp; &nbsp; NE<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">true</span>, <span class="Constant">true</span>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <span class="Constant">true</span>},&nbsp; &nbsp; <span class="Comment">/* LT */<br/></li>
<li></span>&nbsp; &nbsp; {<a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <span class="Constant">true</span>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>},&nbsp; &nbsp; <span class="Comment">/* LE */<br/></li>
<li></span>&nbsp; &nbsp; {<a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <span class="Constant">true</span>, <span class="Constant">true</span>, <span class="Constant">true</span>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>},&nbsp; &nbsp; <span class="Comment">/* EQ */<br/></li>
<li></span>&nbsp; &nbsp; {<a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <span class="Constant">true</span>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>},&nbsp; &nbsp; <span class="Comment">/* GE */<br/></li>
<li></span>&nbsp; &nbsp; {<a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <span class="Constant">true</span>, <span class="Constant">true</span>, <span class="Constant">true</span>},&nbsp; &nbsp; <span class="Comment">/* GT */<br/></li>
<li></span>&nbsp; &nbsp; {<a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <span class="Constant">true</span>}&nbsp; &nbsp; <span class="Comment">/* NE */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><a id="L1685">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">BT_refutes_table</span>[<span class="Constant">6</span>][<span class="Constant">6</span>] = {<br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The predicate operator:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; LT&nbsp; &nbsp; LE&nbsp; &nbsp;&nbsp; EQ&nbsp; &nbsp; GE&nbsp; &nbsp;&nbsp; GT&nbsp; &nbsp; NE<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>&nbsp; &nbsp; {<a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <span class="Constant">true</span>, <span class="Constant">true</span>, <span class="Constant">true</span>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>},&nbsp; &nbsp; <span class="Comment">/* LT */<br/></li>
<li></span>&nbsp; &nbsp; {<a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <span class="Constant">true</span>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>},&nbsp; &nbsp; <span class="Comment">/* LE */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">true</span>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <span class="Constant">true</span>, <span class="Constant">true</span>},&nbsp; &nbsp; <span class="Comment">/* EQ */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">true</span>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>},&nbsp; &nbsp; <span class="Comment">/* GE */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">true</span>, <span class="Constant">true</span>, <span class="Constant">true</span>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>},&nbsp; &nbsp; <span class="Comment">/* GT */<br/></li>
<li></span>&nbsp; &nbsp; {<a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <span class="Constant">true</span>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>}&nbsp; &nbsp; <span class="Comment">/* NE */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><a id="L1698">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> StrategyNumber <span class="linkable">BT_implic_table</span>[<span class="Constant">6</span>][<span class="Constant">6</span>] = {<br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The predicate operator:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; LT&nbsp; &nbsp; LE&nbsp; &nbsp;&nbsp; EQ&nbsp; &nbsp; GE&nbsp; &nbsp;&nbsp; GT&nbsp; &nbsp; NE<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>&nbsp; &nbsp; {<a href="#L1665" title="optimizer/util/predtest.c:1665">BTGE</a>, <a href="#L1665" title="optimizer/util/predtest.c:1665">BTGE</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1665" title="optimizer/util/predtest.c:1665">BTGE</a>},&nbsp; &nbsp; <span class="Comment">/* LT */<br/></li>
<li></span>&nbsp; &nbsp; {<a href="#L1666" title="optimizer/util/predtest.c:1666">BTGT</a>, <a href="#L1665" title="optimizer/util/predtest.c:1665">BTGE</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1666" title="optimizer/util/predtest.c:1666">BTGT</a>},&nbsp; &nbsp; <span class="Comment">/* LE */<br/></li>
<li></span>&nbsp; &nbsp; {<a href="#L1666" title="optimizer/util/predtest.c:1666">BTGT</a>, <a href="#L1665" title="optimizer/util/predtest.c:1665">BTGE</a>, <a href="#L1664" title="optimizer/util/predtest.c:1664">BTEQ</a>, <a href="#L1663" title="optimizer/util/predtest.c:1663">BTLE</a>, <a href="#L1662" title="optimizer/util/predtest.c:1662">BTLT</a>, <a href="#L1667" title="optimizer/util/predtest.c:1667">BTNE</a>},&nbsp; &nbsp; <span class="Comment">/* EQ */<br/></li>
<li></span>&nbsp; &nbsp; {<a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1663" title="optimizer/util/predtest.c:1663">BTLE</a>, <a href="#L1662" title="optimizer/util/predtest.c:1662">BTLT</a>, <a href="#L1662" title="optimizer/util/predtest.c:1662">BTLT</a>},&nbsp; &nbsp; <span class="Comment">/* GE */<br/></li>
<li></span>&nbsp; &nbsp; {<a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1663" title="optimizer/util/predtest.c:1663">BTLE</a>, <a href="#L1663" title="optimizer/util/predtest.c:1663">BTLE</a>, <a href="#L1663" title="optimizer/util/predtest.c:1663">BTLE</a>},&nbsp; &nbsp; <span class="Comment">/* GT */<br/></li>
<li></span>&nbsp; &nbsp; {<a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1664" title="optimizer/util/predtest.c:1664">BTEQ</a>}&nbsp; &nbsp; <span class="Comment">/* NE */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><a id="L1711">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> StrategyNumber <span class="linkable">BT_refute_table</span>[<span class="Constant">6</span>][<span class="Constant">6</span>] = {<br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The predicate operator:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; LT&nbsp; &nbsp; LE&nbsp; &nbsp;&nbsp; EQ&nbsp; &nbsp; GE&nbsp; &nbsp;&nbsp; GT&nbsp; &nbsp; NE<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>&nbsp; &nbsp; {<a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1665" title="optimizer/util/predtest.c:1665">BTGE</a>, <a href="#L1665" title="optimizer/util/predtest.c:1665">BTGE</a>, <a href="#L1665" title="optimizer/util/predtest.c:1665">BTGE</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>},&nbsp; &nbsp; <span class="Comment">/* LT */<br/></li>
<li></span>&nbsp; &nbsp; {<a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1666" title="optimizer/util/predtest.c:1666">BTGT</a>, <a href="#L1666" title="optimizer/util/predtest.c:1666">BTGT</a>, <a href="#L1665" title="optimizer/util/predtest.c:1665">BTGE</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>},&nbsp; &nbsp; <span class="Comment">/* LE */<br/></li>
<li></span>&nbsp; &nbsp; {<a href="#L1663" title="optimizer/util/predtest.c:1663">BTLE</a>, <a href="#L1662" title="optimizer/util/predtest.c:1662">BTLT</a>, <a href="#L1667" title="optimizer/util/predtest.c:1667">BTNE</a>, <a href="#L1666" title="optimizer/util/predtest.c:1666">BTGT</a>, <a href="#L1665" title="optimizer/util/predtest.c:1665">BTGE</a>, <a href="#L1664" title="optimizer/util/predtest.c:1664">BTEQ</a>},&nbsp; &nbsp; <span class="Comment">/* EQ */<br/></li>
<li></span>&nbsp; &nbsp; {<a href="#L1663" title="optimizer/util/predtest.c:1663">BTLE</a>, <a href="#L1662" title="optimizer/util/predtest.c:1662">BTLT</a>, <a href="#L1662" title="optimizer/util/predtest.c:1662">BTLT</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>},&nbsp; &nbsp; <span class="Comment">/* GE */<br/></li>
<li></span>&nbsp; &nbsp; {<a href="#L1663" title="optimizer/util/predtest.c:1663">BTLE</a>, <a href="#L1663" title="optimizer/util/predtest.c:1663">BTLE</a>, <a href="#L1663" title="optimizer/util/predtest.c:1663">BTLE</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>},&nbsp; &nbsp; <span class="Comment">/* GT */<br/></li>
<li></span>&nbsp; &nbsp; {<a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1664" title="optimizer/util/predtest.c:1664">BTEQ</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>, <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a>}&nbsp; &nbsp; <span class="Comment">/* NE */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1779" title="optimizer/util/predtest.c:1779">operator_predicate_proof</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Does the predicate implication or refutation test for a &quot;simple clause&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; predicate and a &quot;simple clause&quot; restriction, when both are operator<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; clauses using related operators and identical input expressions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When refute_it == false, we want to prove the predicate true;<br/></li>
<li></span><span class="Comment"> * when refute_it == true, we want to prove the predicate false.<br/></li>
<li></span><span class="Comment"> * (There is enough common code to justify handling these two cases<br/></li>
<li></span><span class="Comment"> * in one routine.)&nbsp; We return true if able to make the proof, false<br/></li>
<li></span><span class="Comment"> * if not able to prove it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We mostly need not distinguish strong vs. weak implication/refutation here.<br/></li>
<li></span><span class="Comment"> * This depends on the assumption that a pair of related operators (i.e.,<br/></li>
<li></span><span class="Comment"> * commutators, negators, or btree opfamily siblings) will not return one NULL<br/></li>
<li></span><span class="Comment"> * and one non-NULL result for the same inputs.&nbsp; Then, for the proof types<br/></li>
<li></span><span class="Comment"> * where we start with an assumption of truth of the clause, the predicate<br/></li>
<li></span><span class="Comment"> * operator could not return NULL either, so it doesn't matter whether we are<br/></li>
<li></span><span class="Comment"> * trying to make a strong or weak proof.&nbsp; For weak implication, it could be<br/></li>
<li></span><span class="Comment"> * that the clause operator returned NULL, but then the predicate operator<br/></li>
<li></span><span class="Comment"> * would as well, so that the weak implication still holds.&nbsp; This argument<br/></li>
<li></span><span class="Comment"> * doesn't apply in the case where we are considering two different constant<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, since then the operators aren't being given identical inputs.&nbsp; But<br/></li>
<li></span><span class="Comment"> * we only support that for btree operators, for which we can assume that all<br/></li>
<li></span><span class="Comment"> * non-null inputs result in non-null outputs, so that it doesn't matter which<br/></li>
<li></span><span class="Comment"> * two non-null constants we consider.&nbsp; If either constant is NULL, we have<br/></li>
<li></span><span class="Comment"> * to think harder, but sometimes the proof still works, as explained below.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We can make proofs involving several expression forms (here &quot;foo&quot; and &quot;bar&quot;<br/></li>
<li></span><span class="Comment"> * represent subexpressions that are identical according to <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>()):<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &quot;foo op1 bar&quot; refutes &quot;foo op2 bar&quot; if op1 is op2's negator<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &quot;foo op1 bar&quot; implies &quot;bar op2 foo&quot; if op1 is op2's commutator<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &quot;foo op1 bar&quot; refutes &quot;bar op2 foo&quot; if op1 is negator of op2's commutator<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &quot;foo op1 bar&quot; can imply/refute &quot;foo op2 bar&quot; based on btree semantics<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &quot;foo op1 bar&quot; can imply/refute &quot;bar op2 foo&quot; based on btree semantics<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &quot;foo op1 const1&quot; can imply/refute &quot;foo op2 const2&quot; based on btree semantics<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For the last three cases, op1 and op2 have to be members of the same btree<br/></li>
<li></span><span class="Comment"> * operator family.&nbsp; When both subexpressions are identical, the idea is that,<br/></li>
<li></span><span class="Comment"> * for instance, x &lt; y implies x &lt;= y, independently of exactly what x and y<br/></li>
<li></span><span class="Comment"> * are.&nbsp; If we have two different constants compared to the same expression<br/></li>
<li></span><span class="Comment"> * foo, we have to execute a comparison between the two constant <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> * in order to determine the result; for instance, foo &lt; c1 implies foo &lt; c2<br/></li>
<li></span><span class="Comment"> * if c1 &lt;= c2.&nbsp; We assume it's safe to <a href="../geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the constants at plan time<br/></li>
<li></span><span class="Comment"> * if the comparison operator is immutable.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: all the operators and subexpressions have to be immutable for the<br/></li>
<li></span><span class="Comment"> * proof to be safe.&nbsp; We assume the predicate expression is entirely immutable,<br/></li>
<li></span><span class="Comment"> * so no explicit check on the subexpressions is needed here, but in some<br/></li>
<li></span><span class="Comment"> * cases we need an extra check of operator immutability.&nbsp; In particular,<br/></li>
<li></span><span class="Comment"> * btree opfamilies can contain cross-type operators that are merely stable,<br/></li>
<li></span><span class="Comment"> * and we dare not make deductions with those.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1779">&#x200c;</a></span><span class="linkable">operator_predicate_proof</span>(Expr *predicate, Node *clause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> refute_it, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> weak)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; OpExpr&nbsp; &nbsp; &nbsp;&nbsp; *pred_opexpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *clause_opexpr;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pred_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clause_collation;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pred_op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clause_op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test_op;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *pred_leftop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *pred_rightop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *clause_leftop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *clause_rightop;<br/></li>
<li>&nbsp; &nbsp; Const&nbsp; &nbsp; &nbsp;&nbsp; *pred_const,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *clause_const;<br/></li>
<li>&nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *test_expr;<br/></li>
<li>&nbsp; &nbsp; ExprState&nbsp; *test_exprstate;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; test_result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isNull;<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Both expressions must be binary opclauses, else we can't do anything.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: in future we might extend this logic to other operator-based<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constructs such as DistinctExpr.&nbsp; But the <a href="../plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> isn't very smart<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * about DistinctExpr in general, and this probably isn't the first place<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to fix if you want to improve that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!is_opclause(predicate))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pred_opexpr = (OpExpr *) predicate;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(pred_opexpr-&gt;args) != <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!is_opclause(clause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; clause_opexpr = (OpExpr *) clause;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(clause_opexpr-&gt;args) != <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If they're marked with different collations then we can't do anything.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is a cheap test so let's get it out of the way early.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pred_collation = pred_opexpr-&gt;inputcollid;<br/></li>
<li>&nbsp; &nbsp; clause_collation = clause_opexpr-&gt;inputcollid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pred_collation != clause_collation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Grab the operator OIDs <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> too.&nbsp; We may commute these below. */<br/></li>
<li></span>&nbsp; &nbsp; pred_op = pred_opexpr-&gt;opno;<br/></li>
<li>&nbsp; &nbsp; clause_op = clause_opexpr-&gt;opno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have to match up at least one pair of input expressions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pred_leftop = (Node *) linitial(pred_opexpr-&gt;args);<br/></li>
<li>&nbsp; &nbsp; pred_rightop = (Node *) lsecond(pred_opexpr-&gt;args);<br/></li>
<li>&nbsp; &nbsp; clause_leftop = (Node *) linitial(clause_opexpr-&gt;args);<br/></li>
<li>&nbsp; &nbsp; clause_rightop = (Node *) lsecond(clause_opexpr-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(pred_leftop, clause_leftop))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(pred_rightop, clause_rightop))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We have x op1 y and x op2 y */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2032" title="optimizer/util/predtest.c:2032">operator_same_subexprs_proof</a>(pred_op, clause_op, refute_it);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fail unless rightops are both Consts */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pred_rightop == <span class="Constant">NULL</span> || !IsA(pred_rightop, Const))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pred_const = (Const *) pred_rightop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (clause_rightop == <span class="Constant">NULL</span> || !IsA(clause_rightop, Const))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clause_const = (Const *) clause_rightop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(pred_rightop, clause_rightop))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fail unless leftops are both Consts */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pred_leftop == <span class="Constant">NULL</span> || !IsA(pred_leftop, Const))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pred_const = (Const *) pred_leftop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (clause_leftop == <span class="Constant">NULL</span> || !IsA(clause_leftop, Const))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; clause_const = (Const *) clause_leftop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Commute both operators so we can assume Consts are on the right */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pred_op = <a href="../../utils/cache/lsyscache.c.html#L1509" title="utils/cache/lsyscache.c:1509">get_commutator</a>(pred_op);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(pred_op))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; clause_op = <a href="../../utils/cache/lsyscache.c.html#L1509" title="utils/cache/lsyscache.c:1509">get_commutator</a>(clause_op);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(clause_op))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(pred_leftop, clause_rightop))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(pred_rightop, clause_leftop))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We have x op1 y and y op2 x */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Commute pred_op that we can treat this like a straight match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pred_op = <a href="../../utils/cache/lsyscache.c.html#L1509" title="utils/cache/lsyscache.c:1509">get_commutator</a>(pred_op);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(pred_op))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2032" title="optimizer/util/predtest.c:2032">operator_same_subexprs_proof</a>(pred_op, clause_op, refute_it);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fail unless pred_rightop/clause_leftop are both Consts */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pred_rightop == <span class="Constant">NULL</span> || !IsA(pred_rightop, Const))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pred_const = (Const *) pred_rightop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (clause_leftop == <span class="Constant">NULL</span> || !IsA(clause_leftop, Const))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clause_const = (Const *) clause_leftop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Commute clause_op so we can assume Consts are on the right */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clause_op = <a href="../../utils/cache/lsyscache.c.html#L1509" title="utils/cache/lsyscache.c:1509">get_commutator</a>(clause_op);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(clause_op))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(pred_rightop, clause_leftop))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fail unless pred_leftop/clause_rightop are both Consts */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pred_leftop == <span class="Constant">NULL</span> || !IsA(pred_leftop, Const))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pred_const = (Const *) pred_leftop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (clause_rightop == <span class="Constant">NULL</span> || !IsA(clause_rightop, Const))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; clause_const = (Const *) clause_rightop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Commute pred_op so we can assume Consts are on the right */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pred_op = <a href="../../utils/cache/lsyscache.c.html#L1509" title="utils/cache/lsyscache.c:1509">get_commutator</a>(pred_op);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(pred_op))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Failed to match up <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the subexpressions, so we lose */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have two identical subexpressions, and two other subexpressions that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are not identical but are both Consts; and we have commuted the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operators if necessary so that the Consts are on the right.&nbsp; We'll need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to <a href="../geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the Consts' <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; If either is NULL, we can't do that, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * usually the proof fails ... but in some cases we can claim success.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (clause_const-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If clause_op isn't strict, we can't prove anything */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/cache/lsyscache.c.html#L1477" title="utils/cache/lsyscache.c:1477">op_strict</a>(clause_op))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At this point we know that the clause returns NULL.&nbsp; For proof<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * types that assume truth of the clause, this means the proof is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * vacuously true (a/k/a &quot;false implies anything&quot;).&nbsp; That's all proof<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * types except weak implication.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(weak &amp;&amp; !refute_it))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For weak implication, it's still possible for the proof to succeed,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if the predicate can also be proven NULL.&nbsp; In that case we've got<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NULL =&gt; NULL which is valid for this proof type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pred_const-&gt;constisnull &amp;&amp; <a href="../../utils/cache/lsyscache.c.html#L1477" title="utils/cache/lsyscache.c:1477">op_strict</a>(pred_op))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Else the proof fails */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pred_const-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the pred_op is strict, we know the predicate yields NULL, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * means the proof succeeds for either weak implication or weak<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * refutation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (weak &amp;&amp; <a href="../../utils/cache/lsyscache.c.html#L1477" title="utils/cache/lsyscache.c:1477">op_strict</a>(pred_op))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Else the proof fails */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lookup the constant-comparison operator using the system catalogs and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the operator implication tables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; test_op = <a href="#L2330" title="optimizer/util/predtest.c:2330">get_btree_test_op</a>(pred_op, clause_op, refute_it);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(test_op))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* couldn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a suitable comparison operator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Evaluate the test.&nbsp; For this we need an EState.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; estate = <a href="../../executor/execUtils.c.html#L88" title="executor/execUtils.c:88">CreateExecutorState</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can use the estate's working context to avoid memory leaks. */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(estate-&gt;es_query_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build expression tree */<br/></li>
<li></span>&nbsp; &nbsp; test_expr = <a href="../../nodes/makefuncs.c.html#L628" title="nodes/makefuncs.c:628">make_opclause</a>(test_op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BOOLOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Expr *) pred_const,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Expr *) clause_const,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pred_collation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fill in opfuncids */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L1837" title="nodes/nodeFuncs.c:1837">fix_opfuncids</a>((Node *) test_expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare it for execution */<br/></li>
<li></span>&nbsp; &nbsp; test_exprstate = <a href="../../executor/execExpr.c.html#L134" title="executor/execExpr.c:134">ExecInitExpr</a>(test_expr, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And execute it. */<br/></li>
<li></span>&nbsp; &nbsp; test_result = ExecEvalExprSwitchContext(test_exprstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GetPerTupleExprContext(estate),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isNull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get back to outer memory context */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release all the junk we just created */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../executor/execUtils.c.html#L189" title="executor/execUtils.c:189">FreeExecutorState</a>(estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isNull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Treat a null result as non-proof ... but it's a tad fishy ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;null predicate test result&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetBool(test_result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2032" title="optimizer/util/predtest.c:2032">operator_same_subexprs_proof</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Assuming that EXPR1 clause_op EXPR2 is true, try to prove or refute<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; EXPR1 pred_op EXPR2.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return true if able to make the proof, false if not able to prove it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2032">&#x200c;</a></span><span class="linkable">operator_same_subexprs_proof</span>(Oid pred_op, Oid clause_op, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> refute_it)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A simple and general rule is that the predicate is proven if clause_op<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and pred_op are the same, or refuted if they are each other's negators.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need not check immutability since the pred_op is already known<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * immutable.&nbsp; (Actually, by this point we may have the commutator of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * known-immutable pred_op, but that should certainly be immutable too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Likewise we don't worry whether the pred_op's negator is immutable.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: the &quot;same&quot; case won't get here if we actually had EXPR1 clause_op<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * EXPR2 and EXPR1 pred_op EXPR2, because the overall-expression-equality<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * test in <a href="#L1098" title="optimizer/util/predtest.c:1098">predicate_implied_by_simple_clause</a> would have caught it.&nbsp; But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we can see the same operator after having commuted the pred_op.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (refute_it)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/cache/lsyscache.c.html#L1533" title="utils/cache/lsyscache.c:1533">get_negator</a>(pred_op) == clause_op)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pred_op == clause_op)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, see if we can determine the implication by finding the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operators' relationship via some btree opfamily.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2305" title="optimizer/util/predtest.c:2305">operator_same_subexprs_lookup</a>(pred_op, clause_op, refute_it);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We use a lookaside table to cache the result of btree proof operator<br/></li>
<li></span><span class="Comment"> * lookups, since the actual lookup is pretty expensive and doesn't change<br/></li>
<li></span><span class="Comment"> * for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> given pair of operators (at least as long as pg_amop doesn't<br/></li>
<li></span><span class="Comment"> * change).&nbsp; A single <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> entry stores both implication and refutation<br/></li>
<li></span><span class="Comment"> * results for a given pair of operators; but note we may have determined<br/></li>
<li></span><span class="Comment"> * only one of those sets of results as yet.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L2074">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">OprProofCacheKey</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pred_op;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* predicate operator */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clause_op;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* clause operator */<br/></li>
<li><a id="L2078">&#x200c;</a></span>} <span class="linkable">OprProofCacheKey</span>;<br/></li>
<li><br/></li>
<li><a id="L2080">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">OprProofCacheEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> lookup key MUST BE FIRST */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2074" title="optimizer/util/predtest.c:2074">OprProofCacheKey</a> key;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_implic;&nbsp; &nbsp; <span class="Comment">/* do we know the implication result? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_refute;&nbsp; &nbsp; <span class="Comment">/* do we know the refutation result? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; same_subexprs_implies;&nbsp; &nbsp; <span class="Comment">/* X clause_op Y implies X pred_op Y? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; same_subexprs_refutes;&nbsp; &nbsp; <span class="Comment">/* X clause_op Y refutes X pred_op Y? */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; implic_test_op; <span class="Comment">/* OID of the test operator, or 0 if <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a> */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; refute_test_op; <span class="Comment">/* OID of the test operator, or 0 if <a href="#L1670" title="optimizer/util/predtest.c:1670">none</a> */<br/></li>
<li><a id="L2091">&#x200c;</a></span>} <span class="linkable">OprProofCacheEntry</span>;<br/></li>
<li><br/></li>
<li><a id="L2093">&#x200c;</a><span class="Type">static</span> <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">OprProofCacheHash</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2101" title="optimizer/util/predtest.c:2101">lookup_proof_cache</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Get, and fill in if necessary, the appropriate cache entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L2080" title="optimizer/util/predtest.c:2080">OprProofCacheEntry</a> *<br/></li>
<li><a id="L2101">&#x200c;</a><span class="linkable">lookup_proof_cache</span>(Oid pred_op, Oid clause_op, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> refute_it)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L2074" title="optimizer/util/predtest.c:2074">OprProofCacheKey</a> key;<br/></li>
<li>&nbsp; &nbsp; <a href="#L2080" title="optimizer/util/predtest.c:2080">OprProofCacheEntry</a> *cache_entry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; cfound;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; same_subexprs = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test_op = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pred_op_infos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *clause_op_infos;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lcp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lcc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find or make a cache entry for this pair of operators.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2093" title="optimizer/util/predtest.c:2093">OprProofCacheHash</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First time through: <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L2074" title="optimizer/util/predtest.c:2074">OprProofCacheKey</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L2080" title="optimizer/util/predtest.c:2080">OprProofCacheEntry</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2093" title="optimizer/util/predtest.c:2093">OprProofCacheHash</a> = <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;Btree proof lookup cache&quot;</span>, <span class="Constant">256</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;ctl, HASH_ELEM | HASH_BLOBS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Arrange to flush cache on pg_amop changes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a>(AMOPOPID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2346" title="optimizer/util/predtest.c:2346">InvalidateOprProofCacheCallBack</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Datum) <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; key.pred_op = pred_op;<br/></li>
<li>&nbsp; &nbsp; key.clause_op = clause_op;<br/></li>
<li>&nbsp; &nbsp; cache_entry = (<a href="#L2080" title="optimizer/util/predtest.c:2080">OprProofCacheEntry</a> *) <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L2093" title="optimizer/util/predtest.c:2093">OprProofCacheHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ENTER, &amp;cfound);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!cfound)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* new cache entry, set it invalid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cache_entry-&gt;have_implic = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache_entry-&gt;have_refute = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pre-existing cache entry, see if we know the answer yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (refute_it ? cache_entry-&gt;have_refute : cache_entry-&gt;have_implic)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> cache_entry;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a btree opfamily containing the given operators.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a btree opfamily that contains both operators, else the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * implication can't be determined.&nbsp; Also, the opfamily must contain a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * suitable test operator taking the operators' righthand datatypes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are multiple matching opfamilies, assume we can use <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * determine the logical relationship of the two operators and the correct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * corresponding test operator.&nbsp; This should work for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> logically<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consistent opfamilies.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we can determine the operators' relationship for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same-subexprs cases even from an opfamily that lacks a usable test<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operator.&nbsp; This can happen in cases with incomplete sets of cross-type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comparison operators.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; clause_op_infos = <a href="../../utils/cache/lsyscache.c.html#L601" title="utils/cache/lsyscache.c:601">get_op_btree_interpretation</a>(clause_op);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (clause_op_infos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pred_op_infos = <a href="../../utils/cache/lsyscache.c.html#L601" title="utils/cache/lsyscache.c:601">get_op_btree_interpretation</a>(pred_op);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no point in looking */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pred_op_infos = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lcp, pred_op_infos)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OpBtreeInterpretation *pred_op_info = lfirst(lcp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfamily_id = pred_op_info-&gt;opfamily_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lcc, clause_op_infos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OpBtreeInterpretation *clause_op_info = lfirst(lcc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StrategyNumber pred_strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clause_strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test_strategy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> them in same opfamily */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (opfamily_id != clause_op_info-&gt;opfamily_id)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Lefttypes should match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(clause_op_info-&gt;oplefttype == pred_op_info-&gt;oplefttype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pred_strategy = pred_op_info-&gt;strategy;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clause_strategy = clause_op_info-&gt;strategy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check to see if we can make a proof for same-subexpressions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cases based on the operators' relationship in this opfamily.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (refute_it)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; same_subexprs |= <a href="#L1685" title="optimizer/util/predtest.c:1685">BT_refutes_table</a>[clause_strategy - <span class="Constant">1</span>][pred_strategy - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; same_subexprs |= <a href="#L1672" title="optimizer/util/predtest.c:1672">BT_implies_table</a>[clause_strategy - <span class="Constant">1</span>][pred_strategy - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Look up the &quot;test&quot; strategy number in the implication table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (refute_it)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test_strategy = <a href="#L1711" title="optimizer/util/predtest.c:1711">BT_refute_table</a>[clause_strategy - <span class="Constant">1</span>][pred_strategy - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test_strategy = <a href="#L1698" title="optimizer/util/predtest.c:1698">BT_implic_table</a>[clause_strategy - <span class="Constant">1</span>][pred_strategy - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (test_strategy == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can't determine implication using this interpretation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * See if opfamily has an operator for the test strategy and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * datatypes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (test_strategy == <a href="#L1667" title="optimizer/util/predtest.c:1667">BTNE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test_op = <a href="../../utils/cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pred_op_info-&gt;oprighttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clause_op_info-&gt;oprighttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(test_op))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test_op = <a href="../../utils/cache/lsyscache.c.html#L1533" title="utils/cache/lsyscache.c:1533">get_negator</a>(test_op);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test_op = <a href="../../utils/cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pred_op_info-&gt;oprighttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clause_op_info-&gt;oprighttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test_strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(test_op))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Last check: test_op must be immutable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that we require only the test_op to be immutable, not the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * original clause_op.&nbsp; (pred_op is assumed to have been checked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * immutable by the caller.)&nbsp; Essentially we are assuming that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * opfamily is consistent even if it contains operators that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * merely stable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/cache/lsyscache.c.html#L1493" title="utils/cache/lsyscache.c:1493">op_volatile</a>(test_op) == PROVOLATILE_IMMUTABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1560" title="nodes/list.c:1560">list_free_deep</a>(pred_op_infos);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1560" title="nodes/list.c:1560">list_free_deep</a>(clause_op_infos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* couldn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a suitable comparison operator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; test_op = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we think we were able to prove something about same-subexpressions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases, check to make sure the clause_op is immutable <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> believing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it completely.&nbsp; (Usually, the clause_op would be immutable if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pred_op is, but it's not entirely clear that this must be true in all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases, so let's check.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (same_subexprs &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/lsyscache.c.html#L1493" title="utils/cache/lsyscache.c:1493">op_volatile</a>(clause_op) != PROVOLATILE_IMMUTABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; same_subexprs = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cache the results, whether positive or negative */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (refute_it)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache_entry-&gt;refute_test_op = test_op;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache_entry-&gt;same_subexprs_refutes = same_subexprs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache_entry-&gt;have_refute = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache_entry-&gt;implic_test_op = test_op;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache_entry-&gt;same_subexprs_implies = same_subexprs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache_entry-&gt;have_implic = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cache_entry;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2305" title="optimizer/util/predtest.c:2305">operator_same_subexprs_lookup</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Convenience subroutine to look up the cached answer for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; same-subexpressions cases.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2305">&#x200c;</a></span><span class="linkable">operator_same_subexprs_lookup</span>(Oid pred_op, Oid clause_op, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> refute_it)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L2080" title="optimizer/util/predtest.c:2080">OprProofCacheEntry</a> *cache_entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cache_entry = <a href="#L2101" title="optimizer/util/predtest.c:2101">lookup_proof_cache</a>(pred_op, clause_op, refute_it);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (refute_it)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> cache_entry-&gt;same_subexprs_refutes;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> cache_entry-&gt;same_subexprs_implies;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2330" title="optimizer/util/predtest.c:2330">get_btree_test_op</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Identify the comparison operator needed for a btree-operator<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; proof or refutation involving comparison of constants.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given the truth of a clause &quot;var clause_op const1&quot;, we are attempting to<br/></li>
<li></span><span class="Comment"> * prove or refute a predicate &quot;var pred_op const2&quot;.&nbsp; The identities of the<br/></li>
<li></span><span class="Comment"> * two operators are sufficient to determine the operator (if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) to <a href="../geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a><br/></li>
<li></span><span class="Comment"> * const2 to const1 with.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the OID of the operator to use, or InvalidOid if no proof is<br/></li>
<li></span><span class="Comment"> * possible.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Oid<br/></li>
<li><a id="L2330">&#x200c;</a><span class="linkable">get_btree_test_op</span>(Oid pred_op, Oid clause_op, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> refute_it)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L2080" title="optimizer/util/predtest.c:2080">OprProofCacheEntry</a> *cache_entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cache_entry = <a href="#L2101" title="optimizer/util/predtest.c:2101">lookup_proof_cache</a>(pred_op, clause_op, refute_it);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (refute_it)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> cache_entry-&gt;refute_test_op;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> cache_entry-&gt;implic_test_op;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Callback for pg_amop inval events<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2346">&#x200c;</a></span><span class="linkable">InvalidateOprProofCacheCallBack</span>(Datum arg, <span class="Type">int</span> cacheid, uint32 hashvalue)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L2080" title="optimizer/util/predtest.c:2080">OprProofCacheEntry</a> *hentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L2093" title="optimizer/util/predtest.c:2093">OprProofCacheHash</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Currently we just reset all entries; hard to be smarter ... */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L2093" title="optimizer/util/predtest.c:2093">OprProofCacheHash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((hentry = (<a href="#L2080" title="optimizer/util/predtest.c:2080">OprProofCacheEntry</a> *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hentry-&gt;have_implic = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hentry-&gt;have_refute = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
