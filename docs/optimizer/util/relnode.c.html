<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>optimizer/util/relnode.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>optimizer/util/relnode.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L38">JoinHashEntry</a></li>
<li><a href="#L42">JoinHashEntry</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L627">add_join_rel</a></li>
<li><a href="#L881">build_child_join_rel</a></li>
<li><a href="#L2425">build_child_join_reltarget</a></li>
<li><a href="#L665">build_join_rel</a></li>
<li><a href="#L486">build_join_rel_hash</a></li>
<li><a href="#L1334">build_joinrel_joinlist</a></li>
<li><a href="#L2017">build_joinrel_partition_info</a></li>
<li><a href="#L1297">build_joinrel_restrictlist</a></li>
<li><a href="#L1112">build_joinrel_tlist</a></li>
<li><a href="#L192">build_simple_rel</a></li>
<li><a href="#L163">expand_planner_arrays</a></li>
<li><a href="#L1470">fetch_upper_rel</a></li>
<li><a href="#L414">find_base_rel</a></li>
<li><a href="#L454">find_base_rel_ignore_join</a></li>
<li><a href="#L436">find_base_rel_noerr</a></li>
<li><a href="#L1521">find_childrel_parents</a></li>
<li><a href="#L527">find_join_rel</a></li>
<li><a href="#L1901">find_param_path_info</a></li>
<li><a href="#L1868">get_appendrel_parampathinfo</a></li>
<li><a href="#L1557">get_baserel_parampathinfo</a></li>
<li><a href="#L1671">get_joinrel_parampathinfo</a></li>
<li><a href="#L1922">get_param_path_clause_serials</a></li>
<li><a href="#L2090">have_partkey_equi_join</a></li>
<li><a href="#L2232">match_expr_to_partition_keys</a></li>
<li><a href="#L1034">min_join_parameterization</a></li>
<li><a href="#L589">set_foreign_rel_properties</a></li>
<li><a href="#L2281">set_joinrel_partition_key_exprs</a></li>
<li><a href="#L94">setup_simple_rel_arrays</a></li>
<li><a href="#L1418">subbuild_joinrel_joinlist</a></li>
<li><a href="#L1352">subbuild_joinrel_restrictlist</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * relnode.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Relation-node lookup/construction routines<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/optimizer/util/relnode.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/appendinfo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/clauses.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/cost.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/inherit.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/pathnode.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/paths.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/placeholder.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/plancat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/restrictinfo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/tlist.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_relation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;rewrite/rewriteManip.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/hsearch.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L38">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">JoinHashEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; join_relids;&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key --- MUST BE FIRST */<br/></li>
<li></span>&nbsp; &nbsp; RelOptInfo *join_rel;<br/></li>
<li><a id="L42">&#x200c;</a>} <span class="linkable">JoinHashEntry</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1112" title="optimizer/util/relnode.c:1112">build_joinrel_tlist</a>(PlannerInfo *root, RelOptInfo *joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpecialJoinInfo *sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *pushed_down_joins,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> can_null);<br/></li>
<li><span class="Type">static</span> List *<a href="#L1297" title="optimizer/util/relnode.c:1297">build_joinrel_restrictlist</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *outer_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *inner_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpecialJoinInfo *sjinfo);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1334" title="optimizer/util/relnode.c:1334">build_joinrel_joinlist</a>(RelOptInfo *joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *outer_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *inner_rel);<br/></li>
<li><span class="Type">static</span> List *<a href="#L1352" title="optimizer/util/relnode.c:1352">subbuild_joinrel_restrictlist</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids both_input_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *new_restrictlist);<br/></li>
<li><span class="Type">static</span> List *<a href="#L1418" title="optimizer/util/relnode.c:1418">subbuild_joinrel_joinlist</a>(RelOptInfo *joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *joininfo_list,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *new_joininfo);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L589" title="optimizer/util/relnode.c:589">set_foreign_rel_properties</a>(RelOptInfo *joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *outer_rel, RelOptInfo *inner_rel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L627" title="optimizer/util/relnode.c:627">add_join_rel</a>(PlannerInfo *root, RelOptInfo *joinrel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2017" title="optimizer/util/relnode.c:2017">build_joinrel_partition_info</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *outer_rel, RelOptInfo *inner_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SpecialJoinInfo *sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *restrictlist);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2090" title="optimizer/util/relnode.c:2090">have_partkey_equi_join</a>(PlannerInfo *root, RelOptInfo *joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *rel1, RelOptInfo *rel2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JoinType jointype, List *restrictlist);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2232" title="optimizer/util/relnode.c:2232">match_expr_to_partition_keys</a>(Expr *expr, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> strict_op);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2281" title="optimizer/util/relnode.c:2281">set_joinrel_partition_key_exprs</a>(RelOptInfo *joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *outer_rel, RelOptInfo *inner_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JoinType jointype);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2425" title="optimizer/util/relnode.c:2425">build_child_join_reltarget</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *parentrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *childrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nappinfos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AppendRelInfo **appinfos);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L94" title="optimizer/util/relnode.c:94">setup_simple_rel_arrays</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Prepare the arrays we use for quickly accessing base relations<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; and AppendRelInfos.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L94">&#x200c;</a></span><span class="linkable">setup_simple_rel_arrays</span>(PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; rti;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Arrays are accessed using RT indexes (1..N) */<br/></li>
<li></span>&nbsp; &nbsp; size = list_length(root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rtable) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; root-&gt;simple_rel_array_size = size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * simple_rel_array is initialized to all NULLs, since no RelOptInfos<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exist yet.&nbsp; It'll be filled by later calls to <a href="#L192" title="optimizer/util/relnode.c:192">build_simple_rel</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;simple_rel_array = (RelOptInfo **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(size * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelOptInfo *));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* simple_rte_array is an array equivalent of the rtable list */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;simple_rte_array = (RangeTblEntry **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(size * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RangeTblEntry *));<br/></li>
<li>&nbsp; &nbsp; rti = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rtable)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = (RangeTblEntry *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;simple_rte_array[rti++] = rte;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* append_rel_array is not needed if there are no AppendRelInfos */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;append_rel_list == NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;append_rel_array = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; root-&gt;append_rel_array = (AppendRelInfo **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(size * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AppendRelInfo *));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * append_rel_array is filled with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> already-existing AppendRelInfos,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which currently could only come from UNION ALL flattening.&nbsp; We might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * add more later during inheritance expansion, but it's the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * responsibility of the expansion code to update the array properly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, root-&gt;append_rel_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AppendRelInfo *appinfo = lfirst_node(AppendRelInfo, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_relid = appinfo-&gt;child_relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sanity check */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(child_relid &lt; size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;append_rel_array[child_relid])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;child relation already exists&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;append_rel_array[child_relid] = appinfo;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L163" title="optimizer/util/relnode.c:163">expand_planner_arrays</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Expand the PlannerInfo's per-RTE arrays by <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a> members<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the newly added entries to NULLs<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this causes the append_rel_array to become allocated even if<br/></li>
<li></span><span class="Comment"> * it was not <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>.&nbsp; This is okay for current uses, because we only call<br/></li>
<li></span><span class="Comment"> * this when adding child relations, which always have AppendRelInfos.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L163">&#x200c;</a></span><span class="linkable">expand_planner_arrays</span>(PlannerInfo *root, <span class="Type">int</span> <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a> &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; new_size = root-&gt;simple_rel_array_size + <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; root-&gt;simple_rel_array =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; repalloc0_array(root-&gt;simple_rel_array, RelOptInfo *, root-&gt;simple_rel_array_size, new_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; root-&gt;simple_rte_array =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; repalloc0_array(root-&gt;simple_rte_array, RangeTblEntry *, root-&gt;simple_rel_array_size, new_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;append_rel_array)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;append_rel_array =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; repalloc0_array(root-&gt;append_rel_array, AppendRelInfo *, root-&gt;simple_rel_array_size, new_size);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;append_rel_array =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; palloc0_array(AppendRelInfo *, new_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; root-&gt;simple_rel_array_size = new_size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L192" title="optimizer/util/relnode.c:192">build_simple_rel</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Construct a new RelOptInfo for a base relation or 'other' relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RelOptInfo *<br/></li>
<li><a id="L192">&#x200c;</a><span class="linkable">build_simple_rel</span>(PlannerInfo *root, <span class="Type">int</span> relid, RelOptInfo *parent)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *rel;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Rel should not exist already */<br/></li>
<li></span>&nbsp; &nbsp; Assert(relid &gt; <span class="Constant">0</span> &amp;&amp; relid &lt; root-&gt;simple_rel_array_size);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;simple_rel_array[relid] != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;rel </span><span class="Special">%d</span><span class="Constant"> already exists&quot;</span>, relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch RTE for relation */<br/></li>
<li></span>&nbsp; &nbsp; rte = root-&gt;simple_rte_array[relid];<br/></li>
<li>&nbsp; &nbsp; Assert(rte != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel = makeNode(RelOptInfo);<br/></li>
<li>&nbsp; &nbsp; rel-&gt;reloptkind = parent ? RELOPT_OTHER_MEMBER_REL : RELOPT_BASEREL;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;relids = <a href="../../nodes/bitmapset.c.html#L216" title="nodes/bitmapset.c:216">bms_make_singleton</a>(relid);<br/></li>
<li>&nbsp; &nbsp; rel-&gt;rows = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cheap startup cost is interesting iff not all tuples to be retrieved */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;consider_startup = (root-&gt;tuple_fraction &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; rel-&gt;consider_param_startup = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* might get changed later */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;consider_parallel = <span class="Constant">false</span>; <span class="Comment">/* might get changed later */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;reltarget = <a href="tlist.c.html#L681" title="optimizer/util/tlist.c:681">create_empty_pathtarget</a>();<br/></li>
<li>&nbsp; &nbsp; rel-&gt;pathlist = NIL;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;ppilist = NIL;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;partial_pathlist = NIL;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;cheapest_startup_path = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;cheapest_total_path = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;cheapest_unique_path = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;cheapest_parameterized_paths = NIL;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;relid = relid;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;rtekind = rte-&gt;rtekind;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* min_attr, max_attr, attr_needed, attr_widths are set below */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;notnullattnums = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;lateral_vars = NIL;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;indexlist = NIL;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;statlist = NIL;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;pages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;tuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;allvisfrac = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;eclass_indexes = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;subroot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;subplan_params = NIL;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;rel_parallel_workers = -<span class="Constant">1</span>; <span class="Comment">/* set up in <a href="plancat.c.html#L115" title="optimizer/util/plancat.c:115">get_relation_info</a> */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;amflags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;serverid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind == RTE_RELATION)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(parent == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parent-&gt;rtekind == RTE_RELATION ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parent-&gt;rtekind == RTE_SUBQUERY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> RELATION rte, we need a userid with which to check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * permission access. Baserels simply use their own<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * RTEPermissionInfo's checkAsUser.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For otherrels normally there's no RTEPermissionInfo, so we use the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parent's, which normally has one. The exceptional case is that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parent is a subquery, in which case the otherrel will have its own.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;reloptkind == RELOPT_BASEREL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (rel-&gt;reloptkind == RELOPT_OTHER_MEMBER_REL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parent-&gt;rtekind == RTE_SUBQUERY))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTEPermissionInfo *perminfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perminfo = <a href="../../parser/parse_relation.c.html#L3903" title="parser/parse_relation.c:3903">getRTEPermissionInfo</a>(root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rteperminfos, rte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;userid = perminfo-&gt;checkAsUser;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;userid = parent-&gt;userid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;userid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;useridiscurrent = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;fdwroutine = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;fdw_private = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;unique_for_rels = NIL;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;non_unique_for_rels = NIL;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;baserestrictinfo = NIL;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;baserestrictcost.startup = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;baserestrictcost.per_tuple = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;baserestrict_min_security = <span class="Constant">UINT_MAX</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;joininfo = NIL;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;has_eclass_joins = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;consider_partitionwise_join = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* might get changed later */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;part_scheme = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;nparts = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;boundinfo = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;partbounds_merged = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;partition_qual = NIL;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;part_rels = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;live_parts = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;all_partrels = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;partexprs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;nullable_partexprs = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Pass assorted information down the inheritance hierarchy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We keep back-links to immediate parent and topmost parent. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;parent = parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;top_parent = parent-&gt;top_parent ? parent-&gt;top_parent : parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;top_parent_relids = rel-&gt;top_parent-&gt;relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A child rel is below the same outer joins as its parent.&nbsp; (We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * presume this info was already calculated for the parent.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;nulling_relids = parent-&gt;nulling_relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also propagate lateral-reference information from appendrel parent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rels to their child rels.&nbsp; We intentionally give each child rel the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * same minimum parameterization, even though it's quite possible that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * some don't reference all the lateral rels.&nbsp; This is because <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * append path for the parent will have to have the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parameterization for every child anyway, and there's no value in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * forcing extra <a href="pathnode.c.html#L3946" title="optimizer/util/pathnode.c:3946">reparameterize_path</a>() calls.&nbsp; Similarly, a lateral<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reference to the parent prevents use of otherwise-movable join rels<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for each child.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's possible for child rels to have their own children, in which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case the topmost parent's lateral info propagates all the way down.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;direct_lateral_relids = parent-&gt;direct_lateral_relids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;lateral_relids = parent-&gt;lateral_relids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;lateral_referencers = parent-&gt;lateral_referencers;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;parent = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;top_parent = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;top_parent_relids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;nulling_relids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;direct_lateral_relids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;lateral_relids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;lateral_referencers = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check type of rtable entry */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (rte-&gt;rtekind)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_RELATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Table --- retrieve statistics from the system catalogs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="plancat.c.html#L115" title="optimizer/util/plancat.c:115">get_relation_info</a>(root, rte-&gt;relid, rte-&gt;inh, rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_SUBQUERY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_FUNCTION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_TABLEFUNC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_VALUES:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_CTE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_NAMEDTUPLESTORE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Subquery, function, tablefunc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> list, CTE, or ENR --- set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * up attr <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> and arrays<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: 0 is included in <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> to support whole-row Vars<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;min_attr = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;max_attr = list_length(rte-&gt;eref-&gt;colnames);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;attr_needed = (Relids *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>((rel-&gt;max_attr - rel-&gt;min_attr + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Relids));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;attr_widths = (int32 *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>((rel-&gt;max_attr - rel-&gt;min_attr + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int32));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_RESULT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* RTE_RESULT has no columns, nor could it have whole-row Var */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;min_attr = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;max_attr = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;attr_needed = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;attr_widths = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized RTE kind: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) rte-&gt;rtekind);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must apply the partially filled in RelOptInfo <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="inherit.c.html#L834" title="optimizer/util/inherit.c:834">apply_child_basequals</a> due to some transformations within that function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which require the RelOptInfo to be available in the simple_rel_array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;simple_rel_array[relid] = rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Apply the parent's quals to the child, with appropriate substitution of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * variables.&nbsp; If the resulting clause is constant-FALSE or NULL after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * applying transformations, <a href="inherit.c.html#L834" title="optimizer/util/inherit.c:834">apply_child_basequals</a> returns false to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indicate that scanning this relation won't yield <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> rows.&nbsp; In this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case, we mark the child as dummy right away.&nbsp; (We must do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * immediately so that pruning works correctly when recursing in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="inherit.c.html#L318" title="optimizer/util/inherit.c:318">expand_partitioned_rtentry</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AppendRelInfo *appinfo = root-&gt;append_rel_array[relid];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(appinfo != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="inherit.c.html#L834" title="optimizer/util/inherit.c:834">apply_child_basequals</a>(root, parent, rel, rte, appinfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Restriction clause reduced to constant FALSE or NULL.&nbsp; Mark as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dummy so we won't scan this relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/joinrels.c.html#L1381" title="optimizer/path/joinrels.c:1381">mark_dummy_rel</a>(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L414" title="optimizer/util/relnode.c:414">find_base_rel</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Find a base or otherrel relation entry, which must already exist.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RelOptInfo *<br/></li>
<li><a id="L414">&#x200c;</a><span class="linkable">find_base_rel</span>(PlannerInfo *root, <span class="Type">int</span> relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* use an unsigned comparison to prevent negative array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> access */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((uint32) relid &lt; (uint32) root-&gt;simple_rel_array_size)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel = root-&gt;simple_rel_array[relid];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> rel;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;no relation entry for relid </span><span class="Special">%d</span><span class="Constant">&quot;</span>, relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L436" title="optimizer/util/relnode.c:436">find_base_rel_noerr</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Find a base or otherrel relation entry, returning NULL if there's <a href="predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RelOptInfo *<br/></li>
<li><a id="L436">&#x200c;</a><span class="linkable">find_base_rel_noerr</span>(PlannerInfo *root, <span class="Type">int</span> relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* use an unsigned comparison to prevent negative array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> access */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((uint32) relid &lt; (uint32) root-&gt;simple_rel_array_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> root-&gt;simple_rel_array[relid];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L454" title="optimizer/util/relnode.c:454">find_base_rel_ignore_join</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Find a base or otherrel relation entry, which must already exist.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike <a href="#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>, if relid references an outer join then this<br/></li>
<li></span><span class="Comment"> * will return NULL rather than raising an error.&nbsp; This is convenient<br/></li>
<li></span><span class="Comment"> * for callers that must deal with relid sets including both base and<br/></li>
<li></span><span class="Comment"> * outer joins.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RelOptInfo *<br/></li>
<li><a id="L454">&#x200c;</a><span class="linkable">find_base_rel_ignore_join</span>(PlannerInfo *root, <span class="Type">int</span> relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* use an unsigned comparison to prevent negative array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> access */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((uint32) relid &lt; (uint32) root-&gt;simple_rel_array_size)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel = root-&gt;simple_rel_array[relid];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We could just return NULL here, but for debugging purposes it seems<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * best to actually verify that the relid is an outer join and not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * something weird.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rte = root-&gt;simple_rte_array[relid];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte &amp;&amp; rte-&gt;rtekind == RTE_JOIN &amp;&amp; rte-&gt;jointype != JOIN_INNER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;no relation entry for relid </span><span class="Special">%d</span><span class="Constant">&quot;</span>, relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L486" title="optimizer/util/relnode.c:486">build_join_rel_hash</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Construct the auxiliary <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table for join relations.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L486">&#x200c;</a></span><span class="linkable">build_join_rel_hash</span>(PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a>&nbsp; &nbsp; &nbsp;&nbsp; *hashtab;<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; hash_ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Relids);<br/></li>
<li>&nbsp; &nbsp; hash_ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L38" title="optimizer/util/relnode.c:38">JoinHashEntry</a>);<br/></li>
<li>&nbsp; &nbsp; hash_ctl.<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = <a href="../../nodes/bitmapset.c.html#L1432" title="nodes/bitmapset.c:1432">bitmap_hash</a>;<br/></li>
<li>&nbsp; &nbsp; hash_ctl.match = <a href="../../nodes/bitmapset.c.html#L1442" title="nodes/bitmapset.c:1442">bitmap_match</a>;<br/></li>
<li>&nbsp; &nbsp; hash_ctl.hcxt = <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; hashtab = <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;JoinRelHashTable&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">256L</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;hash_ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_FUNCTION | HASH_COMPARE | HASH_CONTEXT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> all the already-existing joinrels */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, root-&gt;join_rel_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel = (RelOptInfo *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L38" title="optimizer/util/relnode.c:38">JoinHashEntry</a> *hentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hentry = (<a href="#L38" title="optimizer/util/relnode.c:38">JoinHashEntry</a> *) <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(hashtab,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;(rel-&gt;relids),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ENTER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hentry-&gt;join_rel = rel;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; root-&gt;join_rel_hash = hashtab;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L527" title="optimizer/util/relnode.c:527">find_join_rel</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Returns relation entry corresponding to 'relids' (a set of RT indexes),<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; or NULL if <a href="predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> exists.&nbsp; This is for join relations.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RelOptInfo *<br/></li>
<li><a id="L527">&#x200c;</a><span class="linkable">find_join_rel</span>(PlannerInfo *root, Relids relids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Switch to using <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> lookup when list grows &quot;too long&quot;.&nbsp; The threshold<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is arbitrary and is known only here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!root-&gt;join_rel_hash &amp;&amp; list_length(root-&gt;join_rel_list) &gt; <span class="Constant">32</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L486" title="optimizer/util/relnode.c:486">build_join_rel_hash</a>(root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use either hashtable lookup or linear search, as appropriate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: the seemingly redundant hashkey variable is used to avoid taking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the address of relids; unless the compiler is exceedingly smart, doing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so would force relids out of a register and thus probably slow down the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list-search case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;join_rel_hash)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; hashkey = relids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L38" title="optimizer/util/relnode.c:38">JoinHashEntry</a> *hentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hentry = (<a href="#L38" title="optimizer/util/relnode.c:38">JoinHashEntry</a> *) <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(root-&gt;join_rel_hash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;hashkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_FIND,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hentry)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> hentry-&gt;join_rel;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, root-&gt;join_rel_list)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel = (RelOptInfo *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(rel-&gt;relids, relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L589" title="optimizer/util/relnode.c:589">set_foreign_rel_properties</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set up foreign-join fields if outer and inner relation are foreign<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; tables (or joins) belonging to the same server and assigned to the same<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; user to check access permissions as.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In addition to an exact match of userid, we allow the case where one side<br/></li>
<li></span><span class="Comment"> * has zero userid (implying current user) and the other side has explicit<br/></li>
<li></span><span class="Comment"> * userid that happens to <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> the current user; but in that case, pushdown of<br/></li>
<li></span><span class="Comment"> * the join is only valid for the current user.&nbsp; The useridiscurrent field<br/></li>
<li></span><span class="Comment"> * <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> whether we had to make such an assumption for this join or <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * sub-join.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Otherwise these fields are left invalid, so GetForeignJoinPaths will not be<br/></li>
<li></span><span class="Comment"> * called for the join relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L589">&#x200c;</a></span><span class="linkable">set_foreign_rel_properties</span>(RelOptInfo *joinrel, RelOptInfo *outer_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *inner_rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(outer_rel-&gt;serverid) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inner_rel-&gt;serverid == outer_rel-&gt;serverid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (inner_rel-&gt;userid == outer_rel-&gt;userid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrel-&gt;serverid = outer_rel-&gt;serverid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrel-&gt;userid = outer_rel-&gt;userid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrel-&gt;useridiscurrent = outer_rel-&gt;useridiscurrent || inner_rel-&gt;useridiscurrent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrel-&gt;fdwroutine = outer_rel-&gt;fdwroutine;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!OidIsValid(inner_rel-&gt;userid) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outer_rel-&gt;userid == <a href="../../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrel-&gt;serverid = outer_rel-&gt;serverid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrel-&gt;userid = outer_rel-&gt;userid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrel-&gt;useridiscurrent = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrel-&gt;fdwroutine = outer_rel-&gt;fdwroutine;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!OidIsValid(outer_rel-&gt;userid) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inner_rel-&gt;userid == <a href="../../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrel-&gt;serverid = outer_rel-&gt;serverid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrel-&gt;userid = inner_rel-&gt;userid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrel-&gt;useridiscurrent = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrel-&gt;fdwroutine = outer_rel-&gt;fdwroutine;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L627" title="optimizer/util/relnode.c:627">add_join_rel</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Add given join relation to the list of join relations in the given<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; PlannerInfo. Also add it to the auxiliary hashtable if there is one.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L627">&#x200c;</a></span><span class="linkable">add_join_rel</span>(PlannerInfo *root, RelOptInfo *joinrel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* GEQO requires us to append the new joinrel to the end of the list! */<br/></li>
<li></span>&nbsp; &nbsp; root-&gt;join_rel_list = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;join_rel_list, joinrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* store it into the auxiliary hashtable if there is one. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;join_rel_hash)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L38" title="optimizer/util/relnode.c:38">JoinHashEntry</a> *hentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hentry = (<a href="#L38" title="optimizer/util/relnode.c:38">JoinHashEntry</a> *) <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(root-&gt;join_rel_hash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;(joinrel-&gt;relids),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ENTER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hentry-&gt;join_rel = joinrel;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L665" title="optimizer/util/relnode.c:665">build_join_rel</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Returns relation entry corresponding to the union of two given rels,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; creating a new relation entry if <a href="predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> already exists.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'joinrelids' is the Relids set that uniquely identifies the join<br/></li>
<li></span><span class="Comment"> * 'outer_rel' and 'inner_rel' are relation nodes for the relations to be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; joined<br/></li>
<li></span><span class="Comment"> * 'sjinfo': join context info<br/></li>
<li></span><span class="Comment"> * 'pushed_down_joins': <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pushed-down outer joins that are <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> completed<br/></li>
<li></span><span class="Comment"> * 'restrictlist_ptr': result variable.&nbsp; If not NULL, *restrictlist_ptr<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; receives the list of RestrictInfo nodes that apply to this<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; particular pair of joinable relations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * restrictlist_ptr makes the routine's API a little grotty, but it saves<br/></li>
<li></span><span class="Comment"> * duplicated calculation of the restrictlist...<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RelOptInfo *<br/></li>
<li><a id="L665">&#x200c;</a><span class="linkable">build_join_rel</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids joinrelids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *outer_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *inner_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SpecialJoinInfo *sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *pushed_down_joins,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **restrictlist_ptr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *joinrel;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *restrictlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This function should be used only for join between parents. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!IS_OTHER_REL(outer_rel) &amp;&amp; !IS_OTHER_REL(inner_rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See if we already have a joinrel for this set of base rels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; joinrel = <a href="#L527" title="optimizer/util/relnode.c:527">find_join_rel</a>(root, joinrelids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (joinrel)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Yes, so we only need to figure the restrictlist for this particular<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pair of component relations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (restrictlist_ptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *restrictlist_ptr = <a href="#L1297" title="optimizer/util/relnode.c:1297">build_joinrel_restrictlist</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outer_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inner_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sjinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> joinrel;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Nope, so make one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; joinrel = makeNode(RelOptInfo);<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;reloptkind = RELOPT_JOINREL;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;relids = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(joinrelids);<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;rows = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cheap startup cost is interesting iff not all tuples to be retrieved */<br/></li>
<li></span>&nbsp; &nbsp; joinrel-&gt;consider_startup = (root-&gt;tuple_fraction &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;consider_param_startup = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;consider_parallel = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;reltarget = <a href="tlist.c.html#L681" title="optimizer/util/tlist.c:681">create_empty_pathtarget</a>();<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;pathlist = NIL;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;ppilist = NIL;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;partial_pathlist = NIL;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;cheapest_startup_path = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;cheapest_total_path = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;cheapest_unique_path = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;cheapest_parameterized_paths = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* init direct_lateral_relids from children; we'll finish it up below */<br/></li>
<li></span>&nbsp; &nbsp; joinrel-&gt;direct_lateral_relids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(outer_rel-&gt;direct_lateral_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inner_rel-&gt;direct_lateral_relids);<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;lateral_relids = <a href="#L1034" title="optimizer/util/relnode.c:1034">min_join_parameterization</a>(root, joinrel-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_rel, inner_rel);<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;relid = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* indicates not a baserel */<br/></li>
<li></span>&nbsp; &nbsp; joinrel-&gt;rtekind = RTE_JOIN;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;min_attr = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;max_attr = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;attr_needed = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;attr_widths = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;notnullattnums = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;nulling_relids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;lateral_vars = NIL;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;lateral_referencers = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;indexlist = NIL;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;statlist = NIL;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;pages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;tuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;allvisfrac = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;eclass_indexes = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;subroot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;subplan_params = NIL;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;rel_parallel_workers = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;amflags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;serverid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;userid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;useridiscurrent = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;fdwroutine = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;fdw_private = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;unique_for_rels = NIL;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;non_unique_for_rels = NIL;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;baserestrictinfo = NIL;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;baserestrictcost.startup = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;baserestrictcost.per_tuple = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;baserestrict_min_security = <span class="Constant">UINT_MAX</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;joininfo = NIL;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;has_eclass_joins = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;consider_partitionwise_join = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* might get changed later */<br/></li>
<li></span>&nbsp; &nbsp; joinrel-&gt;parent = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;top_parent = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;top_parent_relids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;part_scheme = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;nparts = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;boundinfo = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;partbounds_merged = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;partition_qual = NIL;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;part_rels = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;live_parts = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;all_partrels = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;partexprs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;nullable_partexprs = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute information relevant to the foreign relations. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L589" title="optimizer/util/relnode.c:589">set_foreign_rel_properties</a>(joinrel, outer_rel, inner_rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fill the joinrel's tlist with just the Vars and PHVs that need to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * output from this join (ie, are needed for higher joinclauses or final<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * output).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: the tlist order for a join rel will depend on which pair of outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and inner rels we first try to build it from.&nbsp; But the contents should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be the same regardless.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1112" title="optimizer/util/relnode.c:1112">build_joinrel_tlist</a>(root, joinrel, outer_rel, sjinfo, pushed_down_joins,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (sjinfo-&gt;jointype == JOIN_FULL));<br/></li>
<li>&nbsp; &nbsp; <a href="#L1112" title="optimizer/util/relnode.c:1112">build_joinrel_tlist</a>(root, joinrel, inner_rel, sjinfo, pushed_down_joins,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (sjinfo-&gt;jointype != JOIN_INNER));<br/></li>
<li>&nbsp; &nbsp; <a href="placeholder.c.html#L373" title="optimizer/util/placeholder.c:373">add_placeholders_to_joinrel</a>(root, joinrel, outer_rel, inner_rel, sjinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="placeholder.c.html#L373" title="optimizer/util/placeholder.c:373">add_placeholders_to_joinrel</a> also took care of adding the ph_lateral<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sets of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> PlaceHolderVars computed here to direct_lateral_relids, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we can finish computing that.&nbsp; This is much like the computation of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the transitively-closed lateral_relids in <a href="#L1034" title="optimizer/util/relnode.c:1034">min_join_parameterization</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * except that here we *do* have to consider the added PHVs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; joinrel-&gt;direct_lateral_relids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L1161" title="nodes/bitmapset.c:1161">bms_del_members</a>(joinrel-&gt;direct_lateral_relids, joinrel-&gt;relids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Construct restrict and join clause lists for the new joinrel. (The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * caller might or might not need the restrictlist, but I need it anyway<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for <a href="../path/costsize.c.html#L5318" title="optimizer/path/costsize.c:5318">set_joinrel_size_estimates</a>().)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; restrictlist = <a href="#L1297" title="optimizer/util/relnode.c:1297">build_joinrel_restrictlist</a>(root, joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_rel, inner_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sjinfo);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (restrictlist_ptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *restrictlist_ptr = restrictlist;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1334" title="optimizer/util/relnode.c:1334">build_joinrel_joinlist</a>(joinrel, outer_rel, inner_rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is also the right place to check whether the joinrel has <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pending EquivalenceClass joins.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; joinrel-&gt;has_eclass_joins = <a href="../path/equivclass.c.html#L3179" title="optimizer/path/equivclass.c:3179">has_relevant_eclass_joinclause</a>(root, joinrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Store the partition information. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2017" title="optimizer/util/relnode.c:2017">build_joinrel_partition_info</a>(root, joinrel, outer_rel, inner_rel, sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; restrictlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set estimates of the joinrel's size.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../path/costsize.c.html#L5318" title="optimizer/path/costsize.c:5318">set_joinrel_size_estimates</a>(root, joinrel, outer_rel, inner_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sjinfo, restrictlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set the consider_parallel flag if this joinrel could potentially be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scanned within a parallel worker.&nbsp; If this flag is false for either<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inner_rel or outer_rel, then it must be false for the joinrel also.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Even if both are true, there might be parallel-restricted expressions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the targetlist or quals.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that if there are more than two rels in this relation, they could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be divided between inner_rel and outer_rel in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> arbitrary way.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assume this doesn't matter, because we should hit all the same baserels<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and joinclauses while building up to this joinrel no matter which we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * take; therefore, we should make the same decision here however we get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (inner_rel-&gt;consider_parallel &amp;&amp; outer_rel-&gt;consider_parallel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="clauses.c.html#L753" title="optimizer/util/clauses.c:753">is_parallel_safe</a>(root, (Node *) restrictlist) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="clauses.c.html#L753" title="optimizer/util/clauses.c:753">is_parallel_safe</a>(root, (Node *) joinrel-&gt;reltarget-&gt;exprs))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; joinrel-&gt;consider_parallel = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add the joinrel to the PlannerInfo. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L627" title="optimizer/util/relnode.c:627">add_join_rel</a>(root, joinrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, if dynamic-programming join search is active, add the new joinrel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the appropriate sublist.&nbsp; Note: you might think the Assert on number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of members should be for equality, but some of the level 1 rels might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have been joinrels already, so we can only assert &lt;=.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;join_rel_level)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(root-&gt;join_cur_level &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(root-&gt;join_cur_level &lt;= <a href="../../nodes/bitmapset.c.html#L751" title="nodes/bitmapset.c:751">bms_num_members</a>(joinrel-&gt;relids));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;join_rel_level[root-&gt;join_cur_level] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;join_rel_level[root-&gt;join_cur_level], joinrel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> joinrel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L881" title="optimizer/util/relnode.c:881">build_child_join_rel</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Builds RelOptInfo representing join between given two child relations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'outer_rel' and 'inner_rel' are the RelOptInfos of child relations being<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; joined<br/></li>
<li></span><span class="Comment"> * 'parent_joinrel' is the RelOptInfo representing the join between parent<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; relations. Some of the members of new RelOptInfo are produced by<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; translating corresponding members of this RelOptInfo<br/></li>
<li></span><span class="Comment"> * 'restrictlist': list of RestrictInfo nodes that apply to this particular<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; pair of joinable relations<br/></li>
<li></span><span class="Comment"> * 'sjinfo': child join's join-type details<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RelOptInfo *<br/></li>
<li><a id="L881">&#x200c;</a><span class="linkable">build_child_join_rel</span>(PlannerInfo *root, RelOptInfo *outer_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *inner_rel, RelOptInfo *parent_joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *restrictlist, SpecialJoinInfo *sjinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *joinrel = makeNode(RelOptInfo);<br/></li>
<li>&nbsp; &nbsp; AppendRelInfo **appinfos;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nappinfos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Only joins between &quot;other&quot; relations land here. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(IS_OTHER_REL(outer_rel) &amp;&amp; IS_OTHER_REL(inner_rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The parent joinrel should have consider_partitionwise_join set. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(parent_joinrel-&gt;consider_partitionwise_join);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find the AppendRelInfo structures for the child baserels.&nbsp; We'll need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * these for computing the child join's relid set, and later for mapping<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Vars to the child rel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; appinfos = <a href="appendinfo.c.html#L733" title="optimizer/util/appendinfo.c:733">find_appinfos_by_relids</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(outer_rel-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inner_rel-&gt;relids),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;nappinfos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;reloptkind = RELOPT_OTHER_JOINREL;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;relids = <a href="appendinfo.c.html#L554" title="optimizer/util/appendinfo.c:554">adjust_child_relids</a>(parent_joinrel-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nappinfos, appinfos);<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;rows = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cheap startup cost is interesting iff not all tuples to be retrieved */<br/></li>
<li></span>&nbsp; &nbsp; joinrel-&gt;consider_startup = (root-&gt;tuple_fraction &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;consider_param_startup = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;consider_parallel = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;reltarget = <a href="tlist.c.html#L681" title="optimizer/util/tlist.c:681">create_empty_pathtarget</a>();<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;pathlist = NIL;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;ppilist = NIL;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;partial_pathlist = NIL;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;cheapest_startup_path = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;cheapest_total_path = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;cheapest_unique_path = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;cheapest_parameterized_paths = NIL;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;direct_lateral_relids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;lateral_relids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;relid = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* indicates not a baserel */<br/></li>
<li></span>&nbsp; &nbsp; joinrel-&gt;rtekind = RTE_JOIN;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;min_attr = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;max_attr = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;attr_needed = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;attr_widths = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;notnullattnums = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;nulling_relids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;lateral_vars = NIL;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;lateral_referencers = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;indexlist = NIL;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;pages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;tuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;allvisfrac = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;eclass_indexes = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;subroot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;subplan_params = NIL;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;amflags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;serverid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;userid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;useridiscurrent = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;fdwroutine = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;fdw_private = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;baserestrictinfo = NIL;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;baserestrictcost.startup = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;baserestrictcost.per_tuple = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;joininfo = NIL;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;has_eclass_joins = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;consider_partitionwise_join = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* might get changed later */<br/></li>
<li></span>&nbsp; &nbsp; joinrel-&gt;parent = parent_joinrel;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;top_parent = parent_joinrel-&gt;top_parent ? parent_joinrel-&gt;top_parent : parent_joinrel;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;top_parent_relids = joinrel-&gt;top_parent-&gt;relids;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;part_scheme = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;nparts = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;boundinfo = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;partbounds_merged = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;partition_qual = NIL;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;part_rels = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;live_parts = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;all_partrels = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;partexprs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;nullable_partexprs = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute information relevant to foreign relations. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L589" title="optimizer/util/relnode.c:589">set_foreign_rel_properties</a>(joinrel, outer_rel, inner_rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up reltarget struct */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2425" title="optimizer/util/relnode.c:2425">build_child_join_reltarget</a>(root, parent_joinrel, joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nappinfos, appinfos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Construct joininfo list. */<br/></li>
<li></span>&nbsp; &nbsp; joinrel-&gt;joininfo = (List *) <a href="appendinfo.c.html#L196" title="optimizer/util/appendinfo.c:196">adjust_appendrel_attrs</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Node *) parent_joinrel-&gt;joininfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nappinfos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appinfos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lateral relids referred in child join will be same as that referred in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the parent relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; joinrel-&gt;direct_lateral_relids = (Relids) <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(parent_joinrel-&gt;direct_lateral_relids);<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;lateral_relids = (Relids) <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(parent_joinrel-&gt;lateral_relids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the parent joinrel has pending equivalence classes, so does the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * child.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; joinrel-&gt;has_eclass_joins = parent_joinrel-&gt;has_eclass_joins;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Is the join between partitions itself partitioned? */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2017" title="optimizer/util/relnode.c:2017">build_joinrel_partition_info</a>(root, joinrel, outer_rel, inner_rel, sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; restrictlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Child joinrel is parallel safe if parent is parallel safe. */<br/></li>
<li></span>&nbsp; &nbsp; joinrel-&gt;consider_parallel = parent_joinrel-&gt;consider_parallel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set estimates of the child-joinrel's size. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../path/costsize.c.html#L5318" title="optimizer/path/costsize.c:5318">set_joinrel_size_estimates</a>(root, joinrel, outer_rel, inner_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sjinfo, restrictlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We build the join only once. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!<a href="#L527" title="optimizer/util/relnode.c:527">find_join_rel</a>(root, joinrel-&gt;relids));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add the relation to the PlannerInfo. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L627" title="optimizer/util/relnode.c:627">add_join_rel</a>(root, joinrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We might need EquivalenceClass members corresponding to the child join,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so that we can represent sort pathkeys for it.&nbsp; As with children of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * baserels, we shouldn't need this unless there are relevant <a href="../../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a> joins<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (implying that a <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> join might be possible) or pathkeys to sort by.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (joinrel-&gt;has_eclass_joins || <a href="../path/pathkeys.c.html#L2261" title="optimizer/path/pathkeys.c:2261">has_useful_pathkeys</a>(root, parent_joinrel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/equivclass.c.html#L2769" title="optimizer/path/equivclass.c:2769">add_child_join_rel_equivalences</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nappinfos, appinfos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent_joinrel, joinrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(appinfos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> joinrel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1034" title="optimizer/util/relnode.c:1034">min_join_parameterization</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Determine the minimum possible parameterization of a joinrel, that is, the<br/></li>
<li></span><span class="Comment"> * set of other rels it contains LATERAL references to.&nbsp; We save this value in<br/></li>
<li></span><span class="Comment"> * the join's RelOptInfo.&nbsp; This function is split out of <a href="#L665" title="optimizer/util/relnode.c:665">build_join_rel</a>()<br/></li>
<li></span><span class="Comment"> * because <a href="../path/joinrels.c.html#L349" title="optimizer/path/joinrels.c:349">join_is_legal</a>() needs the value to check a prospective join.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Relids<br/></li>
<li><a id="L1034">&#x200c;</a><span class="linkable">min_join_parameterization</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids joinrelids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *outer_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *inner_rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Basically we just need the union of the inputs' lateral_relids, less<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whatever is already in the join.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's not immediately obvious that this is a valid way to compute the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * result, because it might seem that we're ignoring possible lateral refs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of PlaceHolderVars that are due to be computed at the join but not in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * either input.&nbsp; However, because <a href="../plan/initsplan.c.html#L501" title="optimizer/plan/initsplan.c:501">create_lateral_join_info</a>() already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * charged all such PHV refs to each member baserel of the join, they'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be accounted for already in the inputs' lateral_relids.&nbsp; Likewise, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do not need to worry about doing transitive closure here, because that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * was already accounted for in the original baserel lateral_relids.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(outer_rel-&gt;lateral_relids, inner_rel-&gt;lateral_relids);<br/></li>
<li>&nbsp; &nbsp; result = <a href="../../nodes/bitmapset.c.html#L1161" title="nodes/bitmapset.c:1161">bms_del_members</a>(result, joinrelids);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1112" title="optimizer/util/relnode.c:1112">build_joinrel_tlist</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Builds a join relation's target list from an input relation.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; (This is invoked twice to handle the two input relations.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The join's targetlist includes all Vars of its member relations that<br/></li>
<li></span><span class="Comment"> * will still be needed above the join.&nbsp; This subroutine adds all such<br/></li>
<li></span><span class="Comment"> * Vars from the specified input rel's tlist to the join rel's tlist.<br/></li>
<li></span><span class="Comment"> * Likewise for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> PlaceHolderVars emitted by the input rel.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also compute the expected width of the join's output, making use<br/></li>
<li></span><span class="Comment"> * of data that was cached at the baserel level by <a href="../path/costsize.c.html#L6099" title="optimizer/path/costsize.c:6099">set_rel_width</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Pass can_null as true if the join is an outer join that can null Vars<br/></li>
<li></span><span class="Comment"> * from this input relation.&nbsp; If so, we will (normally) add the join's relid<br/></li>
<li></span><span class="Comment"> * to the nulling bitmaps of Vars and PHVs bubbled up from the input.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When forming an outer join's target list, special handling is needed in<br/></li>
<li></span><span class="Comment"> * case the outer join was commuted with another one per outer join identity 3<br/></li>
<li></span><span class="Comment"> * (see optimizer/README).&nbsp; We must take steps to ensure that the output Vars<br/></li>
<li></span><span class="Comment"> * have the same nulling bitmaps that they would if the two joins had been<br/></li>
<li></span><span class="Comment"> * done in syntactic order; else they won't match Vars appearing higher in<br/></li>
<li></span><span class="Comment"> * the query tree.&nbsp; An exception to the match-the-syntactic-order rule is<br/></li>
<li></span><span class="Comment"> * that when an outer join is pushed down into another one's RHS per identity<br/></li>
<li></span><span class="Comment"> * 3, we can't mark its Vars as nulled until the <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-<a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> outer join is also<br/></li>
<li></span><span class="Comment"> * completed.&nbsp; So we need to do three things:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * First, we add the outer join's relid to the nulling bitmap only if the<br/></li>
<li></span><span class="Comment"> * outer join has been completely performed and the Var or PHV actually<br/></li>
<li></span><span class="Comment"> * comes from within the syntactically nullable side(s) of the outer join.<br/></li>
<li></span><span class="Comment"> * This takes care of the possibility that we have transformed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (A leftjoin B on (Pab)) leftjoin C on (Pbc)<br/></li>
<li></span><span class="Comment"> * to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; A leftjoin (B leftjoin C on (Pbc)) on (Pab)<br/></li>
<li></span><span class="Comment"> * Here the pushed-down B/C join cannot mark C columns as nulled yet,<br/></li>
<li></span><span class="Comment"> * while the <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-<a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> A/B join must not mark C columns as nulled by itself.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Second, perform the same operation for each SpecialJoinInfo listed in<br/></li>
<li></span><span class="Comment"> * pushed_down_joins (which, in this example, would be the B/C join when<br/></li>
<li></span><span class="Comment"> * we are at the <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-<a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> A/B join).&nbsp; This allows the <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-<a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> join to<br/></li>
<li></span><span class="Comment"> * complete the marking of &quot;C&quot; Vars that <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> have fully valid <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Third, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> relid in sjinfo-&gt;commute_above_r that is already part of<br/></li>
<li></span><span class="Comment"> * the joinrel is added to the nulling bitmaps of nullable Vars and PHVs.<br/></li>
<li></span><span class="Comment"> * This takes care of the reverse case where we implement<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; A leftjoin (B leftjoin C on (Pbc)) on (Pab)<br/></li>
<li></span><span class="Comment"> * as<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (A leftjoin B on (Pab)) leftjoin C on (Pbc)<br/></li>
<li></span><span class="Comment"> * The C columns emitted by the B/C join need to be shown as nulled by both<br/></li>
<li></span><span class="Comment"> * the B/C and A/B joins, even though they've not physically traversed the<br/></li>
<li></span><span class="Comment"> * A/B join.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1112">&#x200c;</a></span><span class="linkable">build_joinrel_tlist</span>(PlannerInfo *root, RelOptInfo *joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpecialJoinInfo *sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *pushed_down_joins,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> can_null)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; relids = joinrel-&gt;relids;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; tuple_width = joinrel-&gt;reltarget-&gt;width;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>, input_rel-&gt;reltarget-&gt;exprs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) lfirst(<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For a PlaceHolderVar, we have to look up the PlaceHolderInfo.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(var, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *phv = (PlaceHolderVar *) var;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderInfo *phinfo = <a href="placeholder.c.html#L83" title="optimizer/util/placeholder.c:83">find_placeholder_info</a>(root, phv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Is it still needed above this joinrel? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L641" title="nodes/bitmapset.c:641">bms_nonempty_difference</a>(phinfo-&gt;ph_needed, relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Yup, add it to the output.&nbsp; If this join potentially nulls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this input, we have to update the PHV's phnullingrels,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which means making a copy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (can_null)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phv = copyObject(phv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See comments above to understand this logic */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sjinfo-&gt;ojrelid != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(sjinfo-&gt;ojrelid, relids) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(phv-&gt;phrels, sjinfo-&gt;syn_righthand) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (sjinfo-&gt;jointype == JOIN_FULL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(phv-&gt;phrels, sjinfo-&gt;syn_lefthand))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phv-&gt;phnullingrels = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(phv-&gt;phnullingrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sjinfo-&gt;ojrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, pushed_down_joins)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpecialJoinInfo *othersj = (SpecialJoinInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(othersj-&gt;ojrelid, relids));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(phv-&gt;phrels, othersj-&gt;syn_righthand))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phv-&gt;phnullingrels = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(phv-&gt;phnullingrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; othersj-&gt;ojrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phv-&gt;phnullingrels =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L1230" title="nodes/bitmapset.c:1230">bms_join</a>(phv-&gt;phnullingrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/bitmapset.c.html#L292" title="nodes/bitmapset.c:292">bms_intersect</a>(sjinfo-&gt;commute_above_r,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relids));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrel-&gt;reltarget-&gt;exprs = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(joinrel-&gt;reltarget-&gt;exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Bubbling up the precomputed result has cost zero */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_width += phinfo-&gt;ph_width;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, anything in a baserel or joinrel targetlist ought to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a Var.&nbsp; (More general cases can only appear in appendrel child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rels, which will never be seen here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsA(var, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected node type in rel targetlist: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) nodeTag(var));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varno == ROWID_VAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* UPDATE/DELETE/MERGE row identity <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> are always needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RowIdentityVarInfo *ridinfo = (RowIdentityVarInfo *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_nth(root-&gt;row_identity_vars, var-&gt;varattno - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update reltarget width estimate from RowIdentityVarInfo */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_width += ridinfo-&gt;rowidwidth;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *baserel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the Var's original base rel */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; baserel = <a href="#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(root, var-&gt;varno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Is it still needed above this joinrel? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndx = var-&gt;varattno - baserel-&gt;min_attr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L641" title="nodes/bitmapset.c:641">bms_nonempty_difference</a>(baserel-&gt;attr_needed[ndx], relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nope, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update reltarget width estimate from baserel's attr_widths */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_width += baserel-&gt;attr_widths[ndx];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add the Var to the output.&nbsp; If this join potentially nulls this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * input, we have to update the Var's varnullingrels, which means<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * making a copy.&nbsp; But note that we don't ever add nullingrel bits to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * row identity Vars (cf. comments in setrefs.c).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (can_null &amp;&amp; var-&gt;varno != ROWID_VAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var = copyObject(var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See comments above to understand this logic */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sjinfo-&gt;ojrelid != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(sjinfo-&gt;ojrelid, relids) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(var-&gt;varno, sjinfo-&gt;syn_righthand) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (sjinfo-&gt;jointype == JOIN_FULL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(var-&gt;varno, sjinfo-&gt;syn_lefthand))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varnullingrels = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(var-&gt;varnullingrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sjinfo-&gt;ojrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, pushed_down_joins)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpecialJoinInfo *othersj = (SpecialJoinInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(othersj-&gt;ojrelid, relids));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(var-&gt;varno, othersj-&gt;syn_righthand))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varnullingrels = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(var-&gt;varnullingrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; othersj-&gt;ojrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varnullingrels =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L1230" title="nodes/bitmapset.c:1230">bms_join</a>(var-&gt;varnullingrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/bitmapset.c.html#L292" title="nodes/bitmapset.c:292">bms_intersect</a>(sjinfo-&gt;commute_above_r,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relids));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; joinrel-&gt;reltarget-&gt;exprs = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(joinrel-&gt;reltarget-&gt;exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Vars have cost zero, so no need to adjust reltarget-&gt;cost */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;reltarget-&gt;width = <a href="../path/costsize.c.html#L231" title="optimizer/path/costsize.c:231">clamp_width_est</a>(tuple_width);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1297" title="optimizer/util/relnode.c:1297">build_joinrel_restrictlist</a><br/></li>
<li></span><span class="Comment"> * <a href="#L1334" title="optimizer/util/relnode.c:1334">build_joinrel_joinlist</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; These routines build lists of restriction and join clauses for a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; join relation from the joininfo lists of the relations it joins.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; These routines are separate because the restriction list must be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; built afresh for each pair of input sub-relations we consider, whereas<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the join list need only be computed once for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> join RelOptInfo.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; The join list is fully determined by the set of rels making up the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; joinrel, so we should get the same results (up to ordering) from <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; candidate pair of sub-relations.&nbsp; But the restriction list is whatever<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; is not handled in the sub-relations, so it depends on which<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; sub-relations are considered.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; If a join clause from an input relation refers to base+OJ rels still not<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; present in the joinrel, then it is still a join clause for the joinrel;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; we put it into the joininfo list for the joinrel.&nbsp; Otherwise,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the clause is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> a restrict clause for the joined relation, and we<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; return it to the caller of <a href="#L1297" title="optimizer/util/relnode.c:1297">build_joinrel_restrictlist</a>() to be stored in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; join paths made from this pair of sub-relations.&nbsp; (It will not need to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; be considered further up the join tree.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; In many cases we will <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the same RestrictInfos in both input<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; relations' joinlists, so be careful to eliminate duplicates.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Pointer equality should be a sufficient test for dups, since all<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the various joinlist entries ultimately refer to RestrictInfos<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; pushed into them by <a href="../plan/initsplan.c.html#L2836" title="optimizer/plan/initsplan.c:2836">distribute_restrictinfo_to_rels</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'joinrel' is a join relation node<br/></li>
<li></span><span class="Comment"> * 'outer_rel' and 'inner_rel' are a pair of relations that can be joined<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; to form joinrel.<br/></li>
<li></span><span class="Comment"> * 'sjinfo': join context info<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L1297" title="optimizer/util/relnode.c:1297">build_joinrel_restrictlist</a>() returns a list of relevant restrictinfos,<br/></li>
<li></span><span class="Comment"> * whereas <a href="#L1334" title="optimizer/util/relnode.c:1334">build_joinrel_joinlist</a>() stores its results in the joinrel's<br/></li>
<li></span><span class="Comment"> * joininfo list.&nbsp; One or the other must <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> each given clause!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: Formerly, we made deep(!) copies of each input RestrictInfo to pass<br/></li>
<li></span><span class="Comment"> * up to the join relation.&nbsp; I believe this is no longer necessary, because<br/></li>
<li></span><span class="Comment"> * RestrictInfo nodes are no longer context-dependent.&nbsp; Instead, just include<br/></li>
<li></span><span class="Comment"> * the original nodes in the lists made for the join relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L1297">&#x200c;</a><span class="linkable">build_joinrel_restrictlist</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *outer_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *inner_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SpecialJoinInfo *sjinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; both_input_relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; both_input_relids = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(outer_rel-&gt;relids, inner_rel-&gt;relids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Collect all the clauses that syntactically belong at this level,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * eliminating <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> duplicates (important since we will see many of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same clauses arriving from both input relations).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="#L1352" title="optimizer/util/relnode.c:1352">subbuild_joinrel_restrictlist</a>(root, joinrel, outer_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; both_input_relids, NIL);<br/></li>
<li>&nbsp; &nbsp; result = <a href="#L1352" title="optimizer/util/relnode.c:1352">subbuild_joinrel_restrictlist</a>(root, joinrel, inner_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; both_input_relids, result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add on <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> clauses derived from EquivalenceClasses.&nbsp; These cannot be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * redundant with the clauses in the joininfo lists, so don't bother<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checking.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../path/equivclass.c.html#L1392" title="optimizer/path/equivclass.c:1392">generate_join_implied_equalities</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrel-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_rel-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inner_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sjinfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1334">&#x200c;</a></span><span class="linkable">build_joinrel_joinlist</span>(RelOptInfo *joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *outer_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *inner_rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Collect all the clauses that syntactically belong above this level,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * eliminating <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> duplicates (important since we will see many of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same clauses arriving from both input relations).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="#L1418" title="optimizer/util/relnode.c:1418">subbuild_joinrel_joinlist</a>(joinrel, outer_rel-&gt;joininfo, NIL);<br/></li>
<li>&nbsp; &nbsp; result = <a href="#L1418" title="optimizer/util/relnode.c:1418">subbuild_joinrel_joinlist</a>(joinrel, inner_rel-&gt;joininfo, result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;joininfo = result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> List *<br/></li>
<li><a id="L1352">&#x200c;</a><span class="linkable">subbuild_joinrel_restrictlist</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *input_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids both_input_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *new_restrictlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, input_rel-&gt;joininfo)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(rinfo-&gt;required_relids, joinrel-&gt;relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This clause should become a restriction clause for the joinrel,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since it refers to no outside rels.&nbsp; However, if it's a clone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clause then it might be too late to evaluate it, so we have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check.&nbsp; (If it is too late, just ignore the clause, taking it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on faith that another clone was or will be selected.)&nbsp; Clone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clauses should always be outer-join clauses, so we <a href="../geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * against both_input_relids.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rinfo-&gt;has_clone || rinfo-&gt;is_clone)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!RINFO_IS_PUSHED_DOWN(rinfo, joinrel-&gt;relids));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(rinfo-&gt;required_relids, both_input_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(rinfo-&gt;incompatible_relids, both_input_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For non-clone clauses, we just Assert it's OK.&nbsp; These might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be either join or filter clauses; if it's a join clause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then it should not refer to the current join's output.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (There is little point in checking incompatible_relids,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because it'll be NULL.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(RINFO_IS_PUSHED_DOWN(rinfo, joinrel-&gt;relids) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(rinfo-&gt;required_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; both_input_relids));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OK, so add it to the list, being careful to eliminate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * duplicates.&nbsp; (Since RestrictInfo nodes in different joinlists<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will have been multiply-linked rather than copied, pointer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * equality should be a sufficient test.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_restrictlist = <a href="../../nodes/list.c.html#L1356" title="nodes/list.c:1356">list_append_unique_ptr</a>(new_restrictlist, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This clause is still a join clause at this level, so we ignore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it in this routine.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> new_restrictlist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> List *<br/></li>
<li><a id="L1418">&#x200c;</a><span class="linkable">subbuild_joinrel_joinlist</span>(RelOptInfo *joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *joininfo_list,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *new_joininfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Expected to be called only for join between parent relations. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(joinrel-&gt;reloptkind == RELOPT_JOINREL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, joininfo_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(rinfo-&gt;required_relids, joinrel-&gt;relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This clause becomes a restriction clause for the joinrel, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it refers to no outside rels.&nbsp; So we can ignore it in this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * routine.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This clause is still a join clause at this level, so add it to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the new joininfo list, being careful to eliminate duplicates.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (Since RestrictInfo nodes in different joinlists will have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multiply-linked rather than copied, pointer equality should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a sufficient test.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_joininfo = <a href="../../nodes/list.c.html#L1356" title="nodes/list.c:1356">list_append_unique_ptr</a>(new_joininfo, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> new_joininfo;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1470" title="optimizer/util/relnode.c:1470">fetch_upper_rel</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Build a RelOptInfo describing some post-scan/join query processing,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; or return a pre-existing one if somebody already built it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * An &quot;<a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>&quot; relation is identified by an UpperRelationKind and a Relids set.<br/></li>
<li></span><span class="Comment"> * The meaning of the Relids set is not specified here, and very likely will<br/></li>
<li></span><span class="Comment"> * vary for different relation kinds.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Most of the fields in an <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level RelOptInfo are not used and are not<br/></li>
<li></span><span class="Comment"> * set here (though makeNode should ensure they're zeroes).&nbsp; We basically only<br/></li>
<li></span><span class="Comment"> * care about fields that are of interest to <a href="pathnode.c.html#L420" title="optimizer/util/pathnode.c:420">add_path</a>() and <a href="pathnode.c.html#L242" title="optimizer/util/pathnode.c:242">set_cheapest</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RelOptInfo *<br/></li>
<li><a id="L1470">&#x200c;</a><span class="linkable">fetch_upper_rel</span>(PlannerInfo *root, UpperRelationKind kind, Relids relids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *upperrel;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For the moment, our indexing data structure is just a List for each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation kind.&nbsp; If we ever get so many of one kind that this stops<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * working well, we can improve it.&nbsp; No code outside this function should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assume anything about how to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a particular upperrel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we already made this upperrel for the query, return it */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, root-&gt;upper_rels[kind])<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; upperrel = (RelOptInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(upperrel-&gt;relids, relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> upperrel;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; upperrel = makeNode(RelOptInfo);<br/></li>
<li>&nbsp; &nbsp; upperrel-&gt;reloptkind = RELOPT_UPPER_REL;<br/></li>
<li>&nbsp; &nbsp; upperrel-&gt;relids = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(relids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cheap startup cost is interesting iff not all tuples to be retrieved */<br/></li>
<li></span>&nbsp; &nbsp; upperrel-&gt;consider_startup = (root-&gt;tuple_fraction &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; upperrel-&gt;consider_param_startup = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; upperrel-&gt;consider_parallel = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* might get changed later */<br/></li>
<li></span>&nbsp; &nbsp; upperrel-&gt;reltarget = <a href="tlist.c.html#L681" title="optimizer/util/tlist.c:681">create_empty_pathtarget</a>();<br/></li>
<li>&nbsp; &nbsp; upperrel-&gt;pathlist = NIL;<br/></li>
<li>&nbsp; &nbsp; upperrel-&gt;cheapest_startup_path = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; upperrel-&gt;cheapest_total_path = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; upperrel-&gt;cheapest_unique_path = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; upperrel-&gt;cheapest_parameterized_paths = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; root-&gt;upper_rels[kind] = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;upper_rels[kind], upperrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> upperrel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1521" title="optimizer/util/relnode.c:1521">find_childrel_parents</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Compute the set of parent relids of an appendrel child rel.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since appendrels can be nested, a child could have multiple levels of<br/></li>
<li></span><span class="Comment"> * appendrel ancestors.&nbsp; This function computes a Relids set of all the<br/></li>
<li></span><span class="Comment"> * parent relation IDs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Relids<br/></li>
<li><a id="L1521">&#x200c;</a><span class="linkable">find_childrel_parents</span>(PlannerInfo *root, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(rel-&gt;reloptkind == RELOPT_OTHER_MEMBER_REL);<br/></li>
<li>&nbsp; &nbsp; Assert(rel-&gt;relid &gt; <span class="Constant">0</span> &amp;&amp; rel-&gt;relid &lt; root-&gt;simple_rel_array_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AppendRelInfo *appinfo = root-&gt;append_rel_array[rel-&gt;relid];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; prelid = appinfo-&gt;parent_relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(result, prelid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* traverse up to the parent rel, loop if it's also a child rel */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(root, prelid);<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (rel-&gt;reloptkind == RELOPT_OTHER_MEMBER_REL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(rel-&gt;reloptkind == RELOPT_BASEREL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1557" title="optimizer/util/relnode.c:1557">get_baserel_parampathinfo</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get the ParamPathInfo for a parameterized path for a base relation,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; constructing one if we don't have one already.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This centralizes estimating the rowcounts for parameterized paths.<br/></li>
<li></span><span class="Comment"> * We need to cache those to be sure we use the same rowcount for all paths<br/></li>
<li></span><span class="Comment"> * of the same parameterization for a given rel.&nbsp; This is also a convenient<br/></li>
<li></span><span class="Comment"> * place to determine which movable join clauses the parameterized path will<br/></li>
<li></span><span class="Comment"> * be responsible for evaluating.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ParamPathInfo *<br/></li>
<li><a id="L1557">&#x200c;</a><span class="linkable">get_baserel_parampathinfo</span>(PlannerInfo *root, RelOptInfo *baserel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids required_outer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParamPathInfo *ppi;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; joinrelids;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pclauses;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *eqclauses;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *pserials;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; rows;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If rel has LATERAL refs, every path for it should account for them */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(baserel-&gt;lateral_relids, required_outer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Unparameterized paths have no ParamPathInfo */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bms_is_empty(required_outer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(baserel-&gt;relids, required_outer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we already have a PPI for this parameterization, just return it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((ppi = <a href="#L1901" title="optimizer/util/relnode.c:1901">find_param_path_info</a>(baserel, required_outer)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ppi;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Identify all joinclauses that are movable to this base rel given this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parameterization.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; joinrelids = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(baserel-&gt;relids, required_outer);<br/></li>
<li>&nbsp; &nbsp; pclauses = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, baserel-&gt;joininfo)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="restrictinfo.c.html#L670" title="optimizer/util/restrictinfo.c:670">join_clause_is_movable_into</a>(rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; baserel-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrelids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pclauses = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(pclauses, rinfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add in joinclauses generated by EquivalenceClasses, too.&nbsp; (These<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * necessarily satisfy <a href="restrictinfo.c.html#L670" title="optimizer/util/restrictinfo.c:670">join_clause_is_movable_into</a>; but in assert-enabled<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * builds, let's verify that.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; eqclauses = <a href="../path/equivclass.c.html#L1392" title="optimizer/path/equivclass.c:1392">generate_join_implied_equalities</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; joinrelids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; required_outer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; baserel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, eqclauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="restrictinfo.c.html#L670" title="optimizer/util/restrictinfo.c:670">join_clause_is_movable_into</a>(rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; baserel-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; joinrelids));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; pclauses = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(pclauses, eqclauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute set of serial numbers of the enforced clauses */<br/></li>
<li></span>&nbsp; &nbsp; pserials = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, pclauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pserials = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(pserials, rinfo-&gt;rinfo_serial);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Estimate the number of rows returned by the parameterized scan */<br/></li>
<li></span>&nbsp; &nbsp; rows = <a href="../path/costsize.c.html#L5269" title="optimizer/path/costsize.c:5269">get_parameterized_baserel_size</a>(root, baserel, pclauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we can build the ParamPathInfo */<br/></li>
<li></span>&nbsp; &nbsp; ppi = makeNode(ParamPathInfo);<br/></li>
<li>&nbsp; &nbsp; ppi-&gt;ppi_req_outer = required_outer;<br/></li>
<li>&nbsp; &nbsp; ppi-&gt;ppi_rows = rows;<br/></li>
<li>&nbsp; &nbsp; ppi-&gt;ppi_clauses = pclauses;<br/></li>
<li>&nbsp; &nbsp; ppi-&gt;ppi_serials = pserials;<br/></li>
<li>&nbsp; &nbsp; baserel-&gt;ppilist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(baserel-&gt;ppilist, ppi);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ppi;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1671" title="optimizer/util/relnode.c:1671">get_joinrel_parampathinfo</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get the ParamPathInfo for a parameterized path for a join relation,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; constructing one if we don't have one already.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This centralizes estimating the rowcounts for parameterized paths.<br/></li>
<li></span><span class="Comment"> * We need to cache those to be sure we use the same rowcount for all paths<br/></li>
<li></span><span class="Comment"> * of the same parameterization for a given rel.&nbsp; This is also a convenient<br/></li>
<li></span><span class="Comment"> * place to determine which movable join clauses the parameterized path will<br/></li>
<li></span><span class="Comment"> * be responsible for evaluating.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * outer_path and inner_path are a pair of input paths that can be used to<br/></li>
<li></span><span class="Comment"> * construct the join, and restrict_clauses is the list of regular join<br/></li>
<li></span><span class="Comment"> * clauses (including clauses derived from EquivalenceClasses) that must be<br/></li>
<li></span><span class="Comment"> * applied at the join node when using these inputs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike the situation for base rels, the set of movable join clauses to be<br/></li>
<li></span><span class="Comment"> * enforced at a join varies with the selected pair of input paths, so we<br/></li>
<li></span><span class="Comment"> * must calculate that and pass it back, even if we already have a matching<br/></li>
<li></span><span class="Comment"> * ParamPathInfo.&nbsp; We handle this by adding <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> clauses moved down to this<br/></li>
<li></span><span class="Comment"> * join to *restrict_clauses, which is an in/out parameter.&nbsp; (The addition<br/></li>
<li></span><span class="Comment"> * is done in such a way as to not modify the passed-in List structure.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: when considering a nestloop join, the caller must have removed from<br/></li>
<li></span><span class="Comment"> * restrict_clauses <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> movable clauses that are themselves scheduled to be<br/></li>
<li></span><span class="Comment"> * pushed into the right-hand path.&nbsp; We do not do that here since it's<br/></li>
<li></span><span class="Comment"> * unnecessary for other join types.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ParamPathInfo *<br/></li>
<li><a id="L1671">&#x200c;</a><span class="linkable">get_joinrel_parampathinfo</span>(PlannerInfo *root, RelOptInfo *joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path *outer_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path *inner_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpecialJoinInfo *sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids required_outer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **restrict_clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParamPathInfo *ppi;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; join_and_req;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; outer_and_req;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; inner_and_req;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pclauses;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *eclauses;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *dropped_ecs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; rows;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If rel has LATERAL refs, every path for it should account for them */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(joinrel-&gt;lateral_relids, required_outer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Unparameterized paths have no ParamPathInfo or extra join clauses */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bms_is_empty(required_outer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(joinrel-&gt;relids, required_outer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Identify all joinclauses that are movable to this join rel given this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parameterization.&nbsp; These are the clauses that are movable into this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * join, but not movable into either input path.&nbsp; Treat an unparameterized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * input path as not accepting parameterized clauses (because it won't,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * per the shortcut exit above), even though the joinclause movement rules<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might allow the same clauses to be moved into a parameterized path for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that rel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; join_and_req = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(joinrel-&gt;relids, required_outer);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (outer_path-&gt;param_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; outer_and_req = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(outer_path-&gt;parent-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PATH_REQ_OUTER(outer_path));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; outer_and_req = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* outer path does not <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> parameters */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (inner_path-&gt;param_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inner_and_req = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(inner_path-&gt;parent-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PATH_REQ_OUTER(inner_path));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; inner_and_req = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* inner path does not <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> parameters */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; pclauses = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, joinrel-&gt;joininfo)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="restrictinfo.c.html#L670" title="optimizer/util/restrictinfo.c:670">join_clause_is_movable_into</a>(rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrel-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; join_and_req) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="restrictinfo.c.html#L670" title="optimizer/util/restrictinfo.c:670">join_clause_is_movable_into</a>(rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outer_path-&gt;parent-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outer_and_req) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="restrictinfo.c.html#L670" title="optimizer/util/restrictinfo.c:670">join_clause_is_movable_into</a>(rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inner_path-&gt;parent-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inner_and_req))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pclauses = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(pclauses, rinfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Consider joinclauses generated by EquivalenceClasses, too */<br/></li>
<li></span>&nbsp; &nbsp; eclauses = <a href="../path/equivclass.c.html#L1392" title="optimizer/path/equivclass.c:1392">generate_join_implied_equalities</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; join_and_req,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We only want ones that aren't movable to <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> levels */<br/></li>
<li></span>&nbsp; &nbsp; dropped_ecs = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, eclauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="restrictinfo.c.html#L670" title="optimizer/util/restrictinfo.c:670">join_clause_is_movable_into</a>(rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; joinrel-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; join_and_req));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="restrictinfo.c.html#L670" title="optimizer/util/restrictinfo.c:670">join_clause_is_movable_into</a>(rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_path-&gt;parent-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_and_req))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* drop if movable into LHS */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="restrictinfo.c.html#L670" title="optimizer/util/restrictinfo.c:670">join_clause_is_movable_into</a>(rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inner_path-&gt;parent-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inner_and_req))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* drop if movable into RHS, but remember EC for use below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rinfo-&gt;left_ec == rinfo-&gt;right_ec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dropped_ecs = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(dropped_ecs, rinfo-&gt;left_ec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pclauses = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(pclauses, rinfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * EquivalenceClasses are harder to deal with than we could wish, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the fact that a given EC can generate different clauses depending on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * context.&nbsp; Suppose we have an EC {X.X, Y.Y, Z.Z} where X and Y are the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LHS and RHS of the current join and Z is in required_outer, and further<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * suppose that the inner_path is parameterized by both X and Z.&nbsp; The code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * above will have produced either Z.Z = X.X or Z.Z = Y.Y from that EC,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and in the latter case will have discarded it as being movable into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * RHS.&nbsp; However, the EC machinery might have produced either Y.Y = X.X or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Y.Y = Z.Z as the EC enforcement clause within the inner_path; it will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not have produced both, and we can't readily tell from here which one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it did pick.&nbsp; If we add no clause to this join, we'll end up with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * insufficient enforcement of the EC; either Z.Z or X.X will fail to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constrained to be <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the other members of the EC.&nbsp; (When we come<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to join Z to this X/Y path, we will certainly drop whichever EC clause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is generated at that join, so this omission won't get fixed later.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To handle this, for each EC we discarded such a clause from, try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * generate a clause connecting the required_outer rels to the join's LHS<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (&quot;Z.Z = X.X&quot; in the terms of the above example).&nbsp; If successful, and if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the clause can't be moved to the LHS, add it to the current join's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restriction clauses.&nbsp; (If an EC cannot generate such a clause then it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has nothing that needs to be enforced here, while if the clause can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * moved into the LHS then it should have been enforced within that path.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we don't need similar processing for ECs whose clause was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * considered to be movable into the LHS, because the LHS can't refer to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the RHS so there is no comparable ambiguity about what it might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * actually be enforcing internally.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dropped_ecs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; real_outer_and_req;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; real_outer_and_req = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(outer_path-&gt;parent-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; required_outer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eclauses =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/equivclass.c.html#L1492" title="optimizer/path/equivclass.c:1492">generate_join_implied_equalities_for_ecs</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dropped_ecs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; real_outer_and_req,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; required_outer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outer_path-&gt;parent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, eclauses)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="restrictinfo.c.html#L670" title="optimizer/util/restrictinfo.c:670">join_clause_is_movable_into</a>(rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outer_path-&gt;parent-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; real_outer_and_req));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="restrictinfo.c.html#L670" title="optimizer/util/restrictinfo.c:670">join_clause_is_movable_into</a>(rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outer_path-&gt;parent-&gt;relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outer_and_req))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pclauses = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(pclauses, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now, attach the identified moved-down clauses to the caller's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restrict_clauses list.&nbsp; By using <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a> in this order, we leave<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the original list structure of restrict_clauses undamaged.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *restrict_clauses = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(pclauses, *restrict_clauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we already have a PPI for this parameterization, just return it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((ppi = <a href="#L1901" title="optimizer/util/relnode.c:1901">find_param_path_info</a>(joinrel, required_outer)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ppi;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Estimate the number of rows returned by the parameterized join */<br/></li>
<li></span>&nbsp; &nbsp; rows = <a href="../path/costsize.c.html#L5350" title="optimizer/path/costsize.c:5350">get_parameterized_joinrel_size</a>(root, joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inner_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *restrict_clauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we can build the ParamPathInfo.&nbsp; No point in saving the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * input-pair-dependent clause list, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: in GEQO mode, we'll be called in a temporary memory context, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the joinrel structure is there too, so no problem.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ppi = makeNode(ParamPathInfo);<br/></li>
<li>&nbsp; &nbsp; ppi-&gt;ppi_req_outer = required_outer;<br/></li>
<li>&nbsp; &nbsp; ppi-&gt;ppi_rows = rows;<br/></li>
<li>&nbsp; &nbsp; ppi-&gt;ppi_clauses = NIL;<br/></li>
<li>&nbsp; &nbsp; ppi-&gt;ppi_serials = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;ppilist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(joinrel-&gt;ppilist, ppi);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ppi;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1868" title="optimizer/util/relnode.c:1868">get_appendrel_parampathinfo</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get the ParamPathInfo for a parameterized path for an append relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For an append relation, the rowcount estimate will just be the sum of<br/></li>
<li></span><span class="Comment"> * the estimates for its children.&nbsp; However, we still need a ParamPathInfo<br/></li>
<li></span><span class="Comment"> * to flag the fact that the path requires parameters.&nbsp; So this just creates<br/></li>
<li></span><span class="Comment"> * a suitable struct with zero ppi_rows (and no ppi_clauses either, since<br/></li>
<li></span><span class="Comment"> * the Append node isn't responsible for checking quals).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ParamPathInfo *<br/></li>
<li><a id="L1868">&#x200c;</a><span class="linkable">get_appendrel_parampathinfo</span>(RelOptInfo *appendrel, Relids required_outer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParamPathInfo *ppi;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If rel has LATERAL refs, every path for it should account for them */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(appendrel-&gt;lateral_relids, required_outer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Unparameterized paths have no ParamPathInfo */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bms_is_empty(required_outer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(appendrel-&gt;relids, required_outer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we already have a PPI for this parameterization, just return it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((ppi = <a href="#L1901" title="optimizer/util/relnode.c:1901">find_param_path_info</a>(appendrel, required_outer)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ppi;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Else build the ParamPathInfo */<br/></li>
<li></span>&nbsp; &nbsp; ppi = makeNode(ParamPathInfo);<br/></li>
<li>&nbsp; &nbsp; ppi-&gt;ppi_req_outer = required_outer;<br/></li>
<li>&nbsp; &nbsp; ppi-&gt;ppi_rows = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ppi-&gt;ppi_clauses = NIL;<br/></li>
<li>&nbsp; &nbsp; ppi-&gt;ppi_serials = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; appendrel-&gt;ppilist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(appendrel-&gt;ppilist, ppi);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ppi;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns a ParamPathInfo for the parameterization given by required_outer, if<br/></li>
<li></span><span class="Comment"> * already available in the given rel. Returns NULL otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ParamPathInfo *<br/></li>
<li><a id="L1901">&#x200c;</a><span class="linkable">find_param_path_info</span>(RelOptInfo *rel, Relids required_outer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, rel-&gt;ppilist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ParamPathInfo *ppi = (ParamPathInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(ppi-&gt;ppi_req_outer, required_outer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ppi;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1922" title="optimizer/util/relnode.c:1922">get_param_path_clause_serials</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given a parameterized Path, return the set of pushed-down clauses<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (identified by rinfo_serial numbers) enforced within the Path.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Bitmapset *<br/></li>
<li><a id="L1922">&#x200c;</a><span class="linkable">get_param_path_clause_serials</span>(Path *path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (path-&gt;param_info == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not parameterized */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(path, NestPath) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IsA(path, MergePath) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IsA(path, HashPath))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For a join path, <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> clauses enforced within either input path<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with those enforced as joinrestrictinfo in this path.&nbsp; Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * joinrestrictinfo may include some non-pushed-down clauses, but for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current purposes it's okay if we include those in the result. (To<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be more careful, we could check for clause_relids overlapping the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * path parameterization, but it's not worth the cycles for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; JoinPath&nbsp;&nbsp; *jpath = (JoinPath *) path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *pserials;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pserials = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pserials = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(pserials,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1922" title="optimizer/util/relnode.c:1922">get_param_path_clause_serials</a>(jpath-&gt;outerjoinpath));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pserials = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(pserials,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1922" title="optimizer/util/relnode.c:1922">get_param_path_clause_serials</a>(jpath-&gt;innerjoinpath));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, jpath-&gt;joinrestrictinfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pserials = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(pserials, rinfo-&gt;rinfo_serial);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> pserials;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(path, AppendPath))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For an appendrel, take the intersection of the sets of clauses<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * enforced in each input path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; AppendPath *apath = (AppendPath *) path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *pserials;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pserials = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, apath-&gt;subpaths)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *subpath = (Path *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *subserials;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subserials = <a href="#L1922" title="optimizer/util/relnode.c:1922">get_param_path_clause_serials</a>(subpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lc == list_head(apath-&gt;subpaths))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pserials = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(subserials);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pserials = <a href="../../nodes/bitmapset.c.html#L1109" title="nodes/bitmapset.c:1109">bms_int_members</a>(pserials, subserials);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> pserials;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(path, MergeAppendPath))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Same as AppendPath case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MergeAppendPath *apath = (MergeAppendPath *) path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *pserials;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pserials = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, apath-&gt;subpaths)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *subpath = (Path *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *subserials;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subserials = <a href="#L1922" title="optimizer/util/relnode.c:1922">get_param_path_clause_serials</a>(subpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lc == list_head(apath-&gt;subpaths))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pserials = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(subserials);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pserials = <a href="../../nodes/bitmapset.c.html#L1109" title="nodes/bitmapset.c:1109">bms_int_members</a>(pserials, subserials);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> pserials;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, it's a baserel path and we can use the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * previously-computed set of serial numbers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> path-&gt;param_info-&gt;ppi_serials;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2017" title="optimizer/util/relnode.c:2017">build_joinrel_partition_info</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Checks if the two relations being joined can use partitionwise join<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and if yes, <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> partitioning information of the resulting<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; partitioned join relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2017">&#x200c;</a></span><span class="linkable">build_joinrel_partition_info</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *joinrel, RelOptInfo *outer_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *inner_rel, SpecialJoinInfo *sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *restrictlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PartitionScheme part_scheme;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do if partitionwise join technique is disabled. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../path/costsize.c.html#L148" title="optimizer/path/costsize.c:148">enable_partitionwise_join</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!IS_PARTITIONED_REL(joinrel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can only consider this join as an input to further partitionwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * joins if (a) the input relations are partitioned and have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consider_partitionwise_join=true, (b) the partition schemes match, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (c) we can identify an equi-join between the partition keys.&nbsp; Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if it were possible for <a href="#L2090" title="optimizer/util/relnode.c:2090">have_partkey_equi_join</a> to return different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * answers for the same joinrel depending on which join ordering we try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first, this logic would break.&nbsp; That shouldn't happen, though, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the way the query <a href="../plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> deduces implied equalities and reorders<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the joins.&nbsp; Please see optimizer/README for details.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (outer_rel-&gt;part_scheme == <span class="Constant">NULL</span> || inner_rel-&gt;part_scheme == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !outer_rel-&gt;consider_partitionwise_join ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !inner_rel-&gt;consider_partitionwise_join ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; outer_rel-&gt;part_scheme != inner_rel-&gt;part_scheme ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L2090" title="optimizer/util/relnode.c:2090">have_partkey_equi_join</a>(root, joinrel, outer_rel, inner_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sjinfo-&gt;jointype, restrictlist))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!IS_PARTITIONED_REL(joinrel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; part_scheme = outer_rel-&gt;part_scheme;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This function will be called only once for each joinrel, hence it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should not have partitioning fields filled yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!joinrel-&gt;part_scheme &amp;&amp; !joinrel-&gt;partexprs &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !joinrel-&gt;nullable_partexprs &amp;&amp; !joinrel-&gt;part_rels &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !joinrel-&gt;boundinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the join relation is partitioned, it uses the same partitioning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scheme as the joining relations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we calculate the partition bounds, number of partitions, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * child-join relations of the join relation in <a href="../path/joinrels.c.html#L1478" title="optimizer/path/joinrels.c:1478">try_partitionwise_join</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; joinrel-&gt;part_scheme = part_scheme;<br/></li>
<li>&nbsp; &nbsp; <a href="#L2281" title="optimizer/util/relnode.c:2281">set_joinrel_partition_key_exprs</a>(joinrel, outer_rel, inner_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sjinfo-&gt;jointype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set the consider_partitionwise_join flag.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(outer_rel-&gt;consider_partitionwise_join);<br/></li>
<li>&nbsp; &nbsp; Assert(inner_rel-&gt;consider_partitionwise_join);<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;consider_partitionwise_join = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2090" title="optimizer/util/relnode.c:2090">have_partkey_equi_join</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if there exist equi-join conditions involving pairs<br/></li>
<li></span><span class="Comment"> * of matching partition keys of the relations being joined for all<br/></li>
<li></span><span class="Comment"> * partition keys.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2090">&#x200c;</a></span><span class="linkable">have_partkey_equi_join</span>(PlannerInfo *root, RelOptInfo *joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *rel1, RelOptInfo *rel2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JoinType jointype, List *restrictlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PartitionScheme part_scheme = rel1-&gt;part_scheme;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt_pks;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; pk_has_clause[PARTITION_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; strict_op;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This function must only be called when the joined relations have same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partitioning scheme.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(rel1-&gt;part_scheme == rel2-&gt;part_scheme);<br/></li>
<li>&nbsp; &nbsp; Assert(part_scheme);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(pk_has_clause, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pk_has_clause));<br/></li>
<li>&nbsp; &nbsp; foreach(lc, restrictlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OpExpr&nbsp; &nbsp; &nbsp;&nbsp; *opexpr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *expr1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *expr2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ipk1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ipk2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If processing an outer join, only use its own join clauses. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IS_OUTER_JOIN(jointype) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RINFO_IS_PUSHED_DOWN(rinfo, joinrel-&gt;relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip clauses which can not be used for a join. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rinfo-&gt;can_join)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip clauses which are not equality conditions. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rinfo-&gt;mergeopfamilies &amp;&amp; !OidIsValid(rinfo-&gt;hashjoinoperator))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Should be OK to assume it's an OpExpr. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; opexpr = castNode(OpExpr, rinfo-&gt;clause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Match the operands to the relation. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(rinfo-&gt;left_relids, rel1-&gt;relids) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(rinfo-&gt;right_relids, rel2-&gt;relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr1 = linitial(opexpr-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr2 = lsecond(opexpr-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(rinfo-&gt;left_relids, rel2-&gt;relids) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(rinfo-&gt;right_relids, rel1-&gt;relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr1 = lsecond(opexpr-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr2 = linitial(opexpr-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now we need to know whether the join operator is strict; see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * comments in pathnodes.h.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; strict_op = <a href="../../utils/cache/lsyscache.c.html#L1477" title="utils/cache/lsyscache.c:1477">op_strict</a>(opexpr-&gt;opno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Vars appearing in the relation's partition keys will not have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * varnullingrels, but those in expr1 and expr2 will if we're above<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * outer joins that could null the respective rels.&nbsp; It's okay to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * match anyway, if the join operator is strict.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strict_op)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(rel1-&gt;relids, root-&gt;outer_join_rels))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr1 = (Expr *) <a href="../../rewrite/rewriteManip.c.html#L1234" title="rewrite/rewriteManip.c:1234">remove_nulling_relids</a>((Node *) expr1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;outer_join_rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(rel2-&gt;relids, root-&gt;outer_join_rels))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr2 = (Expr *) <a href="../../rewrite/rewriteManip.c.html#L1234" title="rewrite/rewriteManip.c:1234">remove_nulling_relids</a>((Node *) expr2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;outer_join_rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Only clauses referencing the partition keys are useful for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partitionwise join.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ipk1 = <a href="#L2232" title="optimizer/util/relnode.c:2232">match_expr_to_partition_keys</a>(expr1, rel1, strict_op);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ipk1 &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ipk2 = <a href="#L2232" title="optimizer/util/relnode.c:2232">match_expr_to_partition_keys</a>(expr2, rel2, strict_op);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ipk2 &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the clause refers to keys at different ordinal positions, it can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not be used for partitionwise join.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ipk1 != ipk2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The clause allows partitionwise join only if it uses the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operator family as that specified by the partition key.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel1-&gt;part_scheme-&gt;strategy == PARTITION_STRATEGY_HASH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(rinfo-&gt;hashjoinoperator) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../utils/cache/lsyscache.c.html#L66" title="utils/cache/lsyscache.c:66">op_in_opfamily</a>(rinfo-&gt;hashjoinoperator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; part_scheme-&gt;partopfamily[ipk1]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="../../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(rinfo-&gt;mergeopfamilies,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; part_scheme-&gt;partopfamily[ipk1]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark the partition key as having an equi-join clause. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pk_has_clause[ipk1] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check whether every partition key has an equi-join condition. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (cnt_pks = <span class="Constant">0</span>; cnt_pks &lt; part_scheme-&gt;partnatts; cnt_pks++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pk_has_clause[cnt_pks])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2232" title="optimizer/util/relnode.c:2232">match_expr_to_partition_keys</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Tries to match an expression to one of the nullable or non-nullable<br/></li>
<li></span><span class="Comment"> * partition keys of &quot;rel&quot;.&nbsp; Returns the matched key's ordinal position,<br/></li>
<li></span><span class="Comment"> * or -1 if the expression could not be matched to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the keys.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * strict_op must be true if the expression will be compared with the<br/></li>
<li></span><span class="Comment"> * partition key using a strict operator.&nbsp; This allows us to consider<br/></li>
<li></span><span class="Comment"> * nullable as well as nonnullable partition keys.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2232">&#x200c;</a></span><span class="linkable">match_expr_to_partition_keys</span>(Expr *expr, RelOptInfo *rel, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> strict_op)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This function should be called only for partitioned relations. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(rel-&gt;part_scheme);<br/></li>
<li>&nbsp; &nbsp; Assert(rel-&gt;partexprs);<br/></li>
<li>&nbsp; &nbsp; Assert(rel-&gt;nullable_partexprs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> relabel decorations. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (IsA(expr, RelabelType))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; expr = (Expr *) (castNode(RelabelType, expr))-&gt;arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (cnt = <span class="Constant">0</span>; cnt &lt; rel-&gt;part_scheme-&gt;partnatts; cnt++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can always match to the non-nullable partition keys. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, rel-&gt;partexprs[cnt])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(lfirst(lc), expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> cnt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!strict_op)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's a strict join operator then a NULL partition key on one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * side will not join to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> partition key on the other side, and in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * particular such a row can't join to a row from a different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partition on the other side.&nbsp; So, it's okay to search the nullable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partition keys as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, rel-&gt;nullable_partexprs[cnt])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(lfirst(lc), expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> cnt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2281" title="optimizer/util/relnode.c:2281">set_joinrel_partition_key_exprs</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Initialize partition key expressions for a partitioned joinrel.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2281">&#x200c;</a></span><span class="linkable">set_joinrel_partition_key_exprs</span>(RelOptInfo *joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *outer_rel, RelOptInfo *inner_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JoinType jointype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PartitionScheme part_scheme = joinrel-&gt;part_scheme;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partnatts = part_scheme-&gt;partnatts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;partexprs = (List **) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(List *) * partnatts);<br/></li>
<li>&nbsp; &nbsp; joinrel-&gt;nullable_partexprs =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (List **) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(List *) * partnatts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The joinrel's partition expressions are the same as those of the input<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rels, but we must properly classify them as nullable or not in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * joinrel's output.&nbsp; (Also, we add some more partition expressions if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's a FULL JOIN.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> cnt = <span class="Constant">0</span>; cnt &lt; partnatts; cnt++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mark these const to enforce that we copy them properly */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> List *outer_expr = outer_rel-&gt;partexprs[cnt];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> List *outer_null_expr = outer_rel-&gt;nullable_partexprs[cnt];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> List *inner_expr = inner_rel-&gt;partexprs[cnt];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> List *inner_null_expr = inner_rel-&gt;nullable_partexprs[cnt];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *partexpr = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *nullable_partexpr = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (jointype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A join relation resulting from an INNER join may be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * regarded as partitioned by either of the inner and outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation keys.&nbsp; For example, A INNER JOIN B ON A.a = B.b<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can be regarded as partitioned on either A.a or B.b.&nbsp; So we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * add both keys to the joinrel's partexpr lists.&nbsp; However,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anything that was already nullable still has to be treated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as nullable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JOIN_INNER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partexpr = <a href="../../nodes/list.c.html#L598" title="nodes/list.c:598">list_concat_copy</a>(outer_expr, inner_expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullable_partexpr = <a href="../../nodes/list.c.html#L598" title="nodes/list.c:598">list_concat_copy</a>(outer_null_expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inner_null_expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A join relation resulting from a SEMI or ANTI join may be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * regarded as partitioned by the outer relation keys.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inner relation's keys are no longer interesting; since they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aren't visible in the join output, nothing could join to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JOIN_SEMI:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JOIN_ANTI:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partexpr = <a href="../../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(outer_expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullable_partexpr = <a href="../../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(outer_null_expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A join relation resulting from a LEFT OUTER JOIN likewise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * may be regarded as partitioned on the (non-nullable) outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation keys.&nbsp; The inner (nullable) relation keys are okay<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as partition keys for further joins as long as they involve<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * strict join operators.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JOIN_LEFT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partexpr = <a href="../../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(outer_expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullable_partexpr = <a href="../../nodes/list.c.html#L598" title="nodes/list.c:598">list_concat_copy</a>(inner_expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outer_null_expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullable_partexpr = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(nullable_partexpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inner_null_expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For FULL OUTER JOINs, both relations are nullable, so the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * resulting join relation may be regarded as partitioned on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * either of inner and outer relation keys, but only for joins<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that involve strict join operators.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JOIN_FULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullable_partexpr = <a href="../../nodes/list.c.html#L598" title="nodes/list.c:598">list_concat_copy</a>(outer_expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inner_expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullable_partexpr = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(nullable_partexpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_null_expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullable_partexpr = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(nullable_partexpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inner_null_expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also add CoalesceExprs corresponding to each possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * full-join output variable (that is, left side coalesced to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * right side), so that we can match equijoin expressions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * using those variables.&nbsp; We really only need these for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * columns merged by JOIN USING, and only with the pairs of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * input items that correspond to the data structures that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis would build for such variables.&nbsp; But it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hard to tell which those are, so just make all the pairs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Extra items in the nullable_partexprs list won't cause big<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * problems.&nbsp; (It's possible that such items will get matched<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to user-written COALESCEs, but it should still be valid to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partition on those, since they're going to be either the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partition column or NULL; it's the same argument as for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partitionwise nesting of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer join.)&nbsp; We assume no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * type coercions are needed to make the coalesce expressions,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since columns of different types won't have gotten<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * classified as the same PartitionScheme.&nbsp; Note that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * intentionally leave out the varnullingrels decoration that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would ordinarily appear on the Vars inside these<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * CoalesceExprs, because <a href="#L2090" title="optimizer/util/relnode.c:2090">have_partkey_equi_join</a> will strip<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * varnullingrels from the expressions it will <a href="../geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partexprs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, <a href="../../nodes/list.c.html#L598" title="nodes/list.c:598">list_concat_copy</a>(outer_expr, outer_null_expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *larg = (Node *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, <a href="../../nodes/list.c.html#L598" title="nodes/list.c:598">list_concat_copy</a>(inner_expr, inner_null_expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *rarg = (Node *) lfirst(lc2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CoalesceExpr *c = makeNode(CoalesceExpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c-&gt;coalescetype = <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(larg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c-&gt;coalescecollid = <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>(larg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c-&gt;args = list_make2(larg, rarg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullable_partexpr = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(nullable_partexpr, c);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized join type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) jointype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; joinrel-&gt;partexprs[cnt] = partexpr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; joinrel-&gt;nullable_partexprs[cnt] = nullable_partexpr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2425" title="optimizer/util/relnode.c:2425">build_child_join_reltarget</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Set up a child-join relation's reltarget from a parent-join relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2425">&#x200c;</a></span><span class="linkable">build_child_join_reltarget</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *parentrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *childrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nappinfos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AppendRelInfo **appinfos)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build the targetlist */<br/></li>
<li></span>&nbsp; &nbsp; childrel-&gt;reltarget-&gt;exprs = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="appendinfo.c.html#L196" title="optimizer/util/appendinfo.c:196">adjust_appendrel_attrs</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) parentrel-&gt;reltarget-&gt;exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nappinfos, appinfos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set the cost and width fields */<br/></li>
<li></span>&nbsp; &nbsp; childrel-&gt;reltarget-&gt;cost.startup = parentrel-&gt;reltarget-&gt;cost.startup;<br/></li>
<li>&nbsp; &nbsp; childrel-&gt;reltarget-&gt;cost.per_tuple = parentrel-&gt;reltarget-&gt;cost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; childrel-&gt;reltarget-&gt;width = parentrel-&gt;reltarget-&gt;width;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
