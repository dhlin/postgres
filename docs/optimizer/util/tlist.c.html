<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>optimizer/util/tlist.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>optimizer/util/tlist.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L60">split_pathtarget_context</a></li>
<li><a href="#L44">split_pathtarget_item</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L695">add_column_to_pathtarget</a></li>
<li><a href="#L741">add_new_column_to_pathtarget</a></li>
<li><a href="#L752">add_new_columns_to_pathtarget</a></li>
<li><a href="#L1202">add_sp_item_to_pathtarget</a></li>
<li><a href="#L1248">add_sp_items_to_pathtarget</a></li>
<li><a href="#L132">add_to_flat_tlist</a></li>
<li><a href="#L774">apply_pathtarget_labeling_to_tlist</a></li>
<li><a href="#L318">apply_tlist_labeling</a></li>
<li><a href="#L657">copy_pathtarget</a></li>
<li><a href="#L186">count_nonjunk_tlist_entries</a></li>
<li><a href="#L681">create_empty_pathtarget</a></li>
<li><a href="#L489">extract_grouping_collations</a></li>
<li><a href="#L514">extract_grouping_cols</a></li>
<li><a href="#L463">extract_grouping_ops</a></li>
<li><a href="#L379">get_sortgroupclause_expr</a></li>
<li><a href="#L367">get_sortgroupclause_tle</a></li>
<li><a href="#L392">get_sortgrouplist_exprs</a></li>
<li><a href="#L422">get_sortgroupref_clause</a></li>
<li><a href="#L443">get_sortgroupref_clause_noerr</a></li>
<li><a href="#L345">get_sortgroupref_tle</a></li>
<li><a href="#L163">get_tlist_exprs</a></li>
<li><a href="#L560">grouping_is_hashable</a></li>
<li><a href="#L540">grouping_is_sortable</a></li>
<li><a href="#L591">make_pathtarget_from_tlist</a></li>
<li><a href="#L624">make_tlist_from_pathtarget</a></li>
<li><a href="#L881">split_pathtarget_at_srfs</a></li>
<li><a href="#L1077">split_pathtarget_walker</a></li>
<li><a href="#L79">tlist_member</a></li>
<li><a href="#L102">tlist_member_match_var</a></li>
<li><a href="#L282">tlist_same_collations</a></li>
<li><a href="#L248">tlist_same_datatypes</a></li>
<li><a href="#L218">tlist_same_exprs</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L31">IS_SRF_CALL</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * tlist.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Target list manipulation routines<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/optimizer/util/tlist.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/cost.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/tlist.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Test if an expression node represents a SRF call.&nbsp; Beware multiple eval!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Please note that this is only meant for use in <a href="#L881" title="optimizer/util/tlist.c:881">split_pathtarget_at_srfs</a>();<br/></li>
<li></span><span class="Comment"> * if you use it anywhere else, your code is almost certainly wrong for SRFs<br/></li>
<li></span><span class="Comment"> * nested within expressions.&nbsp; Use <a href="../../nodes/nodeFuncs.c.html#L758" title="nodes/nodeFuncs.c:758">expression_returns_set</a>() instead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L31">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">IS_SRF_CALL</span>(node) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((IsA(node, FuncExpr) &amp;&amp; ((FuncExpr *) (node))-&gt;funcretset) || \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; (IsA(node, OpExpr) &amp;&amp; ((OpExpr *) (node))-&gt;opretset))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Data structures for <a href="#L881" title="optimizer/util/tlist.c:881">split_pathtarget_at_srfs</a>().&nbsp; To preserve the identity<br/></li>
<li></span><span class="Comment"> * of sortgroupref items even if they are textually <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(), what we track is<br/></li>
<li></span><span class="Comment"> * not just bare expressions but expressions plus their sortgroupref indexes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *expr;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* some subexpression of a PathTarget */<br/></li>
<li></span>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; sortgroupref;&nbsp; &nbsp; <span class="Comment">/* its sortgroupref, or 0 if <a href="predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> */<br/></li>
<li><a id="L44">&#x200c;</a></span>} <span class="linkable">split_pathtarget_item</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This is a List of bare expressions: */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *input_target_exprs; <span class="Comment">/* exprs available from input */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* These are Lists of Lists of split_pathtarget_items: */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *level_srfs;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* SRF exprs to evaluate at each level */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *level_input_vars;&nbsp; &nbsp; <span class="Comment">/* input <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> needed at each level */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *level_input_srfs;&nbsp; &nbsp; <span class="Comment">/* input SRFs needed at each level */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* These are Lists of split_pathtarget_items: */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *current_input_vars; <span class="Comment">/* <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> needed in current subexpr */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *current_input_srfs; <span class="Comment">/* SRFs needed in current subexpr */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Auxiliary data for current <a href="#L1077" title="optimizer/util/tlist.c:1077">split_pathtarget_walker</a> traversal: */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_depth;&nbsp; &nbsp; <span class="Comment">/* max SRF depth in current subexpr */<br/></li>
<li></span>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; current_sgref;&nbsp; &nbsp; <span class="Comment">/* current subexpr's sortgroupref, or 0 */<br/></li>
<li><a id="L60">&#x200c;</a></span>} <span class="linkable">split_pathtarget_context</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1077" title="optimizer/util/tlist.c:1077">split_pathtarget_walker</a>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L60" title="optimizer/util/tlist.c:60">split_pathtarget_context</a> *context);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1202" title="optimizer/util/tlist.c:1202">add_sp_item_to_pathtarget</a>(PathTarget *target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L44" title="optimizer/util/tlist.c:44">split_pathtarget_item</a> *item);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1248" title="optimizer/util/tlist.c:1248">add_sp_items_to_pathtarget</a>(PathTarget *target, List *items);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Target list creation and searching utilities<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L79" title="optimizer/util/tlist.c:79">tlist_member</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Finds the (first) member of the given tlist whose expression is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>() to the given expression.&nbsp; Result is NULL if no such member.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TargetEntry *<br/></li>
<li><a id="L79">&#x200c;</a><span class="linkable">tlist_member</span>(Expr *node, List *targetlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *temp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(temp, targetlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tlentry = (TargetEntry *) lfirst(temp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(node, tlentry-&gt;expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> tlentry;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L102" title="optimizer/util/tlist.c:102">tlist_member_match_var</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Same as above, except that we match the provided Var on the basis<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; of varno/varattno/varlevelsup/vartype only, rather than full <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is needed in some cases where we can't be sure of an exact typmod<br/></li>
<li></span><span class="Comment"> * match.&nbsp; For safety, though, we insist on vartype match.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TargetEntry *<br/></li>
<li><a id="L102">&#x200c;</a><span class="linkable">tlist_member_match_var</span>(Var *var, List *targetlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *temp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(temp, targetlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tlentry = (TargetEntry *) lfirst(temp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tlvar = (Var *) tlentry-&gt;expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tlvar || !IsA(tlvar, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varno == tlvar-&gt;varno &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varattno == tlvar-&gt;varattno &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varlevelsup == tlvar-&gt;varlevelsup &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;vartype == tlvar-&gt;vartype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> tlentry;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L132" title="optimizer/util/tlist.c:132">add_to_flat_tlist</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Add more items to a flattened tlist (if they're not already in it)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'tlist' is the flattened tlist<br/></li>
<li></span><span class="Comment"> * 'exprs' is a list of expressions (usually, but not necessarily, Vars)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the extended tlist.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L132">&#x200c;</a><span class="linkable">add_to_flat_tlist</span>(List *tlist, List *exprs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_resno = list_length(tlist) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, exprs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *expr = (Expr *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L79" title="optimizer/util/tlist.c:79">tlist_member</a>(expr, tlist))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>(copyObject(expr), <span class="Comment">/* copy needed?? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_resno++,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tlist, tle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tlist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L163" title="optimizer/util/tlist.c:163">get_tlist_exprs</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get just the expression subtrees of a tlist<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Resjunk columns are ignored unless includeJunk is true<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L163">&#x200c;</a><span class="linkable">get_tlist_exprs</span>(List *tlist, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> includeJunk)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, tlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;resjunk &amp;&amp; !includeJunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, tle-&gt;expr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L186" title="optimizer/util/tlist.c:186">count_nonjunk_tlist_entries</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; What it says ...<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L186">&#x200c;</a></span><span class="linkable">count_nonjunk_tlist_entries</span>(List *tlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, tlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> len;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L218" title="optimizer/util/tlist.c:218">tlist_same_exprs</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Check whether two target lists contain the same expressions<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this function is used to decide whether it's safe to jam a new tlist<br/></li>
<li></span><span class="Comment"> * into a non-projection-capable plan node.&nbsp; Obviously we can't do that unless<br/></li>
<li></span><span class="Comment"> * the node's tlist shows it already returns the column <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> we want.<br/></li>
<li></span><span class="Comment"> * However, we can ignore the TargetEntry attributes resname, ressortgroupref,<br/></li>
<li></span><span class="Comment"> * resorigtbl, resorigcol, and resjunk, because those are only labelings that<br/></li>
<li></span><span class="Comment"> * don't affect the row <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> computed by the node.&nbsp; (Moreover, if we didn't<br/></li>
<li></span><span class="Comment"> * ignore them, we'd frequently fail to make the desired optimization, since<br/></li>
<li></span><span class="Comment"> * the <a href="../plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> tends to not bother to make resname etc. valid in intermediate<br/></li>
<li></span><span class="Comment"> * plan nodes.)&nbsp; Note that on success, the caller must still jam the desired<br/></li>
<li></span><span class="Comment"> * tlist into the plan node, else it won't have the desired labeling fields.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L218">&#x200c;</a></span><span class="linkable">tlist_same_exprs</span>(List *tlist1, List *tlist2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(tlist1) != list_length(tlist2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not same length, so can't match */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; forboth(lc1, tlist1, lc2, tlist2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle1 = (TargetEntry *) lfirst(lc1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle2 = (TargetEntry *) lfirst(lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(tle1-&gt;expr, tle2-&gt;expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Does tlist have same output datatypes as listed in colTypes?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Resjunk columns are ignored if junkOK is true; otherwise presence of<br/></li>
<li></span><span class="Comment"> * a resjunk column will always cause a 'false' result.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: currently no callers care about comparing typmods.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L248">&#x200c;</a></span><span class="linkable">tlist_same_datatypes</span>(List *tlist, List *colTypes, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> junkOK)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *curColType = list_head(colTypes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, tlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!junkOK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curColType == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* tlist longer than colTypes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) tle-&gt;expr) != lfirst_oid(curColType))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curColType = lnext(colTypes, curColType);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (curColType != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tlist shorter than colTypes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Does tlist have same exposed collations as listed in colCollations?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Identical logic to the above, but for collations.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L282">&#x200c;</a></span><span class="linkable">tlist_same_collations</span>(List *tlist, List *colCollations, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> junkOK)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *curColColl = list_head(colCollations);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, tlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!junkOK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curColColl == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* tlist longer than colCollations */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) tle-&gt;expr) != lfirst_oid(curColColl))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curColColl = lnext(colCollations, curColColl);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (curColColl != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tlist shorter than colCollations */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L318" title="optimizer/util/tlist.c:318">apply_tlist_labeling</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Apply the TargetEntry labeling attributes of src_tlist to dest_tlist<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is useful for reattaching column names etc to a plan's final output<br/></li>
<li></span><span class="Comment"> * targetlist.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L318">&#x200c;</a></span><span class="linkable">apply_tlist_labeling</span>(List *dest_tlist, List *src_tlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *ld,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *ls;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(list_length(dest_tlist) == list_length(src_tlist));<br/></li>
<li>&nbsp; &nbsp; forboth(ld, dest_tlist, ls, src_tlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *dest_tle = (TargetEntry *) lfirst(ld);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *src_tle = (TargetEntry *) lfirst(ls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(dest_tle-&gt;resno == src_tle-&gt;resno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dest_tle-&gt;resname = src_tle-&gt;resname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dest_tle-&gt;ressortgroupref = src_tle-&gt;ressortgroupref;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dest_tle-&gt;resorigtbl = src_tle-&gt;resorigtbl;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dest_tle-&gt;resorigcol = src_tle-&gt;resorigcol;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dest_tle-&gt;resjunk = src_tle-&gt;resjunk;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L345" title="optimizer/util/tlist.c:345">get_sortgroupref_tle</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Find the targetlist entry matching the given SortGroupRef index,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and return it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TargetEntry *<br/></li>
<li><a id="L345">&#x200c;</a><span class="linkable">get_sortgroupref_tle</span>(Index sortref, List *targetList)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, targetList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;ressortgroupref == sortref)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> tle;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;ORDER/GROUP BY expression not found in targetlist&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L367" title="optimizer/util/tlist.c:367">get_sortgroupclause_tle</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Find the targetlist entry matching the given SortGroupClause<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; by ressortgroupref, and return it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TargetEntry *<br/></li>
<li><a id="L367">&#x200c;</a><span class="linkable">get_sortgroupclause_tle</span>(SortGroupClause *sgClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *targetList)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L345" title="optimizer/util/tlist.c:345">get_sortgroupref_tle</a>(sgClause-&gt;tleSortGroupRef, targetList);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L379" title="optimizer/util/tlist.c:379">get_sortgroupclause_expr</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Find the targetlist entry matching the given SortGroupClause<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; by ressortgroupref, and return its expression.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Node *<br/></li>
<li><a id="L379">&#x200c;</a><span class="linkable">get_sortgroupclause_expr</span>(SortGroupClause *sgClause, List *targetList)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TargetEntry *tle = <a href="#L367" title="optimizer/util/tlist.c:367">get_sortgroupclause_tle</a>(sgClause, targetList);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Node *) tle-&gt;expr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L392" title="optimizer/util/tlist.c:392">get_sortgrouplist_exprs</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given a list of SortGroupClauses, build a list<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; of the referenced targetlist expressions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L392">&#x200c;</a><span class="linkable">get_sortgrouplist_exprs</span>(List *sgClauses, List *targetList)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, sgClauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *sortcl = (SortGroupClause *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *sortexpr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortexpr = <a href="#L379" title="optimizer/util/tlist.c:379">get_sortgroupclause_expr</a>(sortcl, targetList);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, sortexpr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Functions to extract data from a list of SortGroupClauses<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These don't really belong in tlist.c, but they are sort of related to the<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> just above, and they don't seem to deserve their own file.<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L422" title="optimizer/util/tlist.c:422">get_sortgroupref_clause</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Find the SortGroupClause matching the given SortGroupRef index,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and return it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>SortGroupClause *<br/></li>
<li><a id="L422">&#x200c;</a><span class="linkable">get_sortgroupref_clause</span>(Index sortref, List *clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, clauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *cl = (SortGroupClause *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cl-&gt;tleSortGroupRef == sortref)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> cl;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;ORDER/GROUP BY expression not found in list&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L443" title="optimizer/util/tlist.c:443">get_sortgroupref_clause_noerr</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; As above, but return NULL rather than throwing an error if not found.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>SortGroupClause *<br/></li>
<li><a id="L443">&#x200c;</a><span class="linkable">get_sortgroupref_clause_noerr</span>(Index sortref, List *clauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, clauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *cl = (SortGroupClause *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cl-&gt;tleSortGroupRef == sortref)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> cl;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L463" title="optimizer/util/tlist.c:463">extract_grouping_ops</a> - make an array of the equality operator OIDs<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; for a SortGroupClause list<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid *<br/></li>
<li><a id="L463">&#x200c;</a><span class="linkable">extract_grouping_ops</span>(List *groupClause)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numCols = list_length(groupClause);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *groupOperators;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *glitem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; groupOperators = (Oid *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * numCols);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(glitem, groupClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *groupcl = (SortGroupClause *) lfirst(glitem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; groupOperators[colno] = groupcl-&gt;eqop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(OidIsValid(groupOperators[colno]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; colno++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> groupOperators;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L489" title="optimizer/util/tlist.c:489">extract_grouping_collations</a> - make an array of the grouping column collations<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; for a SortGroupClause list<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid *<br/></li>
<li><a id="L489">&#x200c;</a><span class="linkable">extract_grouping_collations</span>(List *groupClause, List *tlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numCols = list_length(groupClause);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *grpCollations;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *glitem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; grpCollations = (Oid *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * numCols);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(glitem, groupClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *groupcl = (SortGroupClause *) lfirst(glitem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = <a href="#L367" title="optimizer/util/tlist.c:367">get_sortgroupclause_tle</a>(groupcl, tlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; grpCollations[colno++] = <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) tle-&gt;expr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> grpCollations;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L514" title="optimizer/util/tlist.c:514">extract_grouping_cols</a> - make an array of the grouping column resnos<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; for a SortGroupClause list<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>AttrNumber *<br/></li>
<li><a id="L514">&#x200c;</a><span class="linkable">extract_grouping_cols</span>(List *groupClause, List *tlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AttrNumber *grpColIdx;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numCols = list_length(groupClause);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *glitem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; grpColIdx = (AttrNumber *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber) * numCols);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(glitem, groupClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *groupcl = (SortGroupClause *) lfirst(glitem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = <a href="#L367" title="optimizer/util/tlist.c:367">get_sortgroupclause_tle</a>(groupcl, tlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; grpColIdx[colno++] = tle-&gt;resno;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> grpColIdx;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L540" title="optimizer/util/tlist.c:540">grouping_is_sortable</a> - is it possible to implement grouping list by sorting?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is easy since the parser will have included a sortop if one exists.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L540">&#x200c;</a></span><span class="linkable">grouping_is_sortable</span>(List *groupClause)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *glitem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(glitem, groupClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *groupcl = (SortGroupClause *) lfirst(glitem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(groupcl-&gt;sortop))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L560" title="optimizer/util/tlist.c:560">grouping_is_hashable</a> - is it possible to implement grouping list by hashing?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We rely on the parser to have set the hashable flag correctly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L560">&#x200c;</a></span><span class="linkable">grouping_is_hashable</span>(List *groupClause)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *glitem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(glitem, groupClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *groupcl = (SortGroupClause *) lfirst(glitem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!groupcl-&gt;hashable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; PathTarget manipulation <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * PathTarget is a somewhat stripped-down version of a full targetlist; it<br/></li>
<li></span><span class="Comment"> * omits all the TargetEntry decoration except (optionally) sortgroupref data,<br/></li>
<li></span><span class="Comment"> * and it adds evaluation cost and output data width info.<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L591" title="optimizer/util/tlist.c:591">make_pathtarget_from_tlist</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Construct a PathTarget equivalent to the given targetlist.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This leaves the cost and width fields as zeroes.&nbsp; Most callers will want<br/></li>
<li></span><span class="Comment"> * to use create_pathtarget(), so as to get those set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PathTarget *<br/></li>
<li><a id="L591">&#x200c;</a><span class="linkable">make_pathtarget_from_tlist</span>(List *tlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PathTarget *target = makeNode(PathTarget);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; target-&gt;sortgrouprefs = (Index *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(list_length(tlist) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Index));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, tlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; target-&gt;exprs = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(target-&gt;exprs, tle-&gt;expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; target-&gt;sortgrouprefs[i] = tle-&gt;ressortgroupref;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark volatility as unknown.&nbsp; The <a href="clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a> function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will determine if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> when called for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first time with this PathTarget.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; target-&gt;has_volatile_expr = VOLATILITY_UNKNOWN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> target;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L624" title="optimizer/util/tlist.c:624">make_tlist_from_pathtarget</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Construct a targetlist from a PathTarget.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L624">&#x200c;</a><span class="linkable">make_tlist_from_pathtarget</span>(PathTarget *target)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, target-&gt;exprs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *expr = (Expr *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>(expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (target-&gt;sortgrouprefs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle-&gt;ressortgroupref = target-&gt;sortgrouprefs[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(tlist, tle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tlist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L657" title="optimizer/util/tlist.c:657">copy_pathtarget</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Copy a PathTarget.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The new PathTarget has its own exprs List, but shares the underlying<br/></li>
<li></span><span class="Comment"> * target expression trees with the old one.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PathTarget *<br/></li>
<li><a id="L657">&#x200c;</a><span class="linkable">copy_pathtarget</span>(PathTarget *src)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PathTarget *dst = makeNode(PathTarget);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy scalar fields */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(dst, src, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PathTarget));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shallow-copy the expression list */<br/></li>
<li></span>&nbsp; &nbsp; dst-&gt;exprs = <a href="../../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(src-&gt;exprs);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Duplicate sortgrouprefs if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> (if not, the memcpy handled this) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (src-&gt;sortgrouprefs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; nbytes = list_length(src-&gt;exprs) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dst-&gt;sortgrouprefs = (Index *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nbytes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(dst-&gt;sortgrouprefs, src-&gt;sortgrouprefs, nbytes);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> dst;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L681" title="optimizer/util/tlist.c:681">create_empty_pathtarget</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Create an empty (zero columns, zero cost) PathTarget.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PathTarget *<br/></li>
<li><a id="L681">&#x200c;</a><span class="linkable">create_empty_pathtarget</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This is easy, but we don't want callers to hard-wire this ... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> makeNode(PathTarget);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L695" title="optimizer/util/tlist.c:695">add_column_to_pathtarget</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Append a target column to the PathTarget.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As with <a href="#L591" title="optimizer/util/tlist.c:591">make_pathtarget_from_tlist</a>, we leave it to the caller to update<br/></li>
<li></span><span class="Comment"> * the cost and width fields.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L695">&#x200c;</a></span><span class="linkable">add_column_to_pathtarget</span>(PathTarget *target, Expr *expr, Index sortgroupref)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Updating the exprs list is easy ... */<br/></li>
<li></span>&nbsp; &nbsp; target-&gt;exprs = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(target-&gt;exprs, expr);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... the sortgroupref data, a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> less so */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (target-&gt;sortgrouprefs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nexprs = list_length(target-&gt;exprs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This might look inefficient, but actually it's usually cheap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; target-&gt;sortgrouprefs = (Index *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(target-&gt;sortgrouprefs, nexprs * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Index));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; target-&gt;sortgrouprefs[nexprs - <span class="Constant">1</span>] = sortgroupref;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (sortgroupref)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Adding sortgroupref labeling to a previously unlabeled target */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nexprs = list_length(target-&gt;exprs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; target-&gt;sortgrouprefs = (Index *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(nexprs * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Index));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; target-&gt;sortgrouprefs[nexprs - <span class="Constant">1</span>] = sortgroupref;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset has_volatile_expr to UNKNOWN.&nbsp; We just leave it up to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a> to set this properly again.&nbsp; Technically we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * could save some effort here and just check the new Expr, but it seems<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * better to keep the logic for setting this flag in one location rather<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than duplicating the logic here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (target-&gt;has_volatile_expr == VOLATILITY_NOVOLATILE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; target-&gt;has_volatile_expr = VOLATILITY_UNKNOWN;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L741" title="optimizer/util/tlist.c:741">add_new_column_to_pathtarget</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Append a target column to the PathTarget, but only if it's not<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>() to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pre-existing target expression.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller cannot specify a sortgroupref, since it would be unclear how<br/></li>
<li></span><span class="Comment"> * to <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> that with a pre-existing column.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As with <a href="#L591" title="optimizer/util/tlist.c:591">make_pathtarget_from_tlist</a>, we leave it to the caller to update<br/></li>
<li></span><span class="Comment"> * the cost and width fields.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L741">&#x200c;</a></span><span class="linkable">add_new_column_to_pathtarget</span>(PathTarget *target, Expr *expr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/list.c.html#L661" title="nodes/list.c:661">list_member</a>(target-&gt;exprs, expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L695" title="optimizer/util/tlist.c:695">add_column_to_pathtarget</a>(target, expr, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L752" title="optimizer/util/tlist.c:752">add_new_columns_to_pathtarget</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Apply <a href="#L741" title="optimizer/util/tlist.c:741">add_new_column_to_pathtarget</a>() for each <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of the list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L752">&#x200c;</a></span><span class="linkable">add_new_columns_to_pathtarget</span>(PathTarget *target, List *exprs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, exprs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *expr = (Expr *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L741" title="optimizer/util/tlist.c:741">add_new_column_to_pathtarget</a>(target, expr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L774" title="optimizer/util/tlist.c:774">apply_pathtarget_labeling_to_tlist</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Apply <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> sortgrouprefs in the PathTarget to matching tlist entries<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Here, we do not assume that the tlist entries are one-for-one with the<br/></li>
<li></span><span class="Comment"> * PathTarget.&nbsp; The intended use of this function is to deal with cases<br/></li>
<li></span><span class="Comment"> * where createplan.c has decided to use some other tlist and we have<br/></li>
<li></span><span class="Comment"> * to identify what matches exist.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L774">&#x200c;</a></span><span class="linkable">apply_pathtarget_labeling_to_tlist</span>(List *tlist, PathTarget *target)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do if PathTarget has no sortgrouprefs data */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (target-&gt;sortgrouprefs == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, target-&gt;exprs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *expr = (Expr *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (target-&gt;sortgrouprefs[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For Vars, use <a href="#L102" title="optimizer/util/tlist.c:102">tlist_member_match_var</a>'s weakened matching rule;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this allows us to deal with some cases where a set-returning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function has been inlined, so that we <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> have more knowledge<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * about what it returns than we did when the original Var was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * created.&nbsp; Otherwise, use regular <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>() to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the matching<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * TLE.&nbsp; (In current usage, only the Var case is actually needed;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but it seems best to have sane behavior here for non-Vars too.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (expr &amp;&amp; IsA(expr, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="#L102" title="optimizer/util/tlist.c:102">tlist_member_match_var</a>((Var *) expr, tlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="#L79" title="optimizer/util/tlist.c:79">tlist_member</a>(expr, tlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Complain if noplace for the sortgrouprefs label, or if we'd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have to label a column twice.&nbsp; (The case where it already has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the desired label probably can't happen, but we may as well<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allow for it.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tle)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;ORDER/GROUP BY expression not found in targetlist&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;ressortgroupref != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle-&gt;ressortgroupref != target-&gt;sortgrouprefs[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;targetlist item has multiple sortgroupref labels&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle-&gt;ressortgroupref = target-&gt;sortgrouprefs[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L881" title="optimizer/util/tlist.c:881">split_pathtarget_at_srfs</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Split given PathTarget into multiple levels to position SRFs safely<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The executor can only handle set-returning <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that appear at the<br/></li>
<li></span><span class="Comment"> * top level of the targetlist of a ProjectSet plan node.&nbsp; If we have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SRFs<br/></li>
<li></span><span class="Comment"> * that are not at top level, we need to split up the evaluation into multiple<br/></li>
<li></span><span class="Comment"> * plan levels in which each level satisfies this constraint.&nbsp; This function<br/></li>
<li></span><span class="Comment"> * creates appropriate PathTarget(s) for each level.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As an example, consider the tlist expression<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; x + srf1(srf2(y + z))<br/></li>
<li></span><span class="Comment"> * This expression should appear as-is in the top PathTarget, but below that<br/></li>
<li></span><span class="Comment"> * we must have a PathTarget containing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; x, srf1(srf2(y + z))<br/></li>
<li></span><span class="Comment"> * and below that, another PathTarget containing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; x, srf2(y + z)<br/></li>
<li></span><span class="Comment"> * and below that, another PathTarget containing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; x, y, z<br/></li>
<li></span><span class="Comment"> * When these tlists are processed by setrefs.c, subexpressions that match<br/></li>
<li></span><span class="Comment"> * output expressions of the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> tlist will be replaced by Vars,<br/></li>
<li></span><span class="Comment"> * so that what the executor gets are tlists looking like<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Var1 + Var2<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Var1, srf1(Var2)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Var1, srf2(Var2 + Var3)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; x, y, z<br/></li>
<li></span><span class="Comment"> * which satisfy the desired property.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Another example is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; srf1(x), srf2(srf3(y))<br/></li>
<li></span><span class="Comment"> * That must appear as-is in the top PathTarget, but below that we need<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; srf1(x), srf3(y)<br/></li>
<li></span><span class="Comment"> * That is, each SRF must be computed at a level corresponding to the nesting<br/></li>
<li></span><span class="Comment"> * depth of SRFs within its arguments.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In some cases, a SRF has already been evaluated in some previous plan level<br/></li>
<li></span><span class="Comment"> * and we shouldn't expand it again (that is, what we see in the target is<br/></li>
<li></span><span class="Comment"> * already meant as a reference to a <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> subexpression).&nbsp; So, don't expand<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tlist expressions that appear in input_target, if that's not NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It's also important that we preserve <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> sortgroupref annotation appearing<br/></li>
<li></span><span class="Comment"> * in the given target, especially on expressions matching input_target items.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The outputs of this function are two parallel lists, one a list of<br/></li>
<li></span><span class="Comment"> * PathTargets and the other an integer list of <a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> flags indicating<br/></li>
<li></span><span class="Comment"> * whether the corresponding PathTarget contains <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> evaluable SRFs.<br/></li>
<li></span><span class="Comment"> * The lists are given in the order they'd need to be evaluated in, with<br/></li>
<li></span><span class="Comment"> * the &quot;lowest&quot; PathTarget first.&nbsp; So the last list entry is always the<br/></li>
<li></span><span class="Comment"> * originally given PathTarget, and <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> entries <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it indicate evaluation<br/></li>
<li></span><span class="Comment"> * levels that must be inserted below it.&nbsp; The first list entry must not<br/></li>
<li></span><span class="Comment"> * contain <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SRFs (other than ones duplicating input_target entries), since<br/></li>
<li></span><span class="Comment"> * it will typically be attached to a plan node that cannot evaluate SRFs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: using a list for the flags may seem like overkill, since there<br/></li>
<li></span><span class="Comment"> * are only a few possible patterns for which levels contain SRFs.<br/></li>
<li></span><span class="Comment"> * But this representation decouples callers from that knowledge.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L881">&#x200c;</a></span><span class="linkable">split_pathtarget_at_srfs</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PathTarget *target, PathTarget *input_target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **targets, List **targets_contain_srfs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L60" title="optimizer/util/tlist.c:60">split_pathtarget_context</a> context;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_depth;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; need_extra_projection;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *prev_level_tlist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lci;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lc1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lc2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lc3;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's not unusual for <a href="../plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>.c to pass us two physically identical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * targets, in which case we can conclude without further ado that all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expressions are available from the input.&nbsp; (The logic below would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * arrive at the same conclusion, but much more tediously.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (target == input_target)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *targets = list_make1(target);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *targets_contain_srfs = list_make1_int(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pass <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> input_target exprs down to <a href="#L1077" title="optimizer/util/tlist.c:1077">split_pathtarget_walker</a>() */<br/></li>
<li></span>&nbsp; &nbsp; context.input_target_exprs = input_target ? input_target-&gt;exprs : NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize with empty level-zero lists, and no levels after that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Note: we could dispense with representing level zero explicitly, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it will never receive <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SRFs, but then we'd have to special-case that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * level when we get to building result PathTargets.&nbsp; Level zero describes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the SRF-free PathTarget that will be given to the input plan node.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; context.level_srfs = list_make1(NIL);<br/></li>
<li>&nbsp; &nbsp; context.level_input_vars = list_make1(NIL);<br/></li>
<li>&nbsp; &nbsp; context.level_input_srfs = list_make1(NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize data we'll accumulate across all the target expressions */<br/></li>
<li></span>&nbsp; &nbsp; context.current_input_vars = NIL;<br/></li>
<li>&nbsp; &nbsp; context.current_input_srfs = NIL;<br/></li>
<li>&nbsp; &nbsp; max_depth = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; need_extra_projection = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan each expression in the PathTarget looking for SRFs */<br/></li>
<li></span>&nbsp; &nbsp; lci = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, target-&gt;exprs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *node = (Node *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Tell <a href="#L1077" title="optimizer/util/tlist.c:1077">split_pathtarget_walker</a> about this expr's sortgroupref */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; context.current_sgref = get_pathtarget_sortgroupref(target, lci);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lci++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find all SRFs and Vars (and Var-like nodes) in this expression, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * enter them into appropriate lists within the context struct.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; context.current_depth = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1077" title="optimizer/util/tlist.c:1077">split_pathtarget_walker</a>(node, &amp;context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* An expression containing no SRFs is of no further interest */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context.current_depth == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Track max SRF nesting depth over the whole PathTarget.&nbsp; Also, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this expression establishes a new max depth, we no longer care<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whether previous expressions contained nested SRFs; we can handle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> required projection for them in the final ProjectSet node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (max_depth &lt; context.current_depth)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_depth = context.current_depth;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; need_extra_projection = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> maximum-depth SRF is not at the top level of its expression,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll need an extra Result node to compute the top-level scalar<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expression.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (max_depth == context.current_depth &amp;&amp; !<a href="#L31" title="optimizer/util/tlist.c:31">IS_SRF_CALL</a>(node))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; need_extra_projection = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we found no SRFs needing evaluation (maybe they were all present in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * input_target, or maybe they were all removed by const-simplification),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then no ProjectSet is needed; fall out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (max_depth == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *targets = list_make1(target);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *targets_contain_srfs = list_make1_int(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The Vars and SRF outputs needed at top level can be added to the last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * level_input lists if we don't need an extra projection step.&nbsp; If we do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need one, add a SRF-free level to the lists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (need_extra_projection)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context.level_srfs = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(context.level_srfs, NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context.level_input_vars = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(context.level_input_vars,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context.current_input_vars);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context.level_input_srfs = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(context.level_input_srfs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context.current_input_srfs);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lc = list_nth_cell(context.level_input_vars, max_depth);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lfirst(lc) = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(lfirst(lc), context.current_input_vars);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lc = list_nth_cell(context.level_input_srfs, max_depth);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lfirst(lc) = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(lfirst(lc), context.current_input_srfs);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now construct the output PathTargets.&nbsp; The original target can be used<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as-is for the last one, but we need to construct a new SRF-free target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * representing what the preceding plan node has to emit, as well as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * target for each intermediate ProjectSet node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *targets = *targets_contain_srfs = NIL;<br/></li>
<li>&nbsp; &nbsp; prev_level_tlist = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; forthree(lc1, context.level_srfs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lc2, context.level_input_vars,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lc3, context.level_input_srfs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *level_srfs = (List *) lfirst(lc1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathTarget *ntarget;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lnext(context.level_srfs, lc1) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntarget = target;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntarget = <a href="#L681" title="optimizer/util/tlist.c:681">create_empty_pathtarget</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This target should actually evaluate <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SRFs of the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * level, and it needs to propagate forward <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> Vars needed by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * later levels, as well as SRFs computed earlier and needed by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * later levels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1248" title="optimizer/util/tlist.c:1248">add_sp_items_to_pathtarget</a>(ntarget, level_srfs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for_each_cell(lc, context.level_input_vars,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lnext(context.level_input_vars, lc2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *input_vars = (List *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1248" title="optimizer/util/tlist.c:1248">add_sp_items_to_pathtarget</a>(ntarget, input_vars);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for_each_cell(lc, context.level_input_srfs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lnext(context.level_input_srfs, lc3))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *input_srfs = (List *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lcx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lcx, input_srfs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L44" title="optimizer/util/tlist.c:44">split_pathtarget_item</a> *item = lfirst(lcx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/list.c.html#L661" title="nodes/list.c:661">list_member</a>(prev_level_tlist, item-&gt;expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1202" title="optimizer/util/tlist.c:1202">add_sp_item_to_pathtarget</a>(ntarget, item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L6256" title="optimizer/path/costsize.c:6256">set_pathtarget_cost_width</a>(root, ntarget);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add current target and does-it-compute-SRFs flag to output lists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *targets = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(*targets, ntarget);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *targets_contain_srfs = <a href="../../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(*targets_contain_srfs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (level_srfs != NIL));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remember this level's output for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> pass */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; prev_level_tlist = ntarget-&gt;exprs;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Recursively examine expressions for <a href="#L881" title="optimizer/util/tlist.c:881">split_pathtarget_at_srfs</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note we make no effort here to prevent duplicate entries in the output<br/></li>
<li></span><span class="Comment"> * lists.&nbsp; Duplicates will be gotten rid of later.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1077">&#x200c;</a></span><span class="linkable">split_pathtarget_walker</span>(Node *node, <a href="#L60" title="optimizer/util/tlist.c:60">split_pathtarget_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A subexpression that matches an expression already computed in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * input_target can be treated like a Var (which indeed it will be after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * setrefs.c gets done with it), even if it's actually a SRF.&nbsp; Record it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as being needed for the current expression, and ignore <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * substructure.&nbsp; (Note in particular that this preserves the identity of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> expressions that appear as sortgrouprefs in input_target.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/list.c.html#L661" title="nodes/list.c:661">list_member</a>(context-&gt;input_target_exprs, node))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L44" title="optimizer/util/tlist.c:44">split_pathtarget_item</a> *item = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L44" title="optimizer/util/tlist.c:44">split_pathtarget_item</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; item-&gt;expr = node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; item-&gt;sortgroupref = context-&gt;current_sgref;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;current_input_vars = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(context-&gt;current_input_vars,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Vars and Var-like constructs are expected to be gotten from the input,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * too.&nbsp; We assume that these constructs cannot contain <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SRFs (if one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * does, there will be an executor failure from a misplaced SRF).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IsA(node, PlaceHolderVar) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IsA(node, Aggref) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IsA(node, GroupingFunc) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IsA(node, WindowFunc))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L44" title="optimizer/util/tlist.c:44">split_pathtarget_item</a> *item = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L44" title="optimizer/util/tlist.c:44">split_pathtarget_item</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; item-&gt;expr = node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; item-&gt;sortgroupref = context-&gt;current_sgref;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;current_input_vars = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(context-&gt;current_input_vars,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's a SRF, recursively examine its inputs, determine its level, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * make appropriate entries in the output lists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L31" title="optimizer/util/tlist.c:31">IS_SRF_CALL</a>(node))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L44" title="optimizer/util/tlist.c:44">split_pathtarget_item</a> *item = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L44" title="optimizer/util/tlist.c:44">split_pathtarget_item</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *save_input_vars = context-&gt;current_input_vars;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *save_input_srfs = context-&gt;current_input_srfs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_current_depth = context-&gt;current_depth;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srf_depth;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; item-&gt;expr = node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; item-&gt;sortgroupref = context-&gt;current_sgref;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;current_input_vars = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;current_input_srfs = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;current_depth = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;current_sgref = <span class="Constant">0</span>; <span class="Comment">/* subexpressions are not sortgroup items */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) expression_tree_walker(node, <a href="#L1077" title="optimizer/util/tlist.c:1077">split_pathtarget_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Depth is one more than <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SRF below it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; srf_depth = context-&gt;current_depth + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If new record depth, <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> another level of output lists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (srf_depth &gt;= list_length(context-&gt;level_srfs))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;level_srfs = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(context-&gt;level_srfs, NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;level_input_vars = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(context-&gt;level_input_vars, NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;level_input_srfs = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(context-&gt;level_input_srfs, NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Record this SRF as needing to be evaluated at appropriate level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lc = list_nth_cell(context-&gt;level_srfs, srf_depth);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lfirst(lc) = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(lfirst(lc), item);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Record its inputs as being needed at the same level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lc = list_nth_cell(context-&gt;level_input_vars, srf_depth);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lfirst(lc) = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(lfirst(lc), context-&gt;current_input_vars);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lc = list_nth_cell(context-&gt;level_input_srfs, srf_depth);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lfirst(lc) = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(lfirst(lc), context-&gt;current_input_srfs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Restore caller-level state and update it for presence of this SRF.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Notice we report the SRF itself as being needed for evaluation of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * surrounding expression.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;current_input_vars = save_input_vars;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;current_input_srfs = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(save_input_srfs, item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;current_depth = Max(save_current_depth, srf_depth);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We're done here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, the node is a scalar (non-set) expression, so recurse to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * examine its inputs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; context-&gt;current_sgref = <span class="Constant">0</span>; <span class="Comment">/* subexpressions are not sortgroup items */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L1077" title="optimizer/util/tlist.c:1077">split_pathtarget_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add a <a href="#L44" title="optimizer/util/tlist.c:44">split_pathtarget_item</a> to the PathTarget, unless a matching item is<br/></li>
<li></span><span class="Comment"> * already present.&nbsp; This is like <a href="#L741" title="optimizer/util/tlist.c:741">add_new_column_to_pathtarget</a>, but allows<br/></li>
<li></span><span class="Comment"> * for sortgrouprefs to be handled.&nbsp; An item having zero sortgroupref can<br/></li>
<li></span><span class="Comment"> * be merged with one that has a sortgroupref, acquiring the latter's<br/></li>
<li></span><span class="Comment"> * sortgroupref.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we don't worry about possibly adding duplicate sortgrouprefs<br/></li>
<li></span><span class="Comment"> * to the PathTarget.&nbsp; That would be bad, but it should be impossible unless<br/></li>
<li></span><span class="Comment"> * the target passed to <a href="#L881" title="optimizer/util/tlist.c:881">split_pathtarget_at_srfs</a> already had duplicates.<br/></li>
<li></span><span class="Comment"> * As long as it didn't, we can have at most one <a href="#L44" title="optimizer/util/tlist.c:44">split_pathtarget_item</a> with<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> particular nonzero sortgroupref.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1202">&#x200c;</a></span><span class="linkable">add_sp_item_to_pathtarget</span>(PathTarget *target, <a href="#L44" title="optimizer/util/tlist.c:44">split_pathtarget_item</a> *item)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lci;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look for a pre-existing entry that is <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>() and does not have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conflicting sortgroupref already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lci = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, target-&gt;exprs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *node = (Node *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; sgref = get_pathtarget_sortgroupref(target, lci);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((item-&gt;sortgroupref == sgref ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; item-&gt;sortgroupref == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sgref == <span class="Constant">0</span>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(item-&gt;expr, node))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found a match.&nbsp; Assign item's sortgroupref if it has one. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item-&gt;sortgroupref)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (target-&gt;sortgrouprefs == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target-&gt;sortgrouprefs = (Index *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(list_length(target-&gt;exprs) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Index));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target-&gt;sortgrouprefs[lci] = item-&gt;sortgroupref;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lci++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No match, so add item to PathTarget.&nbsp; Copy the expr for safety.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L695" title="optimizer/util/tlist.c:695">add_column_to_pathtarget</a>(target, (Expr *) copyObject(item-&gt;expr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; item-&gt;sortgroupref);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Apply <a href="#L1202" title="optimizer/util/tlist.c:1202">add_sp_item_to_pathtarget</a> to each <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1248">&#x200c;</a></span><span class="linkable">add_sp_items_to_pathtarget</span>(PathTarget *target, List *items)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, items)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L44" title="optimizer/util/tlist.c:44">split_pathtarget_item</a> *item = lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1202" title="optimizer/util/tlist.c:1202">add_sp_item_to_pathtarget</a>(target, item);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
