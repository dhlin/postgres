<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>optimizer/util/var.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>optimizer/util/var.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L70">flatten_join_alias_vars_context</a></li>
<li><a href="#L55">locate_var_of_level_context</a></li>
<li><a href="#L61">pull_var_clause_context</a></li>
<li><a href="#L43">pull_varattnos_context</a></li>
<li><a href="#L37">pull_varnos_context</a></li>
<li><a href="#L49">pull_vars_context</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L910">add_nullingrels_if_needed</a></li>
<li><a href="#L1036">adjust_standard_join_alias_expression</a></li>
<li><a href="#L1098">alias_relid_set</a></li>
<li><a href="#L403">contain_var_clause</a></li>
<li><a href="#L409">contain_var_clause_walker</a></li>
<li><a href="#L441">contain_vars_of_level</a></li>
<li><a href="#L452">contain_vars_of_level_walker</a></li>
<li><a href="#L744">flatten_join_alias_vars</a></li>
<li><a href="#L767">flatten_join_alias_vars_mutator</a></li>
<li><a href="#L962">is_standard_join_alias_expression</a></li>
<li><a href="#L509">locate_var_of_level</a></li>
<li><a href="#L525">locate_var_of_level_walker</a></li>
<li><a href="#L607">pull_var_clause</a></li>
<li><a href="#L627">pull_var_clause_walker</a></li>
<li><a href="#L291">pull_varattnos</a></li>
<li><a href="#L304">pull_varattnos_walker</a></li>
<li><a href="#L108">pull_varnos</a></li>
<li><a href="#L134">pull_varnos_of_level</a></li>
<li><a href="#L155">pull_varnos_walker</a></li>
<li><a href="#L335">pull_vars_of_level</a></li>
<li><a href="#L355">pull_vars_walker</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * var.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Var node manipulation routines<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: for most purposes, PlaceHolderVar is considered a Var too,<br/></li>
<li></span><span class="Comment"> * even if its contained expression is variable-free.&nbsp; Also, CurrentOfExpr<br/></li>
<li></span><span class="Comment"> * is treated as a Var for purposes of determining whether an expression<br/></li>
<li></span><span class="Comment"> * contains variables.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/optimizer/util/var.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/sysattr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/placeholder.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/prep.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parsetree.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;rewrite/rewriteManip.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; varnos;<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *root;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublevels_up;<br/></li>
<li><a id="L37">&#x200c;</a>} <span class="linkable">pull_varnos_context</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *varattnos;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; varno;<br/></li>
<li><a id="L43">&#x200c;</a>} <span class="linkable">pull_varattnos_context</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublevels_up;<br/></li>
<li><a id="L49">&#x200c;</a>} <span class="linkable">pull_vars_context</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var_location;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublevels_up;<br/></li>
<li><a id="L55">&#x200c;</a>} <span class="linkable">locate_var_of_level_context</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *varlist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li><a id="L61">&#x200c;</a>} <span class="linkable">pull_var_clause_context</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *root;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* could be NULL! */<br/></li>
<li></span>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* outer Query */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublevels_up;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; possible_sublink;&nbsp; &nbsp; <span class="Comment">/* could aliases include a SubLink? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; inserted_sublink;&nbsp; &nbsp; <span class="Comment">/* have we inserted a SubLink? */<br/></li>
<li><a id="L70">&#x200c;</a></span>} <span class="linkable">flatten_join_alias_vars_context</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L155" title="optimizer/util/var.c:155">pull_varnos_walker</a>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L37" title="optimizer/util/var.c:37">pull_varnos_context</a> *context);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L304" title="optimizer/util/var.c:304">pull_varattnos_walker</a>(Node *node, <a href="#L43" title="optimizer/util/var.c:43">pull_varattnos_context</a> *context);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L355" title="optimizer/util/var.c:355">pull_vars_walker</a>(Node *node, <a href="#L49" title="optimizer/util/var.c:49">pull_vars_context</a> *context);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L409" title="optimizer/util/var.c:409">contain_var_clause_walker</a>(Node *node, <span class="Type">void</span> *context);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L452" title="optimizer/util/var.c:452">contain_vars_of_level_walker</a>(Node *node, <span class="Type">int</span> *sublevels_up);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L525" title="optimizer/util/var.c:525">locate_var_of_level_walker</a>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L55" title="optimizer/util/var.c:55">locate_var_of_level_context</a> *context);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L627" title="optimizer/util/var.c:627">pull_var_clause_walker</a>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L61" title="optimizer/util/var.c:61">pull_var_clause_context</a> *context);<br/></li>
<li><span class="Type">static</span> Node *<a href="#L767" title="optimizer/util/var.c:767">flatten_join_alias_vars_mutator</a>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L70" title="optimizer/util/var.c:70">flatten_join_alias_vars_context</a> *context);<br/></li>
<li><span class="Type">static</span> Node *<a href="#L910" title="optimizer/util/var.c:910">add_nullingrels_if_needed</a>(PlannerInfo *root, Node *newnode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Var *oldvar);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L962" title="optimizer/util/var.c:962">is_standard_join_alias_expression</a>(Node *newnode, Var *oldvar);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1036" title="optimizer/util/var.c:1036">adjust_standard_join_alias_expression</a>(Node *newnode, Var *oldvar);<br/></li>
<li><span class="Type">static</span> Relids <a href="#L1098" title="optimizer/util/var.c:1098">alias_relid_set</a>(Query *query, Relids relids);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L108" title="optimizer/util/var.c:108">pull_varnos</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Create a set of all the distinct varnos present in a parsetree.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Only varnos that reference level-zero rtable entries are considered.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result includes outer-join relids mentioned in Var.varnullingrels and<br/></li>
<li></span><span class="Comment"> * PlaceHolderVar.phnullingrels fields in the parsetree.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;root&quot; can be passed as NULL if it is not necessary to process<br/></li>
<li></span><span class="Comment"> * PlaceHolderVars.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: this is used on not-yet-planned expressions.&nbsp; It may therefore <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a><br/></li>
<li></span><span class="Comment"> * bare SubLinks, and if so it needs to recurse into them to look for uplevel<br/></li>
<li></span><span class="Comment"> * references to the desired rtable level!&nbsp; &nbsp; But when we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a completed<br/></li>
<li></span><span class="Comment"> * SubPlan, we only need to look at the parameters passed to the subplan.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Relids<br/></li>
<li><a id="L108">&#x200c;</a><span class="linkable">pull_varnos</span>(PlannerInfo *root, Node *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L37" title="optimizer/util/var.c:37">pull_varnos_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.varnos = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; context.root = root;<br/></li>
<li>&nbsp; &nbsp; context.sublevels_up = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must be prepared to start with a Query or a bare expression tree; if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's a Query, we don't want to increment sublevels_up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; query_or_expression_tree_walker(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L155" title="optimizer/util/var.c:155">pull_varnos_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) &amp;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> context.varnos;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L134" title="optimizer/util/var.c:134">pull_varnos_of_level</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Create a set of all the distinct varnos present in a parsetree.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Only Vars of the specified level are considered.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Relids<br/></li>
<li><a id="L134">&#x200c;</a><span class="linkable">pull_varnos_of_level</span>(PlannerInfo *root, Node *node, <span class="Type">int</span> levelsup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L37" title="optimizer/util/var.c:37">pull_varnos_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.varnos = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; context.root = root;<br/></li>
<li>&nbsp; &nbsp; context.sublevels_up = levelsup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must be prepared to start with a Query or a bare expression tree; if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's a Query, we don't want to increment sublevels_up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; query_or_expression_tree_walker(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L155" title="optimizer/util/var.c:155">pull_varnos_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) &amp;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> context.varnos;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L155">&#x200c;</a></span><span class="linkable">pull_varnos_walker</span>(Node *node, <a href="#L37" title="optimizer/util/var.c:37">pull_varnos_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varlevelsup == context-&gt;sublevels_up)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;varnos = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(context-&gt;varnos, var-&gt;varno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;varnos = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context-&gt;varnos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varnullingrels);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, CurrentOfExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CurrentOfExpr *cexpr = (CurrentOfExpr *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;sublevels_up == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;varnos = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(context-&gt;varnos, cexpr-&gt;cvarno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *phv = (PlaceHolderVar *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If a PlaceHolderVar is not of the target query level, ignore it,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * instead recursing into its expression to see if it contains <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> that are of the target level.&nbsp; We'll also do that when the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caller doesn't pass a &quot;root&quot; pointer.&nbsp; (We probably shouldn't see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PlaceHolderVars at all in such cases, but if we do, this is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reasonable behavior.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (phv-&gt;phlevelsup == context-&gt;sublevels_up &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;root != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ideally, the PHV's contribution to context-&gt;varnos is its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ph_eval_at set.&nbsp; However, this code can be invoked <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that's been computed.&nbsp; If we cannot <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a PlaceHolderInfo,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fall back to the conservative assumption that the PHV will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * evaluated at its syntactic level (phv-&gt;phrels).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Another problem is that a PlaceHolderVar can appear in quals or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tlists that have been translated for use in a child appendrel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Typically such a PHV is a parameter expression sourced by some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other relation, so that the translation from parent appendrel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to child doesn't change its phrels, and we should still take<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ph_eval_at at face value.&nbsp; But in corner cases, the PHV's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * original phrels can include the parent appendrel itself, in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which case the translated PHV will have the child appendrel in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * phrels, and we must <a href="../../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> ph_eval_at to match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderInfo *phinfo = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (phv-&gt;phlevelsup == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (phv-&gt;phid &lt; context-&gt;root-&gt;placeholder_array_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phinfo = context-&gt;root-&gt;placeholder_array[phv-&gt;phid];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (phinfo == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No PlaceHolderInfo yet, use phrels */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;varnos = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context-&gt;varnos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phv-&gt;phrels);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(phv-&gt;phrels, phinfo-&gt;ph_var-&gt;phrels))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Normal case: use ph_eval_at */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;varnos = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context-&gt;varnos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phinfo-&gt;ph_eval_at);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Translated PlaceHolderVar: <a href="../../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> ph_eval_at to match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; newevalat,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delta;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remove what was removed from phv-&gt;phrels ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delta = <a href="../../nodes/bitmapset.c.html#L346" title="nodes/bitmapset.c:346">bms_difference</a>(phinfo-&gt;ph_var-&gt;phrels, phv-&gt;phrels);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newevalat = <a href="../../nodes/bitmapset.c.html#L346" title="nodes/bitmapset.c:346">bms_difference</a>(phinfo-&gt;ph_eval_at, delta);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... then if that was in fact part of ph_eval_at ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(newevalat, phinfo-&gt;ph_eval_at))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... add what was added */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delta = <a href="../../nodes/bitmapset.c.html#L346" title="nodes/bitmapset.c:346">bms_difference</a>(phv-&gt;phrels, phinfo-&gt;ph_var-&gt;phrels);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newevalat = <a href="../../nodes/bitmapset.c.html#L1230" title="nodes/bitmapset.c:1230">bms_join</a>(newevalat, delta);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;varnos = <a href="../../nodes/bitmapset.c.html#L1230" title="nodes/bitmapset.c:1230">bms_join</a>(context-&gt;varnos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newevalat);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In all three cases, include phnullingrels in the result.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't worry about possibly needing to <a href="../../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> it, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * appendrels only <a href="../../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> varnos of baserels, not outer joins.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;varnos = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(context-&gt;varnos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phv-&gt;phnullingrels);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't recurse into expression */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, Query))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse into RTE subquery or not-yet-planned sublink subquery */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = query_tree_walker((Query *) node, <a href="#L155" title="optimizer/util/var.c:155">pull_varnos_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L155" title="optimizer/util/var.c:155">pull_varnos_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L291" title="optimizer/util/var.c:291">pull_varattnos</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Find all the distinct attribute numbers present in an expression tree,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and add them to the initial contents of *varattnos.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Only Vars of the given varno and rtable level zero are considered.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Attribute numbers are offset by FirstLowInvalidHeapAttributeNumber so that<br/></li>
<li></span><span class="Comment"> * we can include system attributes (e.g., OID) in the bitmap representation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently, this does not support unplanned subqueries; that is not needed<br/></li>
<li></span><span class="Comment"> * for current uses.&nbsp; It will handle already-planned SubPlan nodes, though,<br/></li>
<li></span><span class="Comment"> * looking into only the &quot;testexpr&quot; and the &quot;args&quot; list.&nbsp; (The subplan cannot<br/></li>
<li></span><span class="Comment"> * contain <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other references to Vars of the current level.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L291">&#x200c;</a></span><span class="linkable">pull_varattnos</span>(Node *node, Index varno, Bitmapset **varattnos)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L43" title="optimizer/util/var.c:43">pull_varattnos_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.varattnos = *varattnos;<br/></li>
<li>&nbsp; &nbsp; context.varno = varno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L304" title="optimizer/util/var.c:304">pull_varattnos_walker</a>(node, &amp;context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *varattnos = context.varattnos;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L304">&#x200c;</a></span><span class="linkable">pull_varattnos_walker</span>(Node *node, <a href="#L43" title="optimizer/util/var.c:43">pull_varattnos_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varno == context-&gt;varno &amp;&amp; var-&gt;varlevelsup == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;varattnos =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(context-&gt;varattnos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var-&gt;varattno - FirstLowInvalidHeapAttributeNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an unplanned subquery */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!IsA(node, Query));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L304" title="optimizer/util/var.c:304">pull_varattnos_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L335" title="optimizer/util/var.c:335">pull_vars_of_level</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Create a list of all Vars (and PlaceHolderVars) referencing the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; specified query level in the given parsetree.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caution: the Vars are not copied, only linked into the list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L335">&#x200c;</a><span class="linkable">pull_vars_of_level</span>(Node *node, <span class="Type">int</span> levelsup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="optimizer/util/var.c:49">pull_vars_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> = NIL;<br/></li>
<li>&nbsp; &nbsp; context.sublevels_up = levelsup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must be prepared to start with a Query or a bare expression tree; if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's a Query, we don't want to increment sublevels_up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; query_or_expression_tree_walker(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L355" title="optimizer/util/var.c:355">pull_vars_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) &amp;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> context.<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L355">&#x200c;</a></span><span class="linkable">pull_vars_walker</span>(Node *node, <a href="#L49" title="optimizer/util/var.c:49">pull_vars_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varlevelsup == context-&gt;sublevels_up)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(context-&gt;<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>, var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *phv = (PlaceHolderVar *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (phv-&gt;phlevelsup == context-&gt;sublevels_up)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(context-&gt;<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>, phv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we don't want to look into the contained expression */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Query))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse into RTE subquery or not-yet-planned sublink subquery */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = query_tree_walker((Query *) node, <a href="#L355" title="optimizer/util/var.c:355">pull_vars_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L355" title="optimizer/util/var.c:355">pull_vars_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L403" title="optimizer/util/var.c:403">contain_var_clause</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Recursively scan a clause to discover whether it contains <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> Var nodes<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; (of the current query level).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Returns true if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> varnode found.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Does not examine subqueries, therefore must only be used after reduction<br/></li>
<li></span><span class="Comment"> * of sublinks to subplans!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L403">&#x200c;</a></span><span class="linkable">contain_var_clause</span>(Node *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L409" title="optimizer/util/var.c:409">contain_var_clause_walker</a>(node, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L409">&#x200c;</a></span><span class="linkable">contain_var_clause_walker</span>(Node *node, <span class="Type">void</span> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((Var *) node)-&gt;varlevelsup == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* abort the tree traversal and return true */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, CurrentOfExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((PlaceHolderVar *) node)-&gt;phlevelsup == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* abort the tree traversal and return true */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else fall through to check the contained expr */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L409" title="optimizer/util/var.c:409">contain_var_clause_walker</a>, context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L441" title="optimizer/util/var.c:441">contain_vars_of_level</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Recursively scan a clause to discover whether it contains <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> Var nodes<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; of the specified query level.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Returns true if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such Var found.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Will recurse into sublinks.&nbsp; Also, may be invoked directly on a Query.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L441">&#x200c;</a></span><span class="linkable">contain_vars_of_level</span>(Node *node, <span class="Type">int</span> levelsup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublevels_up = levelsup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> query_or_expression_tree_walker(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L452" title="optimizer/util/var.c:452">contain_vars_of_level_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) &amp;sublevels_up,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L452">&#x200c;</a></span><span class="linkable">contain_vars_of_level_walker</span>(Node *node, <span class="Type">int</span> *sublevels_up)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((Var *) node)-&gt;varlevelsup == *sublevels_up)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* abort tree traversal and return true */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, CurrentOfExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*sublevels_up == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((PlaceHolderVar *) node)-&gt;phlevelsup == *sublevels_up)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* abort the tree traversal and return true */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else fall through to check the contained expr */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Query))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse into subselects */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*sublevels_up)++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = query_tree_walker((Query *) node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L452" title="optimizer/util/var.c:452">contain_vars_of_level_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) sublevels_up,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*sublevels_up)--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L452" title="optimizer/util/var.c:452">contain_vars_of_level_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) sublevels_up);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L509" title="optimizer/util/var.c:509">locate_var_of_level</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Find the <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> location of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> Var of the specified query level.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns -1 if no such Var is in the querytree, or if they all have<br/></li>
<li></span><span class="Comment"> * unknown <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> location.&nbsp; (The former case is probably caller error,<br/></li>
<li></span><span class="Comment"> * but we don't bother to distinguish it from the latter case.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Will recurse into sublinks.&nbsp; Also, may be invoked directly on a Query.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: it might seem appropriate to <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> this functionality into<br/></li>
<li></span><span class="Comment"> * <a href="#L441" title="optimizer/util/var.c:441">contain_vars_of_level</a>, but that would complicate that function's API.<br/></li>
<li></span><span class="Comment"> * Currently, the only uses of this function are for error reporting,<br/></li>
<li></span><span class="Comment"> * and so shaving cycles probably isn't very important.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L509">&#x200c;</a></span><span class="linkable">locate_var_of_level</span>(Node *node, <span class="Type">int</span> levelsup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L55" title="optimizer/util/var.c:55">locate_var_of_level_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.var_location = -<span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* in case we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> nothing */<br/></li>
<li></span>&nbsp; &nbsp; context.sublevels_up = levelsup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) query_or_expression_tree_walker(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L525" title="optimizer/util/var.c:525">locate_var_of_level_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) &amp;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> context.var_location;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L525">&#x200c;</a></span><span class="linkable">locate_var_of_level_walker</span>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L55" title="optimizer/util/var.c:55">locate_var_of_level_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varlevelsup == context-&gt;sublevels_up &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;location &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;var_location = var-&gt;location;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* abort tree traversal and return true */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, CurrentOfExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* since CurrentOfExpr doesn't carry location, nothing we can do */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No extra code needed for PlaceHolderVar; just look in contained expr */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Query))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse into subselects */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = query_tree_walker((Query *) node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L525" title="optimizer/util/var.c:525">locate_var_of_level_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L525" title="optimizer/util/var.c:525">locate_var_of_level_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L607" title="optimizer/util/var.c:607">pull_var_clause</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Recursively pulls all Var nodes from an expression clause.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Aggrefs are handled according to these bits in 'flags':<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; PVC_INCLUDE_AGGREGATES&nbsp; &nbsp; &nbsp; &nbsp; include Aggrefs in output list<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; PVC_RECURSE_AGGREGATES&nbsp; &nbsp; &nbsp; &nbsp; recurse into Aggref arguments<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; neither flag&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw error if Aggref found<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Vars within an Aggref's expression are included in the result only<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; when PVC_RECURSE_AGGREGATES is specified.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; WindowFuncs are handled according to these bits in 'flags':<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; PVC_INCLUDE_WINDOWFUNCS&nbsp; &nbsp; &nbsp; &nbsp; include WindowFuncs in output list<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; PVC_RECURSE_WINDOWFUNCS&nbsp; &nbsp; &nbsp; &nbsp; recurse into WindowFunc arguments<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; neither flag&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw error if WindowFunc found<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Vars within a WindowFunc's expression are included in the result only<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; when PVC_RECURSE_WINDOWFUNCS is specified.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; PlaceHolderVars are handled according to these bits in 'flags':<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; PVC_INCLUDE_PLACEHOLDERS&nbsp; &nbsp; include PlaceHolderVars in output list<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; PVC_RECURSE_PLACEHOLDERS&nbsp; &nbsp; recurse into PlaceHolderVar arguments<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; neither flag&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw error if PlaceHolderVar found<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Vars within a PHV's expression are included in the result only<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; when PVC_RECURSE_PLACEHOLDERS is specified.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; GroupingFuncs are treated exactly like Aggrefs, and so do not need<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; their own flag bits.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; CurrentOfExpr nodes are ignored in all cases.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Upper-level <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> (with varlevelsup &gt; 0) should not be seen here,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; likewise for <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level Aggrefs and PlaceHolderVars.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Returns list of nodes found.&nbsp; Note the nodes themselves are not<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; copied, only referenced.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Does not examine subqueries, therefore must only be used after reduction<br/></li>
<li></span><span class="Comment"> * of sublinks to subplans!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L607">&#x200c;</a><span class="linkable">pull_var_clause</span>(Node *node, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L61" title="optimizer/util/var.c:61">pull_var_clause_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assert that caller has not specified inconsistent flags */<br/></li>
<li></span>&nbsp; &nbsp; Assert((flags &amp; (PVC_INCLUDE_AGGREGATES | PVC_RECURSE_AGGREGATES))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; != (PVC_INCLUDE_AGGREGATES | PVC_RECURSE_AGGREGATES));<br/></li>
<li>&nbsp; &nbsp; Assert((flags &amp; (PVC_INCLUDE_WINDOWFUNCS | PVC_RECURSE_WINDOWFUNCS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; != (PVC_INCLUDE_WINDOWFUNCS | PVC_RECURSE_WINDOWFUNCS));<br/></li>
<li>&nbsp; &nbsp; Assert((flags &amp; (PVC_INCLUDE_PLACEHOLDERS | PVC_RECURSE_PLACEHOLDERS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; != (PVC_INCLUDE_PLACEHOLDERS | PVC_RECURSE_PLACEHOLDERS));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.varlist = NIL;<br/></li>
<li>&nbsp; &nbsp; context.flags = flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L627" title="optimizer/util/var.c:627">pull_var_clause_walker</a>(node, &amp;context);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> context.varlist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L627">&#x200c;</a></span><span class="linkable">pull_var_clause_walker</span>(Node *node, <a href="#L61" title="optimizer/util/var.c:61">pull_var_clause_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((Var *) node)-&gt;varlevelsup != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;Upper-level Var found where not expected&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;varlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(context-&gt;varlist, node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, Aggref))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((Aggref *) node)-&gt;agglevelsup != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;Upper-level Aggref found where not expected&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;flags &amp; PVC_INCLUDE_AGGREGATES)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;varlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(context-&gt;varlist, node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we do NOT descend into the contained expression */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (context-&gt;flags &amp; PVC_RECURSE_AGGREGATES)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through to recurse into the aggregate's arguments */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;Aggref found where not expected&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, GroupingFunc))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((GroupingFunc *) node)-&gt;agglevelsup != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;Upper-level GROUPING found where not expected&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;flags &amp; PVC_INCLUDE_AGGREGATES)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;varlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(context-&gt;varlist, node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we do NOT descend into the contained expression */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (context-&gt;flags &amp; PVC_RECURSE_AGGREGATES)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through to recurse into the GroupingFunc's arguments */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;GROUPING found where not expected&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, WindowFunc))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WindowFuncs have no levelsup field to check ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;flags &amp; PVC_INCLUDE_WINDOWFUNCS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;varlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(context-&gt;varlist, node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we do NOT descend into the contained expressions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (context-&gt;flags &amp; PVC_RECURSE_WINDOWFUNCS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through to recurse into the windowfunc's arguments */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;WindowFunc found where not expected&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((PlaceHolderVar *) node)-&gt;phlevelsup != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;Upper-level PlaceHolderVar found where not expected&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;flags &amp; PVC_INCLUDE_PLACEHOLDERS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;varlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(context-&gt;varlist, node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we do NOT descend into the contained expression */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (context-&gt;flags &amp; PVC_RECURSE_PLACEHOLDERS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through to recurse into the placeholder's expression */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;PlaceHolderVar found where not expected&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L627" title="optimizer/util/var.c:627">pull_var_clause_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L744" title="optimizer/util/var.c:744">flatten_join_alias_vars</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Replace Vars that reference JOIN outputs with references to the original<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; relation variables instead.&nbsp; This allows quals involving such <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> to be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; pushed down.&nbsp; Whole-row Vars that reference JOIN relations are expanded<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; into RowExpr constructs that name the individual output Vars.&nbsp; This<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; is necessary since we will not scan the JOIN as a base relation, which<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; is the only way that the executor can directly handle whole-row Vars.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This also adjusts relid sets found in some expression node types to<br/></li>
<li></span><span class="Comment"> * substitute the contained base+OJ rels for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> join relid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If a JOIN contains sub-selects that have been flattened, its join alias<br/></li>
<li></span><span class="Comment"> * entries might <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> be arbitrary expressions, not just Vars.&nbsp; This affects<br/></li>
<li></span><span class="Comment"> * this function in two important ways.&nbsp; First, we might <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> ourselves<br/></li>
<li></span><span class="Comment"> * inserting SubLink expressions into subqueries, and we must make sure that<br/></li>
<li></span><span class="Comment"> * their Query.hasSubLinks fields get set to true if so.&nbsp; If there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * SubLinks in the join alias lists, the outer Query should already have<br/></li>
<li></span><span class="Comment"> * hasSubLinks = true, so this is only relevant to un-flattened subqueries.<br/></li>
<li></span><span class="Comment"> * Second, we have to preserve <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> varnullingrels info attached to the<br/></li>
<li></span><span class="Comment"> * alias Vars we're replacing.&nbsp; If the replacement expression is a Var or<br/></li>
<li></span><span class="Comment"> * PlaceHolderVar or constructed from those, we can just add the<br/></li>
<li></span><span class="Comment"> * varnullingrels bits to the existing nullingrels field(s); otherwise<br/></li>
<li></span><span class="Comment"> * we have to add a PlaceHolderVar wrapper.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: this is also used by the parser, to expand join alias Vars <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * checking GROUP BY validity.&nbsp; For that use-case, root will be NULL, which<br/></li>
<li></span><span class="Comment"> * is why we have to pass the Query separately.&nbsp; We need the root itself only<br/></li>
<li></span><span class="Comment"> * for making PlaceHolderVars.&nbsp; We can avoid making PlaceHolderVars in the<br/></li>
<li></span><span class="Comment"> * parser's usage because it won't be dealing with arbitrary expressions:<br/></li>
<li></span><span class="Comment"> * so long as <a href="#L1036" title="optimizer/util/var.c:1036">adjust_standard_join_alias_expression</a> can handle everything<br/></li>
<li></span><span class="Comment"> * the parser would make as a join alias expression, we're OK.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Node *<br/></li>
<li><a id="L744">&#x200c;</a><span class="linkable">flatten_join_alias_vars</span>(PlannerInfo *root, Query *query, Node *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L70" title="optimizer/util/var.c:70">flatten_join_alias_vars_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do not expect this to be applied to the whole Query, only to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expressions or LATERAL subqueries.&nbsp; Hence, if the top node is a Query,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's okay to immediately increment sublevels_up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(node != (Node *) query);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.root = root;<br/></li>
<li>&nbsp; &nbsp; context.query = query;<br/></li>
<li>&nbsp; &nbsp; context.sublevels_up = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* flag whether join aliases could possibly contain SubLinks */<br/></li>
<li></span>&nbsp; &nbsp; context.possible_sublink = query-&gt;hasSubLinks;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if hasSubLinks is already true, no need to work hard */<br/></li>
<li></span>&nbsp; &nbsp; context.inserted_sublink = query-&gt;hasSubLinks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L767" title="optimizer/util/var.c:767">flatten_join_alias_vars_mutator</a>(node, &amp;context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Node *<br/></li>
<li><a id="L767">&#x200c;</a><span class="linkable">flatten_join_alias_vars_mutator</span>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L70" title="optimizer/util/var.c:70">flatten_join_alias_vars_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *newvar;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No change unless Var belongs to a JOIN of the target level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varlevelsup != context-&gt;sublevels_up)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> node;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no need to copy, really */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rte = rt_fetch(var-&gt;varno, context-&gt;query-&gt;rtable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind != RTE_JOIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varattno == InvalidAttrNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must expand whole-row reference */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RowExpr&nbsp; &nbsp; *rowexpr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *fields = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *colnames = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lv;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *ln;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(rte-&gt;joinaliasvars) == list_length(rte-&gt;eref-&gt;colnames));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; forboth(lv, rte-&gt;joinaliasvars, ln, rte-&gt;eref-&gt;colnames)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvar = (Node *) lfirst(lv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore dropped columns */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newvar == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvar = copyObject(newvar);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are expanding an alias carried down from an <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * query, must adjust its varlevelsup fields.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;sublevels_up != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../rewrite/rewriteManip.c.html#L849" title="rewrite/rewriteManip.c:849">IncrementVarSublevelsUp</a>(newvar, context-&gt;sublevels_up, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Preserve original Var's location, if possible */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(newvar, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((Var *) newvar)-&gt;location = var-&gt;location;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse in case join input is itself a join */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* (also takes care of setting inserted_sublink if needed) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvar = <a href="#L767" title="optimizer/util/var.c:767">flatten_join_alias_vars_mutator</a>(newvar, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fields = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(fields, newvar);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We need the names of non-dropped columns, too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colnames = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(colnames, copyObject((Node *) lfirst(ln)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowexpr = makeNode(RowExpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowexpr-&gt;args = fields;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowexpr-&gt;row_typeid = var-&gt;vartype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowexpr-&gt;row_format = COERCE_IMPLICIT_CAST;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* vartype will always be RECORDOID, so we always need colnames */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowexpr-&gt;colnames = colnames;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowexpr-&gt;location = var-&gt;location;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Lastly, add <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> varnullingrels to the replacement expression */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L910" title="optimizer/util/var.c:910">add_nullingrels_if_needed</a>(context-&gt;root, (Node *) rowexpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Expand join alias reference */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(var-&gt;varattno &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newvar = (Node *) list_nth(rte-&gt;joinaliasvars, var-&gt;varattno - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(newvar != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newvar = copyObject(newvar);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are expanding an alias carried down from an <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> query, must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * adjust its varlevelsup fields.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;sublevels_up != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../rewrite/rewriteManip.c.html#L849" title="rewrite/rewriteManip.c:849">IncrementVarSublevelsUp</a>(newvar, context-&gt;sublevels_up, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Preserve original Var's location, if possible */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(newvar, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((Var *) newvar)-&gt;location = var-&gt;location;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse in case join input is itself a join */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newvar = <a href="#L767" title="optimizer/util/var.c:767">flatten_join_alias_vars_mutator</a>(newvar, context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Detect if we are adding a sublink to query */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;possible_sublink &amp;&amp; !context-&gt;inserted_sublink)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;inserted_sublink = <a href="../../rewrite/rewriteManip.c.html#L295" title="rewrite/rewriteManip.c:295">checkExprHasSubLink</a>(newvar);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Lastly, add <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> varnullingrels to the replacement expression */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L910" title="optimizer/util/var.c:910">add_nullingrels_if_needed</a>(context-&gt;root, newvar, var);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy the PlaceHolderVar node with correct mutation of subnodes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *phv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; phv = (PlaceHolderVar *) expression_tree_mutator(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L767" title="optimizer/util/var.c:767">flatten_join_alias_vars_mutator</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> fix PlaceHolderVar's relid sets */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (phv-&gt;phlevelsup == context-&gt;sublevels_up)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phv-&gt;phrels = <a href="#L1098" title="optimizer/util/var.c:1098">alias_relid_set</a>(context-&gt;query,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phv-&gt;phrels);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we *don't* change phnullingrels */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) phv;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Query))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse into RTE subquery or not-yet-planned sublink subquery */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *newnode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; save_inserted_sublink;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; save_inserted_sublink = context-&gt;inserted_sublink;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;inserted_sublink = ((Query *) node)-&gt;hasSubLinks;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newnode = query_tree_mutator((Query *) node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L767" title="optimizer/util/var.c:767">flatten_join_alias_vars_mutator</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; QTW_IGNORE_JOINALIASES);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newnode-&gt;hasSubLinks |= context-&gt;inserted_sublink;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;inserted_sublink = save_inserted_sublink;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) newnode;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Already-planned tree not supported */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!IsA(node, SubPlan));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shouldn't need to handle these <a href="../plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> auxiliary nodes here */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!IsA(node, SpecialJoinInfo));<br/></li>
<li>&nbsp; &nbsp; Assert(!IsA(node, PlaceHolderInfo));<br/></li>
<li>&nbsp; &nbsp; Assert(!IsA(node, MinMaxAggInfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_mutator(node, <a href="#L767" title="optimizer/util/var.c:767">flatten_join_alias_vars_mutator</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add oldvar's varnullingrels, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, to a flattened join alias expression.<br/></li>
<li></span><span class="Comment"> * The newnode has been copied, so we can modify it freely.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Node *<br/></li>
<li><a id="L910">&#x200c;</a><span class="linkable">add_nullingrels_if_needed</span>(PlannerInfo *root, Node *newnode, Var *oldvar)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (oldvar-&gt;varnullingrels == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> newnode;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* If possible, do it by adding to existing nullingrel fields */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L962" title="optimizer/util/var.c:962">is_standard_join_alias_expression</a>(newnode, oldvar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1036" title="optimizer/util/var.c:1036">adjust_standard_join_alias_expression</a>(newnode, oldvar);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (root)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can insert a PlaceHolderVar to carry the nullingrels.&nbsp; However,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deciding where to evaluate the PHV is slightly tricky.&nbsp; We first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * try to evaluate it at the natural semantic level of the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expression; but if that expression is variable-free, fall back to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * evaluating it at the join that the oldvar is an alias Var for.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *newphv;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; levelsup = oldvar-&gt;varlevelsup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; phrels = <a href="#L134" title="optimizer/util/var.c:134">pull_varnos_of_level</a>(root, newnode, levelsup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bms_is_empty(phrels))&nbsp; &nbsp; <span class="Comment">/* variable-free? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (levelsup != <span class="Constant">0</span>)&nbsp; &nbsp; <span class="Comment">/* this won't work otherwise */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unsupported join alias expression&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phrels = <a href="../prep/prepjointree.c.html#L3922" title="optimizer/prep/prepjointree.c:3922">get_relids_for_join</a>(root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>, oldvar-&gt;varno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's an outer join, eval below not above the join */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phrels = <a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(phrels, oldvar-&gt;varno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!bms_is_empty(phrels));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newphv = <a href="placeholder.c.html#L54" title="optimizer/util/placeholder.c:54">make_placeholder_expr</a>(root, (Expr *) newnode, phrels);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* newphv has zero phlevelsup and NULL phnullingrels; fix it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newphv-&gt;phlevelsup = levelsup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newphv-&gt;phnullingrels = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(oldvar-&gt;varnullingrels);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newnode = (Node *) newphv;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ooops, we're missing support for something the parser can make */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unsupported join alias expression&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check to see if we can insert nullingrels into this join alias expression<br/></li>
<li></span><span class="Comment"> * without use of a separate PlaceHolderVar.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This will handle Vars, PlaceHolderVars, and implicit-coercion and COALESCE<br/></li>
<li></span><span class="Comment"> * expressions built from those.&nbsp; This coverage needs to handle anything<br/></li>
<li></span><span class="Comment"> * that the parser would put into joinaliasvars.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L962">&#x200c;</a></span><span class="linkable">is_standard_join_alias_expression</span>(Node *newnode, Var *oldvar)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newnode == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(newnode, Var) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((Var *) newnode)-&gt;varlevelsup == oldvar-&gt;varlevelsup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(newnode, PlaceHolderVar) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((PlaceHolderVar *) newnode)-&gt;phlevelsup == oldvar-&gt;varlevelsup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(newnode, FuncExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FuncExpr&nbsp;&nbsp; *fexpr = (FuncExpr *) newnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need to assume that the function wouldn't produce non-NULL from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NULL, which is reasonable for implicit coercions but otherwise not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so much.&nbsp; (Looking at its strictness is likely overkill, and anyway<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it would cause us to fail if someone forgot to mark an implicit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * coercion as strict.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fexpr-&gt;funcformat != COERCE_IMPLICIT_CAST ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fexpr-&gt;args == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Examine only the first argument --- coercions might have additional<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * arguments that are constants.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L962" title="optimizer/util/var.c:962">is_standard_join_alias_expression</a>(linitial(fexpr-&gt;args), oldvar);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(newnode, RelabelType))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelabelType *relabel = (RelabelType *) newnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This definitely won't produce non-NULL from NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L962" title="optimizer/util/var.c:962">is_standard_join_alias_expression</a>((Node *) relabel-&gt;arg, oldvar);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(newnode, CoerceViaIO))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CoerceViaIO *iocoerce = (CoerceViaIO *) newnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This definitely won't produce non-NULL from NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L962" title="optimizer/util/var.c:962">is_standard_join_alias_expression</a>((Node *) iocoerce-&gt;arg, oldvar);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(newnode, ArrayCoerceExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ArrayCoerceExpr *acoerce = (ArrayCoerceExpr *) newnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This definitely won't produce non-NULL from NULL (at array level) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L962" title="optimizer/util/var.c:962">is_standard_join_alias_expression</a>((Node *) acoerce-&gt;arg, oldvar);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(newnode, CoalesceExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CoalesceExpr *cexpr = (CoalesceExpr *) newnode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(cexpr-&gt;args != NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, cexpr-&gt;args)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L962" title="optimizer/util/var.c:962">is_standard_join_alias_expression</a>(lfirst(lc), oldvar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> nullingrels into an expression accepted by<br/></li>
<li></span><span class="Comment"> * <a href="#L962" title="optimizer/util/var.c:962">is_standard_join_alias_expression</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1036">&#x200c;</a></span><span class="linkable">adjust_standard_join_alias_expression</span>(Node *newnode, Var *oldvar)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(newnode, Var) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((Var *) newnode)-&gt;varlevelsup == oldvar-&gt;varlevelsup)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *newvar = (Var *) newnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newvar-&gt;varnullingrels = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(newvar-&gt;varnullingrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldvar-&gt;varnullingrels);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(newnode, PlaceHolderVar) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((PlaceHolderVar *) newnode)-&gt;phlevelsup == oldvar-&gt;varlevelsup)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *newphv = (PlaceHolderVar *) newnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newphv-&gt;phnullingrels = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(newphv-&gt;phnullingrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldvar-&gt;varnullingrels);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(newnode, FuncExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FuncExpr&nbsp;&nbsp; *fexpr = (FuncExpr *) newnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1036" title="optimizer/util/var.c:1036">adjust_standard_join_alias_expression</a>(linitial(fexpr-&gt;args), oldvar);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(newnode, RelabelType))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelabelType *relabel = (RelabelType *) newnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1036" title="optimizer/util/var.c:1036">adjust_standard_join_alias_expression</a>((Node *) relabel-&gt;arg, oldvar);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(newnode, CoerceViaIO))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CoerceViaIO *iocoerce = (CoerceViaIO *) newnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1036" title="optimizer/util/var.c:1036">adjust_standard_join_alias_expression</a>((Node *) iocoerce-&gt;arg, oldvar);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(newnode, ArrayCoerceExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ArrayCoerceExpr *acoerce = (ArrayCoerceExpr *) newnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1036" title="optimizer/util/var.c:1036">adjust_standard_join_alias_expression</a>((Node *) acoerce-&gt;arg, oldvar);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(newnode, CoalesceExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CoalesceExpr *cexpr = (CoalesceExpr *) newnode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(cexpr-&gt;args != NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, cexpr-&gt;args)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1036" title="optimizer/util/var.c:1036">adjust_standard_join_alias_expression</a>(lfirst(lc), oldvar);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1098" title="optimizer/util/var.c:1098">alias_relid_set</a>: in a set of RT indexes, replace joins by their<br/></li>
<li></span><span class="Comment"> * underlying base+OJ relids<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Relids<br/></li>
<li><a id="L1098">&#x200c;</a><span class="linkable">alias_relid_set</span>(Query *query, Relids relids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtindex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rtindex = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((rtindex = <a href="../../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(relids, rtindex)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = rt_fetch(rtindex, query-&gt;rtable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind == RTE_JOIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/bitmapset.c.html#L1230" title="nodes/bitmapset.c:1230">bms_join</a>(result, <a href="../prep/prepjointree.c.html#L3922" title="optimizer/prep/prepjointree.c:3922">get_relids_for_join</a>(query, rtindex));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(result, rtindex);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
