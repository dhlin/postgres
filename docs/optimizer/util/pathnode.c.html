<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>optimizer/util/pathnode.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>optimizer/util/pathnode.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L40">PathCostComparison</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L747">add_partial_path</a></li>
<li><a href="#L865">add_partial_path_precheck</a></li>
<li><a href="#L420">add_path</a></li>
<li><a href="#L642">add_path_precheck</a></li>
<li><a href="#L3878">adjust_limit_rows_costs</a></li>
<li><a href="#L1397">append_startup_cost_compare</a></li>
<li><a href="#L1375">append_total_cost_compare</a></li>
<li><a href="#L2793">apply_projection_to_path</a></li>
<li><a href="#L2378">calc_nestloop_required_outer</a></li>
<li><a href="#L2405">calc_non_nestloop_required_outer</a></li>
<li><a href="#L115">compare_fractional_path_costs</a></li>
<li><a href="#L69">compare_path_costs</a></li>
<li><a href="#L164">compare_path_costs_fuzzily</a></li>
<li><a href="#L3155">create_agg_path</a></li>
<li><a href="#L1244">create_append_path</a></li>
<li><a href="#L1075">create_bitmap_and_path</a></li>
<li><a href="#L1042">create_bitmap_heap_path</a></li>
<li><a href="#L1127">create_bitmap_or_path</a></li>
<li><a href="#L2124">create_ctescan_path</a></li>
<li><a href="#L2281">create_foreign_join_path</a></li>
<li><a href="#L2333">create_foreign_upper_path</a></li>
<li><a href="#L2235">create_foreignscan_path</a></li>
<li><a href="#L2046">create_functionscan_path</a></li>
<li><a href="#L1881">create_gather_merge_path</a></li>
<li><a href="#L1972">create_gather_path</a></li>
<li><a href="#L3044">create_group_path</a></li>
<li><a href="#L1518">create_group_result_path</a></li>
<li><a href="#L3237">create_groupingsets_path</a></li>
<li><a href="#L2619">create_hashjoin_path</a></li>
<li><a href="#L2951">create_incremental_sort_path</a></li>
<li><a href="#L993">create_index_path</a></li>
<li><a href="#L3823">create_limit_path</a></li>
<li><a href="#L3659">create_lockrows_path</a></li>
<li><a href="#L1566">create_material_path</a></li>
<li><a href="#L1598">create_memoize_path</a></li>
<li><a href="#L1415">create_merge_append_path</a></li>
<li><a href="#L2553">create_mergejoin_path</a></li>
<li><a href="#L3397">create_minmaxagg_path</a></li>
<li><a href="#L3722">create_modifytable_path</a></li>
<li><a href="#L2150">create_namedtuplestorescan_path</a></li>
<li><a href="#L2457">create_nestloop_path</a></li>
<li><a href="#L2685">create_projection_path</a></li>
<li><a href="#L3614">create_recursiveunion_path</a></li>
<li><a href="#L2176">create_resultscan_path</a></li>
<li><a href="#L952">create_samplescan_path</a></li>
<li><a href="#L927">create_seqscan_path</a></li>
<li><a href="#L2882">create_set_projection_path</a></li>
<li><a href="#L3552">create_setop_path</a></li>
<li><a href="#L3000">create_sort_path</a></li>
<li><a href="#L2016">create_subqueryscan_path</a></li>
<li><a href="#L2072">create_tablefuncscan_path</a></li>
<li><a href="#L1208">create_tidrangescan_path</a></li>
<li><a href="#L1179">create_tidscan_path</a></li>
<li><a href="#L1654">create_unique_path</a></li>
<li><a href="#L3103">create_upper_unique_path</a></li>
<li><a href="#L2098">create_valuesscan_path</a></li>
<li><a href="#L3484">create_windowagg_path</a></li>
<li><a href="#L2202">create_worktablescan_path</a></li>
<li><a href="#L4408">path_is_reparameterizable_by_child</a></li>
<li><a href="#L4568">pathlist_is_reparameterizable_by_child</a></li>
<li><a href="#L3946">reparameterize_path</a></li>
<li><a href="#L4112">reparameterize_path_by_child</a></li>
<li><a href="#L4539">reparameterize_pathlist_by_child</a></li>
<li><a href="#L242">set_cheapest</a></li>
<li><a href="#L1946">translate_sub_tlist</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L4120">ADJUST_CHILD_ATTRS</a></li>
<li><a href="#L166">CONSIDER_PATH_STARTUP_COST</a></li>
<li><a href="#L211">CONSIDER_PATH_STARTUP_COST</a></li>
<li><a href="#L4416">REJECT_IF_PATH_LIST_NOT_REPARAMETERIZABLE</a></li>
<li><a href="#L4410">REJECT_IF_PATH_NOT_REPARAMETERIZABLE</a></li>
<li><a href="#L4126">REPARAMETERIZE_CHILD_PATH</a></li>
<li><a href="#L4133">REPARAMETERIZE_CHILD_PATH_LIST</a></li>
<li><a href="#L47">STD_FUZZ_FACTOR</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * pathnode.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Routines to manipulate pathlists and create path nodes<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/optimizer/util/pathnode.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;foreign/fdwapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/extensible.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/appendinfo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/clauses.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/cost.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/pathnode.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/paths.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/planmain.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/tlist.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parsetree.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/selfuncs.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; COSTS_EQUAL,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* path costs are fuzzily <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> */<br/></li>
<li></span>&nbsp; &nbsp; COSTS_BETTER1,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* first path is cheaper than second */<br/></li>
<li></span>&nbsp; &nbsp; COSTS_BETTER2,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* second path is cheaper than first */<br/></li>
<li></span>&nbsp; &nbsp; COSTS_DIFFERENT,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* neither path dominates the other on cost */<br/></li>
<li><a id="L40">&#x200c;</a></span>} <span class="linkable">PathCostComparison</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L47" title="optimizer/util/pathnode.c:47">STD_FUZZ_FACTOR</a> is the normal fuzz factor for <a href="#L164" title="optimizer/util/pathnode.c:164">compare_path_costs_fuzzily</a>.<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> is it worth making this user-controllable?&nbsp; It provides a tradeoff<br/></li>
<li></span><span class="Comment"> * between <a href="../plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> runtime and the accuracy of path cost comparisons.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L47">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">STD_FUZZ_FACTOR</span> </span><span class="Constant">1.01<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> List *<a href="#L1946" title="optimizer/util/pathnode.c:1946">translate_sub_tlist</a>(List *tlist, <span class="Type">int</span> relid);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1375" title="optimizer/util/pathnode.c:1375">append_total_cost_compare</a>(<span class="Type">const</span> ListCell *a, <span class="Type">const</span> ListCell *b);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1397" title="optimizer/util/pathnode.c:1397">append_startup_cost_compare</a>(<span class="Type">const</span> ListCell *a, <span class="Type">const</span> ListCell *b);<br/></li>
<li><span class="Type">static</span> List *<a href="#L4539" title="optimizer/util/pathnode.c:4539">reparameterize_pathlist_by_child</a>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *pathlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *child_rel);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L4568" title="optimizer/util/pathnode.c:4568">pathlist_is_reparameterizable_by_child</a>(List *pathlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *child_rel);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; MISC. PATH UTILITIES<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L69" title="optimizer/util/pathnode.c:69">compare_path_costs</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Return -1, 0, or +1 according as path1 is cheaper, the same cost,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; or more expensive than path2 for the specified criterion.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L69">&#x200c;</a></span><span class="linkable">compare_path_costs</span>(Path *path1, Path *path2, CostSelector criterion)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (criterion == STARTUP_COST)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path1-&gt;startup_cost &lt; path2-&gt;startup_cost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path1-&gt;startup_cost &gt; path2-&gt;startup_cost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> +<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If paths have the same startup cost (not at all unlikely), order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * them by total cost.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path1-&gt;total_cost &lt; path2-&gt;total_cost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path1-&gt;total_cost &gt; path2-&gt;total_cost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> +<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path1-&gt;total_cost &lt; path2-&gt;total_cost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path1-&gt;total_cost &gt; path2-&gt;total_cost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> +<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If paths have the same total cost, order them by startup cost.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path1-&gt;startup_cost &lt; path2-&gt;startup_cost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path1-&gt;startup_cost &gt; path2-&gt;startup_cost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> +<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L115" title="optimizer/util/pathnode.c:115">compare_fractional_path_costs</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Return -1, 0, or +1 according as path1 is cheaper, the same cost,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; or more expensive than path2 for fetching the specified fraction<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; of the total tuples.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If fraction is &lt;= 0 or &gt; 1, we interpret it as 1, ie, we <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> the<br/></li>
<li></span><span class="Comment"> * path with the cheaper total_cost.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L115">&#x200c;</a></span><span class="linkable">compare_fractional_path_costs</span>(Path *path1, Path *path2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> fraction)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; cost1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cost2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fraction &lt;= <span class="Constant">0.0</span> || fraction &gt;= <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L69" title="optimizer/util/pathnode.c:69">compare_path_costs</a>(path1, path2, TOTAL_COST);<br/></li>
<li>&nbsp; &nbsp; cost1 = path1-&gt;startup_cost +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fraction * (path1-&gt;total_cost - path1-&gt;startup_cost);<br/></li>
<li>&nbsp; &nbsp; cost2 = path2-&gt;startup_cost +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fraction * (path2-&gt;total_cost - path2-&gt;startup_cost);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cost1 &lt; cost2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cost1 &gt; cost2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> +<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L164" title="optimizer/util/pathnode.c:164">compare_path_costs_fuzzily</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Compare the costs of two paths to see if either can be said to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; dominate the other.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use fuzzy comparisons so that <a href="#L420" title="optimizer/util/pathnode.c:420">add_path</a>() can avoid keeping both of<br/></li>
<li></span><span class="Comment"> * a pair of paths that really have insignificantly different cost.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The fuzz_factor argument must be 1.0 plus delta, where delta is the<br/></li>
<li></span><span class="Comment"> * fraction of the smaller cost that is considered to be a significant<br/></li>
<li></span><span class="Comment"> * difference.&nbsp; For example, fuzz_factor = 1.01 makes the fuzziness limit<br/></li>
<li></span><span class="Comment"> * be 1% of the smaller cost.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The two paths are said to have &quot;<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>&quot; costs if both startup and total<br/></li>
<li></span><span class="Comment"> * costs are fuzzily the same.&nbsp; Path1 is said to be better than path2 if<br/></li>
<li></span><span class="Comment"> * it has fuzzily better startup cost and fuzzily no worse total cost,<br/></li>
<li></span><span class="Comment"> * or if it has fuzzily better total cost and fuzzily no worse startup cost.<br/></li>
<li></span><span class="Comment"> * Path2 is better than path1 if the reverse holds.&nbsp; Finally, if one path<br/></li>
<li></span><span class="Comment"> * is fuzzily better than the other on startup cost and fuzzily worse on<br/></li>
<li></span><span class="Comment"> * total cost, we just say that their costs are &quot;different&quot;, since neither<br/></li>
<li></span><span class="Comment"> * dominates the other across the whole performance spectrum.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function also enforces a policy rule that paths for which the relevant<br/></li>
<li></span><span class="Comment"> * one of parent-&gt;consider_startup and parent-&gt;consider_param_startup is false<br/></li>
<li></span><span class="Comment"> * cannot survive comparisons solely on the grounds of good startup cost, so<br/></li>
<li></span><span class="Comment"> * we never return COSTS_DIFFERENT when that is true for the total-cost loser.<br/></li>
<li></span><span class="Comment"> * (But if total costs are fuzzily <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, we <a href="../geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> startup costs anyway,<br/></li>
<li></span><span class="Comment"> * in hopes of eliminating one path or the other.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L40" title="optimizer/util/pathnode.c:40">PathCostComparison</a><br/></li>
<li><a id="L164">&#x200c;</a><span class="linkable">compare_path_costs_fuzzily</span>(Path *path1, Path *path2, <span class="Type">double</span> fuzz_factor)<br/></li>
<li>{<br/></li>
<li><a id="L166">&#x200c;</a><span class="PreProc">#define <span class="linkable">CONSIDER_PATH_STARTUP_COST</span>(p)&nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((p)-&gt;param_info == </span><span class="Constant">NULL</span><span class="PreProc"> ? (p)-&gt;parent-&gt;consider_startup : (p)-&gt;parent-&gt;consider_param_startup)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check total cost first since it's more likely to be different; many<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * paths have zero startup cost.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (path1-&gt;total_cost &gt; path2-&gt;total_cost * fuzz_factor)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* path1 fuzzily worse on total cost */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L166" title="optimizer/util/pathnode.c:166">CONSIDER_PATH_STARTUP_COST</a>(path1) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path2-&gt;startup_cost &gt; path1-&gt;startup_cost * fuzz_factor)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... but path2 fuzzily worse on startup, so DIFFERENT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> COSTS_DIFFERENT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else path2 dominates */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> COSTS_BETTER2;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (path2-&gt;total_cost &gt; path1-&gt;total_cost * fuzz_factor)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* path2 fuzzily worse on total cost */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L166" title="optimizer/util/pathnode.c:166">CONSIDER_PATH_STARTUP_COST</a>(path2) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path1-&gt;startup_cost &gt; path2-&gt;startup_cost * fuzz_factor)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... but path1 fuzzily worse on startup, so DIFFERENT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> COSTS_DIFFERENT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else path1 dominates */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> COSTS_BETTER1;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fuzzily the same on total cost ... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (path1-&gt;startup_cost &gt; path2-&gt;startup_cost * fuzz_factor)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... but path1 fuzzily worse on startup, so path2 wins */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> COSTS_BETTER2;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (path2-&gt;startup_cost &gt; path1-&gt;startup_cost * fuzz_factor)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... but path2 fuzzily worse on startup, so path1 wins */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> COSTS_BETTER1;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fuzzily the same on both costs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> COSTS_EQUAL;<br/></li>
<li><br/></li>
<li><a id="L211">&#x200c;</a><span class="PreProc">#undef <span class="linkable">CONSIDER_PATH_STARTUP_COST</span><br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L242" title="optimizer/util/pathnode.c:242">set_cheapest</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Find the minimum-cost paths from among a relation's paths,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; and save them in the rel's cheapest-path fields.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * cheapest_total_path is normally the cheapest-total-cost unparameterized<br/></li>
<li></span><span class="Comment"> * path; but if there are no unparameterized paths, we assign it to be the<br/></li>
<li></span><span class="Comment"> * best (cheapest least-parameterized) parameterized path.&nbsp; However, only<br/></li>
<li></span><span class="Comment"> * unparameterized paths are considered candidates for cheapest_startup_path,<br/></li>
<li></span><span class="Comment"> * so that will be NULL if there are no unparameterized paths.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The cheapest_parameterized_paths list collects all parameterized paths<br/></li>
<li></span><span class="Comment"> * that have survived the <a href="#L420" title="optimizer/util/pathnode.c:420">add_path</a>() tournament for this relation.&nbsp; (Since<br/></li>
<li></span><span class="Comment"> * <a href="#L420" title="optimizer/util/pathnode.c:420">add_path</a> ignores pathkeys for a parameterized path, these will be paths<br/></li>
<li></span><span class="Comment"> * that have best cost or best row count for their parameterization.&nbsp; We<br/></li>
<li></span><span class="Comment"> * may also have both a parallel-safe and a non-parallel-safe path in some<br/></li>
<li></span><span class="Comment"> * cases for the same parameterization in some cases, but this should be<br/></li>
<li></span><span class="Comment"> * relatively rare since, most typically, all paths for the same relation<br/></li>
<li></span><span class="Comment"> * will be parallel-safe or <a href="predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of them will.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * cheapest_parameterized_paths always includes the cheapest-total<br/></li>
<li></span><span class="Comment"> * unparameterized path, too, if there is one; the users of that list <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a><br/></li>
<li></span><span class="Comment"> * it more convenient if that's included.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is normally called only after we've finished constructing the path<br/></li>
<li></span><span class="Comment"> * list for the rel node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L242">&#x200c;</a></span><span class="linkable">set_cheapest</span>(RelOptInfo *parent_rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *cheapest_startup_path;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *cheapest_total_path;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *best_param_path;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *parameterized_paths;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *p;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(IsA(parent_rel, RelOptInfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (parent_rel-&gt;pathlist == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not devise a query plan for the given query&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cheapest_startup_path = cheapest_total_path = best_param_path = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; parameterized_paths = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(p, parent_rel-&gt;pathlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path = (Path *) lfirst(p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path-&gt;param_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Parameterized path, so add it to parameterized_paths */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parameterized_paths = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(parameterized_paths, path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have an unparameterized cheapest-total, we no longer care<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * about finding the best parameterized path, so move on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cheapest_total_path)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, track the best parameterized path, which is the one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with least total cost among those of the minimum<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parameterization.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (best_param_path == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_param_path = path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="../../nodes/bitmapset.c.html#L445" title="nodes/bitmapset.c:445">bms_subset_compare</a>(PATH_REQ_OUTER(path),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PATH_REQ_OUTER(best_param_path)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BMS_EQUAL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep the cheaper one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L69" title="optimizer/util/pathnode.c:69">compare_path_costs</a>(path, best_param_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TOTAL_COST) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_param_path = path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BMS_SUBSET1:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* new path is less-parameterized */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_param_path = path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BMS_SUBSET2:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* old path is less-parameterized, keep it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BMS_DIFFERENT:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This means that neither path has the least possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parameterization for the rel.&nbsp; We'll sit on the old<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * path until something better comes along.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Unparameterized path, so consider it for cheapest slots */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cheapest_total_path == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cheapest_startup_path = cheapest_total_path = path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> two paths of identical costs, try to keep the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * better-sorted one.&nbsp; The paths might have unrelated sort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * orderings, in which case we can only guess which might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * better to keep, but if one is superior then we definitely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should keep that one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="#L69" title="optimizer/util/pathnode.c:69">compare_path_costs</a>(cheapest_startup_path, path, STARTUP_COST);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &gt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../path/pathkeys.c.html#L302" title="optimizer/path/pathkeys.c:302">compare_pathkeys</a>(cheapest_startup_path-&gt;pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path-&gt;pathkeys) == PATHKEYS_BETTER2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cheapest_startup_path = path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="#L69" title="optimizer/util/pathnode.c:69">compare_path_costs</a>(cheapest_total_path, path, TOTAL_COST);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &gt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../path/pathkeys.c.html#L302" title="optimizer/path/pathkeys.c:302">compare_pathkeys</a>(cheapest_total_path-&gt;pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path-&gt;pathkeys) == PATHKEYS_BETTER2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cheapest_total_path = path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add cheapest unparameterized path, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, to parameterized_paths */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cheapest_total_path)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parameterized_paths = <a href="../../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(cheapest_total_path, parameterized_paths);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is no unparameterized path, use the best parameterized path as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cheapest_total_path (but not as cheapest_startup_path).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cheapest_total_path == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cheapest_total_path = best_param_path;<br/></li>
<li>&nbsp; &nbsp; Assert(cheapest_total_path != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; parent_rel-&gt;cheapest_startup_path = cheapest_startup_path;<br/></li>
<li>&nbsp; &nbsp; parent_rel-&gt;cheapest_total_path = cheapest_total_path;<br/></li>
<li>&nbsp; &nbsp; parent_rel-&gt;cheapest_unique_path = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* computed only if needed */<br/></li>
<li></span>&nbsp; &nbsp; parent_rel-&gt;cheapest_parameterized_paths = parameterized_paths;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L420" title="optimizer/util/pathnode.c:420">add_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Consider a potential implementation path for the specified parent rel,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; and add it to the rel's pathlist if it is worthy of consideration.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; A path is worthy if it has a better sort order (better pathkeys) or<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; cheaper cost (on either dimension), or generates fewer rows, than <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; existing path that has the same or superset parameterization rels.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; We also consider parallel-safe paths more worthy than others.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; We also remove from the rel's pathlist <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> old paths that are dominated<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; by new_path --- that is, new_path is cheaper, at least as well ordered,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; generates no more rows, requires no outer rels not required by the old<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; path, and is no less parallel-safe.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; In most cases, a path with a superset parameterization will generate<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; fewer rows (since it has more join clauses to apply), so that those two<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; figures of merit move in opposite directions; this means that a path of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; one parameterization can seldom dominate a path of another.&nbsp; But such<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; cases do arise, so we make the full set of checks anyway.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; There are two policy decisions embedded in this function, along with<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; its sibling <a href="#L642" title="optimizer/util/pathnode.c:642">add_path_precheck</a>.&nbsp; First, we treat all parameterized paths<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; as having NIL pathkeys, so that they cannot win comparisons on the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; basis of sort order.&nbsp; This is to reduce the number of parameterized<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; paths that are kept; see discussion in src/backend/optimizer/README.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Second, we only consider cheap startup cost to be interesting if<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; parent_rel-&gt;consider_startup is true for an unparameterized path, or<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; parent_rel-&gt;consider_param_startup is true for a parameterized one.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Again, this allows discarding useless paths sooner.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; The pathlist is kept sorted by total_cost, with cheaper paths<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; at the front.&nbsp; Within this routine, that's simply a speed hack:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; doing it that way makes it more likely that we will reject an inferior<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; path after a few comparisons, rather than many comparisons.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; However, <a href="#L642" title="optimizer/util/pathnode.c:642">add_path_precheck</a> relies on this ordering to exit early<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; when possible.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: discarded Path objects are immediately <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>'d to reduce <a href="../plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; memory consumption.&nbsp; We dare not try to free the substructure of a Path,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; since much of it may be shared with other Paths or the query tree itself;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; but just recycling discarded Path nodes is a very useful savings in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; a large join tree.&nbsp; We can recycle the List nodes of pathlist, too.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; As noted in optimizer/README, deleting a previously-accepted Path is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; safe because we know that Paths of this rel cannot yet be referenced<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; from <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other rel, such as a higher-level join.&nbsp; However, in some cases<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; it is possible that a Path is referenced by another Path for its own<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; rel; we must not delete such a Path, even if it is dominated by the new<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Path.&nbsp; Currently this occurs only for IndexPath objects, which may be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; referenced as children of BitmapHeapPaths as well as being paths in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; their own right.&nbsp; Hence, we don't <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> IndexPaths when rejecting them.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'parent_rel' is the relation entry to which the path corresponds.<br/></li>
<li></span><span class="Comment"> * 'new_path' is a potential path for parent_rel.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns nothing, but modifies parent_rel-&gt;pathlist.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L420">&#x200c;</a></span><span class="linkable">add_path</span>(RelOptInfo *parent_rel, Path *new_path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; accept_new = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* unless we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a superior old path */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insert_at = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* where to insert new item */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *new_path_pathkeys;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *p1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is a convenient place to check for query cancel --- no part of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> goes very long without calling <a href="#L420" title="optimizer/util/pathnode.c:420">add_path</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pretend parameterized paths have no pathkeys, per comment above */<br/></li>
<li></span>&nbsp; &nbsp; new_path_pathkeys = new_path-&gt;param_info ? NIL : new_path-&gt;pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop to check proposed new path against old paths.&nbsp; Note it is possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for more than one old path to be tossed out because new_path dominates<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(p1, parent_rel-&gt;pathlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *old_path = (Path *) lfirst(p1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; remove_old = <span class="Constant">false</span>; <span class="Comment">/* unless new proves superior */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L40" title="optimizer/util/pathnode.c:40">PathCostComparison</a> costcmp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKeysComparison keyscmp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BMS_Comparison outercmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do a fuzzy cost comparison with standard fuzziness limit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; costcmp = <a href="#L164" title="optimizer/util/pathnode.c:164">compare_path_costs_fuzzily</a>(new_path, old_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L47" title="optimizer/util/pathnode.c:47">STD_FUZZ_FACTOR</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the two paths <a href="../geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> differently for startup and total cost,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then we want to keep both, and we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> comparing pathkeys and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * required_outer rels.&nbsp; If they <a href="../geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the same, proceed with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other comparisons.&nbsp; Row count is checked last.&nbsp; (We make the tests<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in this order because the cost comparison is most likely to turn<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * out &quot;different&quot;, and the pathkeys comparison <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> most likely.&nbsp; As<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * explained above, row count very seldom makes a difference, so even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * though it's cheap to <a href="../geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> there's not much point in checking it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * earlier.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (costcmp != COSTS_DIFFERENT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Similarly check to see if either dominates on pathkeys */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *old_path_pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_path_pathkeys = old_path-&gt;param_info ? NIL : old_path-&gt;pathkeys;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyscmp = <a href="../path/pathkeys.c.html#L302" title="optimizer/path/pathkeys.c:302">compare_pathkeys</a>(new_path_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; old_path_pathkeys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (keyscmp != PATHKEYS_DIFFERENT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (costcmp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> COSTS_EQUAL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outercmp = <a href="../../nodes/bitmapset.c.html#L445" title="nodes/bitmapset.c:445">bms_subset_compare</a>(PATH_REQ_OUTER(new_path),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PATH_REQ_OUTER(old_path));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (keyscmp == PATHKEYS_BETTER1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((outercmp == BMS_EQUAL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outercmp == BMS_SUBSET1) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_path-&gt;rows &lt;= old_path-&gt;rows &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_path-&gt;parallel_safe &gt;= old_path-&gt;parallel_safe)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remove_old = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* new dominates old */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (keyscmp == PATHKEYS_BETTER2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((outercmp == BMS_EQUAL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outercmp == BMS_SUBSET2) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_path-&gt;rows &gt;= old_path-&gt;rows &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_path-&gt;parallel_safe &lt;= old_path-&gt;parallel_safe)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accept_new = <span class="Constant">false</span>; <span class="Comment">/* old dominates new */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span>&nbsp; &nbsp; <span class="Comment">/* keyscmp == PATHKEYS_EQUAL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (outercmp == BMS_EQUAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Same pathkeys and outer rels, and fuzzily<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the same cost, so keep just one; to decide<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which, first check parallel-safety, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rows, then do a fuzzy cost comparison with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * very small fuzz limit.&nbsp; (We used to do an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exact cost comparison, but that results in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * annoying platform-specific plan variations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * due to roundoff in the cost estimates.)&nbsp; &nbsp; If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * things are still tied, arbitrarily keep<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only the old path.&nbsp; Notice that we will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keep only the old path even if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * less-fuzzy comparison decides the startup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and total costs <a href="../geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> differently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (new_path-&gt;parallel_safe &gt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_path-&gt;parallel_safe)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remove_old = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* new dominates old */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (new_path-&gt;parallel_safe &lt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; old_path-&gt;parallel_safe)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accept_new = <span class="Constant">false</span>; <span class="Comment">/* old dominates new */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (new_path-&gt;rows &lt; old_path-&gt;rows)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remove_old = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* new dominates old */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (new_path-&gt;rows &gt; old_path-&gt;rows)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accept_new = <span class="Constant">false</span>; <span class="Comment">/* old dominates new */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L164" title="optimizer/util/pathnode.c:164">compare_path_costs_fuzzily</a>(new_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1.0000000001</span>) == COSTS_BETTER1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remove_old = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* new dominates old */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accept_new = <span class="Constant">false</span>; <span class="Comment">/* old equals or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dominates new */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (outercmp == BMS_SUBSET1 &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new_path-&gt;rows &lt;= old_path-&gt;rows &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new_path-&gt;parallel_safe &gt;= old_path-&gt;parallel_safe)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remove_old = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* new dominates old */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (outercmp == BMS_SUBSET2 &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new_path-&gt;rows &gt;= old_path-&gt;rows &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new_path-&gt;parallel_safe &lt;= old_path-&gt;parallel_safe)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accept_new = <span class="Constant">false</span>; <span class="Comment">/* old dominates new */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else different parameterizations, keep both */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> COSTS_BETTER1:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (keyscmp != PATHKEYS_BETTER2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outercmp = <a href="../../nodes/bitmapset.c.html#L445" title="nodes/bitmapset.c:445">bms_subset_compare</a>(PATH_REQ_OUTER(new_path),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PATH_REQ_OUTER(old_path));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((outercmp == BMS_EQUAL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outercmp == BMS_SUBSET1) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_path-&gt;rows &lt;= old_path-&gt;rows &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_path-&gt;parallel_safe &gt;= old_path-&gt;parallel_safe)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remove_old = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* new dominates old */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> COSTS_BETTER2:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (keyscmp != PATHKEYS_BETTER1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outercmp = <a href="../../nodes/bitmapset.c.html#L445" title="nodes/bitmapset.c:445">bms_subset_compare</a>(PATH_REQ_OUTER(new_path),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PATH_REQ_OUTER(old_path));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((outercmp == BMS_EQUAL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outercmp == BMS_SUBSET2) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_path-&gt;rows &gt;= old_path-&gt;rows &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_path-&gt;parallel_safe &lt;= old_path-&gt;parallel_safe)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accept_new = <span class="Constant">false</span>; <span class="Comment">/* old dominates new */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> COSTS_DIFFERENT:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can't get here, but keep this case to keep compiler<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * quiet<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remove current <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> from pathlist if dominated by new.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (remove_old)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent_rel-&gt;pathlist = foreach_delete_current(parent_rel-&gt;pathlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> the data pointed-to by the deleted cell, if possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsA(old_path, IndexPath))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(old_path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* new belongs after this old path if it has cost &gt;= old's */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (new_path-&gt;total_cost &gt;= old_path-&gt;total_cost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insert_at = foreach_current_index(p1) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we found an old path that dominates new_path, we can quit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scanning the pathlist; we will not add new_path, and we assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * new_path cannot dominate <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other elements of the pathlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!accept_new)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (accept_new)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Accept the new path: insert it at proper place in pathlist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; parent_rel-&gt;pathlist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L439" title="nodes/list.c:439">list_insert_nth</a>(parent_rel-&gt;pathlist, insert_at, new_path);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reject and recycle the new path */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsA(new_path, IndexPath))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(new_path);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L642" title="optimizer/util/pathnode.c:642">add_path_precheck</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Check whether a proposed new path could possibly get accepted.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; We assume we know the path's pathkeys and parameterization accurately,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; and have <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bounds for its costs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we do not know the path's rowcount, since getting an estimate for<br/></li>
<li></span><span class="Comment"> * that is too expensive to do <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> prechecking.&nbsp; We assume here that paths<br/></li>
<li></span><span class="Comment"> * of a superset parameterization will generate fewer rows; if that holds,<br/></li>
<li></span><span class="Comment"> * then paths with different parameterizations cannot dominate each other<br/></li>
<li></span><span class="Comment"> * and so we can simply ignore existing paths of another parameterization.<br/></li>
<li></span><span class="Comment"> * (In the infrequent cases where that rule of thumb fails, <a href="#L420" title="optimizer/util/pathnode.c:420">add_path</a> will<br/></li>
<li></span><span class="Comment"> * get rid of the inferior path.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At the time this is called, we haven't actually built a Path structure,<br/></li>
<li></span><span class="Comment"> * so the required information has to be passed piecemeal.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L642">&#x200c;</a></span><span class="linkable">add_path_precheck</span>(RelOptInfo *parent_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cost startup_cost, Cost total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *pathkeys, Relids required_outer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *new_path_pathkeys;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; consider_startup;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *p1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pretend parameterized paths have no pathkeys, per <a href="#L420" title="optimizer/util/pathnode.c:420">add_path</a> policy */<br/></li>
<li></span>&nbsp; &nbsp; new_path_pathkeys = required_outer ? NIL : pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Decide whether new path's startup cost is interesting */<br/></li>
<li></span>&nbsp; &nbsp; consider_startup = required_outer ? parent_rel-&gt;consider_param_startup : parent_rel-&gt;consider_startup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(p1, parent_rel-&gt;pathlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *old_path = (Path *) lfirst(p1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKeysComparison keyscmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are looking for an old_path with the same parameterization (and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by assumption the same rowcount) that dominates the new path on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pathkeys as well as both cost metrics.&nbsp; If we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reject the new path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Cost comparisons here should match <a href="#L164" title="optimizer/util/pathnode.c:164">compare_path_costs_fuzzily</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (total_cost &gt; old_path-&gt;total_cost * <a href="#L47" title="optimizer/util/pathnode.c:47">STD_FUZZ_FACTOR</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* new path can win on startup cost only if consider_startup */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (startup_cost &gt; old_path-&gt;startup_cost * <a href="#L47" title="optimizer/util/pathnode.c:47">STD_FUZZ_FACTOR</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !consider_startup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* new path loses on cost, so check pathkeys... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *old_path_pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_path_pathkeys = old_path-&gt;param_info ? NIL : old_path-&gt;pathkeys;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyscmp = <a href="../path/pathkeys.c.html#L302" title="optimizer/path/pathkeys.c:302">compare_pathkeys</a>(new_path_pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; old_path_pathkeys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (keyscmp == PATHKEYS_EQUAL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyscmp == PATHKEYS_BETTER2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* new path does not win on pathkeys... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(required_outer, PATH_REQ_OUTER(old_path)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found an old path that dominates the new one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since the pathlist is sorted by total_cost, we can stop looking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * once we reach a path with a total_cost larger than the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * path's.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L747" title="optimizer/util/pathnode.c:747">add_partial_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Like <a href="#L420" title="optimizer/util/pathnode.c:420">add_path</a>, our goal here is to consider whether a path is worthy<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; of being kept around, but the considerations here are a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> different.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; A partial path is one which can be executed in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> number of workers in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; parallel such that each worker will generate a <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of the path's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; overall result.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; As in <a href="#L420" title="optimizer/util/pathnode.c:420">add_path</a>, the partial_pathlist is kept sorted with the cheapest<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; total path in front.&nbsp; This is depended on by multiple places, which<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; just take the front entry as the cheapest path without searching.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; We don't generate parameterized partial paths for several reasons.&nbsp; Most<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; importantly, they're not safe to execute, because there's nothing to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; make sure that a parallel scan within the parameterized portion of the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; plan is running with the same value in every worker at the same time.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Fortunately, it seems unlikely to be worthwhile anyway, because having<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; each worker scan the entire outer relation and a <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of the inner<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; relation will generally be a terrible plan.&nbsp; The inner (parameterized)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; side of the plan will be small anyway.&nbsp; There could be rare cases where<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; this wins big - e.g. if join order constraints put a 1-row relation on<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the outer side of the topmost join with a parameterized plan on the inner<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; side - but we'll have to be content not to handle such cases until<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; somebody builds an executor infrastructure that can cope with them.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Because we don't consider parameterized paths here, we also don't<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; need to consider the row counts as a measure of quality: every path will<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; produce the same number of rows.&nbsp; Neither do we need to consider startup<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; costs: parallelism is only used for plans that will be run to completion.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Therefore, this routine is much simpler than <a href="#L420" title="optimizer/util/pathnode.c:420">add_path</a>: it needs to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; consider only pathkeys and total cost.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; As with <a href="#L420" title="optimizer/util/pathnode.c:420">add_path</a>, we <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> paths that are found to be dominated by<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; another partial path; this requires that there be no other references to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; such paths yet.&nbsp; Hence, GatherPaths must not be created for a rel until<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; we're done creating all partial paths for it.&nbsp; Unlike <a href="#L420" title="optimizer/util/pathnode.c:420">add_path</a>, we don't<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; take an exception for IndexPaths as partial index paths won't be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; referenced by partial BitmapHeapPaths.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L747">&#x200c;</a></span><span class="linkable">add_partial_path</span>(RelOptInfo *parent_rel, Path *new_path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; accept_new = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* unless we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a superior old path */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insert_at = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* where to insert new item */<br/></li>
<li></span>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *p1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for query cancel. */<br/></li>
<li></span>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Path to be added must be parallel safe. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(new_path-&gt;parallel_safe);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Relation should be OK for parallelism, too. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(parent_rel-&gt;consider_parallel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As in <a href="#L420" title="optimizer/util/pathnode.c:420">add_path</a>, throw out <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> paths which are dominated by the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * path, but throw out the new path if some existing path dominates it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(p1, parent_rel-&gt;partial_pathlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *old_path = (Path *) lfirst(p1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; remove_old = <span class="Constant">false</span>; <span class="Comment">/* unless new proves superior */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PathKeysComparison keyscmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compare pathkeys. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; keyscmp = <a href="../path/pathkeys.c.html#L302" title="optimizer/path/pathkeys.c:302">compare_pathkeys</a>(new_path-&gt;pathkeys, old_path-&gt;pathkeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Unless pathkeys are incompatible, keep just one of the two paths. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (keyscmp != PATHKEYS_DIFFERENT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (new_path-&gt;total_cost &gt; old_path-&gt;total_cost * <a href="#L47" title="optimizer/util/pathnode.c:47">STD_FUZZ_FACTOR</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* New path costs more; keep it only if pathkeys are better. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (keyscmp != PATHKEYS_BETTER1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accept_new = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (old_path-&gt;total_cost &gt; new_path-&gt;total_cost<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L47" title="optimizer/util/pathnode.c:47">STD_FUZZ_FACTOR</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Old path costs more; keep it only if pathkeys are better. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (keyscmp != PATHKEYS_BETTER2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remove_old = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (keyscmp == PATHKEYS_BETTER1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Costs are about the same, new path has better pathkeys. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remove_old = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (keyscmp == PATHKEYS_BETTER2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Costs are about the same, old path has better pathkeys. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accept_new = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (old_path-&gt;total_cost &gt; new_path-&gt;total_cost * <span class="Constant">1.0000000001</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Pathkeys are the same, and the old path costs more. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remove_old = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pathkeys are the same, and new path isn't materially<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cheaper.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accept_new = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remove current <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> from partial_pathlist if dominated by new.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (remove_old)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent_rel-&gt;partial_pathlist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach_delete_current(parent_rel-&gt;partial_pathlist, p1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(old_path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* new belongs after this old path if it has cost &gt;= old's */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (new_path-&gt;total_cost &gt;= old_path-&gt;total_cost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insert_at = foreach_current_index(p1) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we found an old path that dominates new_path, we can quit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scanning the partial_pathlist; we will not add new_path, and we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assume new_path cannot dominate <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> later path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!accept_new)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (accept_new)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Accept the new path: insert it at proper place */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; parent_rel-&gt;partial_pathlist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L439" title="nodes/list.c:439">list_insert_nth</a>(parent_rel-&gt;partial_pathlist, insert_at, new_path);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reject and recycle the new path */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(new_path);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L865" title="optimizer/util/pathnode.c:865">add_partial_path_precheck</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Check whether a proposed new partial path could possibly get accepted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike <a href="#L642" title="optimizer/util/pathnode.c:642">add_path_precheck</a>, we can ignore startup cost and parameterization,<br/></li>
<li></span><span class="Comment"> * since they don't matter for partial paths (see <a href="#L747" title="optimizer/util/pathnode.c:747">add_partial_path</a>).&nbsp; But<br/></li>
<li></span><span class="Comment"> * we do want to make sure we don't add a partial path if there's already<br/></li>
<li></span><span class="Comment"> * a complete path that dominates it, since in that case the proposed path<br/></li>
<li></span><span class="Comment"> * is surely a loser.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L865">&#x200c;</a></span><span class="linkable">add_partial_path_precheck</span>(RelOptInfo *parent_rel, Cost total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *pathkeys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *p1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Our goal here is twofold.&nbsp; First, we want to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out whether this path<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is clearly inferior to some existing partial path.&nbsp; If so, we want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reject it immediately.&nbsp; Second, we want to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out whether this path<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is clearly superior to some existing partial path -- at least, modulo<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * final cost computations.&nbsp; If so, we definitely want to consider it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unlike <a href="#L420" title="optimizer/util/pathnode.c:420">add_path</a>(), we always <a href="../geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> pathkeys here.&nbsp; This is because we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expect partial_pathlist to be very short, and getting a definitive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * answer at this stage avoids the need to call <a href="#L642" title="optimizer/util/pathnode.c:642">add_path_precheck</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(p1, parent_rel-&gt;partial_pathlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *old_path = (Path *) lfirst(p1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PathKeysComparison keyscmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; keyscmp = <a href="../path/pathkeys.c.html#L302" title="optimizer/path/pathkeys.c:302">compare_pathkeys</a>(pathkeys, old_path-&gt;pathkeys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (keyscmp != PATHKEYS_DIFFERENT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (total_cost &gt; old_path-&gt;total_cost * <a href="#L47" title="optimizer/util/pathnode.c:47">STD_FUZZ_FACTOR</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyscmp != PATHKEYS_BETTER1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (old_path-&gt;total_cost &gt; total_cost * <a href="#L47" title="optimizer/util/pathnode.c:47">STD_FUZZ_FACTOR</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyscmp != PATHKEYS_BETTER2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This path is neither clearly inferior to an existing partial path nor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clearly good enough that it might replace one.&nbsp; Compare it to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-parallel plans.&nbsp; If it loses even <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> accounting for the cost of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the Gather node, we should definitely reject it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we pass the total_cost to <a href="#L642" title="optimizer/util/pathnode.c:642">add_path_precheck</a> twice.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because it's never advantageous to consider the startup cost of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partial path; the resulting plans, if run in parallel, will be run to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * completion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L642" title="optimizer/util/pathnode.c:642">add_path_precheck</a>(parent_rel, total_cost, total_cost, pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; PATH <a href="../../utils/adt/tsquery_cleanup.c.html#L22" title="utils/adt/tsquery_cleanup.c:22">NODE</a> CREATION ROUTINES<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L927" title="optimizer/util/pathnode.c:927">create_seqscan_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a path corresponding to a sequential scan, returning the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; pathnode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Path *<br/></li>
<li><a id="L927">&#x200c;</a><span class="linkable">create_seqscan_path</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids required_outer, <span class="Type">int</span> parallel_workers)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *pathnode = makeNode(Path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;pathtype = T_SeqScan;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;pathtarget = rel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;param_info = <a href="relnode.c.html#L1557" title="optimizer/util/relnode.c:1557">get_baserel_parampathinfo</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; required_outer);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parallel_aware = (parallel_workers &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parallel_safe = rel-&gt;consider_parallel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parallel_workers = parallel_workers;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;pathkeys = NIL;&nbsp; &nbsp; <span class="Comment">/* seqscan has unordered result */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../path/costsize.c.html#L284" title="optimizer/path/costsize.c:284">cost_seqscan</a>(pathnode, root, rel, pathnode-&gt;param_info);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L952" title="optimizer/util/pathnode.c:952">create_samplescan_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a path node for a sampled table scan.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Path *<br/></li>
<li><a id="L952">&#x200c;</a><span class="linkable">create_samplescan_path</span>(PlannerInfo *root, RelOptInfo *rel, Relids required_outer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *pathnode = makeNode(Path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;pathtype = T_SampleScan;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;pathtarget = rel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;param_info = <a href="relnode.c.html#L1557" title="optimizer/util/relnode.c:1557">get_baserel_parampathinfo</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; required_outer);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parallel_safe = rel-&gt;consider_parallel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parallel_workers = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;pathkeys = NIL;&nbsp; &nbsp; <span class="Comment">/* samplescan has unordered result */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../path/costsize.c.html#L361" title="optimizer/path/costsize.c:361">cost_samplescan</a>(pathnode, root, rel, pathnode-&gt;param_info);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L993" title="optimizer/util/pathnode.c:993">create_index_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a path node for an index scan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'index' is a usable index.<br/></li>
<li></span><span class="Comment"> * 'indexclauses' is a list of IndexClause nodes representing clauses<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to be enforced as qual conditions in the scan.<br/></li>
<li></span><span class="Comment"> * 'indexorderbys' is a list of bare expressions (no RestrictInfos)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to be used as index ordering operators in the scan.<br/></li>
<li></span><span class="Comment"> * 'indexorderbycols' is an integer list of index column numbers (zero based)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the ordering operators can be used with.<br/></li>
<li></span><span class="Comment"> * 'pathkeys' describes the ordering of the path.<br/></li>
<li></span><span class="Comment"> * 'indexscandir' is either ForwardScanDirection or BackwardScanDirection.<br/></li>
<li></span><span class="Comment"> * 'indexonly' is true if an index-only scan is wanted.<br/></li>
<li></span><span class="Comment"> * 'required_outer' is the set of outer relids for a parameterized path.<br/></li>
<li></span><span class="Comment"> * 'loop_count' is the number of repetitions of the indexscan to factor into<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; estimates of caching behavior.<br/></li>
<li></span><span class="Comment"> * 'partial_path' is true if constructing a parallel index scan path.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the new path node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexPath *<br/></li>
<li><a id="L993">&#x200c;</a><span class="linkable">create_index_path</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexOptInfo *index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *indexclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *indexorderbys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *indexorderbycols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanDirection indexscandir,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> indexonly,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids required_outer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> loop_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> partial_path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexPath&nbsp; *pathnode = makeNode(IndexPath);<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *rel = index-&gt;rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = indexonly ? T_IndexOnlyScan : T_IndexScan;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = rel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.param_info = <a href="relnode.c.html#L1557" title="optimizer/util/relnode.c:1557">get_baserel_parampathinfo</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;indexinfo = index;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;indexclauses = indexclauses;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;indexorderbys = indexorderbys;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;indexorderbycols = indexorderbycols;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;indexscandir = indexscandir;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../path/costsize.c.html#L549" title="optimizer/path/costsize.c:549">cost_index</a>(pathnode, root, loop_count, partial_path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1042" title="optimizer/util/pathnode.c:1042">create_bitmap_heap_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a path node for a bitmap scan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'bitmapqual' is a tree of IndexPath, BitmapAndPath, and BitmapOrPath nodes.<br/></li>
<li></span><span class="Comment"> * 'required_outer' is the set of outer relids for a parameterized path.<br/></li>
<li></span><span class="Comment"> * 'loop_count' is the number of repetitions of the indexscan to factor into<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; estimates of caching behavior.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * loop_count should match the value used when creating the component<br/></li>
<li></span><span class="Comment"> * IndexPaths.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BitmapHeapPath *<br/></li>
<li><a id="L1042">&#x200c;</a><span class="linkable">create_bitmap_heap_path</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path *bitmapqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids required_outer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> loop_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> parallel_degree)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BitmapHeapPath *pathnode = makeNode(BitmapHeapPath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_BitmapHeapScan;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = rel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.param_info = <a href="relnode.c.html#L1557" title="optimizer/util/relnode.c:1557">get_baserel_parampathinfo</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = (parallel_degree &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = parallel_degree;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = NIL;&nbsp; &nbsp; <span class="Comment">/* always unordered */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;bitmapqual = bitmapqual;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../path/costsize.c.html#L1013" title="optimizer/path/costsize.c:1013">cost_bitmap_heap_scan</a>(&amp;pathnode-&gt;path, root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.param_info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmapqual, loop_count);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1075" title="optimizer/util/pathnode.c:1075">create_bitmap_and_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a path node representing a BitmapAnd.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BitmapAndPath *<br/></li>
<li><a id="L1075">&#x200c;</a><span class="linkable">create_bitmap_and_path</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *bitmapquals)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BitmapAndPath *pathnode = makeNode(BitmapAndPath);<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; required_outer = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_BitmapAnd;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = rel-&gt;reltarget;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Identify the required outer rels as the union of what the child paths<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * depend on.&nbsp; (Alternatively, we could insist that the caller pass this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in, but it's more convenient and reliable to compute it here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, bitmapquals)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *bitmapqual = (Path *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; required_outer = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(required_outer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PATH_REQ_OUTER(bitmapqual));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.param_info = <a href="relnode.c.html#L1557" title="optimizer/util/relnode.c:1557">get_baserel_parampathinfo</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Currently, a BitmapHeapPath, BitmapAndPath, or BitmapOrPath will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parallel-safe if and only if rel-&gt;consider_parallel is set.&nbsp; So, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set the flag for this path based only on the relation-level flag,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * without actually iterating over the list of children.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = NIL;&nbsp; &nbsp; <span class="Comment">/* always unordered */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;bitmapquals = bitmapquals;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* this sets bitmapselectivity as well as the regular cost fields: */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../path/costsize.c.html#L1157" title="optimizer/path/costsize.c:1157">cost_bitmap_and_node</a>(pathnode, root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1127" title="optimizer/util/pathnode.c:1127">create_bitmap_or_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a path node representing a BitmapOr.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BitmapOrPath *<br/></li>
<li><a id="L1127">&#x200c;</a><span class="linkable">create_bitmap_or_path</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *bitmapquals)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BitmapOrPath *pathnode = makeNode(BitmapOrPath);<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; required_outer = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_BitmapOr;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = rel-&gt;reltarget;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Identify the required outer rels as the union of what the child paths<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * depend on.&nbsp; (Alternatively, we could insist that the caller pass this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in, but it's more convenient and reliable to compute it here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, bitmapquals)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *bitmapqual = (Path *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; required_outer = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(required_outer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PATH_REQ_OUTER(bitmapqual));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.param_info = <a href="relnode.c.html#L1557" title="optimizer/util/relnode.c:1557">get_baserel_parampathinfo</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Currently, a BitmapHeapPath, BitmapAndPath, or BitmapOrPath will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parallel-safe if and only if rel-&gt;consider_parallel is set.&nbsp; So, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set the flag for this path based only on the relation-level flag,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * without actually iterating over the list of children.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = NIL;&nbsp; &nbsp; <span class="Comment">/* always unordered */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;bitmapquals = bitmapquals;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* this sets bitmapselectivity as well as the regular cost fields: */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../path/costsize.c.html#L1201" title="optimizer/path/costsize.c:1201">cost_bitmap_or_node</a>(pathnode, root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1179" title="optimizer/util/pathnode.c:1179">create_tidscan_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a path corresponding to a scan by TID, returning the pathnode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TidPath *<br/></li>
<li><a id="L1179">&#x200c;</a><span class="linkable">create_tidscan_path</span>(PlannerInfo *root, RelOptInfo *rel, List *tidquals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids required_outer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TidPath&nbsp; &nbsp; *pathnode = makeNode(TidPath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_TidScan;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = rel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.param_info = <a href="relnode.c.html#L1557" title="optimizer/util/relnode.c:1557">get_baserel_parampathinfo</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = NIL;&nbsp; &nbsp; <span class="Comment">/* always unordered */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;tidquals = tidquals;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../path/costsize.c.html#L1249" title="optimizer/path/costsize.c:1249">cost_tidscan</a>(&amp;pathnode-&gt;path, root, rel, tidquals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pathnode-&gt;path.param_info);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1208" title="optimizer/util/pathnode.c:1208">create_tidrangescan_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a path corresponding to a scan by a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of TIDs, returning<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the pathnode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TidRangePath *<br/></li>
<li><a id="L1208">&#x200c;</a><span class="linkable">create_tidrangescan_path</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *tidrangequals, Relids required_outer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TidRangePath *pathnode = makeNode(TidRangePath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_TidRangeScan;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = rel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.param_info = <a href="relnode.c.html#L1557" title="optimizer/util/relnode.c:1557">get_baserel_parampathinfo</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = NIL;&nbsp; &nbsp; <span class="Comment">/* always unordered */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;tidrangequals = tidrangequals;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../path/costsize.c.html#L1357" title="optimizer/path/costsize.c:1357">cost_tidrangescan</a>(&amp;pathnode-&gt;path, root, rel, tidrangequals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.param_info);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1244" title="optimizer/util/pathnode.c:1244">create_append_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a path corresponding to an Append plan, returning the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; pathnode.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we must handle subpaths = NIL, representing a dummy access path.<br/></li>
<li></span><span class="Comment"> * Also, there are callers that pass root = NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rows', when passed as a non-negative number, will be used to overwrite the<br/></li>
<li></span><span class="Comment"> * returned path's row estimate.&nbsp; Otherwise, the row estimate is calculated<br/></li>
<li></span><span class="Comment"> * by totalling the row estimates from the 'subpaths' list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>AppendPath *<br/></li>
<li><a id="L1244">&#x200c;</a><span class="linkable">create_append_path</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *subpaths, List *partial_subpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *pathkeys, Relids required_outer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> parallel_workers, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> parallel_aware,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> rows)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AppendPath *pathnode = makeNode(AppendPath);<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!parallel_aware || parallel_workers &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_Append;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = rel-&gt;reltarget;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is for a baserel (not a join or non-leaf partition), we prefer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to apply <a href="relnode.c.html#L1557" title="optimizer/util/relnode.c:1557">get_baserel_parampathinfo</a> to construct a full ParamPathInfo<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the path.&nbsp; This supports building a Memoize path atop this path,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and if this is a partitioned table the info may be useful for run-time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pruning (cf <a href="../../partitioning/partprune.c.html#L220" title="partitioning/partprune.c:220">make_partition_pruneinfo</a>()).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, if we don't have &quot;root&quot; then that won't work and we fall back<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on the simpler <a href="relnode.c.html#L1868" title="optimizer/util/relnode.c:1868">get_appendrel_parampathinfo</a>.&nbsp; There's no point in doing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the more expensive thing for a dummy path, either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;reloptkind == RELOPT_BASEREL &amp;&amp; root &amp;&amp; subpaths != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.param_info = <a href="relnode.c.html#L1557" title="optimizer/util/relnode.c:1557">get_baserel_parampathinfo</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.param_info = <a href="relnode.c.html#L1868" title="optimizer/util/relnode.c:1868">get_appendrel_parampathinfo</a>(rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = parallel_aware;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = parallel_workers;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For parallel append, non-partial paths are sorted by descending total<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * costs. That way, the total time to finish all non-partial paths is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * minimized.&nbsp; Also, the partial paths are sorted by descending startup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * costs.&nbsp; There may be some paths that require to do startup work by a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * single worker.&nbsp; In such case, it's better for workers to choose the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expensive ones first, whereas the leader should choose the cheapest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * startup plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pathnode-&gt;path.parallel_aware)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We mustn't fiddle with the order of subpaths when the Append has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pathkeys.&nbsp; The order they're listed in is critical to keeping the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pathkeys valid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(pathkeys == NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1674" title="nodes/list.c:1674">list_sort</a>(subpaths, <a href="#L1375" title="optimizer/util/pathnode.c:1375">append_total_cost_compare</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1674" title="nodes/list.c:1674">list_sort</a>(partial_subpaths, <a href="#L1397" title="optimizer/util/pathnode.c:1397">append_startup_cost_compare</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;first_partial_path = list_length(subpaths);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;subpaths = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(subpaths, partial_subpaths);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Apply query-wide LIMIT if known and path is for sole base relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Handling this at this low level is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> klugy.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root != <span class="Constant">NULL</span> &amp;&amp; <a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(rel-&gt;relids, root-&gt;all_query_rels))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;limit_tuples = root-&gt;limit_tuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;limit_tuples = -<span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, pathnode-&gt;subpaths)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *subpath = (Path *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.parallel_safe = pathnode-&gt;path.parallel_safe &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;parallel_safe;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* All child paths must have same parameterization */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(PATH_REQ_OUTER(subpath), required_outer));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!parallel_aware || pathnode-&gt;path.parallel_safe);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there's exactly one child path then the output of the Append is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * necessarily ordered the same as the child's, so we can inherit the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * child's pathkeys if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, overriding whatever the caller might've said.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Furthermore, if the child's parallel awareness matches the Append's,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then the Append is a no-op and will be discarded later (in setrefs.c).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Then we can inherit the child's size and cost too, effectively charging<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * zero for the Append.&nbsp; Otherwise, we must do the normal costsize<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calculation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(pathnode-&gt;subpaths) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *child = (Path *) linitial(pathnode-&gt;subpaths);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (child-&gt;parallel_aware == parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.rows = child-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.startup_cost = child-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.total_cost = child-&gt;total_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L2231" title="optimizer/path/costsize.c:2231">cost_append</a>(pathnode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must do this last, else <a href="../path/costsize.c.html#L2231" title="optimizer/path/costsize.c:2231">cost_append</a> complains */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.pathkeys = child-&gt;pathkeys;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L2231" title="optimizer/path/costsize.c:2231">cost_append</a>(pathnode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If the caller provided a row estimate, override the computed value. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rows &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.rows = rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1375" title="optimizer/util/pathnode.c:1375">append_total_cost_compare</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1674" title="nodes/list.c:1674">list_sort</a> comparator for sorting append child paths<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; by total_cost descending<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> total costs, we fall back to comparing startup costs; if those<br/></li>
<li></span><span class="Comment"> * are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> too, break ties using <a href="../../nodes/bitmapset.c.html#L183" title="nodes/bitmapset.c:183">bms_compare</a> on the paths' relids.<br/></li>
<li></span><span class="Comment"> * (This is to avoid getting unpredictable results from <a href="../../nodes/list.c.html#L1674" title="nodes/list.c:1674">list_sort</a>.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1375">&#x200c;</a></span><span class="linkable">append_total_cost_compare</span>(<span class="Type">const</span> ListCell *a, <span class="Type">const</span> ListCell *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path1 = (Path *) lfirst(a);<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path2 = (Path *) lfirst(b);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="#L69" title="optimizer/util/pathnode.c:69">compare_path_costs</a>(path1, path2, TOTAL_COST);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../nodes/bitmapset.c.html#L183" title="nodes/bitmapset.c:183">bms_compare</a>(path1-&gt;parent-&gt;relids, path2-&gt;parent-&gt;relids);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1397" title="optimizer/util/pathnode.c:1397">append_startup_cost_compare</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1674" title="nodes/list.c:1674">list_sort</a> comparator for sorting append child paths<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; by startup_cost descending<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> startup costs, we fall back to comparing total costs; if those<br/></li>
<li></span><span class="Comment"> * are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> too, break ties using <a href="../../nodes/bitmapset.c.html#L183" title="nodes/bitmapset.c:183">bms_compare</a> on the paths' relids.<br/></li>
<li></span><span class="Comment"> * (This is to avoid getting unpredictable results from <a href="../../nodes/list.c.html#L1674" title="nodes/list.c:1674">list_sort</a>.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1397">&#x200c;</a></span><span class="linkable">append_startup_cost_compare</span>(<span class="Type">const</span> ListCell *a, <span class="Type">const</span> ListCell *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path1 = (Path *) lfirst(a);<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path2 = (Path *) lfirst(b);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="#L69" title="optimizer/util/pathnode.c:69">compare_path_costs</a>(path1, path2, STARTUP_COST);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../nodes/bitmapset.c.html#L183" title="nodes/bitmapset.c:183">bms_compare</a>(path1-&gt;parent-&gt;relids, path2-&gt;parent-&gt;relids);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1415" title="optimizer/util/pathnode.c:1415">create_merge_append_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a path corresponding to a MergeAppend plan, returning the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; pathnode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MergeAppendPath *<br/></li>
<li><a id="L1415">&#x200c;</a><span class="linkable">create_merge_append_path</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *subpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids required_outer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MergeAppendPath *pathnode = makeNode(MergeAppendPath);<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; input_startup_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; input_total_cost;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_MergeAppend;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = rel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.param_info = <a href="relnode.c.html#L1868" title="optimizer/util/relnode.c:1868">get_appendrel_parampathinfo</a>(rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = pathkeys;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;subpaths = subpaths;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Apply query-wide LIMIT if known and path is for sole base relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Handling this at this low level is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> klugy.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(rel-&gt;relids, root-&gt;all_query_rels))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;limit_tuples = root-&gt;limit_tuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;limit_tuples = -<span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add up the sizes and costs of the input paths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.rows = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; input_startup_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; input_total_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(l, subpaths)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *subpath = (Path *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.rows += subpath-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.parallel_safe = pathnode-&gt;path.parallel_safe &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;parallel_safe;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../path/pathkeys.c.html#L341" title="optimizer/path/pathkeys.c:341">pathkeys_contained_in</a>(pathkeys, subpath-&gt;pathkeys))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Subpath is adequately ordered, we won't need to sort it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_startup_cost += subpath-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_total_cost += subpath-&gt;total_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We'll need to insert a Sort node, so include cost for that */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp; &nbsp; sort_path;&nbsp; &nbsp; <span class="Comment">/* dummy for result of <a href="../path/costsize.c.html#L2124" title="optimizer/path/costsize.c:2124">cost_sort</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L2124" title="optimizer/path/costsize.c:2124">cost_sort</a>(&amp;sort_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;pathtarget-&gt;width,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0.0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;limit_tuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_startup_cost += sort_path.startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_total_cost += sort_path.total_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* All child paths must have same parameterization */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(PATH_REQ_OUTER(subpath), required_outer));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we can compute total costs of the MergeAppend.&nbsp; If there's exactly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one child path and its parallel awareness matches that of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * MergeAppend, then the MergeAppend is a no-op and will be discarded<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * later (in setrefs.c); otherwise we do the normal cost calculation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(subpaths) == <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((Path *) linitial(subpaths))-&gt;parallel_aware ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.parallel_aware)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.startup_cost = input_startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.total_cost = input_total_cost;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L2404" title="optimizer/path/costsize.c:2404">cost_merge_append</a>(&amp;pathnode-&gt;path, root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkeys, list_length(subpaths),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_startup_cost, input_total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.rows);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1518" title="optimizer/util/pathnode.c:1518">create_group_result_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a path representing a Result-and-nothing-else plan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is only used for degenerate grouping cases, in which we know we<br/></li>
<li></span><span class="Comment"> * need to produce one result row, possibly filtered by a HAVING qual.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>GroupResultPath *<br/></li>
<li><a id="L1518">&#x200c;</a><span class="linkable">create_group_result_path</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PathTarget *target, List *havingqual)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GroupResultPath *pathnode = makeNode(GroupResultPath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_Result;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = target;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.param_info = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* there are no other rels... */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = NIL;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;quals = havingqual;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can't quite use <a href="../path/costsize.c.html#L1776" title="optimizer/path/costsize.c:1776">cost_resultscan</a>() because the quals we want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * account for are not baserestrict quals of the rel.&nbsp; Might as well just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hack it here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.rows = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.startup_cost = target-&gt;cost.startup;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.total_cost = target-&gt;cost.startup +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> + target-&gt;cost.per_tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add cost of qual, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> --- but we ignore its selectivity, since our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rowcount estimate should be 1 no matter what the qual is.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (havingqual)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; QualCost&nbsp; &nbsp; qual_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L4640" title="optimizer/path/costsize.c:4640">cost_qual_eval</a>(&amp;qual_cost, havingqual, root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* havingqual is evaluated once at startup */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.startup_cost += qual_cost.startup + qual_cost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.total_cost += qual_cost.startup + qual_cost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1566" title="optimizer/util/pathnode.c:1566">create_material_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a path corresponding to a Material plan, returning the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; pathnode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MaterialPath *<br/></li>
<li><a id="L1566">&#x200c;</a><span class="linkable">create_material_path</span>(RelOptInfo *rel, Path *subpath)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MaterialPath *pathnode = makeNode(MaterialPath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(subpath-&gt;parent == rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_Material;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = rel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.param_info = subpath-&gt;param_info;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;parallel_safe;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = subpath-&gt;parallel_workers;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = subpath-&gt;pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;subpath = subpath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../path/costsize.c.html#L2453" title="optimizer/path/costsize.c:2453">cost_material</a>(&amp;pathnode-&gt;path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;startup_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;pathtarget-&gt;width);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1598" title="optimizer/util/pathnode.c:1598">create_memoize_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a path corresponding to a Memoize plan, returning the pathnode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MemoizePath *<br/></li>
<li><a id="L1598">&#x200c;</a><span class="linkable">create_memoize_path</span>(PlannerInfo *root, RelOptInfo *rel, Path *subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *param_exprs, List *hash_operators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> singlerow, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> binary_mode, <span class="Type">double</span> calls)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoizePath *pathnode = makeNode(MemoizePath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(subpath-&gt;parent == rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_Memoize;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = rel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.param_info = subpath-&gt;param_info;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;parallel_safe;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = subpath-&gt;parallel_workers;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = subpath-&gt;pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;subpath = subpath;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;hash_operators = hash_operators;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;param_exprs = param_exprs;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;singlerow = singlerow;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;binary_mode = binary_mode;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;calls = calls;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we set est_entries to 0.&nbsp; <a href="../path/costsize.c.html#L2509" title="optimizer/path/costsize.c:2509">cost_memoize_rescan</a>() does all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hard work to determine how many cache entries there are likely to be,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so it seems best to leave it up to that function to fill this field in.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If left at 0, the executor will make a guess at a good value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;est_entries = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add a small additional <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> for caching the first entry.&nbsp; All the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * harder calculations for rescans are performed in <a href="../path/costsize.c.html#L2509" title="optimizer/path/costsize.c:2509">cost_memoize_rescan</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.startup_cost = subpath-&gt;startup_cost + <a href="../path/costsize.c.html#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.total_cost = subpath-&gt;total_cost + <a href="../path/costsize.c.html#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.rows = subpath-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1654" title="optimizer/util/pathnode.c:1654">create_unique_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a path representing elimination of distinct rows from the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; input data.&nbsp; Distinct-ness is defined according to the needs of the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; semijoin represented by sjinfo.&nbsp; If it is not possible to identify<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; how to make the data unique, NULL is returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If used at all, this is likely to be called repeatedly on the same rel;<br/></li>
<li></span><span class="Comment"> * and the input subpath should always be the same (the cheapest_total path<br/></li>
<li></span><span class="Comment"> * for the rel).&nbsp; So we cache the result.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>UniquePath *<br/></li>
<li><a id="L1654">&#x200c;</a><span class="linkable">create_unique_path</span>(PlannerInfo *root, RelOptInfo *rel, Path *subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SpecialJoinInfo *sjinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; UniquePath *pathnode;<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp; &nbsp; sort_path;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dummy for result of <a href="../path/costsize.c.html#L2124" title="optimizer/path/costsize.c:2124">cost_sort</a> */<br/></li>
<li></span>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp; &nbsp; agg_path;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dummy for result of <a href="../path/costsize.c.html#L2650" title="optimizer/path/costsize.c:2650">cost_agg</a> */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numCols;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Caller made a mistake if subpath isn't cheapest_total ... */<br/></li>
<li></span>&nbsp; &nbsp; Assert(subpath == rel-&gt;cheapest_total_path);<br/></li>
<li>&nbsp; &nbsp; Assert(subpath-&gt;parent == rel);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... or if SpecialJoinInfo is the wrong one */<br/></li>
<li></span>&nbsp; &nbsp; Assert(sjinfo-&gt;jointype == JOIN_SEMI);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(rel-&gt;relids, sjinfo-&gt;syn_righthand));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If result already cached, return it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;cheapest_unique_path)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (UniquePath *) rel-&gt;cheapest_unique_path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If it's not possible to unique-ify, return NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(sjinfo-&gt;semi_can_btree || sjinfo-&gt;semi_can_hash))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When called during GEQO join planning, we are in a short-lived memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * context.&nbsp; We must make sure that the path and <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subsidiary data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * structures created for a baserel survive the GEQO cycle, else the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * baserel is trashed for future GEQO cycles.&nbsp; On the other hand, when we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are creating those for a joinrel during GEQO, we don't want them to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clutter the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> planning context.&nbsp; Upshot is that the best solution is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to explicitly allocate memory in the same context the given RelOptInfo<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is in.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(<a href="../../utils/mmgr/mcxt.c.html#L707" title="utils/mmgr/mcxt.c:707">GetMemoryChunkContext</a>(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode = makeNode(UniquePath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_Unique;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = rel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.param_info = subpath-&gt;param_info;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;parallel_safe;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = subpath-&gt;parallel_workers;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Assume the output is unsorted, since we don't necessarily have pathkeys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to represent it.&nbsp; (This might get overridden below.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;subpath = subpath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Under GEQO and when planning child joins, the sjinfo might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * short-lived, so we'd better make copies of data structures we extract<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;in_operators = copyObject(sjinfo-&gt;semi_operators);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;uniq_exprs = copyObject(sjinfo-&gt;semi_rhs_exprs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the input is a relation and it has a unique index that proves the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * semi_rhs_exprs are unique, then we don't need to do anything.&nbsp; Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that <a href="../path/indxpath.c.html#L3440" title="optimizer/path/indxpath.c:3440">relation_has_unique_index_for</a> automatically considers restriction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clauses for the rel, as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rtekind == RTE_RELATION &amp;&amp; sjinfo-&gt;semi_can_btree &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/indxpath.c.html#L3440" title="optimizer/path/indxpath.c:3440">relation_has_unique_index_for</a>(root, rel, NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sjinfo-&gt;semi_rhs_exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sjinfo-&gt;semi_operators))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;umethod = UNIQUE_PATH_NOOP;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.rows = rel-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.startup_cost = subpath-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.total_cost = subpath-&gt;total_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.pathkeys = subpath-&gt;pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;cheapest_unique_path = (Path *) pathnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the input is a subquery whose output must be unique already, then we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't need to do anything.&nbsp; The test for uniqueness has to consider<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exactly which columns we are extracting; for example &quot;SELECT DISTINCT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * x,y&quot; doesn't guarantee that x alone is distinct. So we cannot check for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this optimization unless semi_rhs_exprs consists only of simple Vars<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * referencing subquery outputs.&nbsp; (Possibly we could do something with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expressions in the subquery outputs, too, but for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> keep it simple.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rtekind == RTE_SUBQUERY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = planner_rt_fetch(rel-&gt;relid, root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../plan/analyzejoins.c.html#L998" title="optimizer/plan/analyzejoins.c:998">query_supports_distinctness</a>(rte-&gt;subquery))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sub_tlist_colnos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_tlist_colnos = <a href="#L1946" title="optimizer/util/pathnode.c:1946">translate_sub_tlist</a>(sjinfo-&gt;semi_rhs_exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sub_tlist_colnos &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../plan/analyzejoins.c.html#L1035" title="optimizer/plan/analyzejoins.c:1035">query_is_distinct_for</a>(rte-&gt;subquery,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_tlist_colnos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sjinfo-&gt;semi_operators))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;umethod = UNIQUE_PATH_NOOP;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.rows = rel-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.startup_cost = subpath-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.total_cost = subpath-&gt;total_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.pathkeys = subpath-&gt;pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;cheapest_unique_path = (Path *) pathnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Estimate number of output rows */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.rows = <a href="../../utils/adt/selfuncs.c.html#L3416" title="utils/adt/selfuncs.c:3416">estimate_num_groups</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sjinfo-&gt;semi_rhs_exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; numCols = list_length(sjinfo-&gt;semi_rhs_exprs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sjinfo-&gt;semi_can_btree)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Estimate cost for sort+unique implementation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L2124" title="optimizer/path/costsize.c:2124">cost_sort</a>(&amp;sort_path, root, NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;pathtarget-&gt;width,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0.0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1.0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Charge one <a href="../path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> per comparison per input tuple. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assume all columns get compared at most of the tuples. (</span><span class="Todo">XXX<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * probably this is an overestimate.)&nbsp; This should agree with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L3103" title="optimizer/util/pathnode.c:3103">create_upper_unique_path</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sort_path.total_cost += <a href="../path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> * rel-&gt;rows * numCols;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sjinfo-&gt;semi_can_hash)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Estimate the overhead per hashtable entry at 64 bytes (same as in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>.c).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashentrysize = subpath-&gt;pathtarget-&gt;width + <span class="Constant">64</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hashentrysize * pathnode-&gt;path.rows &gt; <a href="../../executor/nodeHash.c.html#L3595" title="executor/nodeHash.c:3595">get_hash_memory_limit</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We should not try to <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>.&nbsp; Hack the SpecialJoinInfo to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remember this, in case we come through here again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sjinfo-&gt;semi_can_hash = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L2650" title="optimizer/path/costsize.c:2650">cost_agg</a>(&amp;agg_path, root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AGG_HASHED, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numCols, pathnode-&gt;path.rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subpath-&gt;startup_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subpath-&gt;total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subpath-&gt;pathtarget-&gt;width);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sjinfo-&gt;semi_can_btree &amp;&amp; sjinfo-&gt;semi_can_hash)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (agg_path.total_cost &lt; sort_path.total_cost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;umethod = UNIQUE_PATH_HASH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;umethod = UNIQUE_PATH_SORT;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (sjinfo-&gt;semi_can_btree)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;umethod = UNIQUE_PATH_SORT;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (sjinfo-&gt;semi_can_hash)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;umethod = UNIQUE_PATH_HASH;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we can get here only if we abandoned hashing above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pathnode-&gt;umethod == UNIQUE_PATH_HASH)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.startup_cost = agg_path.startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.total_cost = agg_path.total_cost;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.startup_cost = sort_path.startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.total_cost = sort_path.total_cost;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel-&gt;cheapest_unique_path = (Path *) pathnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1881" title="optimizer/util/pathnode.c:1881">create_gather_merge_path</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a path corresponding to a gather <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> scan, returning<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the pathnode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>GatherMergePath *<br/></li>
<li><a id="L1881">&#x200c;</a><span class="linkable">create_gather_merge_path</span>(PlannerInfo *root, RelOptInfo *rel, Path *subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PathTarget *target, List *pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids required_outer, <span class="Type">double</span> *rows)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GatherMergePath *pathnode = makeNode(GatherMergePath);<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; input_startup_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; input_total_cost = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(subpath-&gt;parallel_safe);<br/></li>
<li>&nbsp; &nbsp; Assert(pathkeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_GatherMerge;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.param_info = <a href="relnode.c.html#L1557" title="optimizer/util/relnode.c:1557">get_baserel_parampathinfo</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;subpath = subpath;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;num_workers = subpath-&gt;parallel_workers;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = pathkeys;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = target ? target : rel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.rows += subpath-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../path/pathkeys.c.html#L341" title="optimizer/path/pathkeys.c:341">pathkeys_contained_in</a>(pathkeys, subpath-&gt;pathkeys))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Subpath is adequately ordered, we won't need to sort it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; input_startup_cost += subpath-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; input_total_cost += subpath-&gt;total_cost;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We'll need to insert a Sort node, so include cost for that */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp; &nbsp; sort_path;&nbsp; &nbsp; <span class="Comment">/* dummy for result of <a href="../path/costsize.c.html#L2124" title="optimizer/path/costsize.c:2124">cost_sort</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L2124" title="optimizer/path/costsize.c:2124">cost_sort</a>(&amp;sort_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;pathtarget-&gt;width,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0.0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; input_startup_cost += sort_path.startup_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; input_total_cost += sort_path.total_cost;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../path/costsize.c.html#L474" title="optimizer/path/costsize.c:474">cost_gather_merge</a>(pathnode, root, rel, pathnode-&gt;path.param_info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_startup_cost, input_total_cost, rows);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1946" title="optimizer/util/pathnode.c:1946">translate_sub_tlist</a> - get subquery column numbers represented by tlist<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The given targetlist usually contains only Vars referencing the given relid.<br/></li>
<li></span><span class="Comment"> * Extract their varattnos (ie, the column numbers of the subquery) and return<br/></li>
<li></span><span class="Comment"> * as an integer List.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the tlist items is not a simple Var, we cannot determine whether<br/></li>
<li></span><span class="Comment"> * the subquery's uniqueness condition (if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) matches ours, so punt and<br/></li>
<li></span><span class="Comment"> * return NIL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L1946">&#x200c;</a><span class="linkable">translate_sub_tlist</span>(List *tlist, <span class="Type">int</span> relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, tlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!var || !IsA(var, Var) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varno != relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* punt */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(result, var-&gt;varattno);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1972" title="optimizer/util/pathnode.c:1972">create_gather_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a path corresponding to a gather scan, returning the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; pathnode.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rows' may optionally be set to override row estimates from other sources.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>GatherPath *<br/></li>
<li><a id="L1972">&#x200c;</a><span class="linkable">create_gather_path</span>(PlannerInfo *root, RelOptInfo *rel, Path *subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PathTarget *target, Relids required_outer, <span class="Type">double</span> *rows)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GatherPath *pathnode = makeNode(GatherPath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(subpath-&gt;parallel_safe);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_Gather;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = target;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.param_info = <a href="relnode.c.html#L1557" title="optimizer/util/relnode.c:1557">get_baserel_parampathinfo</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = NIL;&nbsp; &nbsp; <span class="Comment">/* Gather has unordered result */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;subpath = subpath;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;num_workers = subpath-&gt;parallel_workers;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;single_copy = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pathnode-&gt;num_workers == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.pathkeys = subpath-&gt;pathkeys;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;num_workers = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;single_copy = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../path/costsize.c.html#L436" title="optimizer/path/costsize.c:436">cost_gather</a>(pathnode, root, rel, pathnode-&gt;path.param_info, rows);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2016" title="optimizer/util/pathnode.c:2016">create_subqueryscan_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a path corresponding to a scan of a subquery,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; returning the pathnode.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must pass trivial_pathtarget = true if it believes rel-&gt;reltarget to<br/></li>
<li></span><span class="Comment"> * be trivial, ie just a fetch of all the subquery output columns in order.<br/></li>
<li></span><span class="Comment"> * While we could determine that here, the caller can usually do it more<br/></li>
<li></span><span class="Comment"> * efficiently (or at least amortize it over multiple calls).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>SubqueryScanPath *<br/></li>
<li><a id="L2016">&#x200c;</a><span class="linkable">create_subqueryscan_path</span>(PlannerInfo *root, RelOptInfo *rel, Path *subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> trivial_pathtarget,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *pathkeys, Relids required_outer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SubqueryScanPath *pathnode = makeNode(SubqueryScanPath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_SubqueryScan;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = rel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.param_info = <a href="relnode.c.html#L1557" title="optimizer/util/relnode.c:1557">get_baserel_parampathinfo</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;parallel_safe;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = subpath-&gt;parallel_workers;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = pathkeys;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;subpath = subpath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../path/costsize.c.html#L1451" title="optimizer/path/costsize.c:1451">cost_subqueryscan</a>(pathnode, root, rel, pathnode-&gt;path.param_info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trivial_pathtarget);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2046" title="optimizer/util/pathnode.c:2046">create_functionscan_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a path corresponding to a sequential scan of a function,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; returning the pathnode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Path *<br/></li>
<li><a id="L2046">&#x200c;</a><span class="linkable">create_functionscan_path</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *pathkeys, Relids required_outer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *pathnode = makeNode(Path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;pathtype = T_FunctionScan;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;pathtarget = rel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;param_info = <a href="relnode.c.html#L1557" title="optimizer/util/relnode.c:1557">get_baserel_parampathinfo</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; required_outer);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parallel_safe = rel-&gt;consider_parallel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parallel_workers = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;pathkeys = pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../path/costsize.c.html#L1531" title="optimizer/path/costsize.c:1531">cost_functionscan</a>(pathnode, root, rel, pathnode-&gt;param_info);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2072" title="optimizer/util/pathnode.c:2072">create_tablefuncscan_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a path corresponding to a sequential scan of a table function,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; returning the pathnode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Path *<br/></li>
<li><a id="L2072">&#x200c;</a><span class="linkable">create_tablefuncscan_path</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids required_outer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *pathnode = makeNode(Path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;pathtype = T_TableFuncScan;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;pathtarget = rel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;param_info = <a href="relnode.c.html#L1557" title="optimizer/util/relnode.c:1557">get_baserel_parampathinfo</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; required_outer);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parallel_safe = rel-&gt;consider_parallel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parallel_workers = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;pathkeys = NIL;&nbsp; &nbsp; <span class="Comment">/* result is always unordered */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../path/costsize.c.html#L1592" title="optimizer/path/costsize.c:1592">cost_tablefuncscan</a>(pathnode, root, rel, pathnode-&gt;param_info);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2098" title="optimizer/util/pathnode.c:2098">create_valuesscan_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a path corresponding to a scan of a VALUES list,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; returning the pathnode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Path *<br/></li>
<li><a id="L2098">&#x200c;</a><span class="linkable">create_valuesscan_path</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids required_outer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *pathnode = makeNode(Path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;pathtype = T_ValuesScan;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;pathtarget = rel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;param_info = <a href="relnode.c.html#L1557" title="optimizer/util/relnode.c:1557">get_baserel_parampathinfo</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; required_outer);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parallel_safe = rel-&gt;consider_parallel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parallel_workers = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;pathkeys = NIL;&nbsp; &nbsp; <span class="Comment">/* result is always unordered */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../path/costsize.c.html#L1648" title="optimizer/path/costsize.c:1648">cost_valuesscan</a>(pathnode, root, rel, pathnode-&gt;param_info);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2124" title="optimizer/util/pathnode.c:2124">create_ctescan_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a path corresponding to a scan of a non-self-reference CTE,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; returning the pathnode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Path *<br/></li>
<li><a id="L2124">&#x200c;</a><span class="linkable">create_ctescan_path</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *pathkeys, Relids required_outer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *pathnode = makeNode(Path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;pathtype = T_CteScan;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;pathtarget = rel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;param_info = <a href="relnode.c.html#L1557" title="optimizer/util/relnode.c:1557">get_baserel_parampathinfo</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; required_outer);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parallel_safe = rel-&gt;consider_parallel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parallel_workers = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;pathkeys = pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../path/costsize.c.html#L1698" title="optimizer/path/costsize.c:1698">cost_ctescan</a>(pathnode, root, rel, pathnode-&gt;param_info);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2150" title="optimizer/util/pathnode.c:2150">create_namedtuplestorescan_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a path corresponding to a scan of a named tuplestore, returning<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the pathnode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Path *<br/></li>
<li><a id="L2150">&#x200c;</a><span class="linkable">create_namedtuplestorescan_path</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids required_outer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *pathnode = makeNode(Path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;pathtype = T_NamedTuplestoreScan;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;pathtarget = rel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;param_info = <a href="relnode.c.html#L1557" title="optimizer/util/relnode.c:1557">get_baserel_parampathinfo</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; required_outer);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parallel_safe = rel-&gt;consider_parallel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parallel_workers = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;pathkeys = NIL;&nbsp; &nbsp; <span class="Comment">/* result is always unordered */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../path/costsize.c.html#L1739" title="optimizer/path/costsize.c:1739">cost_namedtuplestorescan</a>(pathnode, root, rel, pathnode-&gt;param_info);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2176" title="optimizer/util/pathnode.c:2176">create_resultscan_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a path corresponding to a scan of an RTE_RESULT relation,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; returning the pathnode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Path *<br/></li>
<li><a id="L2176">&#x200c;</a><span class="linkable">create_resultscan_path</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids required_outer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *pathnode = makeNode(Path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;pathtype = T_Result;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;pathtarget = rel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;param_info = <a href="relnode.c.html#L1557" title="optimizer/util/relnode.c:1557">get_baserel_parampathinfo</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; required_outer);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parallel_safe = rel-&gt;consider_parallel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parallel_workers = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;pathkeys = NIL;&nbsp; &nbsp; <span class="Comment">/* result is always unordered */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../path/costsize.c.html#L1776" title="optimizer/path/costsize.c:1776">cost_resultscan</a>(pathnode, root, rel, pathnode-&gt;param_info);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2202" title="optimizer/util/pathnode.c:2202">create_worktablescan_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a path corresponding to a scan of a self-reference CTE,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; returning the pathnode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Path *<br/></li>
<li><a id="L2202">&#x200c;</a><span class="linkable">create_worktablescan_path</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids required_outer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *pathnode = makeNode(Path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;pathtype = T_WorkTableScan;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;pathtarget = rel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;param_info = <a href="relnode.c.html#L1557" title="optimizer/util/relnode.c:1557">get_baserel_parampathinfo</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; required_outer);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parallel_safe = rel-&gt;consider_parallel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;parallel_workers = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;pathkeys = NIL;&nbsp; &nbsp; <span class="Comment">/* result is always unordered */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cost is the same as for a regular CTE scan */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../path/costsize.c.html#L1698" title="optimizer/path/costsize.c:1698">cost_ctescan</a>(pathnode, root, rel, pathnode-&gt;param_info);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2235" title="optimizer/util/pathnode.c:2235">create_foreignscan_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a path corresponding to a scan of a foreign base table,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; returning the pathnode.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is never called from core Postgres; rather, it's expected<br/></li>
<li></span><span class="Comment"> * to be called by the GetForeignPaths function of a foreign data wrapper.<br/></li>
<li></span><span class="Comment"> * We make the FDW supply all fields of the path, since we do not have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> way<br/></li>
<li></span><span class="Comment"> * to calculate them in core.&nbsp; However, there is a usually-sane default for<br/></li>
<li></span><span class="Comment"> * the pathtarget (rel-&gt;reltarget), so we let a NULL for &quot;target&quot; <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ForeignPath *<br/></li>
<li><a id="L2235">&#x200c;</a><span class="linkable">create_foreignscan_path</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathTarget *target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> rows, Cost startup_cost, Cost total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids required_outer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path *fdw_outerpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *fdw_restrictinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *fdw_private)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ForeignPath *pathnode = makeNode(ForeignPath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Historically some FDWs were confused about when to use this */<br/></li>
<li></span>&nbsp; &nbsp; Assert(IS_SIMPLE_REL(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_ForeignScan;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = target ? target : rel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.param_info = <a href="relnode.c.html#L1557" title="optimizer/util/relnode.c:1557">get_baserel_parampathinfo</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.rows = rows;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.total_cost = total_cost;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;fdw_outerpath = fdw_outerpath;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;fdw_restrictinfo = fdw_restrictinfo;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;fdw_private = fdw_private;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2281" title="optimizer/util/pathnode.c:2281">create_foreign_join_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a path corresponding to a scan of a foreign join,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; returning the pathnode.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is never called from core Postgres; rather, it's expected<br/></li>
<li></span><span class="Comment"> * to be called by the GetForeignJoinPaths function of a foreign data wrapper.<br/></li>
<li></span><span class="Comment"> * We make the FDW supply all fields of the path, since we do not have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> way<br/></li>
<li></span><span class="Comment"> * to calculate them in core.&nbsp; However, there is a usually-sane default for<br/></li>
<li></span><span class="Comment"> * the pathtarget (rel-&gt;reltarget), so we let a NULL for &quot;target&quot; <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ForeignPath *<br/></li>
<li><a id="L2281">&#x200c;</a><span class="linkable">create_foreign_join_path</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PathTarget *target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> rows, Cost startup_cost, Cost total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids required_outer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Path *fdw_outerpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *fdw_restrictinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *fdw_private)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ForeignPath *pathnode = makeNode(ForeignPath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We should use <a href="relnode.c.html#L1671" title="optimizer/util/relnode.c:1671">get_joinrel_parampathinfo</a> to handle parameterized paths,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but the API of this function doesn't support it, and existing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * extensions aren't yet trying to build such paths anyway.&nbsp; For the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * moment just throw an error if someone tries it; eventually we should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * revisit this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!bms_is_empty(required_outer) || !bms_is_empty(rel-&gt;lateral_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;parameterized foreign joins are not supported yet&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_ForeignScan;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = target ? target : rel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.param_info = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> see above */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.rows = rows;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.total_cost = total_cost;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;fdw_outerpath = fdw_outerpath;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;fdw_restrictinfo = fdw_restrictinfo;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;fdw_private = fdw_private;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2333" title="optimizer/util/pathnode.c:2333">create_foreign_upper_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a path corresponding to an <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> relation that's computed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; directly by an FDW, returning the pathnode.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is never called from core Postgres; rather, it's expected to<br/></li>
<li></span><span class="Comment"> * be called by the GetForeignUpperPaths function of a foreign data wrapper.<br/></li>
<li></span><span class="Comment"> * We make the FDW supply all fields of the path, since we do not have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> way<br/></li>
<li></span><span class="Comment"> * to calculate them in core.&nbsp; However, there is a usually-sane default for<br/></li>
<li></span><span class="Comment"> * the pathtarget (rel-&gt;reltarget), so we let a NULL for &quot;target&quot; <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ForeignPath *<br/></li>
<li><a id="L2333">&#x200c;</a><span class="linkable">create_foreign_upper_path</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathTarget *target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> rows, Cost startup_cost, Cost total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path *fdw_outerpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *fdw_restrictinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *fdw_private)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ForeignPath *pathnode = makeNode(ForeignPath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Upper relations should never have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> lateral references, since joining<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is complete.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(bms_is_empty(rel-&gt;lateral_relids));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_ForeignScan;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = target ? target : rel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.param_info = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.rows = rows;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.startup_cost = startup_cost;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.total_cost = total_cost;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;fdw_outerpath = fdw_outerpath;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;fdw_restrictinfo = fdw_restrictinfo;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;fdw_private = fdw_private;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2378" title="optimizer/util/pathnode.c:2378">calc_nestloop_required_outer</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Compute the required_outer set for a nestloop join path<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: when considering a child join, the inputs nonetheless use top-level<br/></li>
<li></span><span class="Comment"> * parent relids<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: result must not share storage with either input<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Relids<br/></li>
<li><a id="L2378">&#x200c;</a><span class="linkable">calc_nestloop_required_outer</span>(Relids outerrelids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids outer_paramrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids innerrelids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids inner_paramrels)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; required_outer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* inner_path can require rels from outer path, but not vice versa */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(outer_paramrels, innerrelids));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* easy case if inner path is not parameterized */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!inner_paramrels)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(outer_paramrels);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* else, form the union ... */<br/></li>
<li></span>&nbsp; &nbsp; required_outer = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(outer_paramrels, inner_paramrels);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... and remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> mention of <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-satisfied outer rels */<br/></li>
<li></span>&nbsp; &nbsp; required_outer = <a href="../../nodes/bitmapset.c.html#L1161" title="nodes/bitmapset.c:1161">bms_del_members</a>(required_outer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outerrelids);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> required_outer;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2405" title="optimizer/util/pathnode.c:2405">calc_non_nestloop_required_outer</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Compute the required_outer set for a <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> or <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> join path<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: result must not share storage with either input<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Relids<br/></li>
<li><a id="L2405">&#x200c;</a><span class="linkable">calc_non_nestloop_required_outer</span>(Path *outer_path, Path *inner_path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; outer_paramrels = PATH_REQ_OUTER(outer_path);<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; inner_paramrels = PATH_REQ_OUTER(inner_path);<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; innerrelids <a href="../../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; outerrelids <a href="../../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; required_outer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Any parameterization of the input paths refers to topmost parents of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the relevant relations, because <a href="#L4112" title="optimizer/util/pathnode.c:4112">reparameterize_path_by_child</a>() hasn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * been called yet.&nbsp; So we must consider topmost parents of the relations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * being joined, too, while checking for disallowed parameterization<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (inner_path-&gt;parent-&gt;top_parent_relids)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; innerrelids = inner_path-&gt;parent-&gt;top_parent_relids;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; innerrelids = inner_path-&gt;parent-&gt;relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (outer_path-&gt;parent-&gt;top_parent_relids)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; outerrelids = outer_path-&gt;parent-&gt;top_parent_relids;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; outerrelids = outer_path-&gt;parent-&gt;relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* neither path can require rels from the other */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(outer_paramrels, innerrelids));<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(inner_paramrels, outerrelids));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* form the union ... */<br/></li>
<li></span>&nbsp; &nbsp; required_outer = <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(outer_paramrels, inner_paramrels);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we do not need an explicit test for empty; <a href="../../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a> gets it right */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> required_outer;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2457" title="optimizer/util/pathnode.c:2457">create_nestloop_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a pathnode corresponding to a nestloop join between two<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; relations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'joinrel' is the join relation.<br/></li>
<li></span><span class="Comment"> * 'jointype' is the type of join required<br/></li>
<li></span><span class="Comment"> * 'workspace' is the result from <a href="../path/costsize.c.html#L3233" title="optimizer/path/costsize.c:3233">initial_cost_nestloop</a><br/></li>
<li></span><span class="Comment"> * 'extra' contains various information about the join<br/></li>
<li></span><span class="Comment"> * 'outer_path' is the outer path<br/></li>
<li></span><span class="Comment"> * 'inner_path' is the inner path<br/></li>
<li></span><span class="Comment"> * 'restrict_clauses' are the RestrictInfo nodes to apply at the join<br/></li>
<li></span><span class="Comment"> * 'pathkeys' are the path keys of the new join path<br/></li>
<li></span><span class="Comment"> * 'required_outer' is the set of required outer rels<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the resulting path node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>NestPath *<br/></li>
<li><a id="L2457">&#x200c;</a><span class="linkable">create_nestloop_path</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JoinType jointype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JoinCostWorkspace *workspace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JoinPathExtraData *extra,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Path *outer_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Path *inner_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *restrict_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids required_outer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; NestPath&nbsp;&nbsp; *pathnode = makeNode(NestPath);<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; inner_req_outer = PATH_REQ_OUTER(inner_path);<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; outerrelids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Paths are parameterized by top-level parents, so run parameterization<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tests on the parent relids.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (outer_path-&gt;parent-&gt;top_parent_relids)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; outerrelids = outer_path-&gt;parent-&gt;top_parent_relids;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; outerrelids = outer_path-&gt;parent-&gt;relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the inner path is parameterized by the outer, we must drop <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restrict_clauses that are due to be moved into the inner path.&nbsp; We have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to do this <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, rather than postpone the work till createplan time,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because the restrict_clauses list can affect the size and cost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimates for this path.&nbsp; We detect such clauses by checking for serial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number match to clauses already enforced in the inner path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(inner_req_outer, outerrelids))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *enforced_serials = <a href="relnode.c.html#L1922" title="optimizer/util/relnode.c:1922">get_param_path_clause_serials</a>(inner_path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *jclauses = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, restrict_clauses)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(rinfo-&gt;rinfo_serial, enforced_serials))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jclauses = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(jclauses, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; restrict_clauses = jclauses;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.path.pathtype = T_NestLoop;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.path.parent = joinrel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.path.pathtarget = joinrel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.path.param_info =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="relnode.c.html#L1671" title="optimizer/util/relnode.c:1671">get_joinrel_parampathinfo</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inner_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra-&gt;sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;restrict_clauses);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.path.parallel_safe = joinrel-&gt;consider_parallel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; outer_path-&gt;parallel_safe &amp;&amp; inner_path-&gt;parallel_safe;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This is a foolish way to estimate parallel_workers, but for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>... */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;jpath.path.parallel_workers = outer_path-&gt;parallel_workers;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.path.pathkeys = pathkeys;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.jointype = jointype;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.inner_unique = extra-&gt;inner_unique;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.outerjoinpath = outer_path;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.innerjoinpath = inner_path;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.joinrestrictinfo = restrict_clauses;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../path/costsize.c.html#L3308" title="optimizer/path/costsize.c:3308">final_cost_nestloop</a>(root, pathnode, workspace, extra);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2553" title="optimizer/util/pathnode.c:2553">create_mergejoin_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a pathnode corresponding to a mergejoin join between<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; two relations<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'joinrel' is the join relation<br/></li>
<li></span><span class="Comment"> * 'jointype' is the type of join required<br/></li>
<li></span><span class="Comment"> * 'workspace' is the result from <a href="../path/costsize.c.html#L3514" title="optimizer/path/costsize.c:3514">initial_cost_mergejoin</a><br/></li>
<li></span><span class="Comment"> * 'extra' contains various information about the join<br/></li>
<li></span><span class="Comment"> * 'outer_path' is the outer path<br/></li>
<li></span><span class="Comment"> * 'inner_path' is the inner path<br/></li>
<li></span><span class="Comment"> * 'restrict_clauses' are the RestrictInfo nodes to apply at the join<br/></li>
<li></span><span class="Comment"> * 'pathkeys' are the path keys of the new join path<br/></li>
<li></span><span class="Comment"> * 'required_outer' is the set of required outer rels<br/></li>
<li></span><span class="Comment"> * 'mergeclauses' are the RestrictInfo nodes to use as <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> clauses<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (this should be a <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of the restrict_clauses list)<br/></li>
<li></span><span class="Comment"> * 'outersortkeys' are the sort varkeys for the outer relation<br/></li>
<li></span><span class="Comment"> * 'innersortkeys' are the sort varkeys for the inner relation<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MergePath *<br/></li>
<li><a id="L2553">&#x200c;</a><span class="linkable">create_mergejoin_path</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JoinType jointype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JoinCostWorkspace *workspace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JoinPathExtraData *extra,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path *outer_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path *inner_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *restrict_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids required_outer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *mergeclauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *outersortkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *innersortkeys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MergePath&nbsp; *pathnode = makeNode(MergePath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.path.pathtype = T_MergeJoin;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.path.parent = joinrel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.path.pathtarget = joinrel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.path.param_info =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="relnode.c.html#L1671" title="optimizer/util/relnode.c:1671">get_joinrel_parampathinfo</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inner_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra-&gt;sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;restrict_clauses);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.path.parallel_safe = joinrel-&gt;consider_parallel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; outer_path-&gt;parallel_safe &amp;&amp; inner_path-&gt;parallel_safe;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This is a foolish way to estimate parallel_workers, but for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>... */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;jpath.path.parallel_workers = outer_path-&gt;parallel_workers;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.path.pathkeys = pathkeys;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.jointype = jointype;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.inner_unique = extra-&gt;inner_unique;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.outerjoinpath = outer_path;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.innerjoinpath = inner_path;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.joinrestrictinfo = restrict_clauses;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path_mergeclauses = mergeclauses;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;outersortkeys = outersortkeys;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;innersortkeys = innersortkeys;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pathnode-&gt;skip_mark_restore will be set by <a href="../path/costsize.c.html#L3745" title="optimizer/path/costsize.c:3745">final_cost_mergejoin</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* pathnode-&gt;materialize_inner will be set by <a href="../path/costsize.c.html#L3745" title="optimizer/path/costsize.c:3745">final_cost_mergejoin</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../path/costsize.c.html#L3745" title="optimizer/path/costsize.c:3745">final_cost_mergejoin</a>(root, pathnode, workspace, extra);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2619" title="optimizer/util/pathnode.c:2619">create_hashjoin_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a pathnode corresponding to a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> join between two relations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'joinrel' is the join relation<br/></li>
<li></span><span class="Comment"> * 'jointype' is the type of join required<br/></li>
<li></span><span class="Comment"> * 'workspace' is the result from <a href="../path/costsize.c.html#L4073" title="optimizer/path/costsize.c:4073">initial_cost_hashjoin</a><br/></li>
<li></span><span class="Comment"> * 'extra' contains various information about the join<br/></li>
<li></span><span class="Comment"> * 'outer_path' is the cheapest outer path<br/></li>
<li></span><span class="Comment"> * 'inner_path' is the cheapest inner path<br/></li>
<li></span><span class="Comment"> * 'parallel_hash' to <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> Parallel Hash of inner path (shared <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table)<br/></li>
<li></span><span class="Comment"> * 'restrict_clauses' are the RestrictInfo nodes to apply at the join<br/></li>
<li></span><span class="Comment"> * 'required_outer' is the set of required outer rels<br/></li>
<li></span><span class="Comment"> * 'hashclauses' are the RestrictInfo nodes to use as <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> clauses<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (this should be a <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of the restrict_clauses list)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>HashPath *<br/></li>
<li><a id="L2619">&#x200c;</a><span class="linkable">create_hashjoin_path</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JoinType jointype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JoinCostWorkspace *workspace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JoinPathExtraData *extra,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Path *outer_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Path *inner_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> parallel_hash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *restrict_clauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relids required_outer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *hashclauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HashPath&nbsp;&nbsp; *pathnode = makeNode(HashPath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.path.pathtype = T_HashJoin;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.path.parent = joinrel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.path.pathtarget = joinrel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.path.param_info =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="relnode.c.html#L1671" title="optimizer/util/relnode.c:1671">get_joinrel_parampathinfo</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; joinrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inner_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra-&gt;sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;restrict_clauses);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.path.parallel_aware =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; joinrel-&gt;consider_parallel &amp;&amp; parallel_hash;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.path.parallel_safe = joinrel-&gt;consider_parallel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; outer_path-&gt;parallel_safe &amp;&amp; inner_path-&gt;parallel_safe;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This is a foolish way to estimate parallel_workers, but for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>... */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;jpath.path.parallel_workers = outer_path-&gt;parallel_workers;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A hashjoin never has pathkeys, since its output ordering is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unpredictable due to possible batching.&nbsp; </span><span class="Todo">XXX</span><span class="Comment"> If the inner relation is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * small enough, we could instruct the executor that it must not batch,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and then we could assume that the output inherits the outer relation's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ordering, which might save a sort step.&nbsp; However there is considerable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * downside if our estimate of the inner relation size is badly off. For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the moment we don't risk it.&nbsp; (Note also that if we wanted to take this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * seriously, joinpath.c would have to consider many more paths for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * outer rel than it does <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;jpath.path.pathkeys = NIL;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.jointype = jointype;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.inner_unique = extra-&gt;inner_unique;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.outerjoinpath = outer_path;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.innerjoinpath = inner_path;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;jpath.joinrestrictinfo = restrict_clauses;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path_hashclauses = hashclauses;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../path/costsize.c.html#L4181" title="optimizer/path/costsize.c:4181">final_cost_hashjoin</a> will fill in pathnode-&gt;num_batches */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../path/costsize.c.html#L4181" title="optimizer/path/costsize.c:4181">final_cost_hashjoin</a>(root, pathnode, workspace, extra);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2685" title="optimizer/util/pathnode.c:2685">create_projection_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a pathnode that represents performing a projection.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rel' is the parent relation associated with the result<br/></li>
<li></span><span class="Comment"> * 'subpath' is the path representing the source of data<br/></li>
<li></span><span class="Comment"> * 'target' is the PathTarget to be computed<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ProjectionPath *<br/></li>
<li><a id="L2685">&#x200c;</a><span class="linkable">create_projection_path</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Path *subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PathTarget *target)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ProjectionPath *pathnode = makeNode(ProjectionPath);<br/></li>
<li>&nbsp; &nbsp; PathTarget *oldtarget;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We mustn't put a ProjectionPath directly above another; it's useless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and will confuse <a href="../plan/createplan.c.html#L2018" title="optimizer/plan/createplan.c:2018">create_projection_plan</a>.&nbsp; Rather than making sure all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * callers handle that, let's implement it here, by stripping off <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ProjectionPath in what we're given.&nbsp; Given this rule, there won't be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more than one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(subpath, ProjectionPath))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ProjectionPath *subpp = (ProjectionPath *) subpath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(subpp-&gt;path.parent == rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subpath = subpp-&gt;subpath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!IsA(subpath, ProjectionPath));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_Result;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = target;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, assume we are above <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> joins, so no parameterization */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.param_info = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;parallel_safe &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="clauses.c.html#L753" title="optimizer/util/clauses.c:753">is_parallel_safe</a>(root, (Node *) target-&gt;exprs);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = subpath-&gt;parallel_workers;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Projection does not change the sort order */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = subpath-&gt;pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;subpath = subpath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We might not need a separate Result node.&nbsp; If the input plan node type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can project, we can just tell it to project something else.&nbsp; Or, if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't project but the desired target has the same expression list as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * what the input will produce anyway, we can still give it the desired<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tlist (possibly changing its ressortgroupref labels, but nothing else).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: in the latter case, <a href="../plan/createplan.c.html#L2018" title="optimizer/plan/createplan.c:2018">create_projection_plan</a> has to recheck our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conclusion; see comments therein.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldtarget = subpath-&gt;pathtarget;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../plan/createplan.c.html#L7207" title="optimizer/plan/createplan.c:7207">is_projection_capable_path</a>(subpath) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(oldtarget-&gt;exprs, target-&gt;exprs))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No separate Result node needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;dummypp = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set cost of plan as subpath's cost, adjusted for tlist replacement.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.rows = subpath-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.startup_cost = subpath-&gt;startup_cost +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (target-&gt;cost.startup - oldtarget-&gt;cost.startup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.total_cost = subpath-&gt;total_cost +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (target-&gt;cost.startup - oldtarget-&gt;cost.startup) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (target-&gt;cost.per_tuple - oldtarget-&gt;cost.per_tuple) * subpath-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We really do need the Result node */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;dummypp = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The Result node's cost is <a href="../path/costsize.c.html#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> per row, plus the cost of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * evaluating the tlist.&nbsp; There is no qual to worry about.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.rows = subpath-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.startup_cost = subpath-&gt;startup_cost +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target-&gt;cost.startup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.total_cost = subpath-&gt;total_cost +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target-&gt;cost.startup +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../path/costsize.c.html#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> + target-&gt;cost.per_tuple) * subpath-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2793" title="optimizer/util/pathnode.c:2793">apply_projection_to_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Add a projection step, or just apply the target directly to given path.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This has the same net effect as <a href="#L2685" title="optimizer/util/pathnode.c:2685">create_projection_path</a>(), except that if<br/></li>
<li></span><span class="Comment"> * a separate Result plan node isn't needed, we just replace the given path's<br/></li>
<li></span><span class="Comment"> * pathtarget with the desired one.&nbsp; This must be used only when the caller<br/></li>
<li></span><span class="Comment"> * knows that the given path isn't referenced elsewhere and so can be modified<br/></li>
<li></span><span class="Comment"> * in-place.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the input path is a GatherPath or GatherMergePath, we try to <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> the<br/></li>
<li></span><span class="Comment"> * new target down to its input as well; this is a yet more invasive<br/></li>
<li></span><span class="Comment"> * modification of the input path, which <a href="#L2685" title="optimizer/util/pathnode.c:2685">create_projection_path</a>() can't do.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we mustn't change the source path's parent link; so when it is<br/></li>
<li></span><span class="Comment"> * <a href="#L420" title="optimizer/util/pathnode.c:420">add_path</a>'d to &quot;rel&quot; things will be a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> inconsistent.&nbsp; So far that has<br/></li>
<li></span><span class="Comment"> * not caused <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> trouble.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rel' is the parent relation associated with the result<br/></li>
<li></span><span class="Comment"> * 'path' is the path representing the source of data<br/></li>
<li></span><span class="Comment"> * 'target' is the PathTarget to be computed<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Path *<br/></li>
<li><a id="L2793">&#x200c;</a><span class="linkable">apply_projection_to_path</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Path *path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PathTarget *target)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; QualCost&nbsp; &nbsp; oldcost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If given path can't project, we might need a Result node, so make a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * separate ProjectionPath.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../plan/createplan.c.html#L7207" title="optimizer/plan/createplan.c:7207">is_projection_capable_path</a>(path))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Path *) <a href="#L2685" title="optimizer/util/pathnode.c:2685">create_projection_path</a>(root, rel, path, target);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can just jam the desired tlist into the existing path, being sure to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * update its cost estimates appropriately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcost = path-&gt;pathtarget-&gt;cost;<br/></li>
<li>&nbsp; &nbsp; path-&gt;pathtarget = target;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path-&gt;startup_cost += target-&gt;cost.startup - oldcost.startup;<br/></li>
<li>&nbsp; &nbsp; path-&gt;total_cost += target-&gt;cost.startup - oldcost.startup +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (target-&gt;cost.per_tuple - oldcost.per_tuple) * path-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the path happens to be a Gather or GatherMerge path, we'd like to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * arrange for the subpath to return the required target list so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * workers can <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> project.&nbsp; But if there is something that is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parallel-safe in the target expressions, then we can't.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((IsA(path, GatherPath) || IsA(path, GatherMergePath)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="clauses.c.html#L753" title="optimizer/util/clauses.c:753">is_parallel_safe</a>(root, (Node *) target-&gt;exprs))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We always use <a href="#L2685" title="optimizer/util/pathnode.c:2685">create_projection_path</a> here, even if the subpath is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * projection-capable, so as to avoid modifying the subpath in place.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It seems unlikely at present that there could be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * references to the subpath, but better safe than sorry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that we don't change the parallel path's cost estimates; it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might be appropriate to do so, to reflect the fact that the bulk of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the target evaluation will happen in workers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(path, GatherPath))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GatherPath *gpath = (GatherPath *) path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gpath-&gt;subpath = (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2685" title="optimizer/util/pathnode.c:2685">create_projection_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gpath-&gt;subpath-&gt;parent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gpath-&gt;subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; target);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GatherMergePath *gmpath = (GatherMergePath *) path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gmpath-&gt;subpath = (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2685" title="optimizer/util/pathnode.c:2685">create_projection_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gmpath-&gt;subpath-&gt;parent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gmpath-&gt;subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; target);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (path-&gt;parallel_safe &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="clauses.c.html#L753" title="optimizer/util/clauses.c:753">is_parallel_safe</a>(root, (Node *) target-&gt;exprs))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're inserting a parallel-restricted target list into a path<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * currently marked parallel-safe, so we have to mark it as no longer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * safe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;parallel_safe = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> path;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2882" title="optimizer/util/pathnode.c:2882">create_set_projection_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a pathnode that represents performing a projection that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; includes set-returning <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rel' is the parent relation associated with the result<br/></li>
<li></span><span class="Comment"> * 'subpath' is the path representing the source of data<br/></li>
<li></span><span class="Comment"> * 'target' is the PathTarget to be computed<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ProjectSetPath *<br/></li>
<li><a id="L2882">&#x200c;</a><span class="linkable">create_set_projection_path</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Path *subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PathTarget *target)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ProjectSetPath *pathnode = makeNode(ProjectSetPath);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; tlist_rows;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_ProjectSet;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = target;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, assume we are above <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> joins, so no parameterization */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.param_info = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;parallel_safe &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="clauses.c.html#L753" title="optimizer/util/clauses.c:753">is_parallel_safe</a>(root, (Node *) target-&gt;exprs);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = subpath-&gt;parallel_workers;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Projection does not change the sort order </span><span class="Todo">XXX</span><span class="Comment">? */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = subpath-&gt;pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;subpath = subpath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate number of rows produced by SRFs for each row of input; if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there's more than one in this node, use the maximum.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tlist_rows = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, target-&gt;exprs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *node = (Node *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; itemrows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itemrows = <a href="clauses.c.html#L289" title="optimizer/util/clauses.c:289">expression_returns_set_rows</a>(root, node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tlist_rows &lt; itemrows)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tlist_rows = itemrows;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In addition to the cost of evaluating the tlist, <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> <a href="../path/costsize.c.html#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * per input row, and half of <a href="../path/costsize.c.html#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> for each added output row.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is slightly bizarre maybe, but it's what 9.6 did; we may revisit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this estimate later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.rows = subpath-&gt;rows * tlist_rows;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.startup_cost = subpath-&gt;startup_cost +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; target-&gt;cost.startup;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.total_cost = subpath-&gt;total_cost +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; target-&gt;cost.startup +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="../path/costsize.c.html#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> + target-&gt;cost.per_tuple) * subpath-&gt;rows +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (pathnode-&gt;path.rows - subpath-&gt;rows) * <a href="../path/costsize.c.html#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> / <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2951" title="optimizer/util/pathnode.c:2951">create_incremental_sort_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a pathnode that represents performing an incremental sort.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rel' is the parent relation associated with the result<br/></li>
<li></span><span class="Comment"> * 'subpath' is the path representing the source of data<br/></li>
<li></span><span class="Comment"> * 'pathkeys' represents the desired sort order<br/></li>
<li></span><span class="Comment"> * 'presorted_keys' is the number of keys by which the input path is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; already sorted<br/></li>
<li></span><span class="Comment"> * 'limit_tuples' is the estimated bound on the number of output tuples,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; or -1 if no LIMIT or couldn't estimate<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IncrementalSortPath *<br/></li>
<li><a id="L2951">&#x200c;</a><span class="linkable">create_incremental_sort_path</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Path *subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> presorted_keys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> limit_tuples)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IncrementalSortPath *sort = makeNode(IncrementalSortPath);<br/></li>
<li>&nbsp; &nbsp; SortPath&nbsp;&nbsp; *pathnode = &amp;sort-&gt;spath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_IncrementalSort;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort doesn't project, so use source path's pathtarget */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = subpath-&gt;pathtarget;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, assume we are above <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> joins, so no parameterization */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.param_info = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;parallel_safe;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = subpath-&gt;parallel_workers;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;subpath = subpath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../path/costsize.c.html#L1986" title="optimizer/path/costsize.c:1986">cost_incremental_sort</a>(&amp;pathnode-&gt;path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root, pathkeys, presorted_keys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;startup_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;pathtarget-&gt;width,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0.0</span>,&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> comparison_cost shouldn't be 0? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>, limit_tuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sort-&gt;nPresortedCols = presorted_keys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> sort;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3000" title="optimizer/util/pathnode.c:3000">create_sort_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a pathnode that represents performing an explicit sort.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rel' is the parent relation associated with the result<br/></li>
<li></span><span class="Comment"> * 'subpath' is the path representing the source of data<br/></li>
<li></span><span class="Comment"> * 'pathkeys' represents the desired sort order<br/></li>
<li></span><span class="Comment"> * 'limit_tuples' is the estimated bound on the number of output tuples,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; or -1 if no LIMIT or couldn't estimate<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>SortPath *<br/></li>
<li><a id="L3000">&#x200c;</a><span class="linkable">create_sort_path</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Path *subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> limit_tuples)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SortPath&nbsp;&nbsp; *pathnode = makeNode(SortPath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_Sort;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort doesn't project, so use source path's pathtarget */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = subpath-&gt;pathtarget;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, assume we are above <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> joins, so no parameterization */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.param_info = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;parallel_safe;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = subpath-&gt;parallel_workers;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;subpath = subpath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../path/costsize.c.html#L2124" title="optimizer/path/costsize.c:2124">cost_sort</a>(&amp;pathnode-&gt;path, root, pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;pathtarget-&gt;width,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0.0</span>,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> comparison_cost shouldn't be 0? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>, limit_tuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3044" title="optimizer/util/pathnode.c:3044">create_group_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a pathnode that represents performing grouping of presorted input<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rel' is the parent relation associated with the result<br/></li>
<li></span><span class="Comment"> * 'subpath' is the path representing the source of data<br/></li>
<li></span><span class="Comment"> * 'target' is the PathTarget to be computed<br/></li>
<li></span><span class="Comment"> * 'groupClause' is a list of SortGroupClause's representing the grouping<br/></li>
<li></span><span class="Comment"> * 'qual' is the HAVING quals if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * 'numGroups' is the estimated number of groups<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>GroupPath *<br/></li>
<li><a id="L3044">&#x200c;</a><span class="linkable">create_group_path</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path *subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *groupClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> numGroups)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GroupPath&nbsp; *pathnode = makeNode(GroupPath);<br/></li>
<li>&nbsp; &nbsp; PathTarget *target = rel-&gt;reltarget;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_Group;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = target;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, assume we are above <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> joins, so no parameterization */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.param_info = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;parallel_safe;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = subpath-&gt;parallel_workers;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Group doesn't change sort ordering */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = subpath-&gt;pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;subpath = subpath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;groupClause = groupClause;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;qual = qual;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../path/costsize.c.html#L3163" title="optimizer/path/costsize.c:3163">cost_group</a>(&amp;pathnode-&gt;path, root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_length(groupClause),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numGroups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subpath-&gt;startup_cost, subpath-&gt;total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subpath-&gt;rows);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* add tlist eval cost for each output row */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.startup_cost += target-&gt;cost.startup;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.total_cost += target-&gt;cost.startup +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; target-&gt;cost.per_tuple * pathnode-&gt;path.rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3103" title="optimizer/util/pathnode.c:3103">create_upper_unique_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a pathnode that represents performing an explicit Unique step<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; on presorted input.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This produces a Unique plan node, but the use-case is so different from<br/></li>
<li></span><span class="Comment"> * <a href="#L1654" title="optimizer/util/pathnode.c:1654">create_unique_path</a> that it doesn't seem worth trying to <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> the two.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rel' is the parent relation associated with the result<br/></li>
<li></span><span class="Comment"> * 'subpath' is the path representing the source of data<br/></li>
<li></span><span class="Comment"> * 'numCols' is the number of grouping columns<br/></li>
<li></span><span class="Comment"> * 'numGroups' is the estimated number of groups<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The input path must be sorted on the grouping columns, plus possibly<br/></li>
<li></span><span class="Comment"> * additional columns; so the first numCols pathkeys are the grouping columns<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>UpperUniquePath *<br/></li>
<li><a id="L3103">&#x200c;</a><span class="linkable">create_upper_unique_path</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Path *subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> numCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> numGroups)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; UpperUniquePath *pathnode = makeNode(UpperUniquePath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_Unique;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Unique doesn't project, so use source path's pathtarget */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = subpath-&gt;pathtarget;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, assume we are above <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> joins, so no parameterization */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.param_info = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;parallel_safe;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = subpath-&gt;parallel_workers;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Unique doesn't change the input ordering */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = subpath-&gt;pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;subpath = subpath;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;numkeys = numCols;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Charge one <a href="../path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> per comparison per input tuple. We assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all columns get compared at most of the tuples.&nbsp; (</span><span class="Todo">XXX</span><span class="Comment"> probably this is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an overestimate.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.startup_cost = subpath-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.total_cost = subpath-&gt;total_cost +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> * subpath-&gt;rows * numCols;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.rows = numGroups;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3155" title="optimizer/util/pathnode.c:3155">create_agg_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a pathnode that represents performing aggregation/grouping<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rel' is the parent relation associated with the result<br/></li>
<li></span><span class="Comment"> * 'subpath' is the path representing the source of data<br/></li>
<li></span><span class="Comment"> * 'target' is the PathTarget to be computed<br/></li>
<li></span><span class="Comment"> * 'aggstrategy' is the Agg node's basic implementation strategy<br/></li>
<li></span><span class="Comment"> * 'aggsplit' is the Agg node's aggregate-splitting mode<br/></li>
<li></span><span class="Comment"> * 'groupClause' is a list of SortGroupClause's representing the grouping<br/></li>
<li></span><span class="Comment"> * 'qual' is the HAVING quals if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * 'aggcosts' contains cost info about the aggregate <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to be computed<br/></li>
<li></span><span class="Comment"> * 'numGroups' is the estimated number of groups (1 if not grouping)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>AggPath *<br/></li>
<li><a id="L3155">&#x200c;</a><span class="linkable">create_agg_path</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path *subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathTarget *target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStrategy aggstrategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggSplit aggsplit,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *groupClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> AggClauseCosts *aggcosts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> numGroups)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AggPath&nbsp; &nbsp; *pathnode = makeNode(AggPath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_Agg;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = target;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, assume we are above <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> joins, so no parameterization */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.param_info = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;parallel_safe;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = subpath-&gt;parallel_workers;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aggstrategy == AGG_SORTED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Attempt to preserve the order of the subpath.&nbsp; Additional pathkeys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * may have been added in <a href="../plan/planner.c.html#L3173" title="optimizer/plan/planner.c:3173">adjust_group_pathkeys_for_groupagg</a>() to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * support ORDER BY / DISTINCT aggregates.&nbsp; Pathkeys added there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * belong to columns within the aggregate function, so we must strip<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * these additional pathkeys off as those columns are unavailable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * above the aggregate node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(subpath-&gt;pathkeys) &gt; root-&gt;num_groupby_pathkeys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.pathkeys = <a href="../../nodes/list.c.html#L1593" title="nodes/list.c:1593">list_copy_head</a>(subpath-&gt;pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;num_groupby_pathkeys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.pathkeys = subpath-&gt;pathkeys;&nbsp; &nbsp; <span class="Comment">/* preserves order */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.pathkeys = NIL;&nbsp; &nbsp; <span class="Comment">/* output is unordered */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;subpath = subpath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;aggstrategy = aggstrategy;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;aggsplit = aggsplit;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;numGroups = numGroups;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;transitionSpace = aggcosts ? aggcosts-&gt;transitionSpace : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;groupClause = groupClause;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;qual = qual;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../path/costsize.c.html#L2650" title="optimizer/path/costsize.c:2650">cost_agg</a>(&amp;pathnode-&gt;path, root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggstrategy, aggcosts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_length(groupClause), numGroups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subpath-&gt;startup_cost, subpath-&gt;total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subpath-&gt;rows, subpath-&gt;pathtarget-&gt;width);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* add tlist eval cost for each output row */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.startup_cost += target-&gt;cost.startup;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.total_cost += target-&gt;cost.startup +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; target-&gt;cost.per_tuple * pathnode-&gt;path.rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3237" title="optimizer/util/pathnode.c:3237">create_groupingsets_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a pathnode that represents performing GROUPING SETS aggregation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * GroupingSetsPath represents sorted grouping with one or more grouping sets.<br/></li>
<li></span><span class="Comment"> * The input path's result must be sorted to match the last entry in<br/></li>
<li></span><span class="Comment"> * rollup_groupclauses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rel' is the parent relation associated with the result<br/></li>
<li></span><span class="Comment"> * 'subpath' is the path representing the source of data<br/></li>
<li></span><span class="Comment"> * 'target' is the PathTarget to be computed<br/></li>
<li></span><span class="Comment"> * 'having_qual' is the HAVING quals if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * 'rollups' is a list of RollupData nodes<br/></li>
<li></span><span class="Comment"> * 'agg_costs' contains cost info about the aggregate <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to be computed<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>GroupingSetsPath *<br/></li>
<li><a id="L3237">&#x200c;</a><span class="linkable">create_groupingsets_path</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Path *subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *having_qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AggStrategy aggstrategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *rollups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> AggClauseCosts *agg_costs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GroupingSetsPath *pathnode = makeNode(GroupingSetsPath);<br/></li>
<li>&nbsp; &nbsp; PathTarget *target = rel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_first = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_first_sort = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The topmost generated Plan node will be an Agg */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_Agg;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = target;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.param_info = subpath-&gt;param_info;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;parallel_safe;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = subpath-&gt;parallel_workers;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;subpath = subpath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Simplify callers by downgrading AGG_SORTED to AGG_PLAIN, and AGG_MIXED<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to AGG_HASHED, here if possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (aggstrategy == AGG_SORTED &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; list_length(rollups) == <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((RollupData *) linitial(rollups))-&gt;groupClause == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstrategy = AGG_PLAIN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aggstrategy == AGG_MIXED &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; list_length(rollups) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstrategy = AGG_HASHED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Output will be in sorted order by group_pathkeys if, and only if, there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is a single rollup operation on a non-empty list of grouping<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expressions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (aggstrategy == AGG_SORTED &amp;&amp; list_length(rollups) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.pathkeys = root-&gt;group_pathkeys;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.pathkeys = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;aggstrategy = aggstrategy;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;rollups = rollups;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;qual = having_qual;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;transitionSpace = agg_costs ? agg_costs-&gt;transitionSpace : <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(rollups != NIL);<br/></li>
<li>&nbsp; &nbsp; Assert(aggstrategy != AGG_PLAIN || list_length(rollups) == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(aggstrategy != AGG_MIXED || list_length(rollups) &gt; <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, rollups)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RollupData *rollup = lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *gsets = rollup-&gt;gsets;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numGroupCols = list_length(linitial(gsets));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In AGG_SORTED or AGG_PLAIN mode, the first rollup takes the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (already-sorted) input, and following ones do their own sort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In AGG_HASHED mode, there is one rollup for each grouping set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In AGG_MIXED mode, the first rollups are hashed, the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-hashed one takes the (already-sorted) input, and following ones<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do their own sort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_first)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L2650" title="optimizer/path/costsize.c:2650">cost_agg</a>(&amp;pathnode-&gt;path, root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggstrategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; agg_costs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numGroupCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rollup-&gt;numGroups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; having_qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subpath-&gt;startup_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subpath-&gt;total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subpath-&gt;rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subpath-&gt;pathtarget-&gt;width);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_first = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rollup-&gt;is_hashed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_first_sort = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp; &nbsp; sort_path;&nbsp; &nbsp; <span class="Comment">/* dummy for result of <a href="../path/costsize.c.html#L2124" title="optimizer/path/costsize.c:2124">cost_sort</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp; &nbsp; agg_path;&nbsp; &nbsp; <span class="Comment">/* dummy for result of <a href="../path/costsize.c.html#L2650" title="optimizer/path/costsize.c:2650">cost_agg</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rollup-&gt;is_hashed || is_first_sort)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Account for cost of aggregation, but don't <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> input<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cost again<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L2650" title="optimizer/path/costsize.c:2650">cost_agg</a>(&amp;agg_path, root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rollup-&gt;is_hashed ? AGG_HASHED : AGG_SORTED,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; agg_costs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numGroupCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rollup-&gt;numGroups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; having_qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0.0</span>, <span class="Constant">0.0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subpath-&gt;rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subpath-&gt;pathtarget-&gt;width);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rollup-&gt;is_hashed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_first_sort = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Account for cost of sort, but don't <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> input cost again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L2124" title="optimizer/path/costsize.c:2124">cost_sort</a>(&amp;sort_path, root, NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0.0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;pathtarget-&gt;width,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0.0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1.0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Account for cost of aggregation */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L2650" title="optimizer/path/costsize.c:2650">cost_agg</a>(&amp;agg_path, root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AGG_SORTED,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; agg_costs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numGroupCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rollup-&gt;numGroups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; having_qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sort_path.startup_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sort_path.total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sort_path.rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subpath-&gt;pathtarget-&gt;width);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.total_cost += agg_path.total_cost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.rows += agg_path.rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* add tlist eval cost for each output row */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.startup_cost += target-&gt;cost.startup;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.total_cost += target-&gt;cost.startup +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; target-&gt;cost.per_tuple * pathnode-&gt;path.rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3397" title="optimizer/util/pathnode.c:3397">create_minmaxagg_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a pathnode that represents computation of MIN/MAX aggregates<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rel' is the parent relation associated with the result<br/></li>
<li></span><span class="Comment"> * 'target' is the PathTarget to be computed<br/></li>
<li></span><span class="Comment"> * 'mmaggregates' is a list of MinMaxAggInfo structs<br/></li>
<li></span><span class="Comment"> * 'quals' is the HAVING quals if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MinMaxAggPath *<br/></li>
<li><a id="L3397">&#x200c;</a><span class="linkable">create_minmaxagg_path</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathTarget *target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *mmaggregates,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *quals)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MinMaxAggPath *pathnode = makeNode(MinMaxAggPath);<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; initplan_cost;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The topmost generated Plan node will be a Result */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_Result;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = target;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, assume we are above <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> joins, so no parameterization */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.param_info = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* might change below */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Result is one unordered row */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.rows = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;mmaggregates = mmaggregates;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;quals = quals;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Calculate cost of all the initplans, and check parallel safety */<br/></li>
<li></span>&nbsp; &nbsp; initplan_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, mmaggregates)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MinMaxAggInfo *mminfo = (MinMaxAggInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initplan_cost += mminfo-&gt;pathcost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!mminfo-&gt;path-&gt;parallel_safe)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.parallel_safe = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* add tlist eval cost for each output row, plus <a href="../path/costsize.c.html#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.startup_cost = initplan_cost + target-&gt;cost.startup;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.total_cost = initplan_cost + target-&gt;cost.startup +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; target-&gt;cost.per_tuple + <a href="../path/costsize.c.html#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add cost of qual, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> --- but we ignore its selectivity, since our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rowcount estimate should be 1 no matter what the qual is.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (quals)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; QualCost&nbsp; &nbsp; qual_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L4640" title="optimizer/path/costsize.c:4640">cost_qual_eval</a>(&amp;qual_cost, quals, root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.startup_cost += qual_cost.startup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.total_cost += qual_cost.startup + qual_cost.per_tuple;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the initplans were all parallel-safe, also check safety of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * target and quals.&nbsp; (The Result node itself isn't parallelizable, but if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we are in a subquery then it can be useful for the outer query to know<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that this one is parallel-safe.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pathnode-&gt;path.parallel_safe)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.parallel_safe =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="clauses.c.html#L753" title="optimizer/util/clauses.c:753">is_parallel_safe</a>(root, (Node *) target-&gt;exprs) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="clauses.c.html#L753" title="optimizer/util/clauses.c:753">is_parallel_safe</a>(root, (Node *) quals);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3484" title="optimizer/util/pathnode.c:3484">create_windowagg_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a pathnode that represents computation of window <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rel' is the parent relation associated with the result<br/></li>
<li></span><span class="Comment"> * 'subpath' is the path representing the source of data<br/></li>
<li></span><span class="Comment"> * 'target' is the PathTarget to be computed<br/></li>
<li></span><span class="Comment"> * 'windowFuncs' is a list of WindowFunc structs<br/></li>
<li></span><span class="Comment"> * 'winclause' is a WindowClause that is common to all the WindowFuncs<br/></li>
<li></span><span class="Comment"> * 'qual' WindowClause.runconditions from <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-level WindowAggPaths.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Must always be NIL when topwindow == false<br/></li>
<li></span><span class="Comment"> * 'topwindow' pass as true only for the top-level WindowAgg. False for all<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; intermediate WindowAggs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The input must be sorted according to the WindowClause's PARTITION keys<br/></li>
<li></span><span class="Comment"> * plus ORDER BY keys.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>WindowAggPath *<br/></li>
<li><a id="L3484">&#x200c;</a><span class="linkable">create_windowagg_path</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path *subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PathTarget *target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *windowFuncs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WindowClause *winclause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> topwindow)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WindowAggPath *pathnode = makeNode(WindowAggPath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* qual can only be set for the topwindow */<br/></li>
<li></span>&nbsp; &nbsp; Assert(qual == NIL || topwindow);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_WindowAgg;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = target;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, assume we are above <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> joins, so no parameterization */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.param_info = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;parallel_safe;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = subpath-&gt;parallel_workers;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* WindowAgg preserves the input sort order */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = subpath-&gt;pathkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;subpath = subpath;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;winclause = winclause;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;qual = qual;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;topwindow = topwindow;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For costing purposes, assume that there are no redundant partitioning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or ordering columns; it's not worth the trouble to deal with that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * corner case here.&nbsp; So we just pass the unmodified list lengths to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../path/costsize.c.html#L3068" title="optimizer/path/costsize.c:3068">cost_windowagg</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../path/costsize.c.html#L3068" title="optimizer/path/costsize.c:3068">cost_windowagg</a>(&amp;pathnode-&gt;path, root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; windowFuncs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winclause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subpath-&gt;startup_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subpath-&gt;total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subpath-&gt;rows);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* add tlist eval cost for each output row */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.startup_cost += target-&gt;cost.startup;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.total_cost += target-&gt;cost.startup +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; target-&gt;cost.per_tuple * pathnode-&gt;path.rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3552" title="optimizer/util/pathnode.c:3552">create_setop_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a pathnode that represents computation of INTERSECT or EXCEPT<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rel' is the parent relation associated with the result<br/></li>
<li></span><span class="Comment"> * 'subpath' is the path representing the source of data<br/></li>
<li></span><span class="Comment"> * 'cmd' is the specific semantics (INTERSECT or EXCEPT, with/without ALL)<br/></li>
<li></span><span class="Comment"> * 'strategy' is the implementation strategy (sorted or hashed)<br/></li>
<li></span><span class="Comment"> * 'distinctList' is a list of SortGroupClause's representing the grouping<br/></li>
<li></span><span class="Comment"> * 'flagColIdx' is the column number where the flag column will be, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * 'firstFlag' is the flag value for the first input relation when hashing;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; or -1 when sorting<br/></li>
<li></span><span class="Comment"> * 'numGroups' is the estimated number of distinct groups<br/></li>
<li></span><span class="Comment"> * 'outputRows' is the estimated number of output rows<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>SetOpPath *<br/></li>
<li><a id="L3552">&#x200c;</a><span class="linkable">create_setop_path</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path *subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SetOpCmd cmd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SetOpStrategy strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *distinctList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber flagColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> firstFlag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> numGroups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> outputRows)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SetOpPath&nbsp; *pathnode = makeNode(SetOpPath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_SetOp;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* SetOp doesn't project, so use source path's pathtarget */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = subpath-&gt;pathtarget;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, assume we are above <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> joins, so no parameterization */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.param_info = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;parallel_safe;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = subpath-&gt;parallel_workers;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* SetOp preserves the input sort order if in sort mode */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.pathkeys =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (strategy == SETOP_SORTED) ? subpath-&gt;pathkeys : NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;subpath = subpath;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;cmd = cmd;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;strategy = strategy;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;distinctList = distinctList;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;flagColIdx = flagColIdx;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;firstFlag = firstFlag;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;numGroups = numGroups;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Charge one <a href="../path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> per comparison per input tuple. We assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all columns get compared at most of the tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.startup_cost = subpath-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.total_cost = subpath-&gt;total_cost +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> * subpath-&gt;rows * list_length(distinctList);<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.rows = outputRows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3614" title="optimizer/util/pathnode.c:3614">create_recursiveunion_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a pathnode that represents a recursive UNION node<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rel' is the parent relation associated with the result<br/></li>
<li></span><span class="Comment"> * 'leftpath' is the source of data for the non-recursive term<br/></li>
<li></span><span class="Comment"> * 'rightpath' is the source of data for the recursive term<br/></li>
<li></span><span class="Comment"> * 'target' is the PathTarget to be computed<br/></li>
<li></span><span class="Comment"> * 'distinctList' is a list of SortGroupClause's representing the grouping<br/></li>
<li></span><span class="Comment"> * 'wtParam' is the ID of Param representing work table<br/></li>
<li></span><span class="Comment"> * 'numGroups' is the estimated number of groups<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For recursive UNION ALL, distinctList is empty and numGroups is zero<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RecursiveUnionPath *<br/></li>
<li><a id="L3614">&#x200c;</a><span class="linkable">create_recursiveunion_path</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Path *leftpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Path *rightpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PathTarget *target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *distinctList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> wtParam,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> numGroups)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RecursiveUnionPath *pathnode = makeNode(RecursiveUnionPath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_RecursiveUnion;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = target;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, assume we are above <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> joins, so no parameterization */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.param_info = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; leftpath-&gt;parallel_safe &amp;&amp; rightpath-&gt;parallel_safe;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Foolish, but we'll do it like joins for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>: */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = leftpath-&gt;parallel_workers;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* RecursiveUnion result is always unsorted */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;leftpath = leftpath;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;rightpath = rightpath;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;distinctList = distinctList;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;wtParam = wtParam;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;numGroups = numGroups;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../path/costsize.c.html#L1813" title="optimizer/path/costsize.c:1813">cost_recursive_union</a>(&amp;pathnode-&gt;path, leftpath, rightpath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3659" title="optimizer/util/pathnode.c:3659">create_lockrows_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a pathnode that represents acquiring row locks<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rel' is the parent relation associated with the result<br/></li>
<li></span><span class="Comment"> * 'subpath' is the path representing the source of data<br/></li>
<li></span><span class="Comment"> * 'rowMarks' is a list of PlanRowMark's<br/></li>
<li></span><span class="Comment"> * 'epqParam' is the ID of Param for <a href="../../executor/execMain.c.html#L2470" title="executor/execMain.c:2470">EvalPlanQual</a> re-eval<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>LockRowsPath *<br/></li>
<li><a id="L3659">&#x200c;</a><span class="linkable">create_lockrows_path</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Path *subpath, List *rowMarks, <span class="Type">int</span> epqParam)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LockRowsPath *pathnode = makeNode(LockRowsPath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_LockRows;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* LockRows doesn't project, so use source path's pathtarget */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = subpath-&gt;pathtarget;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, assume we are above <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> joins, so no parameterization */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.param_info = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.rows = subpath-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The result cannot be assumed sorted, since locking might cause the sort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * key columns to be replaced with new <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;subpath = subpath;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;rowMarks = rowMarks;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;epqParam = epqParam;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We should <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> something extra for the costs of row locking and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possible refetches, but it's hard to say how much.&nbsp; For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../path/costsize.c.html#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> per row.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.startup_cost = subpath-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.total_cost = subpath-&gt;total_cost +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L121" title="optimizer/path/costsize.c:121">cpu_tuple_cost</a> * subpath-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3722" title="optimizer/util/pathnode.c:3722">create_modifytable_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a pathnode that represents performing INSERT/UPDATE/DELETE/MERGE<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; mods<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rel' is the parent relation associated with the result<br/></li>
<li></span><span class="Comment"> * 'subpath' is a Path producing source data<br/></li>
<li></span><span class="Comment"> * 'operation' is the operation type<br/></li>
<li></span><span class="Comment"> * 'canSetTag' is true if we set the command tag/es_processed<br/></li>
<li></span><span class="Comment"> * 'nominalRelation' is the parent RT index for use of EXPLAIN<br/></li>
<li></span><span class="Comment"> * 'rootRelation' is the partitioned/inherited table root RTI, or 0 if <a href="predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a><br/></li>
<li></span><span class="Comment"> * 'partColsUpdated' is true if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> partitioning columns are being updated,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; either from the target relation or a descendent partitioned table.<br/></li>
<li></span><span class="Comment"> * 'resultRelations' is an integer list of actual RT indexes of target rel(s)<br/></li>
<li></span><span class="Comment"> * 'updateColnosLists' is a list of UPDATE target column number lists<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (one sublist per rel); or NIL if not an UPDATE<br/></li>
<li></span><span class="Comment"> * 'withCheckOptionLists' is a list of WCO lists (one per rel)<br/></li>
<li></span><span class="Comment"> * 'returningLists' is a list of RETURNING tlists (one per rel)<br/></li>
<li></span><span class="Comment"> * 'rowMarks' is a list of PlanRowMarks (non-locking only)<br/></li>
<li></span><span class="Comment"> * 'onconflict' is the ON CONFLICT clause, or NULL<br/></li>
<li></span><span class="Comment"> * 'epqParam' is the ID of Param for <a href="../../executor/execMain.c.html#L2470" title="executor/execMain.c:2470">EvalPlanQual</a> re-eval<br/></li>
<li></span><span class="Comment"> * 'mergeActionLists' is a list of lists of MERGE actions (one per rel)<br/></li>
<li></span><span class="Comment"> * 'mergeJoinConditions' is a list of join conditions for MERGE (one per rel)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ModifyTablePath *<br/></li>
<li><a id="L3722">&#x200c;</a><span class="linkable">create_modifytable_path</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path *subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CmdType operation, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> canSetTag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index nominalRelation, Index rootRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> partColsUpdated,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *resultRelations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *updateColnosLists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *withCheckOptionLists, List *returningLists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *rowMarks, OnConflictExpr *onconflict,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *mergeActionLists, List *mergeJoinConditions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> epqParam)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ModifyTablePath *pathnode = makeNode(ModifyTablePath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(operation == CMD_MERGE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (operation == CMD_UPDATE ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(resultRelations) == list_length(updateColnosLists) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updateColnosLists == NIL));<br/></li>
<li>&nbsp; &nbsp; Assert(withCheckOptionLists == NIL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_length(resultRelations) == list_length(withCheckOptionLists));<br/></li>
<li>&nbsp; &nbsp; Assert(returningLists == NIL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_length(resultRelations) == list_length(returningLists));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_ModifyTable;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pathtarget is not interesting, just make it minimally valid */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = rel-&gt;reltarget;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, assume we are above <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> joins, so no parameterization */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.param_info = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute cost &amp; rowcount as subpath cost &amp; rowcount (if RETURNING)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Currently, we don't <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> anything extra for the actual table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * modification work, nor for the WITH CHECK OPTIONS or RETURNING<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expressions if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.&nbsp; It would only be window dressing, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ModifyTable is always a top-level node and there is no way for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * costs to change <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> higher-level planning choices.&nbsp; But we might want<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to make it look better sometime.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.startup_cost = subpath-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.total_cost = subpath-&gt;total_cost;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (returningLists != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.rows = subpath-&gt;rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set width to match the subpath output.&nbsp; </span><span class="Todo">XXX</span><span class="Comment"> this is totally wrong:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we should return an average of the RETURNING tlist widths.&nbsp; But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's what happened historically, and improving it is a task for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * another day.&nbsp; (Again, it's mostly window dressing.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.pathtarget-&gt;width = subpath-&gt;pathtarget-&gt;width;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.rows = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathnode-&gt;path.pathtarget-&gt;width = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;subpath = subpath;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;operation = operation;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;canSetTag = canSetTag;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;nominalRelation = nominalRelation;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;rootRelation = rootRelation;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;partColsUpdated = partColsUpdated;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;resultRelations = resultRelations;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;updateColnosLists = updateColnosLists;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;withCheckOptionLists = withCheckOptionLists;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;returningLists = returningLists;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;rowMarks = rowMarks;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;onconflict = onconflict;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;epqParam = epqParam;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;mergeActionLists = mergeActionLists;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;mergeJoinConditions = mergeJoinConditions;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3823" title="optimizer/util/pathnode.c:3823">create_limit_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates a pathnode that represents performing LIMIT/OFFSET<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In addition to providing the actual OFFSET and LIMIT expressions,<br/></li>
<li></span><span class="Comment"> * the caller must provide estimates of their <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for costing purposes.<br/></li>
<li></span><span class="Comment"> * The estimates are as computed by <a href="../plan/planner.c.html#L2443" title="optimizer/plan/planner.c:2443">preprocess_limit</a>(), ie, 0 represents<br/></li>
<li></span><span class="Comment"> * the clause not being present, and -1 means it's present but we could<br/></li>
<li></span><span class="Comment"> * not estimate its value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'rel' is the parent relation associated with the result<br/></li>
<li></span><span class="Comment"> * 'subpath' is the path representing the source of data<br/></li>
<li></span><span class="Comment"> * 'limitOffset' is the actual OFFSET expression, or NULL<br/></li>
<li></span><span class="Comment"> * 'limitCount' is the actual LIMIT expression, or NULL<br/></li>
<li></span><span class="Comment"> * 'offset_est' is the estimated value of the OFFSET expression<br/></li>
<li></span><span class="Comment"> * 'count_est' is the estimated value of the LIMIT expression<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>LimitPath *<br/></li>
<li><a id="L3823">&#x200c;</a><span class="linkable">create_limit_path</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path *subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *limitOffset, Node *limitCount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LimitOption limitOption,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64 offset_est, int64 count_est)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LimitPath&nbsp; *pathnode = makeNode(LimitPath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathtype = T_Limit;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parent = rel;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Limit doesn't project, so use source path's pathtarget */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.pathtarget = subpath-&gt;pathtarget;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, assume we are above <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> joins, so no parameterization */<br/></li>
<li></span>&nbsp; &nbsp; pathnode-&gt;path.param_info = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_aware = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_safe = rel-&gt;consider_parallel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subpath-&gt;parallel_safe;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.parallel_workers = subpath-&gt;parallel_workers;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.rows = subpath-&gt;rows;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.startup_cost = subpath-&gt;startup_cost;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.total_cost = subpath-&gt;total_cost;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;path.pathkeys = subpath-&gt;pathkeys;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;subpath = subpath;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;limitOffset = limitOffset;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;limitCount = limitCount;<br/></li>
<li>&nbsp; &nbsp; pathnode-&gt;limitOption = limitOption;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Adjust the output rows count and costs according to the offset/limit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3878" title="optimizer/util/pathnode.c:3878">adjust_limit_rows_costs</a>(&amp;pathnode-&gt;path.rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;pathnode-&gt;path.startup_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;pathnode-&gt;path.total_cost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset_est, count_est);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathnode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3878" title="optimizer/util/pathnode.c:3878">adjust_limit_rows_costs</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Adjust the size and cost estimates for a LimitPath node according to the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; offset/limit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is only a cosmetic issue if we are at top level, but if we are<br/></li>
<li></span><span class="Comment"> * building a subquery then it's important to report correct info to the outer<br/></li>
<li></span><span class="Comment"> * <a href="../plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When the offset or count couldn't be estimated, use 10% of the estimated<br/></li>
<li></span><span class="Comment"> * number of rows emitted from the subpath.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> we don't bother to add eval costs of the offset/limit expressions<br/></li>
<li></span><span class="Comment"> * themselves to the path costs.&nbsp; In theory we should, but in most cases those<br/></li>
<li></span><span class="Comment"> * expressions are trivial and it's just not worth the trouble.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3878">&#x200c;</a></span><span class="linkable">adjust_limit_rows_costs</span>(<span class="Type">double</span> *rows,&nbsp; &nbsp; <span class="Comment">/* in/out parameter */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cost *startup_cost, <span class="Comment">/* in/out parameter */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cost *total_cost,&nbsp; &nbsp; <span class="Comment">/* in/out parameter */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64 offset_est,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64 count_est)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; input_rows = *rows;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; input_startup_cost = *startup_cost;<br/></li>
<li>&nbsp; &nbsp; Cost&nbsp; &nbsp; &nbsp; &nbsp; input_total_cost = *total_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (offset_est != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; offset_rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offset_est &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset_rows = (<span class="Type">double</span>) offset_est;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset_rows = <a href="../path/costsize.c.html#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(input_rows * <span class="Constant">0.10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offset_rows &gt; *rows)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset_rows = *rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (input_rows &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *startup_cost +=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (input_total_cost - input_startup_cost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * offset_rows / input_rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *rows -= offset_rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*rows &lt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rows = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (count_est != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; count_rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count_est &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count_rows = (<span class="Type">double</span>) count_est;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count_rows = <a href="../path/costsize.c.html#L202" title="optimizer/path/costsize.c:202">clamp_row_est</a>(input_rows * <span class="Constant">0.10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count_rows &gt; *rows)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count_rows = *rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (input_rows &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *total_cost = *startup_cost +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (input_total_cost - input_startup_cost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * count_rows / input_rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *rows = count_rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*rows &lt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rows = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3946" title="optimizer/util/pathnode.c:3946">reparameterize_path</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Attempt to modify a Path to have greater parameterization<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use this to attempt to bring all child paths of an appendrel to the<br/></li>
<li></span><span class="Comment"> * same parameterization level, ensuring that they all enforce the same set<br/></li>
<li></span><span class="Comment"> * of join quals (and thus that that parameterization can be attributed to<br/></li>
<li></span><span class="Comment"> * an append path built from such paths).&nbsp; Currently, only a few path types<br/></li>
<li></span><span class="Comment"> * are supported here, though more could be added at need.&nbsp; We return NULL<br/></li>
<li></span><span class="Comment"> * if we can't reparameterize the given path.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we intentionally do not pass created paths to <a href="#L420" title="optimizer/util/pathnode.c:420">add_path</a>(); it would<br/></li>
<li></span><span class="Comment"> * possibly try to delete them on the grounds of being cost-inferior to the<br/></li>
<li></span><span class="Comment"> * paths they were made from, and we don't want that.&nbsp; Paths made here are<br/></li>
<li></span><span class="Comment"> * not necessarily of general-purpose usefulness, but they can be useful<br/></li>
<li></span><span class="Comment"> * as members of an append path.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Path *<br/></li>
<li><a id="L3946">&#x200c;</a><span class="linkable">reparameterize_path</span>(PlannerInfo *root, Path *path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids required_outer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> loop_count)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *rel = path-&gt;parent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can only increase, not decrease, path's parameterization */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L412" title="nodes/bitmapset.c:412">bms_is_subset</a>(PATH_REQ_OUTER(path), required_outer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (path-&gt;pathtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SeqScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L927" title="optimizer/util/pathnode.c:927">create_seqscan_path</a>(root, rel, required_outer, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SampleScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Path *) <a href="#L952" title="optimizer/util/pathnode.c:952">create_samplescan_path</a>(root, rel, required_outer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IndexScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IndexOnlyScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexPath&nbsp; *ipath = (IndexPath *) path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexPath&nbsp; *newpath = makeNode(IndexPath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can't use <a href="#L993" title="optimizer/util/pathnode.c:993">create_index_path</a> directly, and would not want<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to because it would re-compute the indexqual conditions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which is wasted effort.&nbsp; Instead we hack things a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * flat-copy the path node, revise its param_info, and redo<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the cost estimate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(newpath, ipath, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexPath));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newpath-&gt;path.param_info =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="relnode.c.html#L1557" title="optimizer/util/relnode.c:1557">get_baserel_parampathinfo</a>(root, rel, required_outer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/costsize.c.html#L549" title="optimizer/path/costsize.c:549">cost_index</a>(newpath, root, loop_count, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Path *) newpath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_BitmapHeapScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BitmapHeapPath *bpath = (BitmapHeapPath *) path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Path *) <a href="#L1042" title="optimizer/util/pathnode.c:1042">create_bitmap_heap_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bpath-&gt;bitmapqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loop_count, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SubqueryScan:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SubqueryScanPath *spath = (SubqueryScanPath *) path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *subpath = spath-&gt;subpath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; trivial_pathtarget;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If existing node has zero extra cost, we must have decided<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * its target is trivial.&nbsp; (The converse is not true, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it might have a trivial target but quals to enforce; but in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that case the new node will too, so it doesn't matter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whether we get the right answer here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trivial_pathtarget =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (subpath-&gt;total_cost == spath-&gt;path.total_cost);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Path *) <a href="#L2016" title="optimizer/util/pathnode.c:2016">create_subqueryscan_path</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; trivial_pathtarget,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; spath-&gt;path.pathkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; required_outer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Result:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Supported only for RTE_RESULT scan paths */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(path, Path))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2176" title="optimizer/util/pathnode.c:2176">create_resultscan_path</a>(root, rel, required_outer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Append:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AppendPath *apath = (AppendPath *) path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *childpaths = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *partialpaths = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reparameterize the children */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, apath-&gt;subpaths)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *spath = (Path *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spath = <a href="#L3946" title="optimizer/util/pathnode.c:3946">reparameterize_path</a>(root, spath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loop_count);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (spath == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We have to re-split the regular and partial paths */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; apath-&gt;first_partial_path)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childpaths = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(childpaths, spath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partialpaths = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(partialpaths, spath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Path *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1244" title="optimizer/util/pathnode.c:1244">create_append_path</a>(root, rel, childpaths, partialpaths,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; apath-&gt;path.pathkeys, required_outer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; apath-&gt;path.parallel_workers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; apath-&gt;path.parallel_aware,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Material:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MaterialPath *mpath = (MaterialPath *) path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *spath = mpath-&gt;subpath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spath = <a href="#L3946" title="optimizer/util/pathnode.c:3946">reparameterize_path</a>(root, spath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loop_count);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (spath == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Path *) <a href="#L1566" title="optimizer/util/pathnode.c:1566">create_material_path</a>(rel, spath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Memoize:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoizePath *mpath = (MemoizePath *) path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *spath = mpath-&gt;subpath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spath = <a href="#L3946" title="optimizer/util/pathnode.c:3946">reparameterize_path</a>(root, spath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_outer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loop_count);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (spath == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Path *) <a href="#L1598" title="optimizer/util/pathnode.c:1598">create_memoize_path</a>(root, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mpath-&gt;param_exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mpath-&gt;hash_operators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mpath-&gt;singlerow,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mpath-&gt;binary_mode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mpath-&gt;calls);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4112" title="optimizer/util/pathnode.c:4112">reparameterize_path_by_child</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Given a path parameterized by the parent of the given child relation,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> the path to be parameterized by the given child relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Most fields in the path are not changed, but <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> expressions must be<br/></li>
<li></span><span class="Comment"> * adjusted to refer to the correct varnos, and <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subpaths must be<br/></li>
<li></span><span class="Comment"> * recursively reparameterized.&nbsp; Other fields that refer to specific relids<br/></li>
<li></span><span class="Comment"> * also need adjustment.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The cost, number of rows, width and parallel path properties depend upon<br/></li>
<li></span><span class="Comment"> * path-&gt;parent, which does not change during the translation.&nbsp; So we need<br/></li>
<li></span><span class="Comment"> * not change those.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently, only a few path types are supported here, though more could be<br/></li>
<li></span><span class="Comment"> * added at need.&nbsp; We return NULL if we can't reparameterize the given path.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this function can change referenced RangeTblEntries, RelOptInfos<br/></li>
<li></span><span class="Comment"> * and IndexOptInfos as well as the Path structures.&nbsp; Therefore, it's only safe<br/></li>
<li></span><span class="Comment"> * to call during <a href="../plan/createplan.c.html#L337" title="optimizer/plan/createplan.c:337">create_plan</a>(), when we have made a final choice of which Path<br/></li>
<li></span><span class="Comment"> * to use for each RangeTblEntry/RelOptInfo/IndexOptInfo.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Keep this code in sync with <a href="#L4408" title="optimizer/util/pathnode.c:4408">path_is_reparameterizable_by_child</a>()!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Path *<br/></li>
<li><a id="L4112">&#x200c;</a><span class="linkable">reparameterize_path_by_child</span>(PlannerInfo *root, Path *path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *child_rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *new_path;<br/></li>
<li>&nbsp; &nbsp; ParamPathInfo *new_ppi;<br/></li>
<li>&nbsp; &nbsp; ParamPathInfo *old_ppi;<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; required_outer;<br/></li>
<li><br/></li>
<li><a id="L4120">&#x200c;</a><span class="PreProc">#define <span class="linkable">ADJUST_CHILD_ATTRS</span>(node) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((node) = (</span><span class="Type">void</span><span class="PreProc"> *) <a href="appendinfo.c.html#L521" title="optimizer/util/appendinfo.c:521">adjust_appendrel_attrs_multilevel</a>(root, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) (node), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; child_rel, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; child_rel-&gt;top_parent))<br/></li>
<li></span><br/></li>
<li><a id="L4126">&#x200c;</a><span class="PreProc">#define <span class="linkable">REPARAMETERIZE_CHILD_PATH</span>(path) \<br/></li>
<li></span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (path) = <a href="#L4112" title="optimizer/util/pathnode.c:4112">reparameterize_path_by_child</a>(root, (path), child_rel); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> ((path) == </span><span class="Constant">NULL</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="PreProc"> </span><span class="Constant">NULL</span><span class="PreProc">; \<br/></li>
<li></span><span class="PreProc">} </span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L4133">&#x200c;</a><span class="PreProc">#define <span class="linkable">REPARAMETERIZE_CHILD_PATH_LIST</span>(pathlist) \<br/></li>
<li></span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> ((pathlist) != NIL) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; (pathlist) = <a href="#L4539" title="optimizer/util/pathnode.c:4539">reparameterize_pathlist_by_child</a>(root, (pathlist), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_rel); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> ((pathlist) == NIL) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="PreProc"> </span><span class="Constant">NULL</span><span class="PreProc">; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } \<br/></li>
<li></span><span class="PreProc">} </span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the path is not parameterized by the parent of the given relation,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it doesn't need reparameterization.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!path-&gt;param_info ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(PATH_REQ_OUTER(path), child_rel-&gt;top_parent_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If possible, reparameterize the given path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This function is currently only applied to the inner side of a nestloop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * join that is being partitioned by the partitionwise-join code.&nbsp; Hence,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we need only support path types that plausibly arise in that context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (In particular, supporting sorted path types would be a waste of code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and cycles: even if we translated them here, they'd just lose in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subsequent cost comparisons.)&nbsp; If we do see an unsupported path type,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that just means we won't be able to generate a partitionwise-join plan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * using that path type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (nodeTag(path))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Path:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_path = path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4120" title="optimizer/util/pathnode.c:4120">ADJUST_CHILD_ATTRS</a>(new_path-&gt;parent-&gt;baserestrictinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path-&gt;pathtype == T_SampleScan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; scan_relid = path-&gt;parent-&gt;relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* it should be a base rel with a tablesample clause... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(scan_relid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte = planner_rt_fetch(scan_relid, root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_RELATION);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rte-&gt;tablesample != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4120" title="optimizer/util/pathnode.c:4120">ADJUST_CHILD_ATTRS</a>(rte-&gt;tablesample);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IndexPath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexPath&nbsp; *ipath = (IndexPath *) path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4120" title="optimizer/util/pathnode.c:4120">ADJUST_CHILD_ATTRS</a>(ipath-&gt;indexinfo-&gt;indrestrictinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4120" title="optimizer/util/pathnode.c:4120">ADJUST_CHILD_ATTRS</a>(ipath-&gt;indexclauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_path = (Path *) ipath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_BitmapHeapPath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BitmapHeapPath *bhpath = (BitmapHeapPath *) path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4120" title="optimizer/util/pathnode.c:4120">ADJUST_CHILD_ATTRS</a>(bhpath-&gt;path.parent-&gt;baserestrictinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4126" title="optimizer/util/pathnode.c:4126">REPARAMETERIZE_CHILD_PATH</a>(bhpath-&gt;bitmapqual);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_path = (Path *) bhpath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_BitmapAndPath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BitmapAndPath *bapath = (BitmapAndPath *) path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4133" title="optimizer/util/pathnode.c:4133">REPARAMETERIZE_CHILD_PATH_LIST</a>(bapath-&gt;bitmapquals);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_path = (Path *) bapath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_BitmapOrPath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BitmapOrPath *bopath = (BitmapOrPath *) path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4133" title="optimizer/util/pathnode.c:4133">REPARAMETERIZE_CHILD_PATH_LIST</a>(bopath-&gt;bitmapquals);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_path = (Path *) bopath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ForeignPath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForeignPath *fpath = (ForeignPath *) path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReparameterizeForeignPathByChild_function rfpc_func;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4120" title="optimizer/util/pathnode.c:4120">ADJUST_CHILD_ATTRS</a>(fpath-&gt;path.parent-&gt;baserestrictinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fpath-&gt;fdw_outerpath)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4126" title="optimizer/util/pathnode.c:4126">REPARAMETERIZE_CHILD_PATH</a>(fpath-&gt;fdw_outerpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fpath-&gt;fdw_restrictinfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4120" title="optimizer/util/pathnode.c:4120">ADJUST_CHILD_ATTRS</a>(fpath-&gt;fdw_restrictinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Hand over to FDW if needed. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rfpc_func =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path-&gt;parent-&gt;fdwroutine-&gt;ReparameterizeForeignPathByChild;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rfpc_func)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fpath-&gt;fdw_private = rfpc_func(root, fpath-&gt;fdw_private,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; child_rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_path = (Path *) fpath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_CustomPath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CustomPath *cpath = (CustomPath *) path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4120" title="optimizer/util/pathnode.c:4120">ADJUST_CHILD_ATTRS</a>(cpath-&gt;path.parent-&gt;baserestrictinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4133" title="optimizer/util/pathnode.c:4133">REPARAMETERIZE_CHILD_PATH_LIST</a>(cpath-&gt;custom_paths);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cpath-&gt;custom_restrictinfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4120" title="optimizer/util/pathnode.c:4120">ADJUST_CHILD_ATTRS</a>(cpath-&gt;custom_restrictinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cpath-&gt;methods &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cpath-&gt;methods-&gt;ReparameterizeCustomPathByChild)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cpath-&gt;custom_private =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cpath-&gt;methods-&gt;ReparameterizeCustomPathByChild(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cpath-&gt;custom_private,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_path = (Path *) cpath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_NestPath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NestPath&nbsp;&nbsp; *npath = (NestPath *) path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JoinPath&nbsp;&nbsp; *jpath = (JoinPath *) npath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4126" title="optimizer/util/pathnode.c:4126">REPARAMETERIZE_CHILD_PATH</a>(jpath-&gt;outerjoinpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4126" title="optimizer/util/pathnode.c:4126">REPARAMETERIZE_CHILD_PATH</a>(jpath-&gt;innerjoinpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4120" title="optimizer/util/pathnode.c:4120">ADJUST_CHILD_ATTRS</a>(jpath-&gt;joinrestrictinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_path = (Path *) npath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_MergePath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MergePath&nbsp; *mpath = (MergePath *) path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JoinPath&nbsp;&nbsp; *jpath = (JoinPath *) mpath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4126" title="optimizer/util/pathnode.c:4126">REPARAMETERIZE_CHILD_PATH</a>(jpath-&gt;outerjoinpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4126" title="optimizer/util/pathnode.c:4126">REPARAMETERIZE_CHILD_PATH</a>(jpath-&gt;innerjoinpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4120" title="optimizer/util/pathnode.c:4120">ADJUST_CHILD_ATTRS</a>(jpath-&gt;joinrestrictinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4120" title="optimizer/util/pathnode.c:4120">ADJUST_CHILD_ATTRS</a>(mpath-&gt;path_mergeclauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_path = (Path *) mpath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_HashPath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HashPath&nbsp;&nbsp; *hpath = (HashPath *) path;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JoinPath&nbsp;&nbsp; *jpath = (JoinPath *) hpath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4126" title="optimizer/util/pathnode.c:4126">REPARAMETERIZE_CHILD_PATH</a>(jpath-&gt;outerjoinpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4126" title="optimizer/util/pathnode.c:4126">REPARAMETERIZE_CHILD_PATH</a>(jpath-&gt;innerjoinpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4120" title="optimizer/util/pathnode.c:4120">ADJUST_CHILD_ATTRS</a>(jpath-&gt;joinrestrictinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4120" title="optimizer/util/pathnode.c:4120">ADJUST_CHILD_ATTRS</a>(hpath-&gt;path_hashclauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_path = (Path *) hpath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_AppendPath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AppendPath *apath = (AppendPath *) path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4133" title="optimizer/util/pathnode.c:4133">REPARAMETERIZE_CHILD_PATH_LIST</a>(apath-&gt;subpaths);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_path = (Path *) apath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_MaterialPath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MaterialPath *mpath = (MaterialPath *) path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4126" title="optimizer/util/pathnode.c:4126">REPARAMETERIZE_CHILD_PATH</a>(mpath-&gt;subpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_path = (Path *) mpath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_MemoizePath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoizePath *mpath = (MemoizePath *) path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4126" title="optimizer/util/pathnode.c:4126">REPARAMETERIZE_CHILD_PATH</a>(mpath-&gt;subpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4120" title="optimizer/util/pathnode.c:4120">ADJUST_CHILD_ATTRS</a>(mpath-&gt;param_exprs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_path = (Path *) mpath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_GatherPath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GatherPath *gpath = (GatherPath *) path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4126" title="optimizer/util/pathnode.c:4126">REPARAMETERIZE_CHILD_PATH</a>(gpath-&gt;subpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_path = (Path *) gpath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't know how to reparameterize this path. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Adjust the parameterization information, which refers to the topmost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent. The topmost parent can be multiple levels away from the given<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * child, hence use multi-level expression adjustment routines.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; old_ppi = new_path-&gt;param_info;<br/></li>
<li>&nbsp; &nbsp; required_outer =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="appendinfo.c.html#L588" title="optimizer/util/appendinfo.c:588">adjust_child_relids_multilevel</a>(root, old_ppi-&gt;ppi_req_outer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; child_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; child_rel-&gt;top_parent);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we already have a PPI for this parameterization, just return it */<br/></li>
<li></span>&nbsp; &nbsp; new_ppi = <a href="relnode.c.html#L1901" title="optimizer/util/relnode.c:1901">find_param_path_info</a>(new_path-&gt;parent, required_outer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If not, build a new one and link it to the list of PPIs. For the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reason as explained in <a href="../path/joinrels.c.html#L1381" title="optimizer/path/joinrels.c:1381">mark_dummy_rel</a>(), allocate new PPI in the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * context the given RelOptInfo is in.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (new_ppi == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel = path-&gt;parent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(<a href="../../utils/mmgr/mcxt.c.html#L707" title="utils/mmgr/mcxt.c:707">GetMemoryChunkContext</a>(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_ppi = makeNode(ParamPathInfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_ppi-&gt;ppi_req_outer = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(required_outer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_ppi-&gt;ppi_rows = old_ppi-&gt;ppi_rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_ppi-&gt;ppi_clauses = old_ppi-&gt;ppi_clauses;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4120" title="optimizer/util/pathnode.c:4120">ADJUST_CHILD_ATTRS</a>(new_ppi-&gt;ppi_clauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_ppi-&gt;ppi_serials = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(old_ppi-&gt;ppi_serials);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;ppilist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rel-&gt;ppilist, new_ppi);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(required_outer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; new_path-&gt;param_info = new_ppi;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Adjust the path target if the parent of the outer relation is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * referenced in the targetlist. This can happen when only the parent of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * outer relation is laterally referenced in this relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(path-&gt;parent-&gt;lateral_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_rel-&gt;top_parent_relids))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_path-&gt;pathtarget = <a href="tlist.c.html#L657" title="optimizer/util/tlist.c:657">copy_pathtarget</a>(new_path-&gt;pathtarget);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4120" title="optimizer/util/pathnode.c:4120">ADJUST_CHILD_ATTRS</a>(new_path-&gt;pathtarget-&gt;exprs);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> new_path;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4408" title="optimizer/util/pathnode.c:4408">path_is_reparameterizable_by_child</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Given a path parameterized by the parent of the given child relation,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; see if it can be translated to be parameterized by the child relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This must return true if and only if <a href="#L4112" title="optimizer/util/pathnode.c:4112">reparameterize_path_by_child</a>()<br/></li>
<li></span><span class="Comment"> * would succeed on this path.&nbsp; Currently it's sufficient to verify that<br/></li>
<li></span><span class="Comment"> * the path and all of its subpaths (if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) are of the types handled by<br/></li>
<li></span><span class="Comment"> * that function.&nbsp; However, subpaths that are not parameterized can be<br/></li>
<li></span><span class="Comment"> * disregarded since they won't require translation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4408">&#x200c;</a></span><span class="linkable">path_is_reparameterizable_by_child</span>(Path *path, RelOptInfo *child_rel)<br/></li>
<li>{<br/></li>
<li><a id="L4410">&#x200c;</a><span class="PreProc">#define <span class="linkable">REJECT_IF_PATH_NOT_REPARAMETERIZABLE</span>(path) \<br/></li>
<li></span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (!<a href="#L4408" title="optimizer/util/pathnode.c:4408">path_is_reparameterizable_by_child</a>(path, child_rel)) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="PreProc"> </span><span class="Constant">false</span><span class="PreProc">; \<br/></li>
<li></span><span class="PreProc">} </span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L4416">&#x200c;</a><span class="PreProc">#define <span class="linkable">REJECT_IF_PATH_LIST_NOT_REPARAMETERIZABLE</span>(pathlist) \<br/></li>
<li></span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (!<a href="#L4568" title="optimizer/util/pathnode.c:4568">pathlist_is_reparameterizable_by_child</a>(pathlist, child_rel)) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="PreProc"> </span><span class="Constant">false</span><span class="PreProc">; \<br/></li>
<li></span><span class="PreProc">} </span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the path is not parameterized by the parent of the given relation,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it doesn't need reparameterization.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!path-&gt;param_info ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(PATH_REQ_OUTER(path), child_rel-&gt;top_parent_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that the path type is one that <a href="#L4112" title="optimizer/util/pathnode.c:4112">reparameterize_path_by_child</a>() can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handle, and recursively check subpaths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (nodeTag(path))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Path:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IndexPath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_BitmapHeapPath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BitmapHeapPath *bhpath = (BitmapHeapPath *) path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4410" title="optimizer/util/pathnode.c:4410">REJECT_IF_PATH_NOT_REPARAMETERIZABLE</a>(bhpath-&gt;bitmapqual);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_BitmapAndPath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BitmapAndPath *bapath = (BitmapAndPath *) path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4416" title="optimizer/util/pathnode.c:4416">REJECT_IF_PATH_LIST_NOT_REPARAMETERIZABLE</a>(bapath-&gt;bitmapquals);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_BitmapOrPath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BitmapOrPath *bopath = (BitmapOrPath *) path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4416" title="optimizer/util/pathnode.c:4416">REJECT_IF_PATH_LIST_NOT_REPARAMETERIZABLE</a>(bopath-&gt;bitmapquals);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ForeignPath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForeignPath *fpath = (ForeignPath *) path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fpath-&gt;fdw_outerpath)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4410" title="optimizer/util/pathnode.c:4410">REJECT_IF_PATH_NOT_REPARAMETERIZABLE</a>(fpath-&gt;fdw_outerpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_CustomPath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CustomPath *cpath = (CustomPath *) path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4416" title="optimizer/util/pathnode.c:4416">REJECT_IF_PATH_LIST_NOT_REPARAMETERIZABLE</a>(cpath-&gt;custom_paths);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_NestPath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_MergePath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_HashPath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JoinPath&nbsp;&nbsp; *jpath = (JoinPath *) path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4410" title="optimizer/util/pathnode.c:4410">REJECT_IF_PATH_NOT_REPARAMETERIZABLE</a>(jpath-&gt;outerjoinpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4410" title="optimizer/util/pathnode.c:4410">REJECT_IF_PATH_NOT_REPARAMETERIZABLE</a>(jpath-&gt;innerjoinpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_AppendPath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AppendPath *apath = (AppendPath *) path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4416" title="optimizer/util/pathnode.c:4416">REJECT_IF_PATH_LIST_NOT_REPARAMETERIZABLE</a>(apath-&gt;subpaths);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_MaterialPath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MaterialPath *mpath = (MaterialPath *) path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4410" title="optimizer/util/pathnode.c:4410">REJECT_IF_PATH_NOT_REPARAMETERIZABLE</a>(mpath-&gt;subpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_MemoizePath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoizePath *mpath = (MemoizePath *) path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4410" title="optimizer/util/pathnode.c:4410">REJECT_IF_PATH_NOT_REPARAMETERIZABLE</a>(mpath-&gt;subpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_GatherPath:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GatherPath *gpath = (GatherPath *) path;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4410" title="optimizer/util/pathnode.c:4410">REJECT_IF_PATH_NOT_REPARAMETERIZABLE</a>(gpath-&gt;subpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't know how to reparameterize this path. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4539" title="optimizer/util/pathnode.c:4539">reparameterize_pathlist_by_child</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Helper function to reparameterize a list of paths by given child rel.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns NIL to indicate failure, so pathlist had better not be NIL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L4539">&#x200c;</a><span class="linkable">reparameterize_pathlist_by_child</span>(PlannerInfo *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *pathlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *child_rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, pathlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path = <a href="#L4112" title="optimizer/util/pathnode.c:4112">reparameterize_path_by_child</a>(root, lfirst(lc),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (path == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, path);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4568" title="optimizer/util/pathnode.c:4568">pathlist_is_reparameterizable_by_child</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Helper function to check if a list of paths can be reparameterized.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4568">&#x200c;</a></span><span class="linkable">pathlist_is_reparameterizable_by_child</span>(List *pathlist, RelOptInfo *child_rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, pathlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Path&nbsp; &nbsp; &nbsp;&nbsp; *path = (Path *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L4408" title="optimizer/util/pathnode.c:4408">path_is_reparameterizable_by_child</a>(path, child_rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
