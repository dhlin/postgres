<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>optimizer/util/appendinfo.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>optimizer/util/appendinfo.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L36">adjust_appendrel_attrs_context</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L884">add_row_identity_columns</a></li>
<li><a href="#L789">add_row_identity_var</a></li>
<li><a href="#L196">adjust_appendrel_attrs</a></li>
<li><a href="#L521">adjust_appendrel_attrs_multilevel</a></li>
<li><a href="#L215">adjust_appendrel_attrs_mutator</a></li>
<li><a href="#L554">adjust_child_relids</a></li>
<li><a href="#L588">adjust_child_relids_multilevel</a></li>
<li><a href="#L628">adjust_inherited_attnums</a></li>
<li><a href="#L662">adjust_inherited_attnums_multilevel</a></li>
<li><a href="#L965">distribute_row_identity_vars</a></li>
<li><a href="#L733">find_appinfos_by_relids</a></li>
<li><a href="#L690">get_translated_update_targetlist</a></li>
<li><a href="#L51">make_append_rel_info</a></li>
<li><a href="#L80">make_inh_translation_list</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * appendinfo.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Routines for mapping between append parent(s) and children<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/optimizer/util/appendinfo.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;foreign/fdwapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/appendinfo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/pathnode.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/planmain.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parsetree.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *root;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nappinfos;<br/></li>
<li>&nbsp; &nbsp; AppendRelInfo **appinfos;<br/></li>
<li><a id="L36">&#x200c;</a>} <span class="linkable">adjust_appendrel_attrs_context</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L80" title="optimizer/util/appendinfo.c:80">make_inh_translation_list</a>(Relation oldrelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation newrelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index newvarno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AppendRelInfo *appinfo);<br/></li>
<li><span class="Type">static</span> Node *<a href="#L215" title="optimizer/util/appendinfo.c:215">adjust_appendrel_attrs_mutator</a>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L36" title="optimizer/util/appendinfo.c:36">adjust_appendrel_attrs_context</a> *context);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L51" title="optimizer/util/appendinfo.c:51">make_append_rel_info</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Build an AppendRelInfo for the parent-child pair<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>AppendRelInfo *<br/></li>
<li><a id="L51">&#x200c;</a><span class="linkable">make_append_rel_info</span>(Relation parentrel, Relation childrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index parentRTindex, Index childRTindex)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AppendRelInfo *appinfo = makeNode(AppendRelInfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appinfo-&gt;parent_relid = parentRTindex;<br/></li>
<li>&nbsp; &nbsp; appinfo-&gt;child_relid = childRTindex;<br/></li>
<li>&nbsp; &nbsp; appinfo-&gt;parent_reltype = parentrel-&gt;rd_rel-&gt;reltype;<br/></li>
<li>&nbsp; &nbsp; appinfo-&gt;child_reltype = childrel-&gt;rd_rel-&gt;reltype;<br/></li>
<li>&nbsp; &nbsp; <a href="#L80" title="optimizer/util/appendinfo.c:80">make_inh_translation_list</a>(parentrel, childrel, childRTindex, appinfo);<br/></li>
<li>&nbsp; &nbsp; appinfo-&gt;parent_reloid = RelationGetRelid(parentrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> appinfo;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L80" title="optimizer/util/appendinfo.c:80">make_inh_translation_list</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Build the list of translations from parent Vars to child Vars for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; an inheritance child, as well as a reverse-translation array.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The reverse-translation array has an entry for each child relation<br/></li>
<li></span><span class="Comment"> * column, which is either the 1-based index of the corresponding parent<br/></li>
<li></span><span class="Comment"> * column, or 0 if there's no match (that happens for dropped child columns,<br/></li>
<li></span><span class="Comment"> * as well as child columns beyond those of the parent, which are allowed in<br/></li>
<li></span><span class="Comment"> * traditional inheritance though not partitioning).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For paranoia's sake, we match type/collation as well as attribute name.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L80">&#x200c;</a></span><span class="linkable">make_inh_translation_list</span>(Relation oldrelation, Relation newrelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index newvarno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AppendRelInfo *appinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> = NIL;<br/></li>
<li>&nbsp; &nbsp; AttrNumber *pcolnos;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; old_tupdesc = RelationGetDescr(oldrelation);<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; new_tupdesc = RelationGetDescr(newrelation);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_relid = RelationGetRelid(newrelation);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldnatts = old_tupdesc-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newnatts = new_tupdesc-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_attno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_attno = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize reverse-translation array with all entries zero */<br/></li>
<li></span>&nbsp; &nbsp; appinfo-&gt;num_child_cols = newnatts;<br/></li>
<li>&nbsp; &nbsp; appinfo-&gt;parent_colnos = pcolnos =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (AttrNumber *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(newnatts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (old_attno = <span class="Constant">0</span>; old_attno &lt; oldnatts; old_attno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *attname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atttypid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; atttypmod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attcollation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att = TupleDescAttr(old_tupdesc, old_attno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Just put NULL into this list entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attname = NameStr(att-&gt;attname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; atttypid = att-&gt;atttypid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; atttypmod = att-&gt;atttypmod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attcollation = att-&gt;attcollation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When we are generating the &quot;translation list&quot; for the parent table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of an inheritance set, no need to search for matches.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldrelation == newrelation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>, <a href="../../nodes/makefuncs.c.html#L66" title="nodes/makefuncs.c:66">makeVar</a>(newvarno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (AttrNumber) (old_attno + <span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; atttypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attcollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcolnos[old_attno] = old_attno + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise we have to search for the matching column by name.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There's no guarantee it'll have the same column position, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of cases like ALTER TABLE ADD COLUMN and multiple inheritance.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, in simple cases, the relative order of columns is mostly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the same in both relations, so try the column of newrelation that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * follows immediately after the one that we just found, and if that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fails, let syscache handle it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (new_attno &gt;= newnatts ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (att = TupleDescAttr(new_tupdesc, new_attno))-&gt;attisdropped ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcmp(attname, NameStr(att-&gt;attname)) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; newtup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtup = <a href="../../utils/cache/syscache.c.html#L359" title="utils/cache/syscache.c:359">SearchSysCacheAttName</a>(new_relid, attname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(newtup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> inherited attribute </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attname, RelationGetRelationName(newrelation));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_attno = ((Form_pg_attribute) GETSTRUCT(newtup))-&gt;attnum - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(new_attno &gt;= <span class="Constant">0</span> &amp;&amp; new_attno &lt; newnatts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(newtup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att = TupleDescAttr(new_tupdesc, new_attno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found it, check type and collation match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (atttypid != att-&gt;atttypid || atttypmod != att-&gt;atttypmod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;attribute </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not match parent's type&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attname, RelationGetRelationName(newrelation));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attcollation != att-&gt;attcollation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;attribute </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not match parent's collation&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attname, RelationGetRelationName(newrelation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(<a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>, <a href="../../nodes/makefuncs.c.html#L66" title="nodes/makefuncs.c:66">makeVar</a>(newvarno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (AttrNumber) (new_attno + <span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; atttypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attcollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pcolnos[new_attno] = old_attno + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_attno++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appinfo-&gt;translated_vars = <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L196" title="optimizer/util/appendinfo.c:196">adjust_appendrel_attrs</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Copy the specified query or expression and <a href="../../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> Vars referring to a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; parent rel to refer to the corresponding child rel instead.&nbsp; We also<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; update rtindexes appearing outside Vars, such as resultRelation and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; jointree relids.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this is only applied after conversion of sublinks to subplans,<br/></li>
<li></span><span class="Comment"> * so we don't need to cope with recursion into sub-queries.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this is not hugely different from what <a href="../prep/prepjointree.c.html#L2354" title="optimizer/prep/prepjointree.c:2354">pullup_replace_vars</a>() does;<br/></li>
<li></span><span class="Comment"> * maybe we should try to fold the two routines together.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Node *<br/></li>
<li><a id="L196">&#x200c;</a><span class="linkable">adjust_appendrel_attrs</span>(PlannerInfo *root, Node *node, <span class="Type">int</span> nappinfos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AppendRelInfo **appinfos)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L36" title="optimizer/util/appendinfo.c:36">adjust_appendrel_attrs_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.root = root;<br/></li>
<li>&nbsp; &nbsp; context.nappinfos = nappinfos;<br/></li>
<li>&nbsp; &nbsp; context.appinfos = appinfos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there's nothing to adjust, don't call this function. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(nappinfos &gt;= <span class="Constant">1</span> &amp;&amp; appinfos != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should never be translating a Query tree. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(node == <span class="Constant">NULL</span> || !IsA(node, Query));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L215" title="optimizer/util/appendinfo.c:215">adjust_appendrel_attrs_mutator</a>(node, &amp;context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Node *<br/></li>
<li><a id="L215">&#x200c;</a><span class="linkable">adjust_appendrel_attrs_mutator</span>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L36" title="optimizer/util/appendinfo.c:36">adjust_appendrel_attrs_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AppendRelInfo **appinfos = context-&gt;appinfos;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nappinfos = context-&gt;nappinfos;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) copyObject(node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AppendRelInfo *appinfo = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varlevelsup != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) var;&nbsp; &nbsp; <span class="Comment">/* no changes needed */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * You might think we need to adjust var-&gt;varnullingrels, but that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shouldn't need <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> changes.&nbsp; It will contain outer-join relids,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * while the transformation we are making affects only baserels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Below, we just propagate var-&gt;varnullingrels into the translated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Var.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If var-&gt;varnullingrels isn't empty, and the translation wouldn't be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a Var, we have to fail.&nbsp; One could imagine wrapping the translated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expression in a PlaceHolderVar, but that won't work because this is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * typically used after freezing placeholders.&nbsp; Fortunately, the case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * appears unreachable at the moment.&nbsp; We can see nonempty<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * var-&gt;varnullingrels here, but only in cases involving partitionwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * joining, and in such cases the translations will always be Vars.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (Non-Var translations occur only for appendrels made by flattening<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * UNION ALL subqueries.)&nbsp; Should we need to make this work in future,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a possible fix is to mandate that prepjointree.c create PHVs for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all non-Var outputs of such subqueries, and then we could look up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the pre-existing PHV here.&nbsp; Or perhaps just wrap the translations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that way to begin with?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (cnt = <span class="Constant">0</span>; cnt &lt; nappinfos; cnt++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varno == appinfos[cnt]-&gt;parent_relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appinfo = appinfos[cnt];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (appinfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varno = appinfo-&gt;child_relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* it's <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> a generated Var, so drop <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> syntactic labeling */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varnosyn = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varattnosyn = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varattno &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *newnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varattno &gt; list_length(appinfo-&gt;translated_vars))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;attribute </span><span class="Special">%d</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var-&gt;varattno, <a href="../../utils/cache/lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(appinfo-&gt;parent_reloid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newnode = copyObject(list_nth(appinfo-&gt;translated_vars,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varattno - <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newnode == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;attribute </span><span class="Special">%d</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var-&gt;varattno, <a href="../../utils/cache/lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(appinfo-&gt;parent_reloid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(newnode, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((Var *) newnode)-&gt;varnullingrels = var-&gt;varnullingrels;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (var-&gt;varnullingrels != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to apply nullingrels to a non-Var&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> newnode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (var-&gt;varattno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Whole-row Var: if we are dealing with named rowtypes, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can use a whole-row Var for the child table plus a coercion<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * step to convert the tuple layout to the parent's rowtype.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise we have to generate a RowExpr.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(appinfo-&gt;child_reltype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(var-&gt;vartype == appinfo-&gt;parent_reltype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (appinfo-&gt;parent_reltype != appinfo-&gt;child_reltype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ConvertRowtypeExpr *r = makeNode(ConvertRowtypeExpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r-&gt;arg = (Expr *) var;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r-&gt;resulttype = appinfo-&gt;parent_reltype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r-&gt;convertformat = COERCE_IMPLICIT_CAST;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure the Var node has the right type ID, too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;vartype = appinfo-&gt;child_reltype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) r;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Build a RowExpr containing the translated variables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In practice var-&gt;vartype will always be RECORDOID here,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so we need to come up with some suitable column names.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We use the parent RTE's column names.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: we can't get here for inheritance cases, so there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is no need to worry that translated_vars might contain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * some dummy NULLs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RowExpr&nbsp; &nbsp; *rowexpr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *fields;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte = rt_fetch(appinfo-&gt;parent_relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context-&gt;root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rtable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fields = copyObject(appinfo-&gt;translated_vars);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowexpr = makeNode(RowExpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowexpr-&gt;args = fields;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowexpr-&gt;row_typeid = var-&gt;vartype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowexpr-&gt;row_format = COERCE_IMPLICIT_CAST;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowexpr-&gt;colnames = copyObject(rte-&gt;eref-&gt;colnames);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowexpr-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varnullingrels != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to apply nullingrels to a non-Var&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) rowexpr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* system attributes don't need <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other translation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (var-&gt;varno == ROWID_VAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's a ROWID_VAR placeholder, see if we've reached a leaf<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * target rel, for which we can <a href="../../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> the Var to a specific<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * instantiation.&nbsp; We should never be asked to <a href="../../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> to a set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of relids containing more than one leaf target rel, so the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * answer will be unique.&nbsp; If we're still considering non-leaf<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inheritance levels, return the ROWID_VAR Var as-is.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; leaf_result_relids = context-&gt;root-&gt;leaf_result_relids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; leaf_relid = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (cnt = <span class="Constant">0</span>; cnt &lt; nappinfos; cnt++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(appinfos[cnt]-&gt;child_relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leaf_result_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (leaf_relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot <a href="../../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> to multiple leaf relids&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leaf_relid = appinfos[cnt]-&gt;child_relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (leaf_relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RowIdentityVarInfo *ridinfo = (RowIdentityVarInfo *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_nth(context-&gt;root-&gt;row_identity_vars, var-&gt;varattno - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(leaf_relid, ridinfo-&gt;rowidrels))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Substitute the Var given in the RowIdentityVarInfo */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var = copyObject(ridinfo-&gt;rowidvar);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... but use the correct relid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varno = leaf_relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* identity <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> shouldn't have nulling rels */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(var-&gt;varnullingrels == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* varnosyn in the RowIdentityVarInfo is probably wrong */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varnosyn = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varattnosyn = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This leaf rel can't return the desired value, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * substitute a NULL of the correct type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) <a href="../../nodes/makefuncs.c.html#L339" title="nodes/makefuncs.c:339">makeNullConst</a>(var-&gt;vartype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;vartypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varcollid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) var;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, CurrentOfExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CurrentOfExpr *cexpr = (CurrentOfExpr *) copyObject(node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (cnt = <span class="Constant">0</span>; cnt &lt; nappinfos; cnt++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AppendRelInfo *appinfo = appinfos[cnt];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cexpr-&gt;cvarno == appinfo-&gt;parent_relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cexpr-&gt;cvarno = appinfo-&gt;child_relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) cexpr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy the PlaceHolderVar node with correct mutation of subnodes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *phv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; phv = (PlaceHolderVar *) expression_tree_mutator(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L215" title="optimizer/util/appendinfo.c:215">adjust_appendrel_attrs_mutator</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> fix PlaceHolderVar's relid sets */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (phv-&gt;phlevelsup == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phv-&gt;phrels = <a href="#L554" title="optimizer/util/appendinfo.c:554">adjust_child_relids</a>(phv-&gt;phrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nappinfos, appinfos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* as above, we needn't touch phnullingrels */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) phv;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shouldn't need to handle <a href="../plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> auxiliary nodes here */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!IsA(node, SpecialJoinInfo));<br/></li>
<li>&nbsp; &nbsp; Assert(!IsA(node, AppendRelInfo));<br/></li>
<li>&nbsp; &nbsp; Assert(!IsA(node, PlaceHolderInfo));<br/></li>
<li>&nbsp; &nbsp; Assert(!IsA(node, MinMaxAggInfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have to process RestrictInfo nodes specially.&nbsp; (Note: although<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../path/allpaths.c.html#L1232" title="optimizer/path/allpaths.c:1232">set_append_rel_pathlist</a> will hide RestrictInfos in the parent's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * baserestrictinfo list from us, it doesn't hide those in joininfo.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, RestrictInfo))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *oldinfo = (RestrictInfo *) node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *newinfo = makeNode(RestrictInfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy all flat-copiable fields, notably including rinfo_serial */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(newinfo, oldinfo, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RestrictInfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recursively fix the clause itself */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newinfo-&gt;clause = (Expr *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L215" title="optimizer/util/appendinfo.c:215">adjust_appendrel_attrs_mutator</a>((Node *) oldinfo-&gt;clause, context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and the modified version, if an OR clause */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newinfo-&gt;orclause = (Expr *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L215" title="optimizer/util/appendinfo.c:215">adjust_appendrel_attrs_mutator</a>((Node *) oldinfo-&gt;orclause, context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* adjust relid sets too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newinfo-&gt;clause_relids = <a href="#L554" title="optimizer/util/appendinfo.c:554">adjust_child_relids</a>(oldinfo-&gt;clause_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context-&gt;nappinfos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context-&gt;appinfos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newinfo-&gt;required_relids = <a href="#L554" title="optimizer/util/appendinfo.c:554">adjust_child_relids</a>(oldinfo-&gt;required_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context-&gt;nappinfos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context-&gt;appinfos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newinfo-&gt;outer_relids = <a href="#L554" title="optimizer/util/appendinfo.c:554">adjust_child_relids</a>(oldinfo-&gt;outer_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;nappinfos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;appinfos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newinfo-&gt;left_relids = <a href="#L554" title="optimizer/util/appendinfo.c:554">adjust_child_relids</a>(oldinfo-&gt;left_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context-&gt;nappinfos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context-&gt;appinfos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newinfo-&gt;right_relids = <a href="#L554" title="optimizer/util/appendinfo.c:554">adjust_child_relids</a>(oldinfo-&gt;right_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;nappinfos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;appinfos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset cached derivative fields, since these might need to have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * different <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> when considering the child relation.&nbsp; Note we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't reset left_ec/right_ec: each child variable is implicitly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * equivalent to its parent, so still a member of the same EC if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newinfo-&gt;eval_cost.startup = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newinfo-&gt;norm_selec = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newinfo-&gt;outer_selec = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newinfo-&gt;left_em = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newinfo-&gt;right_em = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newinfo-&gt;scansel_cache = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newinfo-&gt;left_bucketsize = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newinfo-&gt;right_bucketsize = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newinfo-&gt;left_mcvfreq = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newinfo-&gt;right_mcvfreq = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) newinfo;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: we do not need to recurse into sublinks, because they should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already have been converted to subplans <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we see them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!IsA(node, SubLink));<br/></li>
<li>&nbsp; &nbsp; Assert(!IsA(node, Query));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We should never see these Query substructures, either. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!IsA(node, RangeTblRef));<br/></li>
<li>&nbsp; &nbsp; Assert(!IsA(node, JoinExpr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_mutator(node, <a href="#L215" title="optimizer/util/appendinfo.c:215">adjust_appendrel_attrs_mutator</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L521" title="optimizer/util/appendinfo.c:521">adjust_appendrel_attrs_multilevel</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Apply Var translations from an appendrel parent down to a child.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Replace Vars in the &quot;node&quot; expression that reference &quot;parentrel&quot; with<br/></li>
<li></span><span class="Comment"> * the appropriate Vars for &quot;childrel&quot;.&nbsp; childrel can be more than one<br/></li>
<li></span><span class="Comment"> * inheritance level removed from parentrel.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Node *<br/></li>
<li><a id="L521">&#x200c;</a><span class="linkable">adjust_appendrel_attrs_multilevel</span>(PlannerInfo *root, Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *childrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *parentrel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AppendRelInfo **appinfos;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nappinfos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Recurse if immediate parent is not the top parent. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (childrel-&gt;parent != parentrel)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (childrel-&gt;parent)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node = <a href="#L521" title="optimizer/util/appendinfo.c:521">adjust_appendrel_attrs_multilevel</a>(root, node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; childrel-&gt;parent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parentrel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;childrel is not a child of parentrel&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now <a href="../../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> for this child. */<br/></li>
<li></span>&nbsp; &nbsp; appinfos = <a href="#L733" title="optimizer/util/appendinfo.c:733">find_appinfos_by_relids</a>(root, childrel-&gt;relids, &amp;nappinfos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node = <a href="#L196" title="optimizer/util/appendinfo.c:196">adjust_appendrel_attrs</a>(root, node, nappinfos, appinfos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(appinfos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> node;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Substitute child relids for parent relids in a Relid set.&nbsp; The array of<br/></li>
<li></span><span class="Comment"> * appinfos specifies the substitutions to be performed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Relids<br/></li>
<li><a id="L554">&#x200c;</a><span class="linkable">adjust_child_relids</span>(Relids relids, <span class="Type">int</span> nappinfos, AppendRelInfo **appinfos)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *result = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (cnt = <span class="Constant">0</span>; cnt &lt; nappinfos; cnt++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AppendRelInfo *appinfo = appinfos[cnt];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remove parent, add child */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(appinfo-&gt;parent_relid, relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make a copy if we are changing the set. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!result)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(relids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(result, appinfo-&gt;parent_relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(result, appinfo-&gt;child_relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we made <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> changes, return the modified copy. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise, return the original set without modification. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> relids;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Substitute child's relids for parent's relids in a Relid set.<br/></li>
<li></span><span class="Comment"> * The childrel can be multiple inheritance levels below the parent.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Relids<br/></li>
<li><a id="L588">&#x200c;</a><span class="linkable">adjust_child_relids_multilevel</span>(PlannerInfo *root, Relids relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *childrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelOptInfo *parentrel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AppendRelInfo **appinfos;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nappinfos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the given relids set doesn't contain <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the parent relids, it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will remain unchanged.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(relids, parentrel-&gt;relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Recurse if immediate parent is not the top parent. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (childrel-&gt;parent != parentrel)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (childrel-&gt;parent)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relids = <a href="#L588" title="optimizer/util/appendinfo.c:588">adjust_child_relids_multilevel</a>(root, relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrel-&gt;parent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentrel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;childrel is not a child of parentrel&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now <a href="../../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> for this child. */<br/></li>
<li></span>&nbsp; &nbsp; appinfos = <a href="#L733" title="optimizer/util/appendinfo.c:733">find_appinfos_by_relids</a>(root, childrel-&gt;relids, &amp;nappinfos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relids = <a href="#L554" title="optimizer/util/appendinfo.c:554">adjust_child_relids</a>(relids, nappinfos, appinfos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(appinfos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> relids;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L628" title="optimizer/util/appendinfo.c:628">adjust_inherited_attnums</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Translate an integer list of attribute numbers from parent to child.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L628">&#x200c;</a><span class="linkable">adjust_inherited_attnums</span>(List *attnums, AppendRelInfo *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This should only happen for an inheritance case, not UNION ALL */<br/></li>
<li></span>&nbsp; &nbsp; Assert(OidIsValid(context-&gt;parent_reloid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look up each attribute in the AppendRelInfo's translated_vars list */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, attnums)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; parentattno = lfirst_int(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *childvar;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Look up the translation of this column: it must be a Var */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parentattno &lt;= <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentattno &gt; list_length(context-&gt;translated_vars))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;attribute </span><span class="Special">%d</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parentattno, <a href="../../utils/cache/lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(context-&gt;parent_reloid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; childvar = (Var *) list_nth(context-&gt;translated_vars, parentattno - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (childvar == <span class="Constant">NULL</span> || !IsA(childvar, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;attribute </span><span class="Special">%d</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parentattno, <a href="../../utils/cache/lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(context-&gt;parent_reloid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(result, childvar-&gt;varattno);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L662" title="optimizer/util/appendinfo.c:662">adjust_inherited_attnums_multilevel</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; As above, but traverse multiple inheritance levels as needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L662">&#x200c;</a><span class="linkable">adjust_inherited_attnums_multilevel</span>(PlannerInfo *root, List *attnums,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index child_relid, Index top_parent_relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AppendRelInfo *appinfo = root-&gt;append_rel_array[child_relid];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!appinfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;child rel </span><span class="Special">%d</span><span class="Constant"> not found in append_rel_array&quot;</span>, child_relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Recurse if immediate parent is not the top parent. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (appinfo-&gt;parent_relid != top_parent_relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attnums = <a href="#L662" title="optimizer/util/appendinfo.c:662">adjust_inherited_attnums_multilevel</a>(root, attnums,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appinfo-&gt;parent_relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; top_parent_relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now <a href="../../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> for this child */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L628" title="optimizer/util/appendinfo.c:628">adjust_inherited_attnums</a>(attnums, appinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L690" title="optimizer/util/appendinfo.c:690">get_translated_update_targetlist</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Get the processed_tlist of an UPDATE query, translated as needed to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; match a child target relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Optionally also return the list of target column numbers translated<br/></li>
<li></span><span class="Comment"> * to this target relation.&nbsp; (The resnos in processed_tlist MUST NOT be<br/></li>
<li></span><span class="Comment"> * relied on for this purpose.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L690">&#x200c;</a></span><span class="linkable">get_translated_update_targetlist</span>(PlannerInfo *root, Index relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **processed_tlist, List **update_colnos)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This is pretty meaningless for commands other than UPDATE. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;commandType == CMD_UPDATE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relid == root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;resultRelation)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Non-inheritance case, so it's easy.&nbsp; The caller might be expecting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a tree it can scribble on, though, so copy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *processed_tlist = copyObject(root-&gt;processed_tlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (update_colnos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *update_colnos = copyObject(root-&gt;update_colnos);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(relid, root-&gt;all_result_relids));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *processed_tlist = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L521" title="optimizer/util/appendinfo.c:521">adjust_appendrel_attrs_multilevel</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Node *) root-&gt;processed_tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="relnode.c.html#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(root, relid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="relnode.c.html#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(root, root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;resultRelation));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (update_colnos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *update_colnos =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L662" title="optimizer/util/appendinfo.c:662">adjust_inherited_attnums_multilevel</a>(root, root-&gt;update_colnos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;resultRelation);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L733" title="optimizer/util/appendinfo.c:733">find_appinfos_by_relids</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Find AppendRelInfo structures for base relations listed in relids.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The relids argument is typically a join relation's relids, which can<br/></li>
<li></span><span class="Comment"> * include outer-join RT indexes in addition to baserels.&nbsp; We silently<br/></li>
<li></span><span class="Comment"> * ignore the outer joins.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The AppendRelInfos are returned in an array, which can be <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>'d by the<br/></li>
<li></span><span class="Comment"> * caller. *nappinfos is set to the number of entries in the array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>AppendRelInfo **<br/></li>
<li><a id="L733">&#x200c;</a><span class="linkable">find_appinfos_by_relids</span>(PlannerInfo *root, Relids relids, <span class="Type">int</span> *nappinfos)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AppendRelInfo **appinfos;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate an array that's certainly big enough */<br/></li>
<li></span>&nbsp; &nbsp; appinfos = (AppendRelInfo **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AppendRelInfo *) * <a href="../../nodes/bitmapset.c.html#L751" title="nodes/bitmapset.c:751">bms_num_members</a>(relids));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((i = <a href="../../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(relids, i)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AppendRelInfo *appinfo = root-&gt;append_rel_array[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!appinfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Probably i is an OJ index, but let's check */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="relnode.c.html#L454" title="optimizer/util/relnode.c:454">find_base_rel_ignore_join</a>(root, i) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It's a base rel, but we lack an append_rel_array entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;child rel </span><span class="Special">%d</span><span class="Constant"> not found in append_rel_array&quot;</span>, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appinfos[cnt++] = appinfo;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *nappinfos = cnt;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> appinfos;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ROW-IDENTITY VARIABLE MANAGEMENT<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This code lacks a good home, perhaps.&nbsp; We choose to keep it here because<br/></li>
<li></span><span class="Comment"> * <a href="#L215" title="optimizer/util/appendinfo.c:215">adjust_appendrel_attrs_mutator</a>() is its principal co-conspirator.&nbsp; That<br/></li>
<li></span><span class="Comment"> * function does most of what is needed to expand ROWID_VAR Vars into the<br/></li>
<li></span><span class="Comment"> * right things.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L789" title="optimizer/util/appendinfo.c:789">add_row_identity_var</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Register a row-identity column to be used in UPDATE/DELETE/MERGE.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The Var must be <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(), aside from varno, to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other row-identity<br/></li>
<li></span><span class="Comment"> * column with the same rowid_name.&nbsp; Thus, for example, &quot;wholerow&quot;<br/></li>
<li></span><span class="Comment"> * row identities had better use vartype == RECORDOID.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * rtindex is currently redundant with rowid_var-&gt;varno, but we specify<br/></li>
<li></span><span class="Comment"> * it as a separate parameter in case this is ever generalized to support<br/></li>
<li></span><span class="Comment"> * non-Var expressions.&nbsp; (We could reasonably handle expressions over<br/></li>
<li></span><span class="Comment"> * Vars of the specified rtindex, but for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that seems unnecessary.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L789">&#x200c;</a></span><span class="linkable">add_row_identity_var</span>(PlannerInfo *root, Var *orig_var,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index rtindex, <span class="Type">const</span> <span class="Type">char</span> *rowid_name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TargetEntry *tle;<br/></li>
<li>&nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *rowid_var;<br/></li>
<li>&nbsp; &nbsp; RowIdentityVarInfo *ridinfo;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, the argument must be just a Var of the given rtindex */<br/></li>
<li></span>&nbsp; &nbsp; Assert(IsA(orig_var, Var));<br/></li>
<li>&nbsp; &nbsp; Assert(orig_var-&gt;varno == rtindex);<br/></li>
<li>&nbsp; &nbsp; Assert(orig_var-&gt;varlevelsup == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(orig_var-&gt;varnullingrels == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're doing non-inherited UPDATE/DELETE/MERGE, there's little need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for ROWID_VAR shenanigans.&nbsp; Just shove the presented Var into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processed_tlist, and we're done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rtindex == root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;resultRelation)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>((Expr *) orig_var,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(root-&gt;processed_tlist) + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(rowid_name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;processed_tlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;processed_tlist, tle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, rtindex should reference a leaf target relation that's being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * added to the query during <a href="inherit.c.html#L86" title="optimizer/util/inherit.c:86">expand_inherited_rtentry</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(rtindex, root-&gt;leaf_result_relids));<br/></li>
<li>&nbsp; &nbsp; Assert(root-&gt;append_rel_array[rtindex] != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a matching RowIdentityVarInfo, or make one if there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>.&nbsp; To allow using <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>() to match the <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>, change the varno to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ROWID_VAR, leaving all else alone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rowid_var = copyObject(orig_var);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This could eventually become <a href="../../rewrite/rewriteManip.c.html#L674" title="rewrite/rewriteManip.c:674">ChangeVarNodes</a>() */<br/></li>
<li></span>&nbsp; &nbsp; rowid_var-&gt;varno = ROWID_VAR;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look for an existing row-id column of the same name */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, root-&gt;row_identity_vars)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ridinfo = (RowIdentityVarInfo *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(rowid_name, ridinfo-&gt;rowidname) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(rowid_var, ridinfo-&gt;rowidvar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found a match; we need only record that rtindex needs it too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ridinfo-&gt;rowidrels = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(ridinfo-&gt;rowidrels, rtindex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ooops, can't handle this */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;conflicting uses of row-identity name </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rowid_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No request yet, so add a new RowIdentityVarInfo */<br/></li>
<li></span>&nbsp; &nbsp; ridinfo = makeNode(RowIdentityVarInfo);<br/></li>
<li>&nbsp; &nbsp; ridinfo-&gt;rowidvar = copyObject(rowid_var);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* for the moment, estimate width using just the datatype info */<br/></li>
<li></span>&nbsp; &nbsp; ridinfo-&gt;rowidwidth = <a href="../../utils/cache/lsyscache.c.html#L2578" title="utils/cache/lsyscache.c:2578">get_typavgwidth</a>(<a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) rowid_var),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>((Node *) rowid_var));<br/></li>
<li>&nbsp; &nbsp; ridinfo-&gt;rowidname = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(rowid_name);<br/></li>
<li>&nbsp; &nbsp; ridinfo-&gt;rowidrels = <a href="../../nodes/bitmapset.c.html#L216" title="nodes/bitmapset.c:216">bms_make_singleton</a>(rtindex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; root-&gt;row_identity_vars = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;row_identity_vars, ridinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Change rowid_var into a reference to this row_identity_vars entry */<br/></li>
<li></span>&nbsp; &nbsp; rowid_var-&gt;varattno = list_length(root-&gt;row_identity_vars);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push the ROWID_VAR reference variable into processed_tlist */<br/></li>
<li></span>&nbsp; &nbsp; tle = <a href="../../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>((Expr *) rowid_var,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(root-&gt;processed_tlist) + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(rowid_name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; root-&gt;processed_tlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(root-&gt;processed_tlist, tle);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L884" title="optimizer/util/appendinfo.c:884">add_row_identity_columns</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function adds the row identity columns needed by the core code.<br/></li>
<li></span><span class="Comment"> * FDWs might call <a href="#L789" title="optimizer/util/appendinfo.c:789">add_row_identity_var</a>() for themselves to add nonstandard<br/></li>
<li></span><span class="Comment"> * columns.&nbsp; (Duplicate requests are fine.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L884">&#x200c;</a></span><span class="linkable">add_row_identity_columns</span>(PlannerInfo *root, Index rtindex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RangeTblEntry *target_rte,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation target_relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CmdType&nbsp; &nbsp; &nbsp; &nbsp; commandType = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;commandType;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; relkind = target_relation-&gt;rd_rel-&gt;relkind;<br/></li>
<li>&nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(commandType == CMD_UPDATE || commandType == CMD_DELETE || commandType == CMD_MERGE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relkind == RELKIND_RELATION ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relkind == RELKIND_MATVIEW ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Emit CTID so that executor can <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the row to <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>, update or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * delete.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; var = <a href="../../nodes/makefuncs.c.html#L66" title="nodes/makefuncs.c:66">makeVar</a>(rtindex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SelfItemPointerAttributeNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TIDOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L789" title="optimizer/util/appendinfo.c:789">add_row_identity_var</a>(root, var, rtindex, <span class="Constant">&quot;ctid&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (relkind == RELKIND_FOREIGN_TABLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Let the foreign table's FDW add whatever junk TLEs it wants.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; FdwRoutine *fdwroutine;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fdwroutine = <a href="../../foreign/foreign.c.html#L432" title="foreign/foreign.c:432">GetFdwRoutineForRelation</a>(target_relation, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fdwroutine-&gt;AddForeignUpdateTargets != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdwroutine-&gt;AddForeignUpdateTargets(root, rtindex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target_rte, target_relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For UPDATE, we need to make the FDW fetch unchanged columns by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * asking it to fetch a whole-row Var.&nbsp; That's because the top-level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * targetlist only contains entries for changed columns, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../executor/nodeModifyTable.c.html#L2259" title="executor/nodeModifyTable.c:2259">ExecUpdate</a> will need to build the complete new tuple.&nbsp; (Actually,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we only really need this in UPDATEs that are not pushed to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remote side, but it's hard to tell if that will be the case at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * point when this function is called.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We will also need the whole row if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> row triggers, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that the executor will have the &quot;old&quot; row to pass to the <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Alas, this misses system columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (commandType == CMD_UPDATE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (target_relation-&gt;trigdesc &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (target_relation-&gt;trigdesc-&gt;trig_delete_after_row ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target_relation-&gt;trigdesc-&gt;trig_delete_before_row)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var = <a href="../../nodes/makefuncs.c.html#L66" title="nodes/makefuncs.c:66">makeVar</a>(rtindex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidAttrNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RECORDOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L789" title="optimizer/util/appendinfo.c:789">add_row_identity_var</a>(root, var, rtindex, <span class="Constant">&quot;wholerow&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L965" title="optimizer/util/appendinfo.c:965">distribute_row_identity_vars</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * After we have finished identifying all the row identity columns<br/></li>
<li></span><span class="Comment"> * needed by an inherited UPDATE/DELETE/MERGE query, make sure that<br/></li>
<li></span><span class="Comment"> * these columns will be generated by all the target relations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is more or less like what <a href="../plan/initsplan.c.html#L234" title="optimizer/plan/initsplan.c:234">build_base_rel_tlists</a>() does,<br/></li>
<li></span><span class="Comment"> * except that it would not understand what to do with ROWID_VAR Vars.<br/></li>
<li></span><span class="Comment"> * Since that function runs <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> inheritance relations are expanded,<br/></li>
<li></span><span class="Comment"> * it will never see <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such Vars anyway.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L965">&#x200c;</a></span><span class="linkable">distribute_row_identity_vars</span>(PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> = root-&gt;<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result_relation = <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;resultRelation;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *target_rte;<br/></li>
<li>&nbsp; &nbsp; RelOptInfo *target_rel;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There's nothing to do if this isn't an inherited UPDATE/DELETE/MERGE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;commandType != CMD_UPDATE &amp;&amp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;commandType != CMD_DELETE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;commandType != CMD_MERGE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(root-&gt;row_identity_vars == NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; target_rte = rt_fetch(result_relation, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-&gt;rtable);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!target_rte-&gt;inh)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(root-&gt;row_identity_vars == NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ordinarily, we expect that leaf result relation(s) will have added some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ROWID_VAR Vars to the query.&nbsp; However, it's possible that constraint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exclusion suppressed every leaf relation.&nbsp; The executor will get upset<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if the plan has no row identity columns at all, even though it will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * certainly process no rows.&nbsp; Handle this edge case by re-opening the top<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * result relation and adding the row identity columns it would have used,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as <a href="../prep/preptlist.c.html#L62" title="optimizer/prep/preptlist.c:62">preprocess_targetlist</a>() would have done if it weren't marked &quot;inh&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Then re-run <a href="../plan/initsplan.c.html#L234" title="optimizer/plan/initsplan.c:234">build_base_rel_tlists</a>() to ensure that the added columns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get propagated to the relation's reltarget.&nbsp; (This is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> ugly, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it seems better to confine the ugliness and extra cycles to this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unusual corner case.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;row_identity_vars == NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; target_relation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; target_relation = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(target_rte-&gt;relid, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L884" title="optimizer/util/appendinfo.c:884">add_row_identity_columns</a>(root, result_relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; target_rte, target_relation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(target_relation, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../plan/initsplan.c.html#L234" title="optimizer/plan/initsplan.c:234">build_base_rel_tlists</a>(root, root-&gt;processed_tlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* There are no ROWID_VAR Vars in this case, so we're done. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Dig through the processed_tlist to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the ROWID_VAR reference Vars,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and forcibly copy them into the reltarget list of the topmost target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation.&nbsp; That's sufficient because they'll be copied to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * individual leaf target rels (with appropriate translation) later,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during appendrel expansion --- see <a href="../path/allpaths.c.html#L944" title="optimizer/path/allpaths.c:944">set_append_rel_size</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; target_rel = <a href="relnode.c.html#L414" title="optimizer/util/relnode.c:414">find_base_rel</a>(root, result_relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, root-&gt;processed_tlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) tle-&gt;expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var &amp;&amp; IsA(var, Var) &amp;&amp; var-&gt;varno == ROWID_VAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target_rel-&gt;reltarget-&gt;exprs =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(target_rel-&gt;reltarget-&gt;exprs, copyObject(var));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reltarget cost and width will be computed later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
