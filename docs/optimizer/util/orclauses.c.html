<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>optimizer/util/orclauses.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>optimizer/util/orclauses.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L254">consider_new_or_clause</a></li>
<li><a href="#L156">extract_or_clause</a></li>
<li><a href="#L75">extract_restriction_or_clauses</a></li>
<li><a href="#L126">is_safe_restriction_clause_for</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * orclauses.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Routines to extract restriction OR clauses from join OR clauses<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/optimizer/util/orclauses.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/orclauses.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/paths.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/restrictinfo.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L126" title="optimizer/util/orclauses.c:126">is_safe_restriction_clause_for</a>(RestrictInfo *rinfo, RelOptInfo *rel);<br/></li>
<li><span class="Type">static</span> Expr *<a href="#L156" title="optimizer/util/orclauses.c:156">extract_or_clause</a>(RestrictInfo *or_rinfo, RelOptInfo *rel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L254" title="optimizer/util/orclauses.c:254">consider_new_or_clause</a>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Expr *orclause, RestrictInfo *join_or_rinfo);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L75" title="optimizer/util/orclauses.c:75">extract_restriction_or_clauses</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Examine join OR-of-AND clauses to see if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> useful restriction OR<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; clauses can be extracted.&nbsp; If so, add them to the query.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Although a join clause must reference multiple relations overall,<br/></li>
<li></span><span class="Comment"> * an OR of ANDs clause might contain sub-clauses that reference just one<br/></li>
<li></span><span class="Comment"> * relation and can be used to build a restriction clause for that rel.<br/></li>
<li></span><span class="Comment"> * For example consider<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; WHERE ((a.x = 42 AND b.y = 43) OR (a.x = 44 AND b.z = 45));<br/></li>
<li></span><span class="Comment"> * We can transform this into<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; WHERE ((a.x = 42 AND b.y = 43) OR (a.x = 44 AND b.z = 45))<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AND (a.x = 42 OR a.x = 44)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AND (b.y = 43 OR b.z = 45);<br/></li>
<li></span><span class="Comment"> * which allows the latter clauses to be applied during the scans of a and b,<br/></li>
<li></span><span class="Comment"> * perhaps as index qualifications, and in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case reducing the number of<br/></li>
<li></span><span class="Comment"> * rows arriving at the join.&nbsp; In essence this is a partial transformation to<br/></li>
<li></span><span class="Comment"> * CNF (AND of ORs format).&nbsp; It is not complete, however, because we do not<br/></li>
<li></span><span class="Comment"> * unravel the original OR --- doing so would usually bloat the qualification<br/></li>
<li></span><span class="Comment"> * expression to little gain.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The added quals are partially redundant with the original OR, and therefore<br/></li>
<li></span><span class="Comment"> * would cause the size of the joinrel to be underestimated when it is finally<br/></li>
<li></span><span class="Comment"> * formed.&nbsp; (This would be true of a full transformation to CNF as well; the<br/></li>
<li></span><span class="Comment"> * fault is not really in the transformation, but in <a href="../path/clausesel.c.html#L100" title="optimizer/path/clausesel.c:100">clauselist_selectivity</a>'s<br/></li>
<li></span><span class="Comment"> * inability to recognize redundant conditions.)&nbsp; We can compensate for this<br/></li>
<li></span><span class="Comment"> * redundancy by changing the cached selectivity of the original OR clause,<br/></li>
<li></span><span class="Comment"> * canceling out the (valid) reduction in the estimated sizes of the base<br/></li>
<li></span><span class="Comment"> * relations so that the estimated joinrel size remains the same.&nbsp; This is<br/></li>
<li></span><span class="Comment"> * a MAJOR HACK: it depends on the fact that clause selectivities are cached<br/></li>
<li></span><span class="Comment"> * and on the fact that the same RestrictInfo node will appear in every<br/></li>
<li></span><span class="Comment"> * joininfo list that might be used when the joinrel is formed.<br/></li>
<li></span><span class="Comment"> * And it doesn't work in cases where the size estimation is nonlinear<br/></li>
<li></span><span class="Comment"> * (i.e., outer and IN joins).&nbsp; But it beats not doing anything.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We examine each base relation to see if join clauses associated with it<br/></li>
<li></span><span class="Comment"> * contain extractable restriction conditions.&nbsp; If so, add those conditions<br/></li>
<li></span><span class="Comment"> * to the rel's baserestrictinfo and update the cached selectivities of the<br/></li>
<li></span><span class="Comment"> * join clauses.&nbsp; Note that the same join clause will be examined afresh<br/></li>
<li></span><span class="Comment"> * from the point of view of each baserel that participates in it, so its<br/></li>
<li></span><span class="Comment"> * cached selectivity may get updated multiple times.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L75">&#x200c;</a></span><span class="linkable">extract_restriction_or_clauses</span>(PlannerInfo *root)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; rti;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Examine each baserel for potential join OR clauses */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (rti = <span class="Constant">1</span>; rti &lt; root-&gt;simple_rel_array_size; rti++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelOptInfo *rel = root-&gt;simple_rel_array[rti];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there may be empty slots corresponding to non-baserel RTEs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(rel-&gt;relid == rti);&nbsp; &nbsp; <span class="Comment">/* sanity check on array */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore RTEs that are &quot;other rels&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;reloptkind != RELOPT_BASEREL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find potentially interesting OR joinclauses.&nbsp; We can use <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * joinclause that is considered safe to move to this rel by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parameterized-path machinery, even though what we are going to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with it is not exactly a parameterized path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, rel-&gt;joininfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="restrictinfo.c.html#L416" title="optimizer/util/restrictinfo.c:416">restriction_is_or_clause</a>(rinfo) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="restrictinfo.c.html#L584" title="optimizer/util/restrictinfo.c:584">join_clause_is_movable_to</a>(rinfo, rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to extract a qual for this rel only */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *orclause = <a href="#L156" title="optimizer/util/orclauses.c:156">extract_or_clause</a>(rinfo, rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If successful, decide whether we want to use the clause,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and insert it into the rel's restrictinfo list if so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (orclause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L254" title="optimizer/util/orclauses.c:254">consider_new_or_clause</a>(root, rel, orclause, rinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Is the given primitive (non-OR) RestrictInfo safe to move to the rel?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L126">&#x200c;</a></span><span class="linkable">is_safe_restriction_clause_for</span>(RestrictInfo *rinfo, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We want clauses that mention the rel, and only the rel.&nbsp; So in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * particular pseudoconstant clauses can be rejected quickly.&nbsp; Then check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the clause's Var membership.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rinfo-&gt;pseudoconstant)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(rinfo-&gt;clause_relids, rel-&gt;relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We don't want extra evaluations of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> volatile <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>((Node *) rinfo-&gt;clause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Try to extract a restriction clause mentioning only &quot;rel&quot; from the given<br/></li>
<li></span><span class="Comment"> * join OR-clause.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We must be able to extract at least one qual for this rel from each of<br/></li>
<li></span><span class="Comment"> * the arms of the OR, else we can't use it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns an OR clause (not a RestrictInfo!) pertaining to rel, or NULL<br/></li>
<li></span><span class="Comment"> * if no OR clause could be extracted.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Expr *<br/></li>
<li><a id="L156">&#x200c;</a><span class="linkable">extract_or_clause</span>(RestrictInfo *or_rinfo, RelOptInfo *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *clauselist = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan each arm of the input OR clause.&nbsp; Notice we descend into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or_rinfo-&gt;orclause, which has RestrictInfo nodes embedded below the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * toplevel OR/AND structure.&nbsp; This is useful because we can use the info<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in those nodes to make <a href="#L126" title="optimizer/util/orclauses.c:126">is_safe_restriction_clause_for</a>()'s checks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cheaper.&nbsp; We'll strip those nodes from the returned tree, though,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * meaning that fresh ones will be built if the clause is accepted as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restriction clause.&nbsp; This might seem wasteful --- couldn't we re-use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the existing RestrictInfos?&nbsp; &nbsp; But that'd require assuming that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * selectivity and other cached data is computed exactly the same way for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a restriction clause as for a join clause, which seems undesirable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(is_orclause(or_rinfo-&gt;orclause));<br/></li>
<li>&nbsp; &nbsp; foreach(lc, ((BoolExpr *) or_rinfo-&gt;orclause)-&gt;args)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *orarg = (Node *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *subclauses = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *subclause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OR arguments should be ANDs or sub-RestrictInfos */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_andclause(orarg))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *andargs = ((BoolExpr *) orarg)-&gt;args;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, andargs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = lfirst_node(RestrictInfo, lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="restrictinfo.c.html#L416" title="optimizer/util/restrictinfo.c:416">restriction_is_or_clause</a>(rinfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Recurse to deal with nested OR.&nbsp; Note we *must* recurse<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here, this isn't just overly-tense optimization: we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have to descend far enough to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> and strip all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * RestrictInfos in the expression.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *suborclause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; suborclause = <a href="#L156" title="optimizer/util/orclauses.c:156">extract_or_clause</a>(rinfo, rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (suborclause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subclauses = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(subclauses, suborclause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L126" title="optimizer/util/orclauses.c:126">is_safe_restriction_clause_for</a>(rinfo, rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subclauses = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(subclauses, rinfo-&gt;clause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = castNode(RestrictInfo, orarg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="restrictinfo.c.html#L416" title="optimizer/util/restrictinfo.c:416">restriction_is_or_clause</a>(rinfo));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L126" title="optimizer/util/orclauses.c:126">is_safe_restriction_clause_for</a>(rinfo, rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subclauses = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(subclauses, rinfo-&gt;clause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If nothing could be extracted from this arm, we can't do anything<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with this OR clause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subclauses == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OK, add subclause(s) to the result OR.&nbsp; If we found more than one,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we need an AND node.&nbsp; But if we found only one, and it is itself an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OR node, add its subclauses to the result instead; this is needed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to preserve AND/OR flatness (ie, no OR directly underneath OR).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; subclause = (Node *) <a href="../../nodes/makefuncs.c.html#L726" title="nodes/makefuncs.c:726">make_ands_explicit</a>(subclauses);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_orclause(subclause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clauselist = <a href="../../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(clauselist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((BoolExpr *) subclause)-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clauselist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(clauselist, subclause);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we got a restriction clause from every arm, wrap them up in an OR<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * node.&nbsp; (In theory the OR node might be unnecessary, if there was only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one arm --- but then the input OR node was also redundant.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (clauselist != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../nodes/makefuncs.c.html#L670" title="nodes/makefuncs.c:670">make_orclause</a>(clauselist);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Consider whether a successfully-extracted restriction OR clause is<br/></li>
<li></span><span class="Comment"> * actually worth using.&nbsp; If so, add it to the <a href="../plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>'s data structures,<br/></li>
<li></span><span class="Comment"> * and adjust the original join clause (join_or_rinfo) to compensate.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L254">&#x200c;</a></span><span class="linkable">consider_new_or_clause</span>(PlannerInfo *root, RelOptInfo *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Expr *orclause, RestrictInfo *join_or_rinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RestrictInfo *or_rinfo;<br/></li>
<li>&nbsp; &nbsp; Selectivity or_selec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orig_selec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build a RestrictInfo from the new OR clause.&nbsp; We can assume it's valid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as a base restriction clause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; or_rinfo = <a href="restrictinfo.c.html#L63" title="optimizer/util/restrictinfo.c:63">make_restrictinfo</a>(root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; orclause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; join_or_rinfo-&gt;security_level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate its selectivity.&nbsp; (We could have done this earlier, but doing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it on the RestrictInfo representation allows the result to get cached,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * saving work later.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; or_selec = <a href="../path/clausesel.c.html#L667" title="optimizer/path/clausesel.c:667">clause_selectivity</a>(root, (Node *) or_rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>, JOIN_INNER, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The clause is only worth adding to the query if it rejects a useful<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fraction of the base relation's rows; otherwise, it's just going to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cause duplicate computation (since we will still have to check the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * original OR clause when the join is formed).&nbsp; Somewhat arbitrarily, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set the selectivity threshold at 0.9.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (or_selec &gt; <span class="Constant">0.9</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* forget it */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK, add it to the rel's restriction-clause list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;baserestrictinfo = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rel-&gt;baserestrictinfo, or_rinfo);<br/></li>
<li>&nbsp; &nbsp; rel-&gt;baserestrict_min_security = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(rel-&gt;baserestrict_min_security,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; or_rinfo-&gt;security_level);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Adjust the original join OR clause's cached selectivity to compensate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the selectivity of the added (but redundant) <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-level qual. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should result in the join rel getting approximately the same rows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimate as it would have gotten without all these shenanigans.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> major hack alert: this depends on the assumption that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * selectivity will stay cached.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> another major hack: we adjust only norm_selec, the cached<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * selectivity for JOIN_INNER semantics, even though the join clause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might've been an outer-join clause.&nbsp; This is partly because we can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * easily identify the relevant SpecialJoinInfo here, and partly because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the linearity assumption we're making would fail anyway.&nbsp; (If it is an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * outer-join clause, &quot;rel&quot; must be on the nullable side, else we'd not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have gotten here.&nbsp; So the computation of the join size is going to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * quite nonlinear with respect to the size of &quot;rel&quot;, so it's not clear<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * how we ought to adjust outer_selec even if we could compute its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * original value correctly.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (or_selec &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpecialJoinInfo sjinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make up a SpecialJoinInfo for JOIN_INNER semantics.&nbsp; (Compare<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../path/costsize.c.html#L5194" title="optimizer/path/costsize.c:5194">approx_tuple_count</a>() in costsize.c.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../path/joinrels.c.html#L669" title="optimizer/path/joinrels.c:669">init_dummy_sjinfo</a>(&amp;sjinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L346" title="nodes/bitmapset.c:346">bms_difference</a>(join_or_rinfo-&gt;clause_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;relids),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;relids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute inner-join size */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; orig_selec = <a href="../path/clausesel.c.html#L667" title="optimizer/path/clausesel.c:667">clause_selectivity</a>(root, (Node *) join_or_rinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>, JOIN_INNER, &amp;sjinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And hack cached selectivity so join size remains the same */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; join_or_rinfo-&gt;norm_selec = orig_selec / or_selec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ensure result stays in sane <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (join_or_rinfo-&gt;norm_selec &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; join_or_rinfo-&gt;norm_selec = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* as explained above, we don't touch outer_selec */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
