<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>nodes/outfuncs.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>nodes/outfuncs.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L29">write_location_fields</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L696">_outA_Const</a></li>
<li><a href="#L576">_outA_Expr</a></li>
<li><a href="#L684">_outBitString</a></li>
<li><a href="#L402">_outBoolExpr</a></li>
<li><a href="#L664">_outBoolean</a></li>
<li><a href="#L382">_outConst</a></li>
<li><a href="#L455">_outEquivalenceClass</a></li>
<li><a href="#L481">_outExtensibleNode</a></li>
<li><a href="#L654">_outFloat</a></li>
<li><a href="#L429">_outForeignKeyOptInfo</a></li>
<li><a href="#L648">_outInteger</a></li>
<li><a href="#L275">_outList</a></li>
<li><a href="#L496">_outRangeTblEntry</a></li>
<li><a href="#L670">_outString</a></li>
<li><a href="#L808">bmsToString</a></li>
<li><a href="#L791">nodeToString</a></li>
<li><a href="#L770">nodeToStringInternal</a></li>
<li><a href="#L797">nodeToStringWithLocations</a></li>
<li><a href="#L325">outBitmapset</a></li>
<li><a href="#L190">outChar</a></li>
<li><a href="#L341">outDatum</a></li>
<li><a href="#L211">outDouble</a></li>
<li><a href="#L716">outNode</a></li>
<li><a href="#L149">outToken</a></li>
<li><a href="#L255">writeNodeArray</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L112">WRITE_ATTRNUMBER_ARRAY</a></li>
<li><a href="#L102">WRITE_BITMAPSET_FIELD</a></li>
<li><a href="#L132">WRITE_BOOL_ARRAY</a></li>
<li><a href="#L83">WRITE_BOOL_FIELD</a></li>
<li><a href="#L68">WRITE_CHAR_FIELD</a></li>
<li><a href="#L73">WRITE_ENUM_FIELD</a></li>
<li><a href="#L78">WRITE_FLOAT_FIELD</a></li>
<li><a href="#L122">WRITE_INDEX_ARRAY</a></li>
<li><a href="#L127">WRITE_INT_ARRAY</a></li>
<li><a href="#L47">WRITE_INT_FIELD</a></li>
<li><a href="#L93">WRITE_LOCATION_FIELD</a></li>
<li><a href="#L64">WRITE_LONG_FIELD</a></li>
<li><a href="#L107">WRITE_NODE_ARRAY</a></li>
<li><a href="#L97">WRITE_NODE_FIELD</a></li>
<li><a href="#L43">WRITE_NODE_TYPE</a></li>
<li><a href="#L117">WRITE_OID_ARRAY</a></li>
<li><a href="#L60">WRITE_OID_FIELD</a></li>
<li><a href="#L227">WRITE_SCALAR_ARRAY</a></li>
<li><a href="#L88">WRITE_STRING_FIELD</a></li>
<li><a href="#L55">WRITE_UINT64_FIELD</a></li>
<li><a href="#L51">WRITE_UINT_FIELD</a></li>
<li><a href="#L136">booltostr</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * outfuncs.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Output <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for Postgres tree nodes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/nodes/outfuncs.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;ctype.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/attnum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/shortest_dec.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/stringinfo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/bitmapset.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/pg_list.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datum.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* State flag that determines how <a href="#L770" title="nodes/outfuncs.c:770">nodeToStringInternal</a>() should treat location fields */<br/></li>
<li><a id="L29">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">write_location_fields</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L190" title="nodes/outfuncs.c:190">outChar</a>(StringInfo str, <span class="Type">char</span> c);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L211" title="nodes/outfuncs.c:211">outDouble</a>(StringInfo str, <span class="Type">double</span> d);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Macros to simplify output of different kinds of fields.&nbsp; Use these<br/></li>
<li></span><span class="Comment"> * wherever possible to reduce the chance for silly typos.&nbsp; Note that these<br/></li>
<li></span><span class="Comment"> * hard-wire conventions about the names of the local variables in an Out<br/></li>
<li></span><span class="Comment"> * routine.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Write the label for the node type */<br/></li>
<li><a id="L43">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WRITE_NODE_TYPE</span>(nodelabel) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; appendStringInfoString(str, nodelabel)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Write an integer field (anything written as &quot;:fldname %d&quot;) */<br/></li>
<li><a id="L47">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WRITE_INT_FIELD</span>(fldname) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; appendStringInfo(str, </span><span class="Constant">&quot; :&quot;</span><span class="PreProc"> CppAsString(fldname) </span><span class="Constant">&quot; </span><span class="Special">%d</span><span class="Constant">&quot;</span><span class="PreProc">, node-&gt;fldname)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Write an unsigned integer field (anything written as &quot;:fldname %u&quot;) */<br/></li>
<li><a id="L51">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WRITE_UINT_FIELD</span>(fldname) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; appendStringInfo(str, </span><span class="Constant">&quot; :&quot;</span><span class="PreProc"> CppAsString(fldname) </span><span class="Constant">&quot; </span><span class="Special">%u</span><span class="Constant">&quot;</span><span class="PreProc">, node-&gt;fldname)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Write an unsigned integer field (anything written with UINT64_FORMAT) */<br/></li>
<li><a id="L55">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WRITE_UINT64_FIELD</span>(fldname) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; appendStringInfo(str, </span><span class="Constant">&quot; :&quot;</span><span class="PreProc"> CppAsString(fldname) </span><span class="Constant">&quot; &quot;</span><span class="PreProc"> UINT64_FORMAT, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;fldname)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Write an OID field (don't hard-wire assumption that OID is same as uint) */<br/></li>
<li><a id="L60">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WRITE_OID_FIELD</span>(fldname) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; appendStringInfo(str, </span><span class="Constant">&quot; :&quot;</span><span class="PreProc"> CppAsString(fldname) </span><span class="Constant">&quot; </span><span class="Special">%u</span><span class="Constant">&quot;</span><span class="PreProc">, node-&gt;fldname)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Write a long-integer field */<br/></li>
<li><a id="L64">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WRITE_LONG_FIELD</span>(fldname) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; appendStringInfo(str, </span><span class="Constant">&quot; :&quot;</span><span class="PreProc"> CppAsString(fldname) </span><span class="Constant">&quot; </span><span class="Special">%ld</span><span class="Constant">&quot;</span><span class="PreProc">, node-&gt;fldname)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Write a char field (ie, one <a href="../utils/adt/oracle_compat.c.html#L925" title="utils/adt/oracle_compat.c:925">ascii</a> character) */<br/></li>
<li><a id="L68">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WRITE_CHAR_FIELD</span>(fldname) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (appendStringInfo(str, </span><span class="Constant">&quot; :&quot;</span><span class="PreProc"> CppAsString(fldname) </span><span class="Constant">&quot; &quot;</span><span class="PreProc">), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; <a href="#L190" title="nodes/outfuncs.c:190">outChar</a>(str, node-&gt;fldname))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Write an enumerated-type field as an integer code */<br/></li>
<li><a id="L73">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WRITE_ENUM_FIELD</span>(fldname, enumtype) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; appendStringInfo(str, </span><span class="Constant">&quot; :&quot;</span><span class="PreProc"> CppAsString(fldname) </span><span class="Constant">&quot; </span><span class="Special">%d</span><span class="Constant">&quot;</span><span class="PreProc">, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (</span><span class="Type">int</span><span class="PreProc">) node-&gt;fldname)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Write a float field (actually, they're double) */<br/></li>
<li><a id="L78">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WRITE_FLOAT_FIELD</span>(fldname) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (appendStringInfo(str, </span><span class="Constant">&quot; :&quot;</span><span class="PreProc"> CppAsString(fldname) </span><span class="Constant">&quot; &quot;</span><span class="PreProc">), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; <a href="#L211" title="nodes/outfuncs.c:211">outDouble</a>(str, node-&gt;fldname))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Write a boolean field */<br/></li>
<li><a id="L83">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WRITE_BOOL_FIELD</span>(fldname) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; appendStringInfo(str, </span><span class="Constant">&quot; :&quot;</span><span class="PreProc"> CppAsString(fldname) </span><span class="Constant">&quot; </span><span class="Special">%s</span><span class="Constant">&quot;</span><span class="PreProc">, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L136" title="nodes/outfuncs.c:136">booltostr</a>(node-&gt;fldname))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Write a character-string (possibly NULL) field */<br/></li>
<li><a id="L88">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WRITE_STRING_FIELD</span>(fldname) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (appendStringInfoString(str, </span><span class="Constant">&quot; :&quot;</span><span class="PreProc"> CppAsString(fldname) </span><span class="Constant">&quot; &quot;</span><span class="PreProc">), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; <a href="#L149" title="nodes/outfuncs.c:149">outToken</a>(str, node-&gt;fldname))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Write a <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> location field (actually same as INT case) */<br/></li>
<li><a id="L93">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WRITE_LOCATION_FIELD</span>(fldname) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; appendStringInfo(str, </span><span class="Constant">&quot; :&quot;</span><span class="PreProc"> CppAsString(fldname) </span><span class="Constant">&quot; </span><span class="Special">%d</span><span class="Constant">&quot;</span><span class="PreProc">, <a href="#L29" title="nodes/outfuncs.c:29">write_location_fields</a> ? node-&gt;fldname : -</span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Write a Node field */<br/></li>
<li><a id="L97">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WRITE_NODE_FIELD</span>(fldname) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (appendStringInfoString(str, </span><span class="Constant">&quot; :&quot;</span><span class="PreProc"> CppAsString(fldname) </span><span class="Constant">&quot; &quot;</span><span class="PreProc">), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; <a href="#L716" title="nodes/outfuncs.c:716">outNode</a>(str, node-&gt;fldname))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Write a bitmapset field */<br/></li>
<li><a id="L102">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WRITE_BITMAPSET_FIELD</span>(fldname) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (appendStringInfoString(str, </span><span class="Constant">&quot; :&quot;</span><span class="PreProc"> CppAsString(fldname) </span><span class="Constant">&quot; &quot;</span><span class="PreProc">), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; <a href="#L325" title="nodes/outfuncs.c:325">outBitmapset</a>(str, node-&gt;fldname))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Write a variable-length array (not a List) of Node pointers */<br/></li>
<li><a id="L107">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WRITE_NODE_ARRAY</span>(fldname, len) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (appendStringInfoString(str, </span><span class="Constant">&quot; :&quot;</span><span class="PreProc"> CppAsString(fldname) </span><span class="Constant">&quot; &quot;</span><span class="PreProc">), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; <a href="#L255" title="nodes/outfuncs.c:255">writeNodeArray</a>(str, (</span><span class="Type">const</span><span class="PreProc"> Node * </span><span class="Type">const</span><span class="PreProc"> *) node-&gt;fldname, len))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Write a variable-length array of AttrNumber */<br/></li>
<li><a id="L112">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WRITE_ATTRNUMBER_ARRAY</span>(fldname, len) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (appendStringInfoString(str, </span><span class="Constant">&quot; :&quot;</span><span class="PreProc"> CppAsString(fldname) </span><span class="Constant">&quot; &quot;</span><span class="PreProc">), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; writeAttrNumberCols(str, node-&gt;fldname, len))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Write a variable-length array of Oid */<br/></li>
<li><a id="L117">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WRITE_OID_ARRAY</span>(fldname, len) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (appendStringInfoString(str, </span><span class="Constant">&quot; :&quot;</span><span class="PreProc"> CppAsString(fldname) </span><span class="Constant">&quot; &quot;</span><span class="PreProc">), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; writeOidCols(str, node-&gt;fldname, len))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Write a variable-length array of Index */<br/></li>
<li><a id="L122">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WRITE_INDEX_ARRAY</span>(fldname, len) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (appendStringInfoString(str, </span><span class="Constant">&quot; :&quot;</span><span class="PreProc"> CppAsString(fldname) </span><span class="Constant">&quot; &quot;</span><span class="PreProc">), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; writeIndexCols(str, node-&gt;fldname, len))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Write a variable-length array of int */<br/></li>
<li><a id="L127">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WRITE_INT_ARRAY</span>(fldname, len) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (appendStringInfoString(str, </span><span class="Constant">&quot; :&quot;</span><span class="PreProc"> CppAsString(fldname) </span><span class="Constant">&quot; &quot;</span><span class="PreProc">), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; writeIntCols(str, node-&gt;fldname, len))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Write a variable-length array of <a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> */<br/></li>
<li><a id="L132">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WRITE_BOOL_ARRAY</span>(fldname, len) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (appendStringInfoString(str, </span><span class="Constant">&quot; :&quot;</span><span class="PreProc"> CppAsString(fldname) </span><span class="Constant">&quot; &quot;</span><span class="PreProc">), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; writeBoolCols(str, node-&gt;fldname, len))<br/></li>
<li></span><br/></li>
<li><a id="L136">&#x200c;</a><span class="PreProc">#define <span class="linkable">booltostr</span>(x)&nbsp; ((x) ? </span><span class="Constant">&quot;true&quot;</span><span class="PreProc"> : </span><span class="Constant">&quot;false&quot;</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L149" title="nodes/outfuncs.c:149">outToken</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Convert an ordinary string (eg, an identifier) into a form that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; will be decoded back to a plain token by read.c's <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; If a null string pointer is given, it is encoded as '&lt;&gt;'.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; An empty string is encoded as '&quot;&quot;'.&nbsp; To avoid ambiguity, input<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; strings beginning with '&lt;' or '&quot;' receive a leading backslash.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L149">&#x200c;</a></span><span class="linkable">outToken</span>(StringInfo str, <span class="Type">const</span> <span class="Type">char</span> *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(str, <span class="Constant">&quot;&lt;&gt;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*s == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(str, <span class="Constant">&quot;</span><span class="Special">\&quot;\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look for characters or patterns that are treated specially by read.c<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (either in <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>() or in <a href="read.c.html#L320" title="nodes/read.c:320">nodeRead</a>()), and therefore need a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * protective backslash.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* These characters only need to be quoted at the start of the string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*s == <span class="Constant">'&lt;'</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *s == <span class="Constant">'&quot;'</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *s) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((*s == <span class="Constant">'+'</span> || *s == <span class="Constant">'-'</span>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) s[<span class="Constant">1</span>]) || s[<span class="Constant">1</span>] == <span class="Constant">'.'</span>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(str, <span class="Special">'\\'</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (*s)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* These chars must be backslashed anywhere in the string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*s == <span class="Constant">' '</span> || *s == <span class="Special">'\n'</span> || *s == <span class="Special">'\t'</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *s == <span class="Constant">'('</span> || *s == <span class="Constant">')'</span> || *s == <span class="Constant">'{'</span> || *s == <span class="Constant">'}'</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *s == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(str, <span class="Special">'\\'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(str, *s++);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert one char.&nbsp; Goes through <a href="#L149" title="nodes/outfuncs.c:149">outToken</a>() so that special characters are<br/></li>
<li></span><span class="Comment"> * escaped.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L190">&#x200c;</a></span><span class="linkable">outChar</span>(StringInfo str, <span class="Type">char</span> c)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; in[<span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Traditionally, we've represented \0 as &lt;&gt;, so keep doing that */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (c == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(str, <span class="Constant">&quot;&lt;&gt;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; in[<span class="Constant">0</span>] = c;<br/></li>
<li>&nbsp; &nbsp; in[<span class="Constant">1</span>] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L149" title="nodes/outfuncs.c:149">outToken</a>(str, in);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert a double value, attempting to ensure the value is preserved exactly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L211">&#x200c;</a></span><span class="linkable">outDouble</span>(StringInfo str, <span class="Type">double</span> d)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[DOUBLE_SHORTEST_DECIMAL_LEN];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; double_to_shortest_decimal_buf(d, buf);<br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(str, buf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * common implementation for scalar-array-writing <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The data format is either &quot;&lt;&gt;&quot; for a NULL pointer or &quot;(item item item)&quot;.<br/></li>
<li></span><span class="Comment"> * fmtstr must include a leading space, and the rest of it must produce<br/></li>
<li></span><span class="Comment"> * something that will be seen as a single simple token by <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>().<br/></li>
<li></span><span class="Comment"> * convfunc can be empty, or the name of a conversion macro or function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L227">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WRITE_SCALAR_ARRAY</span>(fnname, datatype, fmtstr, convfunc) \<br/></li>
<li></span><span class="Type">static</span><span class="PreProc"> </span><span class="Type">void</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">fnname(StringInfo str, </span><span class="Type">const</span><span class="PreProc"> datatype *arr, </span><span class="Type">int</span><span class="PreProc"> len) \<br/></li>
<li></span><span class="PreProc">{ \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (arr != </span><span class="Constant">NULL</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(str, </span><span class="Constant">'('</span><span class="PreProc">); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">for</span><span class="PreProc"> (</span><span class="Type">int</span><span class="PreProc"> i = </span><span class="Constant">0</span><span class="PreProc">; i &lt; len; i++) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(str, fmtstr, convfunc(arr[i])); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(str, </span><span class="Constant">')'</span><span class="PreProc">); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">else</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(str, </span><span class="Constant">&quot;&lt;&gt;&quot;</span><span class="PreProc">); \<br/></li>
<li></span><span class="PreProc">}<br/></li>
<li></span><br/></li>
<li><a href="#L227" title="nodes/outfuncs.c:227">WRITE_SCALAR_ARRAY</a>(writeAttrNumberCols, AttrNumber, <span class="Constant">&quot; </span><span class="Special">%d</span><span class="Constant">&quot;</span>,)<br/></li>
<li><a href="#L227" title="nodes/outfuncs.c:227">WRITE_SCALAR_ARRAY</a>(writeOidCols, Oid, <span class="Constant">&quot; </span><span class="Special">%u</span><span class="Constant">&quot;</span>,)<br/></li>
<li><a href="#L227" title="nodes/outfuncs.c:227">WRITE_SCALAR_ARRAY</a>(writeIndexCols, Index, <span class="Constant">&quot; </span><span class="Special">%u</span><span class="Constant">&quot;</span>,)<br/></li>
<li><a href="#L227" title="nodes/outfuncs.c:227">WRITE_SCALAR_ARRAY</a>(writeIntCols, <span class="Type">int</span>, <span class="Constant">&quot; </span><span class="Special">%d</span><span class="Constant">&quot;</span>,)<br/></li>
<li><a href="#L227" title="nodes/outfuncs.c:227">WRITE_SCALAR_ARRAY</a>(writeBoolCols, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>, <span class="Constant">&quot; </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="#L136" title="nodes/outfuncs.c:136">booltostr</a>)<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Print an array (not a List) of Node pointers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The decoration is identical to that of scalar arrays, but we can't<br/></li>
<li></span><span class="Comment"> * quite use appendStringInfo() in the loop.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L255">&#x200c;</a></span><span class="linkable">writeNodeArray</span>(StringInfo str, <span class="Type">const</span> Node *<span class="Type">const</span> *arr, <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arr != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(str, <span class="Constant">'('</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; len; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(str, <span class="Constant">' '</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L716" title="nodes/outfuncs.c:716">outNode</a>(str, arr[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(str, <span class="Constant">')'</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(str, <span class="Constant">&quot;&lt;&gt;&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Print a List.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L275">&#x200c;</a></span><span class="linkable">_outList</span>(StringInfo str, <span class="Type">const</span> List *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> ListCell *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(str, <span class="Constant">'('</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, IntList))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(str, <span class="Constant">'i'</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, OidList))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(str, <span class="Constant">'o'</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, XidList))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(str, <span class="Constant">'x'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, node)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For the sake of backward compatibility, we emit a slightly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * different whitespace format for lists of nodes vs. other types of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lists. </span><span class="Todo">XXX</span><span class="Comment">: is this necessary?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, List))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L716" title="nodes/outfuncs.c:716">outNode</a>(str, lfirst(lc));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lnext(node, lc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(str, <span class="Constant">' '</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, IntList))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(str, <span class="Constant">&quot; </span><span class="Special">%d</span><span class="Constant">&quot;</span>, lfirst_int(lc));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, OidList))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(str, <span class="Constant">&quot; </span><span class="Special">%u</span><span class="Constant">&quot;</span>, lfirst_oid(lc));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, XidList))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(str, <span class="Constant">&quot; </span><span class="Special">%u</span><span class="Constant">&quot;</span>, lfirst_xid(lc));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized list node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) node-&gt;type);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(str, <span class="Constant">')'</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L325" title="nodes/outfuncs.c:325">outBitmapset</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; converts a bitmap set of integers<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the output format is &quot;(b int int ...)&quot;, similar to an integer List.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We export this function for use by extensions that define extensible nodes.<br/></li>
<li></span><span class="Comment"> * That's somewhat historical, though, because calling <a href="#L716" title="nodes/outfuncs.c:716">outNode</a>() will work.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L325">&#x200c;</a></span><span class="linkable">outBitmapset</span>(StringInfo str, <span class="Type">const</span> Bitmapset *bms)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(str, <span class="Constant">'('</span>);<br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(str, <span class="Constant">'b'</span>);<br/></li>
<li>&nbsp; &nbsp; x = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((x = <a href="bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(bms, x)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(str, <span class="Constant">&quot; </span><span class="Special">%d</span><span class="Constant">&quot;</span>, x);<br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(str, <span class="Constant">')'</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Print the value of a Datum given its type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L341">&#x200c;</a></span><span class="linkable">outDatum</span>(StringInfo str, Datum value, <span class="Type">int</span> typlen, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typbyval)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; length = <a href="../utils/adt/datum.c.html#L65" title="utils/adt/datum.c:65">datumGetSize</a>(value, typbyval, typlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typbyval)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s = (<span class="Type">char</span> *) (&amp;value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(str, <span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant"> [ &quot;</span>, (<span class="Type">unsigned</span> <span class="Type">int</span>) length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; (Size) <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum); i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(str, <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant"> &quot;</span>, (<span class="Type">int</span>) (s[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(str, <span class="Constant">']'</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s = (<span class="Type">char</span> *) DatumGetPointer(value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!PointerIsValid(s))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(str, <span class="Constant">&quot;0 [ ]&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(str, <span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant"> [ &quot;</span>, (<span class="Type">unsigned</span> <span class="Type">int</span>) length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; length; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(str, <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant"> &quot;</span>, (<span class="Type">int</span>) (s[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(str, <span class="Constant">']'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;outfuncs.funcs.c&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Support <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for nodes with custom_read_write attribute or<br/></li>
<li></span><span class="Comment"> * special_read_write attribute<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L382">&#x200c;</a></span><span class="linkable">_outConst</span>(StringInfo str, <span class="Type">const</span> Const *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L43" title="nodes/outfuncs.c:43">WRITE_NODE_TYPE</a>(<span class="Constant">&quot;CONST&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L60" title="nodes/outfuncs.c:60">WRITE_OID_FIELD</a>(consttype);<br/></li>
<li>&nbsp; &nbsp; <a href="#L47" title="nodes/outfuncs.c:47">WRITE_INT_FIELD</a>(consttypmod);<br/></li>
<li>&nbsp; &nbsp; <a href="#L60" title="nodes/outfuncs.c:60">WRITE_OID_FIELD</a>(constcollid);<br/></li>
<li>&nbsp; &nbsp; <a href="#L47" title="nodes/outfuncs.c:47">WRITE_INT_FIELD</a>(constlen);<br/></li>
<li>&nbsp; &nbsp; <a href="#L83" title="nodes/outfuncs.c:83">WRITE_BOOL_FIELD</a>(constbyval);<br/></li>
<li>&nbsp; &nbsp; <a href="#L83" title="nodes/outfuncs.c:83">WRITE_BOOL_FIELD</a>(constisnull);<br/></li>
<li>&nbsp; &nbsp; <a href="#L93" title="nodes/outfuncs.c:93">WRITE_LOCATION_FIELD</a>(location);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(str, <span class="Constant">&quot; :constvalue &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(str, <span class="Constant">&quot;&lt;&gt;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L341" title="nodes/outfuncs.c:341">outDatum</a>(str, node-&gt;constvalue, node-&gt;constlen, node-&gt;constbyval);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L402">&#x200c;</a></span><span class="linkable">_outBoolExpr</span>(StringInfo str, <span class="Type">const</span> BoolExpr *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *opstr = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L43" title="nodes/outfuncs.c:43">WRITE_NODE_TYPE</a>(<span class="Constant">&quot;BOOLEXPR&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do-it-yourself enum representation */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (node-&gt;boolop)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AND_EXPR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opstr = <span class="Constant">&quot;and&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OR_EXPR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opstr = <span class="Constant">&quot;or&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> NOT_EXPR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opstr = <span class="Constant">&quot;not&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(str, <span class="Constant">&quot; :boolop &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L149" title="nodes/outfuncs.c:149">outToken</a>(str, opstr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(args);<br/></li>
<li>&nbsp; &nbsp; <a href="#L93" title="nodes/outfuncs.c:93">WRITE_LOCATION_FIELD</a>(location);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L429">&#x200c;</a></span><span class="linkable">_outForeignKeyOptInfo</span>(StringInfo str, <span class="Type">const</span> ForeignKeyOptInfo *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L43" title="nodes/outfuncs.c:43">WRITE_NODE_TYPE</a>(<span class="Constant">&quot;FOREIGNKEYOPTINFO&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L51" title="nodes/outfuncs.c:51">WRITE_UINT_FIELD</a>(con_relid);<br/></li>
<li>&nbsp; &nbsp; <a href="#L51" title="nodes/outfuncs.c:51">WRITE_UINT_FIELD</a>(ref_relid);<br/></li>
<li>&nbsp; &nbsp; <a href="#L47" title="nodes/outfuncs.c:47">WRITE_INT_FIELD</a>(nkeys);<br/></li>
<li>&nbsp; &nbsp; <a href="#L112" title="nodes/outfuncs.c:112">WRITE_ATTRNUMBER_ARRAY</a>(conkey, node-&gt;nkeys);<br/></li>
<li>&nbsp; &nbsp; <a href="#L112" title="nodes/outfuncs.c:112">WRITE_ATTRNUMBER_ARRAY</a>(confkey, node-&gt;nkeys);<br/></li>
<li>&nbsp; &nbsp; <a href="#L117" title="nodes/outfuncs.c:117">WRITE_OID_ARRAY</a>(conpfeqop, node-&gt;nkeys);<br/></li>
<li>&nbsp; &nbsp; <a href="#L47" title="nodes/outfuncs.c:47">WRITE_INT_FIELD</a>(nmatched_ec);<br/></li>
<li>&nbsp; &nbsp; <a href="#L47" title="nodes/outfuncs.c:47">WRITE_INT_FIELD</a>(nconst_ec);<br/></li>
<li>&nbsp; &nbsp; <a href="#L47" title="nodes/outfuncs.c:47">WRITE_INT_FIELD</a>(nmatched_rcols);<br/></li>
<li>&nbsp; &nbsp; <a href="#L47" title="nodes/outfuncs.c:47">WRITE_INT_FIELD</a>(nmatched_ri);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* for compactness, just <a href="print.c.html#L36" title="nodes/print.c:36">print</a> the number of matches per column: */<br/></li>
<li></span>&nbsp; &nbsp; appendStringInfoString(str, <span class="Constant">&quot; :<a href="../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; node-&gt;nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(str, <span class="Constant">&quot; </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (node-&gt;<a href="../regex/regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a>[i] != <span class="Constant">NULL</span>));<br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(str, <span class="Constant">&quot; :rinfos&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; node-&gt;nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(str, <span class="Constant">&quot; </span><span class="Special">%d</span><span class="Constant">&quot;</span>, list_length(node-&gt;rinfos[i]));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L455">&#x200c;</a></span><span class="linkable">_outEquivalenceClass</span>(StringInfo str, <span class="Type">const</span> EquivalenceClass *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To simplify reading, we just chase up to the topmost merged EC and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="print.c.html#L36" title="nodes/print.c:36">print</a> that, without bothering to show the <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>-ees separately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (node-&gt;ec_merged)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node = node-&gt;ec_merged;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L43" title="nodes/outfuncs.c:43">WRITE_NODE_TYPE</a>(<span class="Constant">&quot;EQUIVALENCECLASS&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(ec_opfamilies);<br/></li>
<li>&nbsp; &nbsp; <a href="#L60" title="nodes/outfuncs.c:60">WRITE_OID_FIELD</a>(ec_collation);<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(ec_members);<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(ec_sources);<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(ec_derives);<br/></li>
<li>&nbsp; &nbsp; <a href="#L102" title="nodes/outfuncs.c:102">WRITE_BITMAPSET_FIELD</a>(ec_relids);<br/></li>
<li>&nbsp; &nbsp; <a href="#L83" title="nodes/outfuncs.c:83">WRITE_BOOL_FIELD</a>(ec_has_const);<br/></li>
<li>&nbsp; &nbsp; <a href="#L83" title="nodes/outfuncs.c:83">WRITE_BOOL_FIELD</a>(ec_has_volatile);<br/></li>
<li>&nbsp; &nbsp; <a href="#L83" title="nodes/outfuncs.c:83">WRITE_BOOL_FIELD</a>(ec_broken);<br/></li>
<li>&nbsp; &nbsp; <a href="#L51" title="nodes/outfuncs.c:51">WRITE_UINT_FIELD</a>(ec_sortref);<br/></li>
<li>&nbsp; &nbsp; <a href="#L51" title="nodes/outfuncs.c:51">WRITE_UINT_FIELD</a>(ec_min_security);<br/></li>
<li>&nbsp; &nbsp; <a href="#L51" title="nodes/outfuncs.c:51">WRITE_UINT_FIELD</a>(ec_max_security);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L481">&#x200c;</a></span><span class="linkable">_outExtensibleNode</span>(StringInfo str, <span class="Type">const</span> ExtensibleNode *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> ExtensibleNodeMethods *methods;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; methods = <a href="extensible.c.html#L125" title="nodes/extensible.c:125">GetExtensibleNodeMethods</a>(node-&gt;extnodename, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L43" title="nodes/outfuncs.c:43">WRITE_NODE_TYPE</a>(<span class="Constant">&quot;EXTENSIBLENODE&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L88" title="nodes/outfuncs.c:88">WRITE_STRING_FIELD</a>(extnodename);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* serialize the private fields */<br/></li>
<li></span>&nbsp; &nbsp; methods-&gt;nodeOut(str, node);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L496">&#x200c;</a></span><span class="linkable">_outRangeTblEntry</span>(StringInfo str, <span class="Type">const</span> RangeTblEntry *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L43" title="nodes/outfuncs.c:43">WRITE_NODE_TYPE</a>(<span class="Constant">&quot;RANGETBLENTRY&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(alias);<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(eref);<br/></li>
<li>&nbsp; &nbsp; <a href="#L73" title="nodes/outfuncs.c:73">WRITE_ENUM_FIELD</a>(rtekind, RTEKind);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (node-&gt;rtekind)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_RELATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L60" title="nodes/outfuncs.c:60">WRITE_OID_FIELD</a>(relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L83" title="nodes/outfuncs.c:83">WRITE_BOOL_FIELD</a>(inh);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L68" title="nodes/outfuncs.c:68">WRITE_CHAR_FIELD</a>(relkind);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L47" title="nodes/outfuncs.c:47">WRITE_INT_FIELD</a>(rellockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L51" title="nodes/outfuncs.c:51">WRITE_UINT_FIELD</a>(perminfoindex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(tablesample);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_SUBQUERY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(subquery);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L83" title="nodes/outfuncs.c:83">WRITE_BOOL_FIELD</a>(security_barrier);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we re-use these RELATION fields, too: */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L60" title="nodes/outfuncs.c:60">WRITE_OID_FIELD</a>(relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L83" title="nodes/outfuncs.c:83">WRITE_BOOL_FIELD</a>(inh);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L68" title="nodes/outfuncs.c:68">WRITE_CHAR_FIELD</a>(relkind);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L47" title="nodes/outfuncs.c:47">WRITE_INT_FIELD</a>(rellockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L51" title="nodes/outfuncs.c:51">WRITE_UINT_FIELD</a>(perminfoindex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_JOIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L73" title="nodes/outfuncs.c:73">WRITE_ENUM_FIELD</a>(jointype, JoinType);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L47" title="nodes/outfuncs.c:47">WRITE_INT_FIELD</a>(joinmergedcols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(joinaliasvars);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(joinleftcols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(joinrightcols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(join_using_alias);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_FUNCTION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(<a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L83" title="nodes/outfuncs.c:83">WRITE_BOOL_FIELD</a>(funcordinality);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_TABLEFUNC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(tablefunc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_VALUES:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(values_lists);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(coltypes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(coltypmods);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(colcollations);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_CTE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L88" title="nodes/outfuncs.c:88">WRITE_STRING_FIELD</a>(ctename);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L51" title="nodes/outfuncs.c:51">WRITE_UINT_FIELD</a>(ctelevelsup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L83" title="nodes/outfuncs.c:83">WRITE_BOOL_FIELD</a>(self_reference);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(coltypes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(coltypmods);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(colcollations);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_NAMEDTUPLESTORE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L88" title="nodes/outfuncs.c:88">WRITE_STRING_FIELD</a>(enrname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="nodes/outfuncs.c:78">WRITE_FLOAT_FIELD</a>(enrtuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(coltypes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(coltypmods);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(colcollations);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we re-use these RELATION fields, too: */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L60" title="nodes/outfuncs.c:60">WRITE_OID_FIELD</a>(relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_RESULT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no extra fields */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized RTE kind: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) node-&gt;rtekind);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L83" title="nodes/outfuncs.c:83">WRITE_BOOL_FIELD</a>(lateral);<br/></li>
<li>&nbsp; &nbsp; <a href="#L83" title="nodes/outfuncs.c:83">WRITE_BOOL_FIELD</a>(inFromCl);<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(securityQuals);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L576">&#x200c;</a></span><span class="linkable">_outA_Expr</span>(StringInfo str, <span class="Type">const</span> A_Expr *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L43" title="nodes/outfuncs.c:43">WRITE_NODE_TYPE</a>(<span class="Constant">&quot;A_EXPR&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (node-&gt;kind)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AEXPR_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AEXPR_OP_ANY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(str, <span class="Constant">&quot; ANY&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AEXPR_OP_ALL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(str, <span class="Constant">&quot; ALL&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AEXPR_DISTINCT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(str, <span class="Constant">&quot; DISTINCT&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AEXPR_NOT_DISTINCT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(str, <span class="Constant">&quot; NOT_DISTINCT&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AEXPR_NULLIF:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(str, <span class="Constant">&quot; NULLIF&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AEXPR_IN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(str, <span class="Constant">&quot; IN&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AEXPR_LIKE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(str, <span class="Constant">&quot; LIKE&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AEXPR_ILIKE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(str, <span class="Constant">&quot; ILIKE&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AEXPR_SIMILAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(str, <span class="Constant">&quot; SIMILAR&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AEXPR_BETWEEN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(str, <span class="Constant">&quot; BETWEEN&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AEXPR_NOT_BETWEEN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(str, <span class="Constant">&quot; NOT_BETWEEN&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AEXPR_BETWEEN_SYM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(str, <span class="Constant">&quot; BETWEEN_SYM&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AEXPR_NOT_BETWEEN_SYM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(str, <span class="Constant">&quot; NOT_BETWEEN_SYM&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized A_Expr_Kind: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) node-&gt;kind);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(lexpr);<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="nodes/outfuncs.c:97">WRITE_NODE_FIELD</a>(rexpr);<br/></li>
<li>&nbsp; &nbsp; <a href="#L93" title="nodes/outfuncs.c:93">WRITE_LOCATION_FIELD</a>(location);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L648">&#x200c;</a></span><span class="linkable">_outInteger</span>(StringInfo str, <span class="Type">const</span> Integer *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(str, <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, node-&gt;ival);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L654">&#x200c;</a></span><span class="linkable">_outFloat</span>(StringInfo str, <span class="Type">const</span> Float *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We assume the value is a valid <a href="../utils/adt/numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> literal and so does not need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * quoting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; appendStringInfoString(str, node-&gt;fval);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L664">&#x200c;</a></span><span class="linkable">_outBoolean</span>(StringInfo str, <span class="Type">const</span> Boolean *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(str, node-&gt;boolval ? <span class="Constant">&quot;true&quot;</span> : <span class="Constant">&quot;false&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L670">&#x200c;</a></span><span class="linkable">_outString</span>(StringInfo str, <span class="Type">const</span> String *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use <a href="#L149" title="nodes/outfuncs.c:149">outToken</a> to provide escaping of the string's content, but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't want it to convert an empty string to '&quot;&quot;', because we're putting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * double quotes around the string already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; appendStringInfoChar(str, <span class="Constant">'&quot;'</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;sval[<span class="Constant">0</span>] != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L149" title="nodes/outfuncs.c:149">outToken</a>(str, node-&gt;sval);<br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(str, <span class="Constant">'&quot;'</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L684">&#x200c;</a></span><span class="linkable">_outBitString</span>(StringInfo str, <span class="Type">const</span> BitString *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The lexer will always produce a string starting with 'b' or 'x'.&nbsp; There<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might be characters following that that need escaping, but <a href="#L149" title="nodes/outfuncs.c:149">outToken</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * won't escape the 'b' or 'x'.&nbsp; This is relied on by <a href="read.c.html#L246" title="nodes/read.c:246">nodeTokenType</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(node-&gt;bsval[<span class="Constant">0</span>] == <span class="Constant">'b'</span> || node-&gt;bsval[<span class="Constant">0</span>] == <span class="Constant">'x'</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L149" title="nodes/outfuncs.c:149">outToken</a>(str, node-&gt;bsval);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L696">&#x200c;</a></span><span class="linkable">_outA_Const</span>(StringInfo str, <span class="Type">const</span> A_Const *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L43" title="nodes/outfuncs.c:43">WRITE_NODE_TYPE</a>(<span class="Constant">&quot;A_CONST&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(str, <span class="Constant">&quot; NULL&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(str, <span class="Constant">&quot; :val &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L716" title="nodes/outfuncs.c:716">outNode</a>(str, &amp;node-&gt;val);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="#L93" title="nodes/outfuncs.c:93">WRITE_LOCATION_FIELD</a>(location);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L716" title="nodes/outfuncs.c:716">outNode</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; converts a Node into <a href="../utils/adt/oracle_compat.c.html#L925" title="utils/adt/oracle_compat.c:925">ascii</a> string and append it to 'str'<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L716">&#x200c;</a></span><span class="linkable">outNode</span>(StringInfo str, <span class="Type">const</span> <span class="Type">void</span> *obj)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Guard against stack overflow due to overly complex expressions */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (obj == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(str, <span class="Constant">&quot;&lt;&gt;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(obj, List) || IsA(obj, IntList) || IsA(obj, OidList) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IsA(obj, XidList))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L275" title="nodes/outfuncs.c:275">_outList</a>(str, obj);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="read.c.html#L320" title="nodes/read.c:320">nodeRead</a> does not want to see { } around these! */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(obj, Integer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L648" title="nodes/outfuncs.c:648">_outInteger</a>(str, (Integer *) obj);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(obj, Float))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L654" title="nodes/outfuncs.c:654">_outFloat</a>(str, (Float *) obj);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(obj, Boolean))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L664" title="nodes/outfuncs.c:664">_outBoolean</a>(str, (Boolean *) obj);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(obj, String))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L670" title="nodes/outfuncs.c:670">_outString</a>(str, (String *) obj);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(obj, BitString))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L684" title="nodes/outfuncs.c:684">_outBitString</a>(str, (BitString *) obj);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(obj, Bitmapset))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L325" title="nodes/outfuncs.c:325">outBitmapset</a>(str, (Bitmapset *) obj);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(str, <span class="Constant">'{'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (nodeTag(obj))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;outfuncs.switch.c&quot;<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This should be an ERROR, but it's too useful to be able to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> structures that <a href="#L716" title="nodes/outfuncs.c:716">outNode</a> only understands part of.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;could not <a href="../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) nodeTag(obj));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(str, <span class="Constant">'}'</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L791" title="nodes/outfuncs.c:791">nodeToString</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; returns the <a href="../utils/adt/oracle_compat.c.html#L925" title="utils/adt/oracle_compat.c:925">ascii</a> representation of the Node as a <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d string<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * write_loc_fields determines whether location fields are output with their<br/></li>
<li></span><span class="Comment"> * actual value rather than -1.&nbsp; The actual value can be useful for debugging,<br/></li>
<li></span><span class="Comment"> * but for most uses, the actual value is not useful, since the original query<br/></li>
<li></span><span class="Comment"> * string is no longer available.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L770">&#x200c;</a><span class="linkable">nodeToStringInternal</span>(<span class="Type">const</span> <span class="Type">void</span> *obj, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> write_loc_fields)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; save_write_location_fields;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; save_write_location_fields = <a href="#L29" title="nodes/outfuncs.c:29">write_location_fields</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L29" title="nodes/outfuncs.c:29">write_location_fields</a> = write_loc_fields;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* see stringinfo.h for an explanation of this maneuver */<br/></li>
<li></span>&nbsp; &nbsp; initStringInfo(&amp;str);<br/></li>
<li>&nbsp; &nbsp; <a href="#L716" title="nodes/outfuncs.c:716">outNode</a>(&amp;str, obj);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L29" title="nodes/outfuncs.c:29">write_location_fields</a> = save_write_location_fields;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> str.data;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Externally visible entry points<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L791">&#x200c;</a><span class="linkable">nodeToString</span>(<span class="Type">const</span> <span class="Type">void</span> *obj)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L770" title="nodes/outfuncs.c:770">nodeToStringInternal</a>(obj, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">char</span> *<br/></li>
<li><a id="L797">&#x200c;</a><span class="linkable">nodeToStringWithLocations</span>(<span class="Type">const</span> <span class="Type">void</span> *obj)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L770" title="nodes/outfuncs.c:770">nodeToStringInternal</a>(obj, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L808" title="nodes/outfuncs.c:808">bmsToString</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; returns the <a href="../utils/adt/oracle_compat.c.html#L925" title="utils/adt/oracle_compat.c:925">ascii</a> representation of the Bitmapset as a <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d string<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L808">&#x200c;</a><span class="linkable">bmsToString</span>(<span class="Type">const</span> Bitmapset *bms)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* see stringinfo.h for an explanation of this maneuver */<br/></li>
<li></span>&nbsp; &nbsp; initStringInfo(&amp;str);<br/></li>
<li>&nbsp; &nbsp; <a href="#L325" title="nodes/outfuncs.c:325">outBitmapset</a>(&amp;str, bms);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> str.data;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
