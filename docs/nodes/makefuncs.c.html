<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>nodes/makefuncs.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>nodes/makefuncs.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L273">flatCopyTargetEntry</a></li>
<li><a href="#L30">makeA_Expr</a></li>
<li><a href="#L389">makeAlias</a></li>
<li><a href="#L359">makeBoolConst</a></li>
<li><a href="#L371">makeBoolExpr</a></li>
<li><a href="#L492">makeColumnDef</a></li>
<li><a href="#L301">makeConst</a></li>
<li><a href="#L564">makeDefElem</a></li>
<li><a href="#L582">makeDefElemExtended</a></li>
<li><a href="#L287">makeFromExpr</a></li>
<li><a href="#L603">makeFuncCall</a></li>
<li><a href="#L521">makeFuncExpr</a></li>
<li><a href="#L817">makeGroupingSet</a></li>
<li><a href="#L761">makeIndexInfo</a></li>
<li><a href="#L880">makeJsonBehavior</a></li>
<li><a href="#L847">makeJsonFormat</a></li>
<li><a href="#L911">makeJsonIsPredicate</a></li>
<li><a href="#L896">makeJsonKeyValue</a></li>
<li><a href="#L951">makeJsonTablePath</a></li>
<li><a href="#L930">makeJsonTablePathSpec</a></li>
<li><a href="#L863">makeJsonValueExpr</a></li>
<li><a href="#L339">makeNullConst</a></li>
<li><a href="#L424">makeRangeVar</a></li>
<li><a href="#L404">makeRelabelType</a></li>
<li><a href="#L48">makeSimpleA_Expr</a></li>
<li><a href="#L545">makeStringConst</a></li>
<li><a href="#L240">makeTargetEntry</a></li>
<li><a href="#L446">makeTypeName</a></li>
<li><a href="#L458">makeTypeNameFromNameList</a></li>
<li><a href="#L474">makeTypeNameFromOid</a></li>
<li><a href="#L832">makeVacuumRelation</a></li>
<li><a href="#L66">makeVar</a></li>
<li><a href="#L105">makeVarFromTargetEntry</a></li>
<li><a href="#L135">makeWholeRowVar</a></li>
<li><a href="#L707">make_and_qual</a></li>
<li><a href="#L654">make_andclause</a></li>
<li><a href="#L726">make_ands_explicit</a></li>
<li><a href="#L737">make_ands_implicit</a></li>
<li><a href="#L686">make_notclause</a></li>
<li><a href="#L628">make_opclause</a></li>
<li><a href="#L670">make_orclause</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * makefuncs.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; creator <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for various nodes. The <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> here are for the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; most frequently created nodes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/nodes/makefuncs.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_class.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L30" title="nodes/makefuncs.c:30">makeA_Expr</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; makes an A_Expr node<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>A_Expr *<br/></li>
<li><a id="L30">&#x200c;</a><span class="linkable">makeA_Expr</span>(A_Expr_Kind kind, List *name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *lexpr, Node *rexpr, <span class="Type">int</span> location)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; A_Expr&nbsp; &nbsp; &nbsp;&nbsp; *a = makeNode(A_Expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; a-&gt;kind = kind;<br/></li>
<li>&nbsp; &nbsp; a-&gt;name = name;<br/></li>
<li>&nbsp; &nbsp; a-&gt;lexpr = lexpr;<br/></li>
<li>&nbsp; &nbsp; a-&gt;rexpr = rexpr;<br/></li>
<li>&nbsp; &nbsp; a-&gt;location = location;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> a;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L48" title="nodes/makefuncs.c:48">makeSimpleA_Expr</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; As above, given a simple (unqualified) operator name<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>A_Expr *<br/></li>
<li><a id="L48">&#x200c;</a><span class="linkable">makeSimpleA_Expr</span>(A_Expr_Kind kind, <span class="Type">char</span> *name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *lexpr, Node *rexpr, <span class="Type">int</span> location)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; A_Expr&nbsp; &nbsp; &nbsp;&nbsp; *a = makeNode(A_Expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; a-&gt;kind = kind;<br/></li>
<li>&nbsp; &nbsp; a-&gt;name = list_make1(<a href="value.c.html#L63" title="nodes/value.c:63">makeString</a>((<span class="Type">char</span> *) name));<br/></li>
<li>&nbsp; &nbsp; a-&gt;lexpr = lexpr;<br/></li>
<li>&nbsp; &nbsp; a-&gt;rexpr = rexpr;<br/></li>
<li>&nbsp; &nbsp; a-&gt;location = location;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> a;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L66" title="nodes/makefuncs.c:66">makeVar</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; creates a Var node<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Var *<br/></li>
<li><a id="L66">&#x200c;</a><span class="linkable">makeVar</span>(<span class="Type">int</span> varno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber varattno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid vartype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32 vartypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid varcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Index varlevelsup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = makeNode(Var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; var-&gt;varno = varno;<br/></li>
<li>&nbsp; &nbsp; var-&gt;varattno = varattno;<br/></li>
<li>&nbsp; &nbsp; var-&gt;vartype = vartype;<br/></li>
<li>&nbsp; &nbsp; var-&gt;vartypmod = vartypmod;<br/></li>
<li>&nbsp; &nbsp; var-&gt;varcollid = varcollid;<br/></li>
<li>&nbsp; &nbsp; var-&gt;varlevelsup = varlevelsup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Only a few callers need to make Var nodes with non-null varnullingrels,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or with varnosyn/varattnosyn different from varno/varattno.&nbsp; We don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * provide separate arguments for them, but just <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> them to NULL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and the given varno/varattno.&nbsp; This reduces code clutter and chance of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * error for most callers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; var-&gt;varnullingrels = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; var-&gt;varnosyn = (Index) varno;<br/></li>
<li>&nbsp; &nbsp; var-&gt;varattnosyn = varattno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Likewise, we just set location to &quot;unknown&quot; here */<br/></li>
<li></span>&nbsp; &nbsp; var-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> var;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L105" title="nodes/makefuncs.c:105">makeVarFromTargetEntry</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; convenience function to create a same-level Var node from a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Var *<br/></li>
<li><a id="L105">&#x200c;</a><span class="linkable">makeVarFromTargetEntry</span>(<span class="Type">int</span> varno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TargetEntry *tle)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L66" title="nodes/makefuncs.c:66">makeVar</a>(varno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tle-&gt;resno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) tle-&gt;expr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>((Node *) tle-&gt;expr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) tle-&gt;expr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L135" title="nodes/makefuncs.c:135">makeWholeRowVar</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; creates a Var node representing a whole row of the specified RTE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A whole-row reference is a Var with varno set to the correct <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment"> * table entry, and varattno == 0 to signal that it references the whole<br/></li>
<li></span><span class="Comment"> * tuple.&nbsp; (Use of zero here is unclean, since it could easily be confused<br/></li>
<li></span><span class="Comment"> * with error cases, but it's not worth changing <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.)&nbsp; The vartype indicates<br/></li>
<li></span><span class="Comment"> * a rowtype; either a named composite type, or a domain over a named<br/></li>
<li></span><span class="Comment"> * composite type (only possible if the RTE is a function returning that),<br/></li>
<li></span><span class="Comment"> * or RECORD.&nbsp; This function encapsulates the logic for determining the<br/></li>
<li></span><span class="Comment"> * correct rowtype OID to use.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If allowScalar is true, then for the case where the RTE is a single function<br/></li>
<li></span><span class="Comment"> * returning a non-composite result type, we produce a normal Var referencing<br/></li>
<li></span><span class="Comment"> * the function's result directly, instead of the single-column composite<br/></li>
<li></span><span class="Comment"> * value that the whole-row notation might otherwise suggest.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Var *<br/></li>
<li><a id="L135">&#x200c;</a><span class="linkable">makeWholeRowVar</span>(RangeTblEntry *rte,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> varno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index varlevelsup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> allowScalar)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toid;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *fexpr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (rte-&gt;rtekind)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_RELATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* relation: the rowtype is a named composite type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toid = <a href="../utils/cache/lsyscache.c.html#L1979" title="utils/cache/lsyscache.c:1979">get_rel_type_id</a>(rte-&gt;relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(toid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not have a composite type&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(rte-&gt;relid))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L66" title="nodes/makefuncs.c:66">makeVar</a>(varno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidAttrNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; toid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; varlevelsup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_FUNCTION:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there's more than one function, or ordinality is requested,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * force a RECORD result, since there's certainly more than one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column involved and it can't be a known named type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;funcordinality || list_length(rte-&gt;<a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* always produces an anonymous RECORD result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L66" title="nodes/makefuncs.c:66">makeVar</a>(varno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidAttrNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RECORDOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; varlevelsup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fexpr = ((RangeTblFunction *) linitial(rte-&gt;<a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>))-&gt;funcexpr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toid = <a href="nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(fexpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/cache/lsyscache.c.html#L2655" title="utils/cache/lsyscache.c:2655">type_is_rowtype</a>(toid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* func returns composite; same as relation case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L66" title="nodes/makefuncs.c:66">makeVar</a>(varno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidAttrNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; toid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; varlevelsup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (allowScalar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* func returns scalar; just return its output as-is */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L66" title="nodes/makefuncs.c:66">makeVar</a>(varno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; toid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>(fexpr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; varlevelsup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* func returns scalar, but we want a composite result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L66" title="nodes/makefuncs.c:66">makeVar</a>(varno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidAttrNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RECORDOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; varlevelsup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * RTE is a join, subselect, tablefunc, or VALUES.&nbsp; We represent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this as a whole-row Var of RECORD type. (Note that in most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cases the Var will be expanded to a RowExpr during planning,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but that is not our concern here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L66" title="nodes/makefuncs.c:66">makeVar</a>(varno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidAttrNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RECORDOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; varlevelsup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; creates a TargetEntry node<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TargetEntry *<br/></li>
<li><a id="L240">&#x200c;</a><span class="linkable">makeTargetEntry</span>(Expr *expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber resno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> *resname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> resjunk)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TargetEntry *tle = makeNode(TargetEntry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tle-&gt;expr = expr;<br/></li>
<li>&nbsp; &nbsp; tle-&gt;resno = resno;<br/></li>
<li>&nbsp; &nbsp; tle-&gt;resname = resname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We always set these fields to 0. If the caller wants to change them he<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must do so explicitly.&nbsp; Few callers do that, so omitting these<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * arguments reduces the chance of error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tle-&gt;ressortgroupref = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; tle-&gt;resorigtbl = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; tle-&gt;resorigcol = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tle-&gt;resjunk = resjunk;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tle;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L273" title="nodes/makefuncs.c:273">flatCopyTargetEntry</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; duplicate a TargetEntry, but don't copy substructure<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is commonly used when we just want to modify the resno or substitute<br/></li>
<li></span><span class="Comment"> * a new expression.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TargetEntry *<br/></li>
<li><a id="L273">&#x200c;</a><span class="linkable">flatCopyTargetEntry</span>(TargetEntry *src_tle)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TargetEntry *tle = makeNode(TargetEntry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(IsA(src_tle, TargetEntry));<br/></li>
<li>&nbsp; &nbsp; memcpy(tle, src_tle, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TargetEntry));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tle;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L287" title="nodes/makefuncs.c:287">makeFromExpr</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; creates a FromExpr node<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>FromExpr *<br/></li>
<li><a id="L287">&#x200c;</a><span class="linkable">makeFromExpr</span>(List *fromlist, Node *quals)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FromExpr&nbsp;&nbsp; *f = makeNode(FromExpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; f-&gt;fromlist = fromlist;<br/></li>
<li>&nbsp; &nbsp; f-&gt;quals = quals;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> f;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L301" title="nodes/makefuncs.c:301">makeConst</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; creates a Const node<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Const *<br/></li>
<li><a id="L301">&#x200c;</a><span class="linkable">makeConst</span>(Oid consttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32 consttypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid constcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> constlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum constvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> constisnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> constbyval)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Const&nbsp; &nbsp; &nbsp;&nbsp; *cnst = makeNode(Const);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's a varlena value, force it to be in non-expanded (non-toasted)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * format; this avoids <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> possible dependency on external <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * improves consistency of representation, which is important for <a href="equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!constisnull &amp;&amp; constlen == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constvalue = PointerGetDatum(PG_DETOAST_DATUM(constvalue));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cnst-&gt;consttype = consttype;<br/></li>
<li>&nbsp; &nbsp; cnst-&gt;consttypmod = consttypmod;<br/></li>
<li>&nbsp; &nbsp; cnst-&gt;constcollid = constcollid;<br/></li>
<li>&nbsp; &nbsp; cnst-&gt;constlen = constlen;<br/></li>
<li>&nbsp; &nbsp; cnst-&gt;constvalue = constvalue;<br/></li>
<li>&nbsp; &nbsp; cnst-&gt;constisnull = constisnull;<br/></li>
<li>&nbsp; &nbsp; cnst-&gt;constbyval = constbyval;<br/></li>
<li>&nbsp; &nbsp; cnst-&gt;location = -<span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* &quot;unknown&quot; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cnst;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L339" title="nodes/makefuncs.c:339">makeNullConst</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; creates a Const node representing a NULL of the specified type/typmod<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a convenience routine that just saves a lookup of the type's<br/></li>
<li></span><span class="Comment"> * storage properties.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Const *<br/></li>
<li><a id="L339">&#x200c;</a><span class="linkable">makeNullConst</span>(Oid consttype, int32 consttypmod, Oid constcollid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; typLen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typByVal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L2251" title="utils/cache/lsyscache.c:2251">get_typlenbyval</a>(consttype, &amp;typLen, &amp;typByVal);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L301" title="nodes/makefuncs.c:301">makeConst</a>(consttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; consttypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; constcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) typLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typByVal);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L359" title="nodes/makefuncs.c:359">makeBoolConst</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; creates a Const node representing a boolean value (can be NULL too)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Node *<br/></li>
<li><a id="L359">&#x200c;</a><span class="linkable">makeBoolConst</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> value, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* note that pg_type.h hardwires size of <a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> as 1 ... duplicate it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (Node *) <a href="#L301" title="nodes/makefuncs.c:301">makeConst</a>(BOOLOID, -<span class="Constant">1</span>, InvalidOid, <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BoolGetDatum(value), isnull, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L371" title="nodes/makefuncs.c:371">makeBoolExpr</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; creates a BoolExpr node<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Expr *<br/></li>
<li><a id="L371">&#x200c;</a><span class="linkable">makeBoolExpr</span>(BoolExprType boolop, List *args, <span class="Type">int</span> location)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BoolExpr&nbsp;&nbsp; *b = makeNode(BoolExpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; b-&gt;boolop = boolop;<br/></li>
<li>&nbsp; &nbsp; b-&gt;args = args;<br/></li>
<li>&nbsp; &nbsp; b-&gt;location = location;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Expr *) b;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L389" title="nodes/makefuncs.c:389">makeAlias</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; creates an Alias node<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: the given name is copied, but the colnames list (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) isn't.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Alias *<br/></li>
<li><a id="L389">&#x200c;</a><span class="linkable">makeAlias</span>(<span class="Type">const</span> <span class="Type">char</span> *aliasname, List *colnames)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Alias&nbsp; &nbsp; &nbsp;&nbsp; *a = makeNode(Alias);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; a-&gt;aliasname = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(aliasname);<br/></li>
<li>&nbsp; &nbsp; a-&gt;colnames = colnames;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> a;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L404" title="nodes/makefuncs.c:404">makeRelabelType</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; creates a RelabelType node<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RelabelType *<br/></li>
<li><a id="L404">&#x200c;</a><span class="linkable">makeRelabelType</span>(Expr *arg, Oid rtype, int32 rtypmod, Oid rcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CoercionForm rformat)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelabelType *r = makeNode(RelabelType);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; r-&gt;arg = arg;<br/></li>
<li>&nbsp; &nbsp; r-&gt;resulttype = rtype;<br/></li>
<li>&nbsp; &nbsp; r-&gt;resulttypmod = rtypmod;<br/></li>
<li>&nbsp; &nbsp; r-&gt;resultcollid = rcollid;<br/></li>
<li>&nbsp; &nbsp; r-&gt;relabelformat = rformat;<br/></li>
<li>&nbsp; &nbsp; r-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> r;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L424" title="nodes/makefuncs.c:424">makeRangeVar</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; creates a RangeVar node (rather oversimplified case)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RangeVar *<br/></li>
<li><a id="L424">&#x200c;</a><span class="linkable">makeRangeVar</span>(<span class="Type">char</span> *schemaname, <span class="Type">char</span> *relname, <span class="Type">int</span> location)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeVar&nbsp;&nbsp; *r = makeNode(RangeVar);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; r-&gt;catalogname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; r-&gt;schemaname = schemaname;<br/></li>
<li>&nbsp; &nbsp; r-&gt;relname = relname;<br/></li>
<li>&nbsp; &nbsp; r-&gt;inh = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; r-&gt;relpersistence = RELPERSISTENCE_PERMANENT;<br/></li>
<li>&nbsp; &nbsp; r-&gt;alias = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; r-&gt;location = location;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> r;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L446" title="nodes/makefuncs.c:446">makeTypeName</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; build a TypeName node for an unqualified name.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * typmod is defaulted, but can be changed later by caller.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TypeName *<br/></li>
<li><a id="L446">&#x200c;</a><span class="linkable">makeTypeName</span>(<span class="Type">char</span> *typnam)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L458" title="nodes/makefuncs.c:458">makeTypeNameFromNameList</a>(list_make1(<a href="value.c.html#L63" title="nodes/value.c:63">makeString</a>(typnam)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L458" title="nodes/makefuncs.c:458">makeTypeNameFromNameList</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; build a TypeName node for a String list representing a qualified name.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * typmod is defaulted, but can be changed later by caller.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TypeName *<br/></li>
<li><a id="L458">&#x200c;</a><span class="linkable">makeTypeNameFromNameList</span>(List *names)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TypeName&nbsp;&nbsp; *n = makeNode(TypeName);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; n-&gt;names = names;<br/></li>
<li>&nbsp; &nbsp; n-&gt;typmods = NIL;<br/></li>
<li>&nbsp; &nbsp; n-&gt;typemod = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; n-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> n;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L474" title="nodes/makefuncs.c:474">makeTypeNameFromOid</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; build a TypeName node to represent a type already known by OID/typmod.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TypeName *<br/></li>
<li><a id="L474">&#x200c;</a><span class="linkable">makeTypeNameFromOid</span>(Oid typeOid, int32 typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TypeName&nbsp;&nbsp; *n = makeNode(TypeName);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; n-&gt;typeOid = typeOid;<br/></li>
<li>&nbsp; &nbsp; n-&gt;typemod = typmod;<br/></li>
<li>&nbsp; &nbsp; n-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> n;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L492" title="nodes/makefuncs.c:492">makeColumnDef</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; build a ColumnDef node to represent a simple column definition.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Type and collation are specified by OID.<br/></li>
<li></span><span class="Comment"> * Other properties are all basic to start with.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ColumnDef *<br/></li>
<li><a id="L492">&#x200c;</a><span class="linkable">makeColumnDef</span>(<span class="Type">const</span> <span class="Type">char</span> *colname, Oid typeOid, int32 typmod, Oid collOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ColumnDef&nbsp; *n = makeNode(ColumnDef);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; n-&gt;colname = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(colname);<br/></li>
<li>&nbsp; &nbsp; n-&gt;typeName = <a href="#L474" title="nodes/makefuncs.c:474">makeTypeNameFromOid</a>(typeOid, typmod);<br/></li>
<li>&nbsp; &nbsp; n-&gt;inhcount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; n-&gt;is_local = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; n-&gt;is_not_null = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; n-&gt;is_from_type = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; n-&gt;storage = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; n-&gt;raw_default = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; n-&gt;cooked_default = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; n-&gt;collClause = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; n-&gt;collOid = collOid;<br/></li>
<li>&nbsp; &nbsp; n-&gt;constraints = NIL;<br/></li>
<li>&nbsp; &nbsp; n-&gt;fdwoptions = NIL;<br/></li>
<li>&nbsp; &nbsp; n-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> n;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L521" title="nodes/makefuncs.c:521">makeFuncExpr</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; build an expression tree representing a function call.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The argument expressions must have been transformed already.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>FuncExpr *<br/></li>
<li><a id="L521">&#x200c;</a><span class="linkable">makeFuncExpr</span>(Oid funcid, Oid rettype, List *args,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid funccollid, Oid inputcollid, CoercionForm fformat)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FuncExpr&nbsp;&nbsp; *funcexpr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; funcexpr = makeNode(FuncExpr);<br/></li>
<li>&nbsp; &nbsp; funcexpr-&gt;funcid = funcid;<br/></li>
<li>&nbsp; &nbsp; funcexpr-&gt;funcresulttype = rettype;<br/></li>
<li>&nbsp; &nbsp; funcexpr-&gt;funcretset = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* only allowed case here */<br/></li>
<li></span>&nbsp; &nbsp; funcexpr-&gt;funcvariadic = <span class="Constant">false</span>; <span class="Comment">/* only allowed case here */<br/></li>
<li></span>&nbsp; &nbsp; funcexpr-&gt;funcformat = fformat;<br/></li>
<li>&nbsp; &nbsp; funcexpr-&gt;funccollid = funccollid;<br/></li>
<li>&nbsp; &nbsp; funcexpr-&gt;inputcollid = inputcollid;<br/></li>
<li>&nbsp; &nbsp; funcexpr-&gt;args = args;<br/></li>
<li>&nbsp; &nbsp; funcexpr-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> funcexpr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L545" title="nodes/makefuncs.c:545">makeStringConst</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; build a A_Const node of type T_String for given string<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Node *<br/></li>
<li><a id="L545">&#x200c;</a><span class="linkable">makeStringConst</span>(<span class="Type">char</span> *str, <span class="Type">int</span> location)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; A_Const&nbsp; &nbsp; *n = makeNode(A_Const);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; n-&gt;val.sval.type = T_String;<br/></li>
<li>&nbsp; &nbsp; n-&gt;val.sval.sval = str;<br/></li>
<li>&nbsp; &nbsp; n-&gt;location = location;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Node *) n;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L564" title="nodes/makefuncs.c:564">makeDefElem</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; build a DefElem node<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is sufficient for the &quot;typical&quot; case with an unqualified option name<br/></li>
<li></span><span class="Comment"> * and no special action.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>DefElem *<br/></li>
<li><a id="L564">&#x200c;</a><span class="linkable">makeDefElem</span>(<span class="Type">char</span> *name, Node *arg, <span class="Type">int</span> location)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DefElem&nbsp; &nbsp; *res = makeNode(DefElem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res-&gt;defnamespace = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; res-&gt;defname = name;<br/></li>
<li>&nbsp; &nbsp; res-&gt;arg = arg;<br/></li>
<li>&nbsp; &nbsp; res-&gt;defaction = DEFELEM_UNSPEC;<br/></li>
<li>&nbsp; &nbsp; res-&gt;location = location;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L582" title="nodes/makefuncs.c:582">makeDefElemExtended</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; build a DefElem node with all fields available to be specified<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>DefElem *<br/></li>
<li><a id="L582">&#x200c;</a><span class="linkable">makeDefElemExtended</span>(<span class="Type">char</span> *nameSpace, <span class="Type">char</span> *name, Node *arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DefElemAction defaction, <span class="Type">int</span> location)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DefElem&nbsp; &nbsp; *res = makeNode(DefElem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res-&gt;defnamespace = nameSpace;<br/></li>
<li>&nbsp; &nbsp; res-&gt;defname = name;<br/></li>
<li>&nbsp; &nbsp; res-&gt;arg = arg;<br/></li>
<li>&nbsp; &nbsp; res-&gt;defaction = defaction;<br/></li>
<li>&nbsp; &nbsp; res-&gt;location = location;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L603" title="nodes/makefuncs.c:603">makeFuncCall</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Initialize a FuncCall struct with the information every caller must<br/></li>
<li></span><span class="Comment"> * supply.&nbsp; Any non-default parameters have to be inserted by the caller.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>FuncCall *<br/></li>
<li><a id="L603">&#x200c;</a><span class="linkable">makeFuncCall</span>(List *name, List *args, CoercionForm funcformat, <span class="Type">int</span> location)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FuncCall&nbsp;&nbsp; *n = makeNode(FuncCall);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; n-&gt;funcname = name;<br/></li>
<li>&nbsp; &nbsp; n-&gt;args = args;<br/></li>
<li>&nbsp; &nbsp; n-&gt;agg_order = NIL;<br/></li>
<li>&nbsp; &nbsp; n-&gt;agg_filter = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; n-&gt;over = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; n-&gt;agg_within_group = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; n-&gt;agg_star = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; n-&gt;agg_distinct = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; n-&gt;func_variadic = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; n-&gt;funcformat = funcformat;<br/></li>
<li>&nbsp; &nbsp; n-&gt;location = location;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> n;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L628" title="nodes/makefuncs.c:628">make_opclause</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Creates an operator clause given its operator info, left operand<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; and right operand (pass NULL to create single-operand clause),<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; and collation info.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Expr *<br/></li>
<li><a id="L628">&#x200c;</a><span class="linkable">make_opclause</span>(Oid opno, Oid opresulttype, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> opretset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Expr *leftop, Expr *rightop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid opcollid, Oid inputcollid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; OpExpr&nbsp; &nbsp; &nbsp;&nbsp; *expr = makeNode(OpExpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; expr-&gt;opno = opno;<br/></li>
<li>&nbsp; &nbsp; expr-&gt;opfuncid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; expr-&gt;opresulttype = opresulttype;<br/></li>
<li>&nbsp; &nbsp; expr-&gt;opretset = opretset;<br/></li>
<li>&nbsp; &nbsp; expr-&gt;opcollid = opcollid;<br/></li>
<li>&nbsp; &nbsp; expr-&gt;inputcollid = inputcollid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rightop)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; expr-&gt;args = list_make2(leftop, rightop);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; expr-&gt;args = list_make1(leftop);<br/></li>
<li>&nbsp; &nbsp; expr-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Expr *) expr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L654" title="nodes/makefuncs.c:654">make_andclause</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Creates an 'and' clause given a list of its subclauses.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Expr *<br/></li>
<li><a id="L654">&#x200c;</a><span class="linkable">make_andclause</span>(List *andclauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BoolExpr&nbsp;&nbsp; *expr = makeNode(BoolExpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; expr-&gt;boolop = AND_EXPR;<br/></li>
<li>&nbsp; &nbsp; expr-&gt;args = andclauses;<br/></li>
<li>&nbsp; &nbsp; expr-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Expr *) expr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L670" title="nodes/makefuncs.c:670">make_orclause</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Creates an 'or' clause given a list of its subclauses.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Expr *<br/></li>
<li><a id="L670">&#x200c;</a><span class="linkable">make_orclause</span>(List *orclauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BoolExpr&nbsp;&nbsp; *expr = makeNode(BoolExpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; expr-&gt;boolop = OR_EXPR;<br/></li>
<li>&nbsp; &nbsp; expr-&gt;args = orclauses;<br/></li>
<li>&nbsp; &nbsp; expr-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Expr *) expr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L686" title="nodes/makefuncs.c:686">make_notclause</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Create a 'not' clause given the expression to be negated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Expr *<br/></li>
<li><a id="L686">&#x200c;</a><span class="linkable">make_notclause</span>(Expr *notclause)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BoolExpr&nbsp;&nbsp; *expr = makeNode(BoolExpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; expr-&gt;boolop = NOT_EXPR;<br/></li>
<li>&nbsp; &nbsp; expr-&gt;args = list_make1(notclause);<br/></li>
<li>&nbsp; &nbsp; expr-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Expr *) expr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L707" title="nodes/makefuncs.c:707">make_and_qual</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Variant of <a href="#L654" title="nodes/makefuncs.c:654">make_andclause</a> for ANDing two qual conditions together.<br/></li>
<li></span><span class="Comment"> * Qual conditions have the property that a NULL nodetree is interpreted<br/></li>
<li></span><span class="Comment"> * as 'true'.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: this makes no attempt to preserve AND/OR flatness; so it should not<br/></li>
<li></span><span class="Comment"> * be used on a qual that has already been run through prepqual.c.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Node *<br/></li>
<li><a id="L707">&#x200c;</a><span class="linkable">make_and_qual</span>(Node *qual1, Node *qual2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (qual1 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> qual2;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (qual2 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> qual1;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Node *) <a href="#L654" title="nodes/makefuncs.c:654">make_andclause</a>(list_make2(qual1, qual2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> and executor usually represent qualification expressions<br/></li>
<li></span><span class="Comment"> * as lists of boolean expressions with implicit AND semantics.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> convert between an AND-semantics expression list and the<br/></li>
<li></span><span class="Comment"> * ordinary representation of a boolean expression.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that an empty list is considered equivalent to TRUE.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Expr *<br/></li>
<li><a id="L726">&#x200c;</a><span class="linkable">make_ands_explicit</span>(List *andclauses)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (andclauses == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Expr *) <a href="#L359" title="nodes/makefuncs.c:359">makeBoolConst</a>(<span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (list_length(andclauses) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Expr *) linitial(andclauses);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L654" title="nodes/makefuncs.c:654">make_andclause</a>(andclauses);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>List *<br/></li>
<li><a id="L737">&#x200c;</a><span class="linkable">make_ands_implicit</span>(Expr *clause)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: because the parser sets the qual field to NULL in a query that has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no WHERE clause, we must consider a NULL input clause as TRUE, even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * though one might more reasonably think it FALSE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (clause == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NULL -&gt; NIL list == TRUE */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (is_andclause(clause))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ((BoolExpr *) clause)-&gt;args;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(clause, Const) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !((Const *) clause)-&gt;constisnull &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DatumGetBool(((Const *) clause)-&gt;constvalue))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* constant TRUE input -&gt; NIL list */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> list_make1(clause);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L761" title="nodes/makefuncs.c:761">makeIndexInfo</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; create an IndexInfo node<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexInfo *<br/></li>
<li><a id="L761">&#x200c;</a><span class="linkable">makeIndexInfo</span>(<span class="Type">int</span> numattrs, <span class="Type">int</span> numkeyattrs, Oid amoid, List *expressions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *predicates, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> unique, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nulls_not_distinct,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isready, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> concurrent, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> summarizing)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexInfo&nbsp; *n = makeNode(IndexInfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; n-&gt;ii_NumIndexAttrs = numattrs;<br/></li>
<li>&nbsp; &nbsp; n-&gt;ii_NumIndexKeyAttrs = numkeyattrs;<br/></li>
<li>&nbsp; &nbsp; Assert(n-&gt;ii_NumIndexKeyAttrs != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(n-&gt;ii_NumIndexKeyAttrs &lt;= n-&gt;ii_NumIndexAttrs);<br/></li>
<li>&nbsp; &nbsp; n-&gt;ii_Unique = unique;<br/></li>
<li>&nbsp; &nbsp; n-&gt;ii_NullsNotDistinct = nulls_not_distinct;<br/></li>
<li>&nbsp; &nbsp; n-&gt;ii_ReadyForInserts = isready;<br/></li>
<li>&nbsp; &nbsp; n-&gt;ii_CheckedUnchanged = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; n-&gt;ii_IndexUnchanged = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; n-&gt;ii_Concurrent = concurrent;<br/></li>
<li>&nbsp; &nbsp; n-&gt;ii_Summarizing = summarizing;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* summarizing indexes cannot contain non-key attributes */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!summarizing || (numkeyattrs == numattrs));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* expressions */<br/></li>
<li></span>&nbsp; &nbsp; n-&gt;ii_Expressions = expressions;<br/></li>
<li>&nbsp; &nbsp; n-&gt;ii_ExpressionsState = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* predicates&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; n-&gt;ii_Predicate = predicates;<br/></li>
<li>&nbsp; &nbsp; n-&gt;ii_PredicateState = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* exclusion constraints */<br/></li>
<li></span>&nbsp; &nbsp; n-&gt;ii_ExclusionOps = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; n-&gt;ii_ExclusionProcs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; n-&gt;ii_ExclusionStrats = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* speculative inserts */<br/></li>
<li></span>&nbsp; &nbsp; n-&gt;ii_UniqueOps = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; n-&gt;ii_UniqueProcs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; n-&gt;ii_UniqueStrats = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> index-build state to default */<br/></li>
<li></span>&nbsp; &nbsp; n-&gt;ii_BrokenHotChain = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; n-&gt;ii_ParallelWorkers = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set up for possible use by index AM */<br/></li>
<li></span>&nbsp; &nbsp; n-&gt;ii_Am = amoid;<br/></li>
<li>&nbsp; &nbsp; n-&gt;ii_AmCache = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; n-&gt;ii_Context = <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> n;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L817" title="nodes/makefuncs.c:817">makeGroupingSet</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>GroupingSet *<br/></li>
<li><a id="L817">&#x200c;</a><span class="linkable">makeGroupingSet</span>(GroupingSetKind kind, List *content, <span class="Type">int</span> location)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GroupingSet *n = makeNode(GroupingSet);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; n-&gt;kind = kind;<br/></li>
<li>&nbsp; &nbsp; n-&gt;content = content;<br/></li>
<li>&nbsp; &nbsp; n-&gt;location = location;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> n;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L832" title="nodes/makefuncs.c:832">makeVacuumRelation</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; create a VacuumRelation node<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>VacuumRelation *<br/></li>
<li><a id="L832">&#x200c;</a><span class="linkable">makeVacuumRelation</span>(RangeVar *relation, Oid oid, List *va_cols)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VacuumRelation *v = makeNode(VacuumRelation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; v-&gt;relation = relation;<br/></li>
<li>&nbsp; &nbsp; v-&gt;oid = oid;<br/></li>
<li>&nbsp; &nbsp; v-&gt;va_cols = va_cols;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> v;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L847" title="nodes/makefuncs.c:847">makeJsonFormat</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; creates a JsonFormat node<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>JsonFormat *<br/></li>
<li><a id="L847">&#x200c;</a><span class="linkable">makeJsonFormat</span>(JsonFormatType type, JsonEncoding encoding, <span class="Type">int</span> location)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonFormat *jf = makeNode(JsonFormat);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; jf-&gt;<a href="../utils/adt/format_type.c.html#L60" title="utils/adt/format_type.c:60">format_type</a> = type;<br/></li>
<li>&nbsp; &nbsp; jf-&gt;encoding = encoding;<br/></li>
<li>&nbsp; &nbsp; jf-&gt;location = location;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> jf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L863" title="nodes/makefuncs.c:863">makeJsonValueExpr</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; creates a JsonValueExpr node<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>JsonValueExpr *<br/></li>
<li><a id="L863">&#x200c;</a><span class="linkable">makeJsonValueExpr</span>(Expr *raw_expr, Expr *formatted_expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonFormat *format)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonValueExpr *jve = makeNode(JsonValueExpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; jve-&gt;raw_expr = raw_expr;<br/></li>
<li>&nbsp; &nbsp; jve-&gt;formatted_expr = formatted_expr;<br/></li>
<li>&nbsp; &nbsp; jve-&gt;format = format;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> jve;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L880" title="nodes/makefuncs.c:880">makeJsonBehavior</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; creates a JsonBehavior node<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>JsonBehavior *<br/></li>
<li><a id="L880">&#x200c;</a><span class="linkable">makeJsonBehavior</span>(JsonBehaviorType btype, Node *expr, <span class="Type">int</span> location)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonBehavior *behavior = makeNode(JsonBehavior);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; behavior-&gt;btype = btype;<br/></li>
<li>&nbsp; &nbsp; behavior-&gt;expr = expr;<br/></li>
<li>&nbsp; &nbsp; behavior-&gt;location = location;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> behavior;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L896" title="nodes/makefuncs.c:896">makeJsonKeyValue</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; creates a JsonKeyValue node<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Node *<br/></li>
<li><a id="L896">&#x200c;</a><span class="linkable">makeJsonKeyValue</span>(Node *key, Node *value)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonKeyValue *n = makeNode(JsonKeyValue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; n-&gt;key = (Expr *) key;<br/></li>
<li>&nbsp; &nbsp; n-&gt;value = castNode(JsonValueExpr, value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Node *) n;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L911" title="nodes/makefuncs.c:911">makeJsonIsPredicate</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; creates a JsonIsPredicate node<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Node *<br/></li>
<li><a id="L911">&#x200c;</a><span class="linkable">makeJsonIsPredicate</span>(Node *expr, JsonFormat *format, JsonValueType item_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> unique_keys, <span class="Type">int</span> location)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonIsPredicate *n = makeNode(JsonIsPredicate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; n-&gt;expr = expr;<br/></li>
<li>&nbsp; &nbsp; n-&gt;format = format;<br/></li>
<li>&nbsp; &nbsp; n-&gt;item_type = item_type;<br/></li>
<li>&nbsp; &nbsp; n-&gt;unique_keys = unique_keys;<br/></li>
<li>&nbsp; &nbsp; n-&gt;location = location;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Node *) n;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L930" title="nodes/makefuncs.c:930">makeJsonTablePathSpec</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Make JsonTablePathSpec node from given path string and name (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>JsonTablePathSpec *<br/></li>
<li><a id="L930">&#x200c;</a><span class="linkable">makeJsonTablePathSpec</span>(<span class="Type">char</span> *string, <span class="Type">char</span> *name, <span class="Type">int</span> string_location,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> name_location)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonTablePathSpec *pathspec = makeNode(JsonTablePathSpec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(string != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; pathspec-&gt;string = <a href="#L545" title="nodes/makefuncs.c:545">makeStringConst</a>(string, string_location);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (name != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pathspec-&gt;name = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pathspec-&gt;name_location = name_location;<br/></li>
<li>&nbsp; &nbsp; pathspec-&gt;location = string_location;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pathspec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L951" title="nodes/makefuncs.c:951">makeJsonTablePath</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Make JsonTablePath node for given path string and name<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>JsonTablePath *<br/></li>
<li><a id="L951">&#x200c;</a><span class="linkable">makeJsonTablePath</span>(Const *pathvalue, <span class="Type">char</span> *pathname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonTablePath *path = makeNode(JsonTablePath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(IsA(pathvalue, Const));<br/></li>
<li>&nbsp; &nbsp; path-&gt;value = pathvalue;<br/></li>
<li>&nbsp; &nbsp; path-&gt;name = pathname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> path;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
