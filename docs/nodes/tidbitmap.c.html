<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>nodes/tidbitmap.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>nodes/tidbitmap.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L112">PTEntryArray</a></li>
<li><a href="#L116">PTEntryArray</a></li>
<li><a href="#L209">PTIterationArray</a></li>
<li><a href="#L213">PTIterationArray</a></li>
<li><a href="#L100">PagetableEntry</a></li>
<li><a href="#L107">PagetableEntry</a></li>
<li><a href="#L144">TBMIteratingState</a></li>
<li><a href="#L178">TBMIterator</a></li>
<li><a href="#L219">TBMSharedIterator</a></li>
<li><a href="#L191">TBMSharedIteratorState</a></li>
<li><a href="#L204">TBMSharedIteratorState</a></li>
<li><a href="#L134">TBMStatus</a></li>
<li><a href="#L149">TIDBitmap</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1494">pagetable_allocate</a></li>
<li><a href="#L1522">pagetable_free</a></li>
<li><a href="#L443">tbm_add_page</a></li>
<li><a href="#L377">tbm_add_tuples</a></li>
<li><a href="#L941">tbm_advance_schunkbit</a></li>
<li><a href="#L1461">tbm_attach_shared_iterate</a></li>
<li><a href="#L689">tbm_begin_iterate</a></li>
<li><a href="#L1542">tbm_calculate_entries</a></li>
<li><a href="#L1424">tbm_comparator</a></li>
<li><a href="#L266">tbm_create</a></li>
<li><a href="#L292">tbm_create_pagetable</a></li>
<li><a href="#L1146">tbm_end_iterate</a></li>
<li><a href="#L1158">tbm_end_shared_iterate</a></li>
<li><a href="#L911">tbm_extract_page_tuple</a></li>
<li><a href="#L1169">tbm_find_pageentry</a></li>
<li><a href="#L322">tbm_free</a></li>
<li><a href="#L341">tbm_free_shared_area</a></li>
<li><a href="#L1202">tbm_get_pageentry</a></li>
<li><a href="#L540">tbm_intersect</a></li>
<li><a href="#L589">tbm_intersect_page</a></li>
<li><a href="#L670">tbm_is_empty</a></li>
<li><a href="#L971">tbm_iterate</a></li>
<li><a href="#L1355">tbm_lossify</a></li>
<li><a href="#L1283">tbm_mark_page_lossy</a></li>
<li><a href="#L1249">tbm_page_is_lossy</a></li>
<li><a href="#L766">tbm_prepare_shared_iterate</a></li>
<li><a href="#L1438">tbm_shared_comparator</a></li>
<li><a href="#L1052">tbm_shared_iterate</a></li>
<li><a href="#L458">tbm_union</a></li>
<li><a href="#L481">tbm_union_page</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L79">BITNUM</a></li>
<li><a href="#L57">MAX_TUPLES_PER_PAGE</a></li>
<li><a href="#L74">PAGES_PER_CHUNK</a></li>
<li><a href="#L252">SH_DECLARE</a></li>
<li><a href="#L251">SH_DEFINE</a></li>
<li><a href="#L245">SH_ELEMENT_TYPE</a></li>
<li><a href="#L249">SH_EQUAL</a></li>
<li><a href="#L248">SH_HASH_KEY</a></li>
<li><a href="#L247">SH_KEY</a></li>
<li><a href="#L246">SH_KEY_TYPE</a></li>
<li><a href="#L244">SH_PREFIX</a></li>
<li><a href="#L250">SH_SCOPE</a></li>
<li><a href="#L243">SH_USE_NONDEFAULT_ALLOCATOR</a></li>
<li><a href="#L78">WORDNUM</a></li>
<li><a href="#L84">WORDS_PER_CHUNK</a></li>
<li><a href="#L82">WORDS_PER_PAGE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * tidbitmap.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; PostgreSQL tuple-id (TID) bitmap package<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This module provides bitmap data structures that are spiritually<br/></li>
<li></span><span class="Comment"> * similar to Bitmapsets, but are specially adapted to store sets of<br/></li>
<li></span><span class="Comment"> * tuple identifiers (TIDs), or ItemPointers.&nbsp; In particular, the division<br/></li>
<li></span><span class="Comment"> * of an ItemPointer into BlockNumber and OffsetNumber is catered for.<br/></li>
<li></span><span class="Comment"> * Also, since we wish to be able to store very large tuple sets in<br/></li>
<li></span><span class="Comment"> * memory with this data structure, we support &quot;lossy&quot; storage, in which<br/></li>
<li></span><span class="Comment"> * we no longer remember individual tuple offsets on a page but only the<br/></li>
<li></span><span class="Comment"> * fact that a particular page needs to be visited.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The &quot;lossy&quot; storage uses one <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> per disk page, so at the standard 8K<br/></li>
<li></span><span class="Comment"> * BLCKSZ, we can represent all pages in 64Gb of disk space in about 1Mb<br/></li>
<li></span><span class="Comment"> * of memory.&nbsp; People pushing around tables of that size should have a<br/></li>
<li></span><span class="Comment"> * couple of Mb to spare, so we don't worry about providing a second level<br/></li>
<li></span><span class="Comment"> * of lossiness.&nbsp; In theory we could fall back to page ranges at some<br/></li>
<li></span><span class="Comment"> * point, but for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that seems useless complexity.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also support the notion of candidate matches, or rechecking.&nbsp; This<br/></li>
<li></span><span class="Comment"> * means we know that a search need visit only some tuples on a page,<br/></li>
<li></span><span class="Comment"> * but we are not certain that all of those tuples are real matches.<br/></li>
<li></span><span class="Comment"> * So the eventual heap scan must recheck the quals for these tuples only,<br/></li>
<li></span><span class="Comment"> * rather than rechecking the quals for all tuples on the page as in the<br/></li>
<li></span><span class="Comment"> * lossy-bitmap case.&nbsp; Rechecking can be specified when TIDs are inserted<br/></li>
<li></span><span class="Comment"> * into a bitmap, and it can also happen internally when we AND a lossy<br/></li>
<li></span><span class="Comment"> * and a non-lossy page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2003-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/nodes/tidbitmap.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/hashfn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/int.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/bitmapset.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/tidbitmap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lwlock.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/dsa.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The maximum number of tuples per page is not large (typically 256 with<br/></li>
<li></span><span class="Comment"> * 8K pages, or 1024 with 32K pages).&nbsp; So there's not much point in making<br/></li>
<li></span><span class="Comment"> * the per-page bitmaps variable size.&nbsp; We just legislate that the size<br/></li>
<li></span><span class="Comment"> * is this:<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L57">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_TUPLES_PER_PAGE</span>&nbsp; MaxHeapTuplesPerPage<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * When we have to switch over to lossy storage, we use a data structure<br/></li>
<li></span><span class="Comment"> * with one <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> per page, where all pages having the same number DIV<br/></li>
<li></span><span class="Comment"> * <a href="#L74" title="nodes/tidbitmap.c:74">PAGES_PER_CHUNK</a> are aggregated into one chunk.&nbsp; When a chunk is present<br/></li>
<li></span><span class="Comment"> * and has the <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> set for a given page, there must not be a per-page entry<br/></li>
<li></span><span class="Comment"> * for that page in the page table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We actually store both exact pages and lossy chunks in the same <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment"> * table, using identical data structures.&nbsp; (This is because the memory<br/></li>
<li></span><span class="Comment"> * management for hashtables doesn't easily/efficiently allow space to be<br/></li>
<li></span><span class="Comment"> * transferred easily from one hashtable to another.)&nbsp; Therefore it's best<br/></li>
<li></span><span class="Comment"> * if <a href="#L74" title="nodes/tidbitmap.c:74">PAGES_PER_CHUNK</a> is the same as <a href="#L57" title="nodes/tidbitmap.c:57">MAX_TUPLES_PER_PAGE</a>, or at least not<br/></li>
<li></span><span class="Comment"> * too different.&nbsp; But we also want <a href="#L74" title="nodes/tidbitmap.c:74">PAGES_PER_CHUNK</a> to be a power of 2 to<br/></li>
<li></span><span class="Comment"> * avoid expensive integer remainder operations.&nbsp; So, define it like this:<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L74">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PAGES_PER_CHUNK</span>&nbsp; (BLCKSZ / </span><span class="Constant">32</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* We use BITS_PER_BITMAPWORD and typedef bitmapword from nodes/bitmapset.h */<br/></li>
<li></span><br/></li>
<li><a id="L78">&#x200c;</a><span class="PreProc">#define <span class="linkable">WORDNUM</span>(x)&nbsp; &nbsp; ((x) / BITS_PER_BITMAPWORD)<br/></li>
<li><a id="L79">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BITNUM</span>(x)&nbsp; &nbsp; ((x) % BITS_PER_BITMAPWORD)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* number of active words for an exact page: */<br/></li>
<li><a id="L82">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WORDS_PER_PAGE</span>&nbsp; &nbsp; ((<a href="#L57" title="nodes/tidbitmap.c:57">MAX_TUPLES_PER_PAGE</a> - </span><span class="Constant">1</span><span class="PreProc">) / BITS_PER_BITMAPWORD + </span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li></span><span class="Comment">/* number of active words for a lossy chunk: */<br/></li>
<li><a id="L84">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WORDS_PER_CHUNK</span>&nbsp; ((<a href="#L74" title="nodes/tidbitmap.c:74">PAGES_PER_CHUNK</a> - </span><span class="Constant">1</span><span class="PreProc">) / BITS_PER_BITMAPWORD + </span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The hashtable entries are represented by this data structure.&nbsp; For<br/></li>
<li></span><span class="Comment"> * an exact page, blockno is the page number and <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> k of the bitmap<br/></li>
<li></span><span class="Comment"> * represents tuple offset k+1.&nbsp; For a lossy chunk, blockno is the first<br/></li>
<li></span><span class="Comment"> * page in the chunk (this must be a multiple of <a href="#L74" title="nodes/tidbitmap.c:74">PAGES_PER_CHUNK</a>) and<br/></li>
<li></span><span class="Comment"> * <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> k represents page blockno+k.&nbsp; Note that it is not possible to<br/></li>
<li></span><span class="Comment"> * have exact storage for the first page of a chunk if we are using<br/></li>
<li></span><span class="Comment"> * lossy storage for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> page in the chunk's <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, since the same<br/></li>
<li></span><span class="Comment"> * hashtable entry has to serve both purposes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * recheck is used only on exact pages --- it indicates that although<br/></li>
<li></span><span class="Comment"> * only the stated tuples need be checked, the full index qual condition<br/></li>
<li></span><span class="Comment"> * must be checked for each (ie, these are candidate matches).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L100">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">PagetableEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber blockno;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* page number (hashtable key) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; status;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> entry status */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ischunk;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* T = lossy storage, F = exact */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; recheck;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* should the tuples be rechecked? */<br/></li>
<li></span>&nbsp; &nbsp; bitmapword&nbsp; &nbsp; words[Max(<a href="../access/common/tidstore.c.html#L35" title="access/common/tidstore.c:35">WORDS_PER_PAGE</a>, <a href="#L84" title="nodes/tidbitmap.c:84">WORDS_PER_CHUNK</a>)];<br/></li>
<li><a id="L107">&#x200c;</a>} <span class="linkable">PagetableEntry</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Holds array of pagetable entries.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L112">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">PTEntryArray</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_atomic_uint32 refcount;&nbsp; &nbsp; <span class="Comment">/* no. of iterator attached */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> ptentry[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L116">&#x200c;</a>} <span class="linkable">PTEntryArray</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We want to avoid the overhead of creating the hashtable, which is<br/></li>
<li></span><span class="Comment"> * comparatively large, when not necessary. Particularly when we are using a<br/></li>
<li></span><span class="Comment"> * bitmap scan on the inside of a nestloop join: a bitmap may well live only<br/></li>
<li></span><span class="Comment"> * long enough to accumulate one entry in such cases.&nbsp; We therefore avoid<br/></li>
<li></span><span class="Comment"> * creating an actual hashtable until we need two pagetable entries.&nbsp; When<br/></li>
<li></span><span class="Comment"> * just one pagetable entry is needed, we store it in a fixed field of<br/></li>
<li></span><span class="Comment"> * TIDBitMap.&nbsp; (<a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: we don't get rid of the hashtable if the bitmap later<br/></li>
<li></span><span class="Comment"> * shrinks down to zero or one page again.&nbsp; So, status can be TBM_HASH even<br/></li>
<li></span><span class="Comment"> * when nentries is zero or one.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; TBM_EMPTY,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no hashtable, nentries == 0 */<br/></li>
<li></span>&nbsp; &nbsp; TBM_ONE_PAGE,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* entry1 contains the single entry */<br/></li>
<li></span>&nbsp; &nbsp; TBM_HASH,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pagetable is valid, entry1 is not */<br/></li>
<li><a id="L134">&#x200c;</a></span>} <span class="linkable">TBMStatus</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Current iterating state of the TBM.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; TBM_NOT_ITERATING,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not yet converted to page and chunk array */<br/></li>
<li></span>&nbsp; &nbsp; TBM_ITERATING_PRIVATE,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* converted to local page and chunk array */<br/></li>
<li></span>&nbsp; &nbsp; TBM_ITERATING_SHARED,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* converted to shared page and chunk array */<br/></li>
<li><a id="L144">&#x200c;</a></span>} <span class="linkable">TBMIteratingState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Here is the representation for a whole TIDBitMap:<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L149">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">TIDBitmap</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; NodeTag&nbsp; &nbsp; &nbsp; &nbsp; type;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* to make it a valid Node */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContext mcxt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* memory context containing me */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L134" title="nodes/tidbitmap.c:134">TBMStatus</a>&nbsp; &nbsp; status;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see codes above */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> pagetable_hash *pagetable;&nbsp; &nbsp; <span class="Comment">/* <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table of <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a>'s */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nentries;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of entries in pagetable */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxentries;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* limit on same to meet maxbytes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npages;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of exact entries in pagetable */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nchunks;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of lossy entries in pagetable */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L144" title="nodes/tidbitmap.c:144">TBMIteratingState</a> iterating;&nbsp; &nbsp; <span class="Comment">/* <a href="#L689" title="nodes/tidbitmap.c:689">tbm_begin_iterate</a> called? */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; lossify_start;&nbsp; &nbsp; <span class="Comment">/* offset to start lossifying hashtable at */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> entry1;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* used when status == TBM_ONE_PAGE */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* these are valid when iterating is true: */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> **spages;&nbsp; &nbsp; <span class="Comment">/* sorted exact-page list, or NULL */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> **schunks;&nbsp; &nbsp; <span class="Comment">/* sorted lossy-chunk list, or NULL */<br/></li>
<li></span>&nbsp; &nbsp; dsa_pointer dsapagetable;&nbsp; &nbsp; <span class="Comment">/* dsa_pointer to the <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> array */<br/></li>
<li></span>&nbsp; &nbsp; dsa_pointer dsapagetableold;&nbsp; &nbsp; <span class="Comment">/* dsa_pointer to the old <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> array */<br/></li>
<li></span>&nbsp; &nbsp; dsa_pointer ptpages;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dsa_pointer to the page array */<br/></li>
<li></span>&nbsp; &nbsp; dsa_pointer ptchunks;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dsa_pointer to the chunk array */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/dsa.c.html#L347" title="utils/mmgr/dsa.c:347">dsa_area</a>&nbsp;&nbsp; *dsa;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reference to per-query dsa area */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * When iterating over a bitmap in sorted order, a <a href="#L178" title="nodes/tidbitmap.c:178">TBMIterator</a> is used to<br/></li>
<li></span><span class="Comment"> * track our progress.&nbsp; There can be several iterators scanning the same<br/></li>
<li></span><span class="Comment"> * bitmap concurrently.&nbsp; Note that the bitmap becomes read-only as soon as<br/></li>
<li></span><span class="Comment"> * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> iterator is created.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L178">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">TBMIterator</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a>&nbsp; *tbm;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> we're iterating over */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spageptr;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> spages index */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; schunkptr;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> schunks index */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; schunkbit;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> to check in current schunk */<br/></li>
<li></span>&nbsp; &nbsp; TBMIterateResult output;&nbsp; &nbsp; <span class="Comment">/* MUST BE LAST (because variable-size) */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Holds the shared members of the iterator so that multiple processes<br/></li>
<li></span><span class="Comment"> * can jointly iterate.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L191">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">TBMSharedIteratorState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nentries;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of entries in pagetable */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxentries;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* limit on same to meet maxbytes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npages;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of exact entries in pagetable */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nchunks;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of lossy entries in pagetable */<br/></li>
<li></span>&nbsp; &nbsp; dsa_pointer pagetable;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dsa pointers to head of pagetable data */<br/></li>
<li></span>&nbsp; &nbsp; dsa_pointer spages;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dsa pointer to page array */<br/></li>
<li></span>&nbsp; &nbsp; dsa_pointer schunks;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dsa pointer to chunk array */<br/></li>
<li></span>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp; &nbsp; lock;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* lock to protect below members */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spageptr;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> spages index */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; schunkptr;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> schunks index */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; schunkbit;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> to check in current schunk */<br/></li>
<li><a id="L204">&#x200c;</a></span>} <span class="linkable">TBMSharedIteratorState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * pagetable iteration array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L209">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">PTIterationArray</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_atomic_uint32 refcount;&nbsp; &nbsp; <span class="Comment">/* no. of iterator attached */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index[FLEXIBLE_ARRAY_MEMBER];&nbsp; &nbsp; <span class="Comment">/* index array */<br/></li>
<li><a id="L213">&#x200c;</a></span>} <span class="linkable">PTIterationArray</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * same as <a href="#L178" title="nodes/tidbitmap.c:178">TBMIterator</a>, but it is used for joint iteration, therefore this<br/></li>
<li></span><span class="Comment"> * also holds a reference to the shared state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L219">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">TBMSharedIterator</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L191" title="nodes/tidbitmap.c:191">TBMSharedIteratorState</a> *state;&nbsp; &nbsp; <span class="Comment">/* shared state */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L112" title="nodes/tidbitmap.c:112">PTEntryArray</a> *ptbase;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pagetable <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> array */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L209" title="nodes/tidbitmap.c:209">PTIterationArray</a> *ptpages;&nbsp; &nbsp; <span class="Comment">/* sorted exact page index list */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L209" title="nodes/tidbitmap.c:209">PTIterationArray</a> *ptchunks; <span class="Comment">/* sorted lossy page index list */<br/></li>
<li></span>&nbsp; &nbsp; TBMIterateResult output;&nbsp; &nbsp; <span class="Comment">/* MUST BE LAST (because variable-size) */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Local function prototypes */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L481" title="nodes/tidbitmap.c:481">tbm_union_page</a>(<a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *a, <span class="Type">const</span> <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *bpage);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L589" title="nodes/tidbitmap.c:589">tbm_intersect_page</a>(<a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *a, <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *apage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *b);<br/></li>
<li><span class="Type">static</span> <span class="Type">const</span> <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *<a href="#L1169" title="nodes/tidbitmap.c:1169">tbm_find_pageentry</a>(<span class="Type">const</span> <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *tbm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber pageno);<br/></li>
<li><span class="Type">static</span> <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *<a href="#L1202" title="nodes/tidbitmap.c:1202">tbm_get_pageentry</a>(<a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *tbm, BlockNumber pageno);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1249" title="nodes/tidbitmap.c:1249">tbm_page_is_lossy</a>(<span class="Type">const</span> <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *tbm, BlockNumber pageno);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1283" title="nodes/tidbitmap.c:1283">tbm_mark_page_lossy</a>(<a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *tbm, BlockNumber pageno);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1355" title="nodes/tidbitmap.c:1355">tbm_lossify</a>(<a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *tbm);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1424" title="nodes/tidbitmap.c:1424">tbm_comparator</a>(<span class="Type">const</span> <span class="Type">void</span> *left, <span class="Type">const</span> <span class="Type">void</span> *right);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1438" title="nodes/tidbitmap.c:1438">tbm_shared_comparator</a>(<span class="Type">const</span> <span class="Type">void</span> *left, <span class="Type">const</span> <span class="Type">void</span> *right,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *arg);<br/></li>
<li><br/></li>
<li><span class="Comment">/* define hashtable mapping block numbers to <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a>'s */<br/></li>
<li><a id="L243">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_USE_NONDEFAULT_ALLOCATOR</span><br/></li>
<li><a id="L244">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_PREFIX</span> pagetable<br/></li>
<li><a id="L245">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_ELEMENT_TYPE</span> <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a><br/></li>
<li><a id="L246">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_KEY_TYPE</span> BlockNumber<br/></li>
<li><a id="L247">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_KEY</span> blockno<br/></li>
<li><a id="L248">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_HASH_KEY</span>(tb, key) murmurhash32(key)<br/></li>
<li><a id="L249">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_EQUAL</span>(tb, a, b) a == b<br/></li>
<li><a id="L250">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_SCOPE</span> </span><span class="Type">static</span><span class="PreProc"> </span><span class="Type">inline<br/></li>
<li><a id="L251">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_DEFINE</span><br/></li>
<li><a id="L252">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_DECLARE</span><br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/simplehash.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L266" title="nodes/tidbitmap.c:266">tbm_create</a> - create an initially-empty bitmap<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The bitmap will live in the memory context that is <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a><br/></li>
<li></span><span class="Comment"> * at the time of this call.&nbsp; It will be limited to (approximately) maxbytes<br/></li>
<li></span><span class="Comment"> * total memory consumption.&nbsp; If the DSA passed to this function is not NULL<br/></li>
<li></span><span class="Comment"> * then the memory for storing elements of the underlying page table will<br/></li>
<li></span><span class="Comment"> * be allocated from the DSA.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *<br/></li>
<li><a id="L266">&#x200c;</a><span class="linkable">tbm_create</span>(<span class="Type">long</span> maxbytes, <a href="../utils/mmgr/dsa.c.html#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *dsa)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a>&nbsp; *tbm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> struct and zero all its fields */<br/></li>
<li></span>&nbsp; &nbsp; tbm = makeNode(<a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tbm-&gt;mcxt = <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; tbm-&gt;status = TBM_EMPTY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tbm-&gt;maxentries = (<span class="Type">int</span>) <a href="#L1542" title="nodes/tidbitmap.c:1542">tbm_calculate_entries</a>(maxbytes);<br/></li>
<li>&nbsp; &nbsp; tbm-&gt;lossify_start = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; tbm-&gt;dsa = dsa;<br/></li>
<li>&nbsp; &nbsp; tbm-&gt;dsapagetable = InvalidDsaPointer;<br/></li>
<li>&nbsp; &nbsp; tbm-&gt;dsapagetableold = InvalidDsaPointer;<br/></li>
<li>&nbsp; &nbsp; tbm-&gt;ptpages = InvalidDsaPointer;<br/></li>
<li>&nbsp; &nbsp; tbm-&gt;ptchunks = InvalidDsaPointer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tbm;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Actually create the hashtable.&nbsp; Since this is a moderately expensive<br/></li>
<li></span><span class="Comment"> * proposition, we don't do it until we have to.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L292">&#x200c;</a></span><span class="linkable">tbm_create_pagetable</span>(<a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *tbm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(tbm-&gt;status != TBM_HASH);<br/></li>
<li>&nbsp; &nbsp; Assert(tbm-&gt;pagetable == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tbm-&gt;pagetable = pagetable_create(tbm-&gt;mcxt, <span class="Constant">128</span>, tbm);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If entry1 is valid, <a href="../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> it into the hashtable */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tbm-&gt;status == TBM_ONE_PAGE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; oldstatus;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = pagetable_insert(tbm-&gt;pagetable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tbm-&gt;entry1.blockno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldstatus = page-&gt;status;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(page, &amp;tbm-&gt;entry1, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page-&gt;status = oldstatus;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tbm-&gt;status = TBM_HASH;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L322" title="nodes/tidbitmap.c:322">tbm_free</a> - free a <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L322">&#x200c;</a></span><span class="linkable">tbm_free</span>(<a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *tbm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tbm-&gt;pagetable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pagetable_destroy(tbm-&gt;pagetable);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tbm-&gt;spages)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tbm-&gt;spages);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tbm-&gt;schunks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tbm-&gt;schunks);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tbm);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L341" title="nodes/tidbitmap.c:341">tbm_free_shared_area</a> - free shared state<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Free shared iterator state, Also free shared pagetable and iterator arrays<br/></li>
<li></span><span class="Comment"> * memory if they are not referred by <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the shared iterator i.e recount<br/></li>
<li></span><span class="Comment"> * is becomes 0.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L341">&#x200c;</a></span><span class="linkable">tbm_free_shared_area</span>(<a href="../utils/mmgr/dsa.c.html#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *dsa, dsa_pointer dp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L191" title="nodes/tidbitmap.c:191">TBMSharedIteratorState</a> *istate = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(dsa, dp);<br/></li>
<li>&nbsp; &nbsp; <a href="#L112" title="nodes/tidbitmap.c:112">PTEntryArray</a> *ptbase;<br/></li>
<li>&nbsp; &nbsp; <a href="#L209" title="nodes/tidbitmap.c:209">PTIterationArray</a> *ptpages;<br/></li>
<li>&nbsp; &nbsp; <a href="#L209" title="nodes/tidbitmap.c:209">PTIterationArray</a> *ptchunks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DsaPointerIsValid(istate-&gt;pagetable))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptbase = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(dsa, istate-&gt;pagetable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_atomic_sub_fetch_u32(&amp;ptbase-&gt;refcount, <span class="Constant">1</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/dsa.c.html#L826" title="utils/mmgr/dsa.c:826">dsa_free</a>(dsa, istate-&gt;pagetable);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DsaPointerIsValid(istate-&gt;spages))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptpages = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(dsa, istate-&gt;spages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_atomic_sub_fetch_u32(&amp;ptpages-&gt;refcount, <span class="Constant">1</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/dsa.c.html#L826" title="utils/mmgr/dsa.c:826">dsa_free</a>(dsa, istate-&gt;spages);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DsaPointerIsValid(istate-&gt;schunks))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptchunks = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(dsa, istate-&gt;schunks);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_atomic_sub_fetch_u32(&amp;ptchunks-&gt;refcount, <span class="Constant">1</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/dsa.c.html#L826" title="utils/mmgr/dsa.c:826">dsa_free</a>(dsa, istate-&gt;schunks);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/dsa.c.html#L826" title="utils/mmgr/dsa.c:826">dsa_free</a>(dsa, dp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L377" title="nodes/tidbitmap.c:377">tbm_add_tuples</a> - add some tuple IDs to a <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If recheck is true, then the recheck flag will be set in the<br/></li>
<li></span><span class="Comment"> * TBMIterateResult when <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of these tuples are reported out.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L377">&#x200c;</a></span><span class="linkable">tbm_add_tuples</span>(<a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *tbm, <span class="Type">const</span> ItemPointer tids, <span class="Type">int</span> ntids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recheck)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber currblk = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *page = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* only valid when currblk is valid */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(tbm-&gt;iterating == TBM_NOT_ITERATING);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ntids; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blk = ItemPointerGetBlockNumber(tids + i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber off = ItemPointerGetOffsetNumber(tids + i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wordnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* safety check to ensure we don't overrun <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> array bounds */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (off &lt; <span class="Constant">1</span> || off &gt; <a href="#L57" title="nodes/tidbitmap.c:57">MAX_TUPLES_PER_PAGE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;tuple offset out of <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">%u</span><span class="Constant">&quot;</span>, off);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Look up target page unless we already did.&nbsp; This saves cycles when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the input includes consecutive tuples on the same page, which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * common enough to justify an extra test here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blk != currblk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1249" title="nodes/tidbitmap.c:1249">tbm_page_is_lossy</a>(tbm, blk))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* remember page is lossy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = <a href="#L1202" title="nodes/tidbitmap.c:1202">tbm_get_pageentry</a>(tbm, blk);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currblk = blk;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (page == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* whole page is already marked */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (page-&gt;ischunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The page is a lossy chunk header, set <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> for itself */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wordnum = bitnum = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Page is exact, so set <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> for individual tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wordnum = <a href="../access/common/tidstore.c.html#L31" title="access/common/tidstore.c:31">WORDNUM</a>(off - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitnum = <a href="../access/common/tidstore.c.html#L32" title="access/common/tidstore.c:32">BITNUM</a>(off - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page-&gt;words[wordnum] |= ((bitmapword) <span class="Constant">1</span> &lt;&lt; bitnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page-&gt;recheck |= recheck;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tbm-&gt;nentries &gt; tbm-&gt;maxentries)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1355" title="nodes/tidbitmap.c:1355">tbm_lossify</a>(tbm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Page could have been converted to lossy, so force new lookup */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currblk = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L443" title="nodes/tidbitmap.c:443">tbm_add_page</a> - add a whole page to a <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This causes the whole page to be reported (with the recheck flag)<br/></li>
<li></span><span class="Comment"> * when the <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> is scanned.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L443">&#x200c;</a></span><span class="linkable">tbm_add_page</span>(<a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *tbm, BlockNumber pageno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Enter the page in the bitmap, or mark it lossy if already present */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1283" title="nodes/tidbitmap.c:1283">tbm_mark_page_lossy</a>(tbm, pageno);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we went over the memory limit, lossify some more pages */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tbm-&gt;nentries &gt; tbm-&gt;maxentries)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1355" title="nodes/tidbitmap.c:1355">tbm_lossify</a>(tbm);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L458" title="nodes/tidbitmap.c:458">tbm_union</a> - set union<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * a is modified in-place, b is not changed<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L458">&#x200c;</a></span><span class="linkable">tbm_union</span>(<a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *a, <span class="Type">const</span> <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!a-&gt;iterating);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do if b is empty */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (b-&gt;nentries == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan through chunks and pages in b, <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> into a */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (b-&gt;status == TBM_ONE_PAGE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L481" title="nodes/tidbitmap.c:481">tbm_union_page</a>(a, &amp;b-&gt;entry1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pagetable_iterator i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *bpage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(b-&gt;status == TBM_HASH);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pagetable_start_iterate(b-&gt;pagetable, &amp;i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((bpage = pagetable_iterate(b-&gt;pagetable, &amp;i)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L481" title="nodes/tidbitmap.c:481">tbm_union_page</a>(a, bpage);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Process one page of b during a union op */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L481">&#x200c;</a></span><span class="linkable">tbm_union_page</span>(<a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *a, <span class="Type">const</span> <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *bpage)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *apage;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wordnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bpage-&gt;ischunk)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Scan b's chunk, mark each indicated page lossy in a */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (wordnum = <span class="Constant">0</span>; wordnum &lt; <a href="#L84" title="nodes/tidbitmap.c:84">WORDS_PER_CHUNK</a>; wordnum++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmapword&nbsp; &nbsp; w = bpage-&gt;words[wordnum];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (w != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber pg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg = bpage-&gt;blockno + (wordnum * BITS_PER_BITMAPWORD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (w != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (w &amp; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1283" title="nodes/tidbitmap.c:1283">tbm_mark_page_lossy</a>(a, pg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; w &gt;&gt;= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L1249" title="nodes/tidbitmap.c:1249">tbm_page_is_lossy</a>(a, bpage-&gt;blockno))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* page is already lossy in a, nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; apage = <a href="#L1202" title="nodes/tidbitmap.c:1202">tbm_get_pageentry</a>(a, bpage-&gt;blockno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (apage-&gt;ischunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The page is a lossy chunk header, set <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> for itself */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; apage-&gt;words[<span class="Constant">0</span>] |= ((bitmapword) <span class="Constant">1</span> &lt;&lt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Both pages are exact, <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> at the <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (wordnum = <span class="Constant">0</span>; wordnum &lt; <a href="../access/common/tidstore.c.html#L35" title="access/common/tidstore.c:35">WORDS_PER_PAGE</a>; wordnum++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; apage-&gt;words[wordnum] |= bpage-&gt;words[wordnum];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; apage-&gt;recheck |= bpage-&gt;recheck;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;nentries &gt; a-&gt;maxentries)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1355" title="nodes/tidbitmap.c:1355">tbm_lossify</a>(a);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L540" title="nodes/tidbitmap.c:540">tbm_intersect</a> - set intersection<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * a is modified in-place, b is not changed<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L540">&#x200c;</a></span><span class="linkable">tbm_intersect</span>(<a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *a, <span class="Type">const</span> <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!a-&gt;iterating);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do if a is empty */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;nentries == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan through chunks and pages in a, try to match to b */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;status == TBM_ONE_PAGE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L589" title="nodes/tidbitmap.c:589">tbm_intersect_page</a>(a, &amp;a-&gt;entry1, b))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Page is <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> empty, remove it from a */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!a-&gt;entry1.ischunk);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a-&gt;npages--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a-&gt;nentries--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(a-&gt;nentries == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a-&gt;status = TBM_EMPTY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pagetable_iterator i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *apage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(a-&gt;status == TBM_HASH);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pagetable_start_iterate(a-&gt;pagetable, &amp;i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((apage = pagetable_iterate(a-&gt;pagetable, &amp;i)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L589" title="nodes/tidbitmap.c:589">tbm_intersect_page</a>(a, apage, b))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Page or chunk is <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> empty, remove it from a */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (apage-&gt;ischunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a-&gt;nchunks--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a-&gt;npages--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a-&gt;nentries--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pagetable_delete(a-&gt;pagetable, apage-&gt;blockno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table corrupted&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Process one page of a during an intersection op<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if apage is <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> empty and should be deleted from a<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L589">&#x200c;</a></span><span class="linkable">tbm_intersect_page</span>(<a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *a, <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *apage, <span class="Type">const</span> <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *bpage;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wordnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (apage-&gt;ischunk)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Scan each <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> in chunk, try to clear */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; candelete = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (wordnum = <span class="Constant">0</span>; wordnum &lt; <a href="#L84" title="nodes/tidbitmap.c:84">WORDS_PER_CHUNK</a>; wordnum++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmapword&nbsp; &nbsp; w = apage-&gt;words[wordnum];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (w != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmapword&nbsp; &nbsp; neww = w;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber pg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg = apage-&gt;blockno + (wordnum * BITS_PER_BITMAPWORD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitnum = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (w != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (w &amp; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1249" title="nodes/tidbitmap.c:1249">tbm_page_is_lossy</a>(b, pg) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1169" title="nodes/tidbitmap.c:1169">tbm_find_pageentry</a>(b, pg) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Page is not in b at all, lose lossy <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; neww &amp;= ~((bitmapword) <span class="Constant">1</span> &lt;&lt; bitnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitnum++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; w &gt;&gt;= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; apage-&gt;words[wordnum] = neww;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (neww != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; candelete = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> candelete;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L1249" title="nodes/tidbitmap.c:1249">tbm_page_is_lossy</a>(b, apage-&gt;blockno))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Some of the tuples in 'a' might not satisfy the quals for 'b', but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because the page 'b' is lossy, we don't know which ones. Therefore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we mark 'a' as requiring rechecks, to indicate that at most those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples set in 'a' are matches.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; apage-&gt;recheck = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; candelete = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bpage = <a href="#L1169" title="nodes/tidbitmap.c:1169">tbm_find_pageentry</a>(b, apage-&gt;blockno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bpage != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Both pages are exact, <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> at the <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!bpage-&gt;ischunk);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (wordnum = <span class="Constant">0</span>; wordnum &lt; <a href="../access/common/tidstore.c.html#L35" title="access/common/tidstore.c:35">WORDS_PER_PAGE</a>; wordnum++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; apage-&gt;words[wordnum] &amp;= bpage-&gt;words[wordnum];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (apage-&gt;words[wordnum] != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; candelete = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; apage-&gt;recheck |= bpage-&gt;recheck;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If there is no matching b page, we can just delete the a page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> candelete;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L670" title="nodes/tidbitmap.c:670">tbm_is_empty</a> - is a <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> completely empty?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L670">&#x200c;</a></span><span class="linkable">tbm_is_empty</span>(<span class="Type">const</span> <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *tbm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (tbm-&gt;nentries == <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L689" title="nodes/tidbitmap.c:689">tbm_begin_iterate</a> - prepare to iterate through a <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="#L178" title="nodes/tidbitmap.c:178">TBMIterator</a> struct is created in the caller's memory context.<br/></li>
<li></span><span class="Comment"> * For a clean shutdown of the iteration, call <a href="#L1146" title="nodes/tidbitmap.c:1146">tbm_end_iterate</a>; but it's<br/></li>
<li></span><span class="Comment"> * okay to just allow the memory context to be released, too.&nbsp; It is caller's<br/></li>
<li></span><span class="Comment"> * responsibility not to touch the <a href="#L178" title="nodes/tidbitmap.c:178">TBMIterator</a> anymore once the <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a><br/></li>
<li></span><span class="Comment"> * is freed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: after this is called, it is no longer allowed to modify the contents<br/></li>
<li></span><span class="Comment"> * of the bitmap.&nbsp; However, you can call this multiple times to scan the<br/></li>
<li></span><span class="Comment"> * contents repeatedly, including parallel scans.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L178" title="nodes/tidbitmap.c:178">TBMIterator</a> *<br/></li>
<li><a id="L689">&#x200c;</a><span class="linkable">tbm_begin_iterate</span>(<a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *tbm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L178" title="nodes/tidbitmap.c:178">TBMIterator</a> *iterator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(tbm-&gt;iterating != TBM_ITERATING_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the <a href="#L178" title="nodes/tidbitmap.c:178">TBMIterator</a> struct, with enough trailing space to serve the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needs of the TBMIterateResult sub-struct.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; iterator = (<a href="#L178" title="nodes/tidbitmap.c:178">TBMIterator</a> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L178" title="nodes/tidbitmap.c:178">TBMIterator</a>) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L57" title="nodes/tidbitmap.c:57">MAX_TUPLES_PER_PAGE</a> * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber));<br/></li>
<li>&nbsp; &nbsp; iterator-&gt;tbm = tbm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize iteration pointers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; iterator-&gt;spageptr = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; iterator-&gt;schunkptr = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; iterator-&gt;schunkbit = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have a hashtable, create and fill the sorted page lists, unless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we already did that for a previous iterator.&nbsp; Note that the lists are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attached to the bitmap not the iterator, so they can be used by more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than one iterator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tbm-&gt;status == TBM_HASH &amp;&amp; tbm-&gt;iterating == TBM_NOT_ITERATING)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pagetable_iterator i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nchunks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tbm-&gt;spages &amp;&amp; tbm-&gt;npages &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tbm-&gt;spages = (<a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(tbm-&gt;mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tbm-&gt;npages * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tbm-&gt;schunks &amp;&amp; tbm-&gt;nchunks &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tbm-&gt;schunks = (<a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(tbm-&gt;mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tbm-&gt;nchunks * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; npages = nchunks = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pagetable_start_iterate(tbm-&gt;pagetable, &amp;i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((page = pagetable_iterate(tbm-&gt;pagetable, &amp;i)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (page-&gt;ischunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tbm-&gt;schunks[nchunks++] = page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tbm-&gt;spages[npages++] = page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(npages == tbm-&gt;npages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(nchunks == tbm-&gt;nchunks);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (npages &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qsort(tbm-&gt;spages, npages, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1424" title="nodes/tidbitmap.c:1424">tbm_comparator</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nchunks &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qsort(tbm-&gt;schunks, nchunks, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1424" title="nodes/tidbitmap.c:1424">tbm_comparator</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tbm-&gt;iterating = TBM_ITERATING_PRIVATE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> iterator;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L766" title="nodes/tidbitmap.c:766">tbm_prepare_shared_iterate</a> - prepare shared iteration state for a <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The necessary shared state will be allocated from the DSA passed to<br/></li>
<li></span><span class="Comment"> * <a href="#L266" title="nodes/tidbitmap.c:266">tbm_create</a>, so that multiple processes can attach to it and iterate jointly.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This will convert the pagetable <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> into page and chunk array of the index<br/></li>
<li></span><span class="Comment"> * into pagetable array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>dsa_pointer<br/></li>
<li><a id="L766">&#x200c;</a><span class="linkable">tbm_prepare_shared_iterate</span>(<a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *tbm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dsa_pointer dp;<br/></li>
<li>&nbsp; &nbsp; <a href="#L191" title="nodes/tidbitmap.c:191">TBMSharedIteratorState</a> *istate;<br/></li>
<li>&nbsp; &nbsp; <a href="#L112" title="nodes/tidbitmap.c:112">PTEntryArray</a> *ptbase = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L209" title="nodes/tidbitmap.c:209">PTIterationArray</a> *ptpages = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L209" title="nodes/tidbitmap.c:209">PTIterationArray</a> *ptchunks = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(tbm-&gt;dsa != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(tbm-&gt;iterating != TBM_ITERATING_PRIVATE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate <a href="#L191" title="nodes/tidbitmap.c:191">TBMSharedIteratorState</a> from DSA to hold the shared members and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock, this will also be used by multiple worker for shared iterate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dp = dsa_allocate0(tbm-&gt;dsa, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L191" title="nodes/tidbitmap.c:191">TBMSharedIteratorState</a>));<br/></li>
<li>&nbsp; &nbsp; istate = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(tbm-&gt;dsa, dp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're not already iterating, create and fill the sorted page lists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (If we are, the sorted page lists are already stored in the <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and we can just reuse them.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tbm-&gt;iterating == TBM_NOT_ITERATING)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pagetable_iterator i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nchunks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Allocate the page and chunk array memory from the DSA to share<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * across multiple processes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tbm-&gt;npages)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tbm-&gt;ptpages = dsa_allocate(tbm-&gt;dsa, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L209" title="nodes/tidbitmap.c:209">PTIterationArray</a>) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tbm-&gt;npages * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptpages = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(tbm-&gt;dsa, tbm-&gt;ptpages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_init_u32(&amp;ptpages-&gt;refcount, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tbm-&gt;nchunks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tbm-&gt;ptchunks = dsa_allocate(tbm-&gt;dsa, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L209" title="nodes/tidbitmap.c:209">PTIterationArray</a>) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tbm-&gt;nchunks * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptchunks = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(tbm-&gt;dsa, tbm-&gt;ptchunks);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_init_u32(&amp;ptchunks-&gt;refcount, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If TBM status is TBM_HASH then iterate over the pagetable and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * convert it to page and chunk arrays.&nbsp; But if it's in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * TBM_ONE_PAGE mode then directly allocate the space for one entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from the DSA.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; npages = nchunks = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tbm-&gt;status == TBM_HASH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptbase = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(tbm-&gt;dsa, tbm-&gt;dsapagetable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pagetable_start_iterate(tbm-&gt;pagetable, &amp;i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((page = pagetable_iterate(tbm-&gt;pagetable, &amp;i)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx = page - ptbase-&gt;ptentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (page-&gt;ischunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptchunks-&gt;index[nchunks++] = idx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptpages-&gt;index[npages++] = idx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(npages == tbm-&gt;npages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(nchunks == tbm-&gt;nchunks);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (tbm-&gt;status == TBM_ONE_PAGE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In one page mode allocate the space for one pagetable entry,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> it, and directly store its index (i.e. 0) in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tbm-&gt;dsapagetable = dsa_allocate(tbm-&gt;dsa, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L112" title="nodes/tidbitmap.c:112">PTEntryArray</a>) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptbase = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(tbm-&gt;dsa, tbm-&gt;dsapagetable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptbase-&gt;ptentry, &amp;tbm-&gt;entry1, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptpages-&gt;index[<span class="Constant">0</span>] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptbase != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_init_u32(&amp;ptbase-&gt;refcount, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (npages &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qsort_arg(ptpages-&gt;index, npages, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1438" title="nodes/tidbitmap.c:1438">tbm_shared_comparator</a>, ptbase-&gt;ptentry);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nchunks &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qsort_arg(ptchunks-&gt;index, nchunks, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1438" title="nodes/tidbitmap.c:1438">tbm_shared_comparator</a>, ptbase-&gt;ptentry);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Store the TBM members in the shared state so that we can share them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * across multiple processes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; istate-&gt;nentries = tbm-&gt;nentries;<br/></li>
<li>&nbsp; &nbsp; istate-&gt;maxentries = tbm-&gt;maxentries;<br/></li>
<li>&nbsp; &nbsp; istate-&gt;npages = tbm-&gt;npages;<br/></li>
<li>&nbsp; &nbsp; istate-&gt;nchunks = tbm-&gt;nchunks;<br/></li>
<li>&nbsp; &nbsp; istate-&gt;pagetable = tbm-&gt;dsapagetable;<br/></li>
<li>&nbsp; &nbsp; istate-&gt;spages = tbm-&gt;ptpages;<br/></li>
<li>&nbsp; &nbsp; istate-&gt;schunks = tbm-&gt;ptchunks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ptbase = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(tbm-&gt;dsa, tbm-&gt;dsapagetable);<br/></li>
<li>&nbsp; &nbsp; ptpages = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(tbm-&gt;dsa, tbm-&gt;ptpages);<br/></li>
<li>&nbsp; &nbsp; ptchunks = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(tbm-&gt;dsa, tbm-&gt;ptchunks);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For every shared iterator, referring to pagetable and iterator array,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * increase the refcount by 1 so that while freeing the shared iterator we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't free pagetable and iterator array until its refcount becomes 0.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ptbase != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_add_fetch_u32(&amp;ptbase-&gt;refcount, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ptpages != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_add_fetch_u32(&amp;ptpages-&gt;refcount, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ptchunks != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_add_fetch_u32(&amp;ptchunks-&gt;refcount, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the iterator lock */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L709" title="storage/lmgr/lwlock.c:709">LWLockInitialize</a>(&amp;istate-&gt;lock, LWTRANCHE_SHARED_TIDBITMAP);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the shared iterator state */<br/></li>
<li></span>&nbsp; &nbsp; istate-&gt;schunkbit = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; istate-&gt;schunkptr = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; istate-&gt;spageptr = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tbm-&gt;iterating = TBM_ITERATING_SHARED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> dp;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L911" title="nodes/tidbitmap.c:911">tbm_extract_page_tuple</a> - extract the tuple offsets from a page<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The extracted offsets are stored into TBMIterateResult.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int<br/></li>
<li><a id="L911">&#x200c;</a></span><span class="linkable">tbm_extract_page_tuple</span>(<a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *page, TBMIterateResult *output)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wordnum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntuples = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (wordnum = <span class="Constant">0</span>; wordnum &lt; <a href="../access/common/tidstore.c.html#L35" title="access/common/tidstore.c:35">WORDS_PER_PAGE</a>; wordnum++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitmapword&nbsp; &nbsp; w = page-&gt;words[wordnum];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (w != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off = wordnum * BITS_PER_BITMAPWORD + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (w != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (w &amp; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; output-&gt;offsets[ntuples++] = (OffsetNumber) off;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; w &gt;&gt;= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ntuples;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L941" title="nodes/tidbitmap.c:941">tbm_advance_schunkbit</a> - Advance the schunkbit<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L941">&#x200c;</a></span><span class="linkable">tbm_advance_schunkbit</span>(<a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *chunk, <span class="Type">int</span> *schunkbitp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; schunkbit = *schunkbitp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (schunkbit &lt; <a href="#L74" title="nodes/tidbitmap.c:74">PAGES_PER_CHUNK</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wordnum = <a href="../access/common/tidstore.c.html#L31" title="access/common/tidstore.c:31">WORDNUM</a>(schunkbit);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitnum = <a href="../access/common/tidstore.c.html#L32" title="access/common/tidstore.c:32">BITNUM</a>(schunkbit);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((chunk-&gt;words[wordnum] &amp; ((bitmapword) <span class="Constant">1</span> &lt;&lt; bitnum)) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; schunkbit++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *schunkbitp = schunkbit;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L971" title="nodes/tidbitmap.c:971">tbm_iterate</a> - scan through <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page of a <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a TBMIterateResult representing one page, or NULL if there are<br/></li>
<li></span><span class="Comment"> * no more pages to scan.&nbsp; Pages are guaranteed to be delivered in numerical<br/></li>
<li></span><span class="Comment"> * order.&nbsp; If result-&gt;ntuples &lt; 0, then the bitmap is &quot;lossy&quot; and failed to<br/></li>
<li></span><span class="Comment"> * remember the exact tuples to look at on this page --- the caller must<br/></li>
<li></span><span class="Comment"> * examine all tuples on the page and check if they meet the intended<br/></li>
<li></span><span class="Comment"> * condition.&nbsp; If result-&gt;recheck is true, only the indicated tuples need<br/></li>
<li></span><span class="Comment"> * be examined, but the condition must be rechecked anyway.&nbsp; (For ease of<br/></li>
<li></span><span class="Comment"> * testing, recheck is always set true when ntuples &lt; 0.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TBMIterateResult *<br/></li>
<li><a id="L971">&#x200c;</a><span class="linkable">tbm_iterate</span>(<a href="#L178" title="nodes/tidbitmap.c:178">TBMIterator</a> *iterator)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a>&nbsp; *tbm = iterator-&gt;tbm;<br/></li>
<li>&nbsp; &nbsp; TBMIterateResult *output = &amp;(iterator-&gt;output);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(tbm-&gt;iterating == TBM_ITERATING_PRIVATE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If lossy chunk pages remain, make sure we've advanced schunkptr/<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * schunkbit to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> set <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (iterator-&gt;schunkptr &lt; tbm-&gt;nchunks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *chunk = tbm-&gt;schunks[iterator-&gt;schunkptr];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; schunkbit = iterator-&gt;schunkbit;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L941" title="nodes/tidbitmap.c:941">tbm_advance_schunkbit</a>(chunk, &amp;schunkbit);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (schunkbit &lt; <a href="#L74" title="nodes/tidbitmap.c:74">PAGES_PER_CHUNK</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iterator-&gt;schunkbit = schunkbit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* advance to <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> chunk */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; iterator-&gt;schunkptr++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iterator-&gt;schunkbit = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If both chunk and per-page data remain, must output the numerically<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * earlier page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (iterator-&gt;schunkptr &lt; tbm-&gt;nchunks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *chunk = tbm-&gt;schunks[iterator-&gt;schunkptr];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber chunk_blockno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; chunk_blockno = chunk-&gt;blockno + iterator-&gt;schunkbit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (iterator-&gt;spageptr &gt;= tbm-&gt;npages ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunk_blockno &lt; tbm-&gt;spages[iterator-&gt;spageptr]-&gt;blockno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Return a lossy page indicator from the chunk */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; output-&gt;blockno = chunk_blockno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; output-&gt;ntuples = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; output-&gt;recheck = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iterator-&gt;schunkbit++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> output;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (iterator-&gt;spageptr &lt; tbm-&gt;npages)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In TBM_ONE_PAGE state, we don't allocate an spages[] array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tbm-&gt;status == TBM_ONE_PAGE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = &amp;tbm-&gt;entry1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = tbm-&gt;spages[iterator-&gt;spageptr];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* scan bitmap to extract individual offset numbers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ntuples = <a href="#L911" title="nodes/tidbitmap.c:911">tbm_extract_page_tuple</a>(page, output);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; output-&gt;blockno = page-&gt;blockno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; output-&gt;ntuples = ntuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; output-&gt;recheck = page-&gt;recheck;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iterator-&gt;spageptr++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> output;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing more in the bitmap */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1052" title="nodes/tidbitmap.c:1052">tbm_shared_iterate</a> - scan through <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page of a <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; As above, but this will iterate using an iterator which is shared<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; across multiple processes.&nbsp; We need to acquire the iterator LWLock,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> accessing the shared members.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TBMIterateResult *<br/></li>
<li><a id="L1052">&#x200c;</a><span class="linkable">tbm_shared_iterate</span>(<a href="#L219" title="nodes/tidbitmap.c:219">TBMSharedIterator</a> *iterator)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TBMIterateResult *output = &amp;iterator-&gt;output;<br/></li>
<li>&nbsp; &nbsp; <a href="#L191" title="nodes/tidbitmap.c:191">TBMSharedIteratorState</a> *istate = iterator-&gt;state;<br/></li>
<li>&nbsp; &nbsp; <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *ptbase = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *idxpages = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *idxchunks = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (iterator-&gt;ptbase != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptbase = iterator-&gt;ptbase-&gt;ptentry;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (iterator-&gt;ptpages != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idxpages = iterator-&gt;ptpages-&gt;index;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (iterator-&gt;ptchunks != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idxchunks = iterator-&gt;ptchunks-&gt;index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Acquire the LWLock <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> accessing the shared members */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;istate-&gt;lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If lossy chunk pages remain, make sure we've advanced schunkptr/<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * schunkbit to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> set <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (istate-&gt;schunkptr &lt; istate-&gt;nchunks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *chunk = &amp;ptbase[idxchunks[istate-&gt;schunkptr]];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; schunkbit = istate-&gt;schunkbit;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L941" title="nodes/tidbitmap.c:941">tbm_advance_schunkbit</a>(chunk, &amp;schunkbit);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (schunkbit &lt; <a href="#L74" title="nodes/tidbitmap.c:74">PAGES_PER_CHUNK</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; istate-&gt;schunkbit = schunkbit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* advance to <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> chunk */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; istate-&gt;schunkptr++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; istate-&gt;schunkbit = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If both chunk and per-page data remain, must output the numerically<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * earlier page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (istate-&gt;schunkptr &lt; istate-&gt;nchunks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *chunk = &amp;ptbase[idxchunks[istate-&gt;schunkptr]];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber chunk_blockno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; chunk_blockno = chunk-&gt;blockno + istate-&gt;schunkbit;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (istate-&gt;spageptr &gt;= istate-&gt;npages ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunk_blockno &lt; ptbase[idxpages[istate-&gt;spageptr]].blockno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Return a lossy page indicator from the chunk */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; output-&gt;blockno = chunk_blockno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; output-&gt;ntuples = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; output-&gt;recheck = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; istate-&gt;schunkbit++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;istate-&gt;lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> output;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (istate-&gt;spageptr &lt; istate-&gt;npages)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *page = &amp;ptbase[idxpages[istate-&gt;spageptr]];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* scan bitmap to extract individual offset numbers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ntuples = <a href="#L911" title="nodes/tidbitmap.c:911">tbm_extract_page_tuple</a>(page, output);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; output-&gt;blockno = page-&gt;blockno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; output-&gt;ntuples = ntuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; output-&gt;recheck = page-&gt;recheck;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; istate-&gt;spageptr++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;istate-&gt;lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> output;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;istate-&gt;lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing more in the bitmap */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1146" title="nodes/tidbitmap.c:1146">tbm_end_iterate</a> - finish an iteration over a <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently this is just a <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>, but it might do more someday.&nbsp; (For<br/></li>
<li></span><span class="Comment"> * instance, it could be useful to count open iterators and allow the<br/></li>
<li></span><span class="Comment"> * bitmap to return to read/write status when there are no more iterators.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1146">&#x200c;</a></span><span class="linkable">tbm_end_iterate</span>(<a href="#L178" title="nodes/tidbitmap.c:178">TBMIterator</a> *iterator)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(iterator);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1158" title="nodes/tidbitmap.c:1158">tbm_end_shared_iterate</a> - finish a shared iteration over a <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This doesn't free <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the shared state associated with the iterator,<br/></li>
<li></span><span class="Comment"> * just our backend-private state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1158">&#x200c;</a></span><span class="linkable">tbm_end_shared_iterate</span>(<a href="#L219" title="nodes/tidbitmap.c:219">TBMSharedIterator</a> *iterator)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(iterator);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1169" title="nodes/tidbitmap.c:1169">tbm_find_pageentry</a> - <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> for the pageno<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns NULL if there is no non-lossy entry for the pageno.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *<br/></li>
<li><a id="L1169">&#x200c;</a><span class="linkable">tbm_find_pageentry</span>(<span class="Type">const</span> <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *tbm, BlockNumber pageno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tbm-&gt;nentries == <span class="Constant">0</span>)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* in case pagetable doesn't exist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tbm-&gt;status == TBM_ONE_PAGE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = &amp;tbm-&gt;entry1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (page-&gt;blockno != pageno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!page-&gt;ischunk);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> page;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = pagetable_lookup(tbm-&gt;pagetable, pageno);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (page == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (page-&gt;ischunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't want a lossy chunk header */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> page;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1202" title="nodes/tidbitmap.c:1202">tbm_get_pageentry</a> - <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> or create a <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> for the pageno<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If new, the entry is marked as an exact (non-chunk) entry.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This may cause the table to exceed the desired memory size.&nbsp; It is<br/></li>
<li></span><span class="Comment"> * up to the caller to call <a href="#L1355" title="nodes/tidbitmap.c:1355">tbm_lossify</a>() at the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> safe point if so.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *<br/></li>
<li><a id="L1202">&#x200c;</a><span class="linkable">tbm_get_pageentry</span>(<a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *tbm, BlockNumber pageno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *page;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tbm-&gt;status == TBM_EMPTY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use the fixed slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; page = &amp;tbm-&gt;entry1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tbm-&gt;status = TBM_ONE_PAGE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tbm-&gt;status == TBM_ONE_PAGE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = &amp;tbm-&gt;entry1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (page-&gt;blockno == pageno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Time to switch from one page to a hashtable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L292" title="nodes/tidbitmap.c:292">tbm_create_pagetable</a>(tbm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Look up or create an entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; page = pagetable_insert(tbm-&gt;pagetable, pageno, &amp;found);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize it if not present <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; oldstatus = page-&gt;status;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(page, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page-&gt;status = oldstatus;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page-&gt;blockno = pageno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must count it too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tbm-&gt;nentries++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tbm-&gt;npages++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> page;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1249" title="nodes/tidbitmap.c:1249">tbm_page_is_lossy</a> - is the page marked as lossily stored?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1249">&#x200c;</a></span><span class="linkable">tbm_page_is_lossy</span>(<span class="Type">const</span> <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *tbm, BlockNumber pageno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *page;<br/></li>
<li>&nbsp; &nbsp; BlockNumber chunk_pageno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we can <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the lookup if there are no lossy chunks */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tbm-&gt;nchunks == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; Assert(tbm-&gt;status == TBM_HASH);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bitno = pageno % <a href="#L74" title="nodes/tidbitmap.c:74">PAGES_PER_CHUNK</a>;<br/></li>
<li>&nbsp; &nbsp; chunk_pageno = pageno - bitno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = pagetable_lookup(tbm-&gt;pagetable, chunk_pageno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (page != <span class="Constant">NULL</span> &amp;&amp; page-&gt;ischunk)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wordnum = <a href="../access/common/tidstore.c.html#L31" title="access/common/tidstore.c:31">WORDNUM</a>(bitno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitnum = <a href="../access/common/tidstore.c.html#L32" title="access/common/tidstore.c:32">BITNUM</a>(bitno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((page-&gt;words[wordnum] &amp; ((bitmapword) <span class="Constant">1</span> &lt;&lt; bitnum)) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1283" title="nodes/tidbitmap.c:1283">tbm_mark_page_lossy</a> - mark the page number as lossily stored<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This may cause the table to exceed the desired memory size.&nbsp; It is<br/></li>
<li></span><span class="Comment"> * up to the caller to call <a href="#L1355" title="nodes/tidbitmap.c:1355">tbm_lossify</a>() at the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> safe point if so.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1283">&#x200c;</a></span><span class="linkable">tbm_mark_page_lossy</span>(<a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *tbm, BlockNumber pageno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *page;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; BlockNumber chunk_pageno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wordnum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We force the bitmap into hashtable mode whenever it's lossy */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tbm-&gt;status != TBM_HASH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L292" title="nodes/tidbitmap.c:292">tbm_create_pagetable</a>(tbm);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bitno = pageno % <a href="#L74" title="nodes/tidbitmap.c:74">PAGES_PER_CHUNK</a>;<br/></li>
<li>&nbsp; &nbsp; chunk_pageno = pageno - bitno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remove <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> extant non-lossy entry for the page.&nbsp; If the page is its own<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * chunk header, however, we <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this and handle the case below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bitno != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pagetable_delete(tbm-&gt;pagetable, pageno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It was present, so adjust counts */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tbm-&gt;nentries--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tbm-&gt;npages--;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* assume it must have been non-lossy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look up or create entry for chunk-header page */<br/></li>
<li></span>&nbsp; &nbsp; page = pagetable_insert(tbm-&gt;pagetable, chunk_pageno, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize it if not present <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; oldstatus = page-&gt;status;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(page, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page-&gt;status = oldstatus;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page-&gt;blockno = chunk_pageno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page-&gt;ischunk = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must count it too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tbm-&gt;nentries++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tbm-&gt;nchunks++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!page-&gt;ischunk)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; oldstatus = page-&gt;status;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* chunk header page was formerly non-lossy, make it lossy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(page, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page-&gt;status = oldstatus;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page-&gt;blockno = chunk_pageno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page-&gt;ischunk = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we assume it had some tuple <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>(s) set, so mark it lossy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; page-&gt;words[<span class="Constant">0</span>] = ((bitmapword) <span class="Constant">1</span> &lt;&lt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* adjust counts */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tbm-&gt;nchunks++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tbm-&gt;npages--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now set the original target page's <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> */<br/></li>
<li></span>&nbsp; &nbsp; wordnum = <a href="../access/common/tidstore.c.html#L31" title="access/common/tidstore.c:31">WORDNUM</a>(bitno);<br/></li>
<li>&nbsp; &nbsp; bitnum = <a href="../access/common/tidstore.c.html#L32" title="access/common/tidstore.c:32">BITNUM</a>(bitno);<br/></li>
<li>&nbsp; &nbsp; page-&gt;words[wordnum] |= ((bitmapword) <span class="Constant">1</span> &lt;&lt; bitnum);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1355" title="nodes/tidbitmap.c:1355">tbm_lossify</a> - lose some information to get back under the memory limit<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1355">&#x200c;</a></span><span class="linkable">tbm_lossify</span>(<a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *tbm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pagetable_iterator i;<br/></li>
<li>&nbsp; &nbsp; <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> Really stupid implementation: this just lossifies pages in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * essentially random order.&nbsp; We should be paying some attention to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number of bits set in each page, instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we are called as soon as nentries exceeds maxentries, we should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> nentries down to significantly less than maxentries, or else we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just end up doing this again very soon.&nbsp; We shoot for maxentries/2.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(tbm-&gt;iterating == TBM_NOT_ITERATING);<br/></li>
<li>&nbsp; &nbsp; Assert(tbm-&gt;status == TBM_HASH);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pagetable_start_iterate_at(tbm-&gt;pagetable, &amp;i, tbm-&gt;lossify_start);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((page = pagetable_iterate(tbm-&gt;pagetable, &amp;i)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (page-&gt;ischunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* already a chunk header */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the page would become a chunk header, we won't save anything by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * converting it to lossy, so <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((page-&gt;blockno % <a href="#L74" title="nodes/tidbitmap.c:74">PAGES_PER_CHUNK</a>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This does the dirty work ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1283" title="nodes/tidbitmap.c:1283">tbm_mark_page_lossy</a>(tbm, page-&gt;blockno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tbm-&gt;nentries &lt;= tbm-&gt;maxentries / <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have made enough room. Remember where to start lossifying<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> round, so we evenly iterate over the hashtable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tbm-&gt;lossify_start = i.cur;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: <a href="#L1283" title="nodes/tidbitmap.c:1283">tbm_mark_page_lossy</a> may have inserted a lossy chunk into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hashtable and may have deleted the non-lossy chunk.&nbsp; We can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * continue the same <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table scan, since failure to visit one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> or visiting the newly inserted <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, isn't fatal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * With a big bitmap and small <a href="../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>, it's possible that we cannot get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * under maxentries.&nbsp; Again, if that happens, we'd end up uselessly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calling <a href="#L1355" title="nodes/tidbitmap.c:1355">tbm_lossify</a> over and over.&nbsp; To prevent this from becoming a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * performance sink, force maxentries up to at least double the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number of entries.&nbsp; (In essence, we're admitting inability to fit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * within <a href="../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a> when we do this.)&nbsp; Note that this test will not fire if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we broke out of the loop early; and if we didn't, the current number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entries is simply not reducible <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> further.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tbm-&gt;nentries &gt; tbm-&gt;maxentries / <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tbm-&gt;maxentries = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(tbm-&gt;nentries, (<span class="Constant">INT_MAX</span> - <span class="Constant">1</span>) / <span class="Constant">2</span>) * <span class="Constant">2</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * qsort comparator to handle <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> pointers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1424">&#x200c;</a></span><span class="linkable">tbm_comparator</span>(<span class="Type">const</span> <span class="Type">void</span> *left, <span class="Type">const</span> <span class="Type">void</span> *right)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber l = (*((<a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *<span class="Type">const</span> *) left))-&gt;blockno;<br/></li>
<li>&nbsp; &nbsp; BlockNumber r = (*((<a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *<span class="Type">const</span> *) right))-&gt;blockno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_cmp_u32(l, r);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * As above, but this will get index into <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> array.&nbsp; Therefore,<br/></li>
<li></span><span class="Comment"> * it needs to get actual <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> using the index <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> comparing the<br/></li>
<li></span><span class="Comment"> * blockno.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1438">&#x200c;</a></span><span class="linkable">tbm_shared_comparator</span>(<span class="Type">const</span> <span class="Type">void</span> *left, <span class="Type">const</span> <span class="Type">void</span> *right, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *base = (<a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *) arg;<br/></li>
<li>&nbsp; &nbsp; <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *lpage = &amp;base[*(<span class="Type">int</span> *) left];<br/></li>
<li>&nbsp; &nbsp; <a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> *rpage = &amp;base[*(<span class="Type">int</span> *) right];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lpage-&gt;blockno &lt; rpage-&gt;blockno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (lpage-&gt;blockno &gt; rpage-&gt;blockno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1461" title="nodes/tidbitmap.c:1461">tbm_attach_shared_iterate</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Allocate a backend-private iterator and attach the shared iterator state<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; to it so that multiple processed can iterate jointly.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; We also converts the DSA pointers to local pointers and store them into<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; our private iterator.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L219" title="nodes/tidbitmap.c:219">TBMSharedIterator</a> *<br/></li>
<li><a id="L1461">&#x200c;</a><span class="linkable">tbm_attach_shared_iterate</span>(<a href="../utils/mmgr/dsa.c.html#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *dsa, dsa_pointer dp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L219" title="nodes/tidbitmap.c:219">TBMSharedIterator</a> *iterator;<br/></li>
<li>&nbsp; &nbsp; <a href="#L191" title="nodes/tidbitmap.c:191">TBMSharedIteratorState</a> *istate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the <a href="#L219" title="nodes/tidbitmap.c:219">TBMSharedIterator</a> struct, with enough trailing space to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * serve the needs of the TBMIterateResult sub-struct.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; iterator = (<a href="#L219" title="nodes/tidbitmap.c:219">TBMSharedIterator</a> *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L219" title="nodes/tidbitmap.c:219">TBMSharedIterator</a>) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L57" title="nodes/tidbitmap.c:57">MAX_TUPLES_PER_PAGE</a> * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; istate = (<a href="#L191" title="nodes/tidbitmap.c:191">TBMSharedIteratorState</a> *) <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(dsa, dp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; iterator-&gt;state = istate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; iterator-&gt;ptbase = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(dsa, istate-&gt;pagetable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (istate-&gt;npages)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iterator-&gt;ptpages = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(dsa, istate-&gt;spages);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (istate-&gt;nchunks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iterator-&gt;ptchunks = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(dsa, istate-&gt;schunks);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> iterator;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1494" title="nodes/tidbitmap.c:1494">pagetable_allocate</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Callback function for allocating the memory for hashtable elements.<br/></li>
<li></span><span class="Comment"> * Allocate memory for hashtable elements, using DSA if available.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> *<br/></li>
<li><a id="L1494">&#x200c;</a><span class="linkable">pagetable_allocate</span>(pagetable_hash *pagetable, Size size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a>&nbsp; *tbm = (<a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *) pagetable-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; <a href="#L112" title="nodes/tidbitmap.c:112">PTEntryArray</a> *ptbase;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tbm-&gt;dsa == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../utils/mmgr/mcxt.c.html#L1237" title="utils/mmgr/mcxt.c:1237">MemoryContextAllocExtended</a>(pagetable-&gt;ctx, size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MCXT_ALLOC_HUGE | MCXT_ALLOC_ZERO);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Save the dsapagetable reference in dsapagetableold <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> allocating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new memory so that <a href="#L1522" title="nodes/tidbitmap.c:1522">pagetable_free</a> can free the old entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tbm-&gt;dsapagetableold = tbm-&gt;dsapagetable;<br/></li>
<li>&nbsp; &nbsp; tbm-&gt;dsapagetable = <a href="../utils/mmgr/dsa.c.html#L671" title="utils/mmgr/dsa.c:671">dsa_allocate_extended</a>(tbm-&gt;dsa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L112" title="nodes/tidbitmap.c:112">PTEntryArray</a>) + size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DSA_ALLOC_HUGE | DSA_ALLOC_ZERO);<br/></li>
<li>&nbsp; &nbsp; ptbase = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(tbm-&gt;dsa, tbm-&gt;dsapagetable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ptbase-&gt;ptentry;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1522" title="nodes/tidbitmap.c:1522">pagetable_free</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Callback function for freeing <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table elements.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L1522">&#x200c;</a></span><span class="linkable">pagetable_free</span>(pagetable_hash *pagetable, <span class="Type">void</span> *pointer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a>&nbsp; *tbm = (<a href="#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *) pagetable-&gt;private_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> the input pointer if DSA is not available */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tbm-&gt;dsa == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pointer);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (DsaPointerIsValid(tbm-&gt;dsapagetableold))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/dsa.c.html#L826" title="utils/mmgr/dsa.c:826">dsa_free</a>(tbm-&gt;dsa, tbm-&gt;dsapagetableold);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tbm-&gt;dsapagetableold = InvalidDsaPointer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1542" title="nodes/tidbitmap.c:1542">tbm_calculate_entries</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Estimate number of hashtable entries we can have within maxbytes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">long<br/></li>
<li><a id="L1542">&#x200c;</a></span><span class="linkable">tbm_calculate_entries</span>(<span class="Type">double</span> maxbytes)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; nbuckets;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate number of hashtable entries we can have within maxbytes. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimates the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> cost as <a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(<a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a>), which is good enough<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for our purpose.&nbsp; Also count an extra Pointer per entry for the arrays<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * created during iteration readout.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nbuckets = maxbytes /<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a>) + <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Pointer) + <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Pointer));<br/></li>
<li>&nbsp; &nbsp; nbuckets = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(nbuckets, <span class="Constant">INT_MAX</span> - <span class="Constant">1</span>);&nbsp; &nbsp; <span class="Comment">/* safety limit */<br/></li>
<li></span>&nbsp; &nbsp; nbuckets = Max(nbuckets, <span class="Constant">16</span>);&nbsp; &nbsp; <span class="Comment">/* sanity limit */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nbuckets;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
