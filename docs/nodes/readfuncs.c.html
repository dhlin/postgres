<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>nodes/readfuncs.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>nodes/readfuncs.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L304">_readA_Const</a></li>
<li><a href="#L439">_readA_Expr</a></li>
<li><a href="#L203">_readBitmapset</a></li>
<li><a href="#L281">_readBoolExpr</a></li>
<li><a href="#L259">_readConst</a></li>
<li><a href="#L526">_readExtensibleNode</a></li>
<li><a href="#L347">_readRangeTblEntry</a></li>
<li><a href="#L182">nullable_string</a></li>
<li><a href="#L562">parseNodeString</a></li>
<li><a href="#L245">readBitmapset</a></li>
<li><a href="#L589">readDatum</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L571">MATCH</a></li>
<li><a href="#L147">READ_ATTRNUMBER_ARRAY</a></li>
<li><a href="#L141">READ_BITMAPSET_FIELD</a></li>
<li><a href="#L162">READ_BOOL_ARRAY</a></li>
<li><a href="#L109">READ_BOOL_FIELD</a></li>
<li><a href="#L90">READ_CHAR_FIELD</a></li>
<li><a href="#L167">READ_DONE</a></li>
<li><a href="#L97">READ_ENUM_FIELD</a></li>
<li><a href="#L103">READ_FLOAT_FIELD</a></li>
<li><a href="#L157">READ_INT_ARRAY</a></li>
<li><a href="#L60">READ_INT_FIELD</a></li>
<li><a href="#L55">READ_LOCALS</a></li>
<li><a href="#L46">READ_LOCALS_NO_FIELDS</a></li>
<li><a href="#L122">READ_LOCATION_FIELD</a></li>
<li><a href="#L127">READ_LOCATION_FIELD</a></li>
<li><a href="#L78">READ_LONG_FIELD</a></li>
<li><a href="#L135">READ_NODE_FIELD</a></li>
<li><a href="#L152">READ_OID_ARRAY</a></li>
<li><a href="#L84">READ_OID_FIELD</a></li>
<li><a href="#L650">READ_SCALAR_ARRAY</a></li>
<li><a href="#L115">READ_STRING_FIELD</a></li>
<li><a href="#L50">READ_TEMP_LOCALS</a></li>
<li><a href="#L72">READ_UINT64_FIELD</a></li>
<li><a href="#L66">READ_UINT_FIELD</a></li>
<li><a href="#L177">atoui</a></li>
<li><a href="#L179">strtobool</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * readfuncs.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Reader <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for Postgres tree nodes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/nodes/readfuncs.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Parse location fields are written out by outfuncs.c, but only for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; debugging use.&nbsp; When reading a location field, we normally discard<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the stored value and set the location field to -1 (ie, &quot;unknown&quot;).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; This is because nodes coming from a stored rule should not be thought<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; to have a known location in the current query's text.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; However, if <a href="read.c.html#L36" title="nodes/read.c:36">restore_location_fields</a> is true, we do restore location<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; fields from the string.&nbsp; This is currently intended only for use by the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; WRITE_READ_PARSE_PLAN_TREES test code, which doesn't want to cause<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> change in the node contents.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/bitmapset.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/readfuncs.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Macros to simplify reading of different kinds of fields.&nbsp; Use these<br/></li>
<li></span><span class="Comment"> * wherever possible to reduce the chance for silly typos.&nbsp; Note that these<br/></li>
<li></span><span class="Comment"> * hard-wire conventions about the names of the local variables in a Read<br/></li>
<li></span><span class="Comment"> * routine.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Macros for declaring appropriate local variables */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* A few guys need only local_node */<br/></li>
<li><a id="L46">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">READ_LOCALS_NO_FIELDS</span>(nodeTypeName) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; nodeTypeName *local_node = makeNode(nodeTypeName)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* And a few guys need only the <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a> support fields */<br/></li>
<li><a id="L50">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">READ_TEMP_LOCALS</span>()&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Type">const</span><span class="PreProc"> </span><span class="Type">char</span><span class="PreProc"> *token;&nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Type">int</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; length<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* ... but most need both */<br/></li>
<li><a id="L55">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">READ_LOCALS</span>(nodeTypeName)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; <a href="#L46" title="nodes/readfuncs.c:46">READ_LOCALS_NO_FIELDS</a>(nodeTypeName);&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; <a href="#L50" title="nodes/readfuncs.c:50">READ_TEMP_LOCALS</a>()<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Read an integer field (anything written as &quot;:fldname %d&quot;) */<br/></li>
<li><a id="L60">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">READ_INT_FIELD</span>(fldname) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> :fldname */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* get field value */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; local_node-&gt;fldname = atoi(token)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Read an unsigned integer field (anything written as &quot;:fldname %u&quot;) */<br/></li>
<li><a id="L66">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">READ_UINT_FIELD</span>(fldname) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> :fldname */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* get field value */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; local_node-&gt;fldname = <a href="#L177" title="nodes/readfuncs.c:177">atoui</a>(token)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Read an unsigned integer field (anything written using UINT64_FORMAT) */<br/></li>
<li><a id="L72">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">READ_UINT64_FIELD</span>(fldname) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> :fldname */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* get field value */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; local_node-&gt;fldname = strtou64(token, </span><span class="Constant">NULL</span><span class="PreProc">, </span><span class="Constant">10</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Read a long integer field (anything written as &quot;:fldname %ld&quot;) */<br/></li>
<li><a id="L78">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">READ_LONG_FIELD</span>(fldname) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> :fldname */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* get field value */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; local_node-&gt;fldname = atol(token)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Read an OID field (don't hard-wire assumption that OID is same as uint) */<br/></li>
<li><a id="L84">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">READ_OID_FIELD</span>(fldname) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> :fldname */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* get field value */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; local_node-&gt;fldname = atooid(token)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Read a char field (ie, one <a href="../utils/adt/oracle_compat.c.html#L925" title="utils/adt/oracle_compat.c:925">ascii</a> character) */<br/></li>
<li><a id="L90">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">READ_CHAR_FIELD</span>(fldname) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> :fldname */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* get field value */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* avoid overhead of calling <a href="read.c.html#L214" title="nodes/read.c:214">debackslash</a>() for one char */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; local_node-&gt;fldname = (length == </span><span class="Constant">0</span><span class="PreProc">) ? </span><span class="Special">'\0'</span><span class="PreProc"> : (token[</span><span class="Constant">0</span><span class="PreProc">] == </span><span class="Special">'\\'</span><span class="PreProc"> ? token[</span><span class="Constant">1</span><span class="PreProc">] : token[</span><span class="Constant">0</span><span class="PreProc">])<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Read an enumerated-type field that was written as an integer code */<br/></li>
<li><a id="L97">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">READ_ENUM_FIELD</span>(fldname, enumtype) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> :fldname */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* get field value */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; local_node-&gt;fldname = (enumtype) atoi(token)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Read a float field */<br/></li>
<li><a id="L103">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">READ_FLOAT_FIELD</span>(fldname) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> :fldname */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* get field value */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; local_node-&gt;fldname = atof(token)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Read a boolean field */<br/></li>
<li><a id="L109">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">READ_BOOL_FIELD</span>(fldname) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> :fldname */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* get field value */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; local_node-&gt;fldname = <a href="#L179" title="nodes/readfuncs.c:179">strtobool</a>(token)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Read a character-string field */<br/></li>
<li><a id="L115">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">READ_STRING_FIELD</span>(fldname) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> :fldname */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* get field value */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; local_node-&gt;fldname = <a href="#L182" title="nodes/readfuncs.c:182">nullable_string</a>(token, length)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Read a <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> location field (and possibly throw away the value) */<br/></li>
<li></span><span class="PreProc">#ifdef WRITE_READ_PARSE_PLAN_TREES<br/></li>
<li><a id="L122">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">READ_LOCATION_FIELD</span>(fldname) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> :fldname */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* get field value */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; local_node-&gt;fldname = <a href="read.c.html#L36" title="nodes/read.c:36">restore_location_fields</a> ? atoi(token) : -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li><a id="L127">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">READ_LOCATION_FIELD</span>(fldname) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> :fldname */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* get field value */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (</span><span class="Type">void</span><span class="PreProc">) token;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* in case not used elsewhere */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; local_node-&gt;fldname = -</span><span class="Constant">1</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* set field to &quot;unknown&quot; */<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Read a Node field */<br/></li>
<li><a id="L135">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">READ_NODE_FIELD</span>(fldname) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> :fldname */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (</span><span class="Type">void</span><span class="PreProc">) token;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* in case not used elsewhere */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; local_node-&gt;fldname = <a href="read.c.html#L320" title="nodes/read.c:320">nodeRead</a>(</span><span class="Constant">NULL</span><span class="PreProc">, </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Read a bitmapset field */<br/></li>
<li><a id="L141">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">READ_BITMAPSET_FIELD</span>(fldname) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> :fldname */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (</span><span class="Type">void</span><span class="PreProc">) token;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* in case not used elsewhere */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; local_node-&gt;fldname = <a href="#L203" title="nodes/readfuncs.c:203">_readBitmapset</a>()<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Read an attribute number array */<br/></li>
<li><a id="L147">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">READ_ATTRNUMBER_ARRAY</span>(fldname, len) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> :fldname */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; local_node-&gt;fldname = readAttrNumberCols(len)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Read an oid array */<br/></li>
<li><a id="L152">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">READ_OID_ARRAY</span>(fldname, len) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> :fldname */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; local_node-&gt;fldname = readOidCols(len)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Read an int array */<br/></li>
<li><a id="L157">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">READ_INT_ARRAY</span>(fldname, len) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> :fldname */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; local_node-&gt;fldname = readIntCols(len)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Read a <a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> array */<br/></li>
<li><a id="L162">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">READ_BOOL_ARRAY</span>(fldname, len) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> :fldname */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; local_node-&gt;fldname = readBoolCols(len)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Routine exit */<br/></li>
<li><a id="L167">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">READ_DONE</span>() \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">return</span><span class="PreProc"> local_node<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: use atoi() to read <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> written with %d, or <a href="#L177" title="nodes/readfuncs.c:177">atoui</a>() to read<br/></li>
<li></span><span class="Comment"> * <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> written with %u in outfuncs.c.&nbsp; An exception is OID <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li></span><span class="Comment"> * for which use atooid().&nbsp; (As of 7.1, outfuncs.c writes OIDs as %u,<br/></li>
<li></span><span class="Comment"> * but this will probably change in the future.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L177">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">atoui</span>(x)&nbsp; ((</span><span class="Type">unsigned</span><span class="PreProc"> </span><span class="Type">int</span><span class="PreProc">) strtoul((x), </span><span class="Constant">NULL</span><span class="PreProc">, </span><span class="Constant">10</span><span class="PreProc">))<br/></li>
<li></span><br/></li>
<li><a id="L179">&#x200c;</a><span class="PreProc">#define <span class="linkable">strtobool</span>(x)&nbsp; ((*(x) == </span><span class="Constant">'t'</span><span class="PreProc">) ? </span><span class="Constant">true</span><span class="PreProc"> : </span><span class="Constant">false</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L182">&#x200c;</a><span class="linkable">nullable_string</span>(<span class="Type">const</span> <span class="Type">char</span> *token, <span class="Type">int</span> length)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="outfuncs.c.html#L149" title="nodes/outfuncs.c:149">outToken</a> emits &lt;&gt; for NULL, and <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a> makes that an empty string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (length == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="outfuncs.c.html#L149" title="nodes/outfuncs.c:149">outToken</a> emits &quot;&quot; for empty string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (length == <span class="Constant">2</span> &amp;&amp; token[<span class="Constant">0</span>] == <span class="Constant">'&quot;'</span> &amp;&amp; token[<span class="Constant">1</span>] == <span class="Constant">'&quot;'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* otherwise, we must remove protective backslashes added by <a href="outfuncs.c.html#L149" title="nodes/outfuncs.c:149">outToken</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="read.c.html#L214" title="nodes/read.c:214">debackslash</a>(token, length);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L203" title="nodes/readfuncs.c:203">_readBitmapset</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this code is used in contexts where we know that a Bitmapset<br/></li>
<li></span><span class="Comment"> * is expected.&nbsp; There is equivalent code in <a href="read.c.html#L320" title="nodes/read.c:320">nodeRead</a>() that can read a<br/></li>
<li></span><span class="Comment"> * Bitmapset when we come across one in other contexts.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Bitmapset *<br/></li>
<li><a id="L203">&#x200c;</a><span class="linkable">_readBitmapset</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *result = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="nodes/readfuncs.c:50">READ_TEMP_LOCALS</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (token == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;incomplete Bitmapset structure&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (length != <span class="Constant">1</span> || token[<span class="Constant">0</span>] != <span class="Constant">'('</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized token: </span><span class="Special">\&quot;%.*s\&quot;</span><span class="Constant">&quot;</span>, length, token);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (token == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;incomplete Bitmapset structure&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (length != <span class="Constant">1</span> || token[<span class="Constant">0</span>] != <span class="Constant">'b'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized token: </span><span class="Special">\&quot;%.*s\&quot;</span><span class="Constant">&quot;</span>, length, token);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *endptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (token == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unterminated Bitmapset structure&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (length == <span class="Constant">1</span> &amp;&amp; token[<span class="Constant">0</span>] == <span class="Constant">')'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; val = (<span class="Type">int</span>) strtol(token, &amp;endptr, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (endptr != token + length)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized integer: </span><span class="Special">\&quot;%.*s\&quot;</span><span class="Constant">&quot;</span>, length, token);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(result, val);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We export this function for use by extensions that define extensible nodes.<br/></li>
<li></span><span class="Comment"> * That's somewhat historical, though, because calling <a href="read.c.html#L320" title="nodes/read.c:320">nodeRead</a>() will work.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Bitmapset *<br/></li>
<li><a id="L245">&#x200c;</a><span class="linkable">readBitmapset</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L203" title="nodes/readfuncs.c:203">_readBitmapset</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;readfuncs.funcs.c&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Support <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for nodes with custom_read_write attribute or<br/></li>
<li></span><span class="Comment"> * special_read_write attribute<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> Const *<br/></li>
<li><a id="L259">&#x200c;</a><span class="linkable">_readConst</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L55" title="nodes/readfuncs.c:55">READ_LOCALS</a>(Const);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L84" title="nodes/readfuncs.c:84">READ_OID_FIELD</a>(consttype);<br/></li>
<li>&nbsp; &nbsp; <a href="#L60" title="nodes/readfuncs.c:60">READ_INT_FIELD</a>(consttypmod);<br/></li>
<li>&nbsp; &nbsp; <a href="#L84" title="nodes/readfuncs.c:84">READ_OID_FIELD</a>(constcollid);<br/></li>
<li>&nbsp; &nbsp; <a href="#L60" title="nodes/readfuncs.c:60">READ_INT_FIELD</a>(constlen);<br/></li>
<li>&nbsp; &nbsp; <a href="#L109" title="nodes/readfuncs.c:109">READ_BOOL_FIELD</a>(constbyval);<br/></li>
<li>&nbsp; &nbsp; <a href="#L109" title="nodes/readfuncs.c:109">READ_BOOL_FIELD</a>(constisnull);<br/></li>
<li>&nbsp; &nbsp; <a href="#L122" title="nodes/readfuncs.c:122">READ_LOCATION_FIELD</a>(location);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length); <span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> :constvalue */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (local_node-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length); <span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> &quot;&lt;&gt;&quot; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; local_node-&gt;constvalue = <a href="#L589" title="nodes/readfuncs.c:589">readDatum</a>(local_node-&gt;constbyval);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L167" title="nodes/readfuncs.c:167">READ_DONE</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> BoolExpr *<br/></li>
<li><a id="L281">&#x200c;</a><span class="linkable">_readBoolExpr</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L55" title="nodes/readfuncs.c:55">READ_LOCALS</a>(BoolExpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do-it-yourself enum representation */<br/></li>
<li></span>&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length); <span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> :boolop */<br/></li>
<li></span>&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length); <span class="Comment">/* get field value */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (length == <span class="Constant">3</span> &amp;&amp; strncmp(token, <span class="Constant">&quot;and&quot;</span>, <span class="Constant">3</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_node-&gt;boolop = AND_EXPR;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (length == <span class="Constant">2</span> &amp;&amp; strncmp(token, <span class="Constant">&quot;or&quot;</span>, <span class="Constant">2</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_node-&gt;boolop = OR_EXPR;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (length == <span class="Constant">3</span> &amp;&amp; strncmp(token, <span class="Constant">&quot;not&quot;</span>, <span class="Constant">3</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_node-&gt;boolop = NOT_EXPR;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized boolop </span><span class="Special">\&quot;%.*s\&quot;</span><span class="Constant">&quot;</span>, length, token);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(args);<br/></li>
<li>&nbsp; &nbsp; <a href="#L122" title="nodes/readfuncs.c:122">READ_LOCATION_FIELD</a>(location);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L167" title="nodes/readfuncs.c:167">READ_DONE</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> A_Const *<br/></li>
<li><a id="L304">&#x200c;</a><span class="linkable">_readA_Const</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L55" title="nodes/readfuncs.c:55">READ_LOCALS</a>(A_Const);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We expect either NULL or :val here */<br/></li>
<li></span>&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (length == <span class="Constant">4</span> &amp;&amp; strncmp(token, <span class="Constant">&quot;NULL&quot;</span>, <span class="Constant">4</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_node-&gt;isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">union</span> ValUnion *tmp = <a href="read.c.html#L320" title="nodes/read.c:320">nodeRead</a>(<span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* To forestall valgrind complaints, copy only the valid data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (nodeTag(tmp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Integer:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;local_node-&gt;val, tmp, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Integer));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Float:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;local_node-&gt;val, tmp, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Float));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Boolean:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;local_node-&gt;val, tmp, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Boolean));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_String:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;local_node-&gt;val, tmp, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(String));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_BitString:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;local_node-&gt;val, tmp, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BitString));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) nodeTag(tmp));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L122" title="nodes/readfuncs.c:122">READ_LOCATION_FIELD</a>(location);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L167" title="nodes/readfuncs.c:167">READ_DONE</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> RangeTblEntry *<br/></li>
<li><a id="L347">&#x200c;</a><span class="linkable">_readRangeTblEntry</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L55" title="nodes/readfuncs.c:55">READ_LOCALS</a>(RangeTblEntry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(alias);<br/></li>
<li>&nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(eref);<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="nodes/readfuncs.c:97">READ_ENUM_FIELD</a>(rtekind, RTEKind);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (local_node-&gt;rtekind)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_RELATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="nodes/readfuncs.c:84">READ_OID_FIELD</a>(relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L109" title="nodes/readfuncs.c:109">READ_BOOL_FIELD</a>(inh);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L90" title="nodes/readfuncs.c:90">READ_CHAR_FIELD</a>(relkind);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L60" title="nodes/readfuncs.c:60">READ_INT_FIELD</a>(rellockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L66" title="nodes/readfuncs.c:66">READ_UINT_FIELD</a>(perminfoindex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(tablesample);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_SUBQUERY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(subquery);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L109" title="nodes/readfuncs.c:109">READ_BOOL_FIELD</a>(security_barrier);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we re-use these RELATION fields, too: */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="nodes/readfuncs.c:84">READ_OID_FIELD</a>(relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L109" title="nodes/readfuncs.c:109">READ_BOOL_FIELD</a>(inh);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L90" title="nodes/readfuncs.c:90">READ_CHAR_FIELD</a>(relkind);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L60" title="nodes/readfuncs.c:60">READ_INT_FIELD</a>(rellockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L66" title="nodes/readfuncs.c:66">READ_UINT_FIELD</a>(perminfoindex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_JOIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="nodes/readfuncs.c:97">READ_ENUM_FIELD</a>(jointype, JoinType);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L60" title="nodes/readfuncs.c:60">READ_INT_FIELD</a>(joinmergedcols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(joinaliasvars);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(joinleftcols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(joinrightcols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(join_using_alias);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_FUNCTION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(<a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L109" title="nodes/readfuncs.c:109">READ_BOOL_FIELD</a>(funcordinality);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_TABLEFUNC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(tablefunc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The RTE must have a copy of the column type info, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (local_node-&gt;tablefunc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TableFunc&nbsp; *tf = local_node-&gt;tablefunc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local_node-&gt;coltypes = tf-&gt;coltypes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local_node-&gt;coltypmods = tf-&gt;coltypmods;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local_node-&gt;colcollations = tf-&gt;colcollations;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_VALUES:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(values_lists);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(coltypes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(coltypmods);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(colcollations);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_CTE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L115" title="nodes/readfuncs.c:115">READ_STRING_FIELD</a>(ctename);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L66" title="nodes/readfuncs.c:66">READ_UINT_FIELD</a>(ctelevelsup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L109" title="nodes/readfuncs.c:109">READ_BOOL_FIELD</a>(self_reference);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(coltypes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(coltypmods);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(colcollations);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_NAMEDTUPLESTORE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L115" title="nodes/readfuncs.c:115">READ_STRING_FIELD</a>(enrname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L103" title="nodes/readfuncs.c:103">READ_FLOAT_FIELD</a>(enrtuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(coltypes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(coltypmods);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(colcollations);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we re-use these RELATION fields, too: */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="nodes/readfuncs.c:84">READ_OID_FIELD</a>(relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_RESULT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no extra fields */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized RTE kind: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) local_node-&gt;rtekind);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L109" title="nodes/readfuncs.c:109">READ_BOOL_FIELD</a>(lateral);<br/></li>
<li>&nbsp; &nbsp; <a href="#L109" title="nodes/readfuncs.c:109">READ_BOOL_FIELD</a>(inFromCl);<br/></li>
<li>&nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(securityQuals);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L167" title="nodes/readfuncs.c:167">READ_DONE</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> A_Expr *<br/></li>
<li><a id="L439">&#x200c;</a><span class="linkable">_readA_Expr</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L55" title="nodes/readfuncs.c:55">READ_LOCALS</a>(A_Expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (length == <span class="Constant">3</span> &amp;&amp; strncmp(token, <span class="Constant">&quot;ANY&quot;</span>, <span class="Constant">3</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_node-&gt;kind = AEXPR_OP_ANY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(name);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (length == <span class="Constant">3</span> &amp;&amp; strncmp(token, <span class="Constant">&quot;ALL&quot;</span>, <span class="Constant">3</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_node-&gt;kind = AEXPR_OP_ALL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(name);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (length == <span class="Constant">8</span> &amp;&amp; strncmp(token, <span class="Constant">&quot;DISTINCT&quot;</span>, <span class="Constant">8</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_node-&gt;kind = AEXPR_DISTINCT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(name);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (length == <span class="Constant">12</span> &amp;&amp; strncmp(token, <span class="Constant">&quot;NOT_DISTINCT&quot;</span>, <span class="Constant">12</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_node-&gt;kind = AEXPR_NOT_DISTINCT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(name);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (length == <span class="Constant">6</span> &amp;&amp; strncmp(token, <span class="Constant">&quot;NULLIF&quot;</span>, <span class="Constant">6</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_node-&gt;kind = AEXPR_NULLIF;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(name);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (length == <span class="Constant">2</span> &amp;&amp; strncmp(token, <span class="Constant">&quot;IN&quot;</span>, <span class="Constant">2</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_node-&gt;kind = AEXPR_IN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(name);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (length == <span class="Constant">4</span> &amp;&amp; strncmp(token, <span class="Constant">&quot;LIKE&quot;</span>, <span class="Constant">4</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_node-&gt;kind = AEXPR_LIKE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(name);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (length == <span class="Constant">5</span> &amp;&amp; strncmp(token, <span class="Constant">&quot;ILIKE&quot;</span>, <span class="Constant">5</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_node-&gt;kind = AEXPR_ILIKE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(name);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (length == <span class="Constant">7</span> &amp;&amp; strncmp(token, <span class="Constant">&quot;SIMILAR&quot;</span>, <span class="Constant">7</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_node-&gt;kind = AEXPR_SIMILAR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(name);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (length == <span class="Constant">7</span> &amp;&amp; strncmp(token, <span class="Constant">&quot;BETWEEN&quot;</span>, <span class="Constant">7</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_node-&gt;kind = AEXPR_BETWEEN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(name);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (length == <span class="Constant">11</span> &amp;&amp; strncmp(token, <span class="Constant">&quot;NOT_BETWEEN&quot;</span>, <span class="Constant">11</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_node-&gt;kind = AEXPR_NOT_BETWEEN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(name);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (length == <span class="Constant">11</span> &amp;&amp; strncmp(token, <span class="Constant">&quot;BETWEEN_SYM&quot;</span>, <span class="Constant">11</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_node-&gt;kind = AEXPR_BETWEEN_SYM;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(name);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (length == <span class="Constant">15</span> &amp;&amp; strncmp(token, <span class="Constant">&quot;NOT_BETWEEN_SYM&quot;</span>, <span class="Constant">15</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_node-&gt;kind = AEXPR_NOT_BETWEEN_SYM;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(name);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (length == <span class="Constant">5</span> &amp;&amp; strncmp(token, <span class="Constant">&quot;:name&quot;</span>, <span class="Constant">5</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_node-&gt;kind = AEXPR_OP;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_node-&gt;name = <a href="read.c.html#L320" title="nodes/read.c:320">nodeRead</a>(<span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized A_Expr kind: </span><span class="Special">\&quot;%.*s\&quot;</span><span class="Constant">&quot;</span>, length, token);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(lexpr);<br/></li>
<li>&nbsp; &nbsp; <a href="#L135" title="nodes/readfuncs.c:135">READ_NODE_FIELD</a>(rexpr);<br/></li>
<li>&nbsp; &nbsp; <a href="#L122" title="nodes/readfuncs.c:122">READ_LOCATION_FIELD</a>(location);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L167" title="nodes/readfuncs.c:167">READ_DONE</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> ExtensibleNode *<br/></li>
<li><a id="L526">&#x200c;</a><span class="linkable">_readExtensibleNode</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> ExtensibleNodeMethods *methods;<br/></li>
<li>&nbsp; &nbsp; ExtensibleNode *local_node;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *extnodename;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="nodes/readfuncs.c:50">READ_TEMP_LOCALS</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length); <span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> :extnodename */<br/></li>
<li></span>&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length); <span class="Comment">/* get extnodename */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; extnodename = <a href="#L182" title="nodes/readfuncs.c:182">nullable_string</a>(token, length);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!extnodename)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;extnodename has to be supplied&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; methods = <a href="extensible.c.html#L125" title="nodes/extensible.c:125">GetExtensibleNodeMethods</a>(extnodename, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; local_node = (ExtensibleNode *) newNode(methods-&gt;node_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; T_ExtensibleNode);<br/></li>
<li>&nbsp; &nbsp; local_node-&gt;extnodename = extnodename;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* deserialize the private fields */<br/></li>
<li></span>&nbsp; &nbsp; methods-&gt;<a href="read.c.html#L320" title="nodes/read.c:320">nodeRead</a>(local_node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L167" title="nodes/readfuncs.c:167">READ_DONE</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L562" title="nodes/readfuncs.c:562">parseNodeString</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given a character string representing a node tree, <a href="#L562" title="nodes/readfuncs.c:562">parseNodeString</a> creates<br/></li>
<li></span><span class="Comment"> * the <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> node structure.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The string to be read must already have been loaded into <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Node *<br/></li>
<li><a id="L562">&#x200c;</a><span class="linkable">parseNodeString</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="nodes/readfuncs.c:50">READ_TEMP_LOCALS</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Guard against stack overflow due to overly complex expressions */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length);<br/></li>
<li><br/></li>
<li><a id="L571">&#x200c;</a><span class="PreProc">#define <span class="linkable">MATCH</span>(tokname, namelen) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (length == namelen &amp;&amp; memcmp(token, tokname, namelen) == </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;readfuncs.switch.c&quot;<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;badly formatted node string </span><span class="Special">\&quot;%.32s\&quot;</span><span class="Constant">...&quot;</span>, token);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L589" title="nodes/readfuncs.c:589">readDatum</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given a string representation of a constant, recreate the appropriate<br/></li>
<li></span><span class="Comment"> * Datum.&nbsp; The string representation embeds length info, but not byValue,<br/></li>
<li></span><span class="Comment"> * so we must be told that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L589">&#x200c;</a><span class="linkable">readDatum</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typbyval)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tokenLength;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *token;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * read the actual length of the value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;tokenLength);<br/></li>
<li>&nbsp; &nbsp; length = <a href="#L177" title="nodes/readfuncs.c:177">atoui</a>(token);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;tokenLength);&nbsp; &nbsp; <span class="Comment">/* read the '[' */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (token == <span class="Constant">NULL</span> || token[<span class="Constant">0</span>] != <span class="Constant">'['</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;expected </span><span class="Special">\&quot;</span><span class="Constant">[</span><span class="Special">\&quot;</span><span class="Constant"> to start datum, but got </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">; length = </span><span class="Special">%zu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; token ? token : <span class="Constant">&quot;[NULL]&quot;</span>, length);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typbyval)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (length &gt; (Size) <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;byval datum but length = </span><span class="Special">%zu</span><span class="Constant">&quot;</span>, length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s = (<span class="Type">char</span> *) (&amp;res);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; (Size) <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum); i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;tokenLength);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s[i] = (<span class="Type">char</span>) atoi(token);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (length &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = (Datum) <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s = (<span class="Type">char</span> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; length; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;tokenLength);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s[i] = (<span class="Type">char</span>) atoi(token);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = PointerGetDatum(s);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;tokenLength);&nbsp; &nbsp; <span class="Comment">/* read the ']' */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (token == <span class="Constant">NULL</span> || token[<span class="Constant">0</span>] != <span class="Constant">']'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;expected </span><span class="Special">\&quot;</span><span class="Constant">]</span><span class="Special">\&quot;</span><span class="Constant"> to end datum, but got </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">; length = </span><span class="Special">%zu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; token ? token : <span class="Constant">&quot;[NULL]&quot;</span>, length);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * common implementation for scalar-array-reading <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The data format is either &quot;&lt;&gt;&quot; for a NULL pointer (in which case numCols<br/></li>
<li></span><span class="Comment"> * is ignored) or &quot;(item item item)&quot; where the number of items must <a href="equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a><br/></li>
<li></span><span class="Comment"> * numCols.&nbsp; The convfunc must be okay with stopping at whitespace or a<br/></li>
<li></span><span class="Comment"> * right parenthesis, since <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a> won't null-terminate the token.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L650">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">READ_SCALAR_ARRAY</span>(fnname, datatype, convfunc) \<br/></li>
<li></span><span class="PreProc">datatype * \<br/></li>
<li></span><span class="PreProc">fnname(</span><span class="Type">int</span><span class="PreProc"> numCols) \<br/></li>
<li></span><span class="PreProc">{ \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; datatype&nbsp;&nbsp; *vals; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; <a href="#L50" title="nodes/readfuncs.c:50">READ_TEMP_LOCALS</a>(); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (token == </span><span class="Constant">NULL</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, </span><span class="Constant">&quot;incomplete scalar array&quot;</span><span class="PreProc">); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (length == </span><span class="Constant">0</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="PreProc"> </span><span class="Constant">NULL</span><span class="PreProc">;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* it was &quot;&lt;&gt;&quot;, so return NULL pointer */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (length != </span><span class="Constant">1</span><span class="PreProc"> || token[</span><span class="Constant">0</span><span class="PreProc">] != </span><span class="Constant">'('</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, </span><span class="Constant">&quot;unrecognized token: </span><span class="Special">\&quot;%.*s\&quot;</span><span class="Constant">&quot;</span><span class="PreProc">, length, token); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; vals = (datatype *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numCols * </span><span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(datatype)); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">for</span><span class="PreProc"> (</span><span class="Type">int</span><span class="PreProc"> i = </span><span class="Constant">0</span><span class="PreProc">; i &lt; numCols; i++) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (token == </span><span class="Constant">NULL</span><span class="PreProc"> || token[</span><span class="Constant">0</span><span class="PreProc">] == </span><span class="Constant">')'</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, </span><span class="Constant">&quot;incomplete scalar array&quot;</span><span class="PreProc">); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; vals[i] = convfunc(token); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; token = <a href="read.c.html#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;length); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (token == </span><span class="Constant">NULL</span><span class="PreProc"> || length != </span><span class="Constant">1</span><span class="PreProc"> || token[</span><span class="Constant">0</span><span class="PreProc">] != </span><span class="Constant">')'</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, </span><span class="Constant">&quot;incomplete scalar array&quot;</span><span class="PreProc">); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">return</span><span class="PreProc"> vals; \<br/></li>
<li></span><span class="PreProc">}<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Note: these <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are exported in nodes.h for possible use by<br/></li>
<li></span><span class="Comment"> * extensions, so don't mess too much with their names or API.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L650" title="nodes/readfuncs.c:650">READ_SCALAR_ARRAY</a>(readAttrNumberCols, int16, atoi)<br/></li>
<li><a href="#L650" title="nodes/readfuncs.c:650">READ_SCALAR_ARRAY</a>(readOidCols, Oid, atooid)<br/></li>
<li><span class="Comment">/* outfuncs.c has writeIndexCols, but we don't yet need that here */<br/></li>
<li></span><span class="Comment">/* <a href="#L650" title="nodes/readfuncs.c:650">READ_SCALAR_ARRAY</a>(readIndexCols, Index, <a href="#L177" title="nodes/readfuncs.c:177">atoui</a>) */<br/></li>
<li></span><a href="#L650" title="nodes/readfuncs.c:650">READ_SCALAR_ARRAY</a>(readIntCols, <span class="Type">int</span>, atoi)<br/></li>
<li><a href="#L650" title="nodes/readfuncs.c:650">READ_SCALAR_ARRAY</a>(readBoolCols, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>, <a href="#L179" title="nodes/readfuncs.c:179">strtobool</a>)<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
