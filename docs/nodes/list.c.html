<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>nodes/list.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>nodes/list.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L65">check_list_invariants</a></li>
<li><a href="#L155">enlarge_list</a></li>
<li><a href="#L415">insert_new_cell</a></li>
<li><a href="#L339">lappend</a></li>
<li><a href="#L357">lappend_int</a></li>
<li><a href="#L375">lappend_oid</a></li>
<li><a href="#L393">lappend_xid</a></li>
<li><a href="#L495">lcons</a></li>
<li><a href="#L513">lcons_int</a></li>
<li><a href="#L531">lcons_oid</a></li>
<li><a href="#L1343">list_append_unique</a></li>
<li><a href="#L1368">list_append_unique_int</a></li>
<li><a href="#L1380">list_append_unique_oid</a></li>
<li><a href="#L1356">list_append_unique_ptr</a></li>
<li><a href="#L561">list_concat</a></li>
<li><a href="#L598">list_concat_copy</a></li>
<li><a href="#L1405">list_concat_unique</a></li>
<li><a href="#L1448">list_concat_unique_int</a></li>
<li><a href="#L1469">list_concat_unique_oid</a></li>
<li><a href="#L1427">list_concat_unique_ptr</a></li>
<li><a href="#L1573">list_copy</a></li>
<li><a href="#L1639">list_copy_deep</a></li>
<li><a href="#L1593">list_copy_head</a></li>
<li><a href="#L1613">list_copy_tail</a></li>
<li><a href="#L1495">list_deduplicate_oid</a></li>
<li><a href="#L853">list_delete</a></li>
<li><a href="#L841">list_delete_cell</a></li>
<li><a href="#L943">list_delete_first</a></li>
<li><a href="#L983">list_delete_first_n</a></li>
<li><a href="#L891">list_delete_int</a></li>
<li><a href="#L957">list_delete_last</a></li>
<li><a href="#L767">list_delete_nth_cell</a></li>
<li><a href="#L910">list_delete_oid</a></li>
<li><a href="#L872">list_delete_ptr</a></li>
<li><a href="#L1237">list_difference</a></li>
<li><a href="#L1288">list_difference_int</a></li>
<li><a href="#L1313">list_difference_oid</a></li>
<li><a href="#L1263">list_difference_ptr</a></li>
<li><a href="#L1546">list_free</a></li>
<li><a href="#L1560">list_free_deep</a></li>
<li><a href="#L1520">list_free_private</a></li>
<li><a href="#L439">list_insert_nth</a></li>
<li><a href="#L453">list_insert_nth_int</a></li>
<li><a href="#L467">list_insert_nth_oid</a></li>
<li><a href="#L1691">list_int_cmp</a></li>
<li><a href="#L1174">list_intersection</a></li>
<li><a href="#L1200">list_intersection_int</a></li>
<li><a href="#L236">list_make1_impl</a></li>
<li><a href="#L246">list_make2_impl</a></li>
<li><a href="#L257">list_make3_impl</a></li>
<li><a href="#L270">list_make4_impl</a></li>
<li><a href="#L284">list_make5_impl</a></li>
<li><a href="#L661">list_member</a></li>
<li><a href="#L702">list_member_int</a></li>
<li><a href="#L722">list_member_oid</a></li>
<li><a href="#L682">list_member_ptr</a></li>
<li><a href="#L742">list_member_xid</a></li>
<li><a href="#L1703">list_oid_cmp</a></li>
<li><a href="#L1674">list_sort</a></li>
<li><a href="#L631">list_truncate</a></li>
<li><a href="#L1066">list_union</a></li>
<li><a href="#L1113">list_union_int</a></li>
<li><a href="#L1136">list_union_oid</a></li>
<li><a href="#L1090">list_union_ptr</a></li>
<li><a href="#L305">new_head_cell</a></li>
<li><a href="#L91">new_list</a></li>
<li><a href="#L323">new_tail_cell</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L44">DEBUG_LIST_MEMORY_USAGE</a></li>
<li><a href="#L56">IsIntegerList</a></li>
<li><a href="#L57">IsOidList</a></li>
<li><a href="#L55">IsPointerList</a></li>
<li><a href="#L58">IsXidList</a></li>
<li><a href="#L48">LIST_HEADER_OVERHEAD</a></li>
<li><a href="#L80">check_list_invariants</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * list.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; implementation for PostgreSQL generic list package<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See comments in pg_list.h.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/nodes/list.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;common/int.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/pg_list.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bitutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memdebug.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The previous List implementation, since it used a separate <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> chunk<br/></li>
<li></span><span class="Comment"> * for each cons cell, had the property that adding or deleting list cells<br/></li>
<li></span><span class="Comment"> * did not move the storage of other existing cells in the list.&nbsp; Quite a<br/></li>
<li></span><span class="Comment"> * <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of existing code depended on that, by retaining ListCell pointers<br/></li>
<li></span><span class="Comment"> * across such operations on a list.&nbsp; There is no such guarantee in this<br/></li>
<li></span><span class="Comment"> * implementation, so instead we have debugging support that is meant to<br/></li>
<li></span><span class="Comment"> * <a href="../main/main.c.html#L320" title="main/main.c:320">help</a> flush out <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-broken assumptions.&nbsp; Defining <a href="#L44" title="nodes/list.c:44">DEBUG_LIST_MEMORY_USAGE</a><br/></li>
<li></span><span class="Comment"> * while building this file causes the List operations to forcibly move<br/></li>
<li></span><span class="Comment"> * all cells in a list whenever a cell is added or deleted.&nbsp; In combination<br/></li>
<li></span><span class="Comment"> * with MEMORY_CONTEXT_CHECKING and/or Valgrind, this can usually expose<br/></li>
<li></span><span class="Comment"> * broken code.&nbsp; It's a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> expensive though, as there's many more <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a><br/></li>
<li></span><span class="Comment"> * cycles and a lot more data-copying than in a default build.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * By default, we enable this when building for Valgrind.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef USE_VALGRIND<br/></li>
<li><a id="L44">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DEBUG_LIST_MEMORY_USAGE</span><br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Overhead for the fixed part of a List header, measured in ListCells */<br/></li>
<li><a id="L48">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LIST_HEADER_OVERHEAD</span>&nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((</span><span class="Type">int</span><span class="PreProc">) ((offsetof(List, initial_elements) - </span><span class="Constant">1</span><span class="PreProc">) / </span><span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(ListCell) + </span><span class="Constant">1</span><span class="PreProc">))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Macros to simplify writing assertions about the type of a list; a<br/></li>
<li></span><span class="Comment"> * NIL list is considered to be an empty list of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L55">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">IsPointerList</span>(l)&nbsp; &nbsp; &nbsp; &nbsp; ((l) == NIL || IsA((l), List))<br/></li>
<li><a id="L56">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">IsIntegerList</span>(l)&nbsp; &nbsp; &nbsp; &nbsp; ((l) == NIL || IsA((l), IntList))<br/></li>
<li><a id="L57">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">IsOidList</span>(l)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((l) == NIL || IsA((l), OidList))<br/></li>
<li><a id="L58">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">IsXidList</span>(l)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((l) == NIL || IsA((l), XidList))<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check that the specified List is valid (so far as we can tell).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L65">&#x200c;</a></span><span class="linkable">check_list_invariants</span>(<span class="Type">const</span> List *list)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(list-&gt;length &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(list-&gt;length &lt;= list-&gt;max_length);<br/></li>
<li>&nbsp; &nbsp; Assert(list-&gt;elements != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(list-&gt;type == T_List ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list-&gt;type == T_IntList ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list-&gt;type == T_OidList ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list-&gt;type == T_XidList);<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#else<br/></li>
<li><a id="L80">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">check_list_invariants</span>(l)&nbsp; ((</span><span class="Type">void</span><span class="PreProc">) </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_ASSERT_CHECKING */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return a freshly allocated List with room for at least min_size cells.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since empty non-NIL lists are invalid, <a href="#L91" title="nodes/list.c:91">new_list</a>() sets the initial length<br/></li>
<li></span><span class="Comment"> * to min_size, effectively marking that number of cells as valid; the caller<br/></li>
<li></span><span class="Comment"> * is responsible for filling in their data.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L91">&#x200c;</a><span class="linkable">new_list</span>(NodeTag type, <span class="Type">int</span> min_size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newlist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(min_size &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We allocate all the requested cells, and possibly some more, as part of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the same <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> request as the List header.&nbsp; This is a big win for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * typical case of short fixed-length lists.&nbsp; It can lose if we allocate a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * moderately long list and then it gets extended; we'll be wasting more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initial_elements[] space than if we'd made the header small.&nbsp; However,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rounding up the request as we do in the normal code path provides some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * defense against small extensions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifndef <a href="#L44" title="nodes/list.c:44">DEBUG_LIST_MEMORY_USAGE</a><br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Normally, we set up a list with some extra cells, to allow it to grow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * without a <a href="../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>.&nbsp; Prefer cell counts chosen to make the total<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocation a power-of-2, since <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> would round it up to that anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (That stops being true for very large allocations, but very long lists<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are infrequent, so it doesn't seem worth special logic for such cases.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The minimum allocation is 8 ListCell units, providing either 4 or 5<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * available ListCells depending on the machine's <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> width.&nbsp; Counting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'s overhead, this uses the same amount of space as a one-cell<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list did in the old implementation, and less space for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> longer list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We needn't worry about integer overflow; no caller passes min_size<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that's more than twice the size of an existing list, so the size limits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * within <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> will ensure that we don't overflow here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; max_size = pg_nextpower2_32(Max(<span class="Constant">8</span>, min_size + <a href="#L48" title="nodes/list.c:48">LIST_HEADER_OVERHEAD</a>));<br/></li>
<li>&nbsp; &nbsp; max_size -= <a href="#L48" title="nodes/list.c:48">LIST_HEADER_OVERHEAD</a>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For debugging, don't allow <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> extra space.&nbsp; This forces <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> cell<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * addition to go through <a href="#L155" title="nodes/list.c:155">enlarge_list</a>() and thus move the existing data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; max_size = min_size;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; newlist = (List *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(offsetof(List, initial_elements) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_size * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell));<br/></li>
<li>&nbsp; &nbsp; newlist-&gt;type = type;<br/></li>
<li>&nbsp; &nbsp; newlist-&gt;length = min_size;<br/></li>
<li>&nbsp; &nbsp; newlist-&gt;max_length = max_size;<br/></li>
<li>&nbsp; &nbsp; newlist-&gt;elements = newlist-&gt;initial_elements;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newlist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Enlarge an existing non-NIL List to have room for at least min_size cells.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This does *not* update list-&gt;length, as some callers would <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> that<br/></li>
<li></span><span class="Comment"> * inconvenient.&nbsp; (list-&gt;length had better be the correct number of existing<br/></li>
<li></span><span class="Comment"> * valid cells, though.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L155">&#x200c;</a></span><span class="linkable">enlarge_list</span>(List *list, <span class="Type">int</span> min_size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_max_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(min_size &gt; list-&gt;max_length);&nbsp; &nbsp; <span class="Comment">/* else we shouldn't be here */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifndef <a href="#L44" title="nodes/list.c:44">DEBUG_LIST_MEMORY_USAGE</a><br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As above, we prefer power-of-two total allocations; but here we need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not account for list header overhead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* clamp the minimum value to 16, a semi-arbitrary small power of 2 */<br/></li>
<li></span>&nbsp; &nbsp; new_max_len = pg_nextpower2_32(Max(<span class="Constant">16</span>, min_size));<br/></li>
<li><br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* As above, don't allocate anything extra */<br/></li>
<li></span>&nbsp; &nbsp; new_max_len = min_size;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list-&gt;elements == list-&gt;initial_elements)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Replace original in-line allocation with a separate <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> block.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ensure it is in the same memory context as the List header.&nbsp; (The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * previous List implementation did not offer <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> guarantees about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keeping all list cells in the same context, but it seems reasonable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to create such a guarantee <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; list-&gt;elements = (ListCell *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../utils/mmgr/mcxt.c.html#L707" title="utils/mmgr/mcxt.c:707">GetMemoryChunkContext</a>(list),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new_max_len * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(list-&gt;elements, list-&gt;initial_elements,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list-&gt;length * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must not move the list header, so it's unsafe to try to reclaim<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the initial_elements[] space via <a href="../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>.&nbsp; In debugging builds,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * however, we can clear that space and/or mark it inaccessible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (wipe_mem includes VALGRIND_MAKE_MEM_NOACCESS.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef CLOBBER_FREED_MEMORY<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; wipe_mem(list-&gt;initial_elements,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list-&gt;max_length * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell));<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS(list-&gt;initial_elements,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list-&gt;max_length * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifndef <a href="#L44" title="nodes/list.c:44">DEBUG_LIST_MEMORY_USAGE</a><br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Normally, let <a href="../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a> deal with enlargement */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; list-&gt;elements = (ListCell *) <a href="../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(list-&gt;elements,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new_max_len * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell));<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>() might enlarge the space in-place, which we don't want<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for debugging purposes, so forcibly move the data somewhere else.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *newelements;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newelements = (ListCell *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../utils/mmgr/mcxt.c.html#L707" title="utils/mmgr/mcxt.c:707">GetMemoryChunkContext</a>(list),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new_max_len * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(newelements, list-&gt;elements,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list-&gt;length * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(list-&gt;elements);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; list-&gt;elements = newelements;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; list-&gt;max_length = new_max_len;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convenience <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to construct short Lists from given <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> * (These are normally invoked via the list_makeN macros.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L236">&#x200c;</a><span class="linkable">list_make1_impl</span>(NodeTag t, ListCell datum1)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *list = <a href="#L91" title="nodes/list.c:91">new_list</a>(t, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; list-&gt;elements[<span class="Constant">0</span>] = datum1;<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>List *<br/></li>
<li><a id="L246">&#x200c;</a><span class="linkable">list_make2_impl</span>(NodeTag t, ListCell datum1, ListCell datum2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *list = <a href="#L91" title="nodes/list.c:91">new_list</a>(t, <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; list-&gt;elements[<span class="Constant">0</span>] = datum1;<br/></li>
<li>&nbsp; &nbsp; list-&gt;elements[<span class="Constant">1</span>] = datum2;<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>List *<br/></li>
<li><a id="L257">&#x200c;</a><span class="linkable">list_make3_impl</span>(NodeTag t, ListCell datum1, ListCell datum2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell datum3)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *list = <a href="#L91" title="nodes/list.c:91">new_list</a>(t, <span class="Constant">3</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; list-&gt;elements[<span class="Constant">0</span>] = datum1;<br/></li>
<li>&nbsp; &nbsp; list-&gt;elements[<span class="Constant">1</span>] = datum2;<br/></li>
<li>&nbsp; &nbsp; list-&gt;elements[<span class="Constant">2</span>] = datum3;<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>List *<br/></li>
<li><a id="L270">&#x200c;</a><span class="linkable">list_make4_impl</span>(NodeTag t, ListCell datum1, ListCell datum2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell datum3, ListCell datum4)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *list = <a href="#L91" title="nodes/list.c:91">new_list</a>(t, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; list-&gt;elements[<span class="Constant">0</span>] = datum1;<br/></li>
<li>&nbsp; &nbsp; list-&gt;elements[<span class="Constant">1</span>] = datum2;<br/></li>
<li>&nbsp; &nbsp; list-&gt;elements[<span class="Constant">2</span>] = datum3;<br/></li>
<li>&nbsp; &nbsp; list-&gt;elements[<span class="Constant">3</span>] = datum4;<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>List *<br/></li>
<li><a id="L284">&#x200c;</a><span class="linkable">list_make5_impl</span>(NodeTag t, ListCell datum1, ListCell datum2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell datum3, ListCell datum4, ListCell datum5)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *list = <a href="#L91" title="nodes/list.c:91">new_list</a>(t, <span class="Constant">5</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; list-&gt;elements[<span class="Constant">0</span>] = datum1;<br/></li>
<li>&nbsp; &nbsp; list-&gt;elements[<span class="Constant">1</span>] = datum2;<br/></li>
<li>&nbsp; &nbsp; list-&gt;elements[<span class="Constant">2</span>] = datum3;<br/></li>
<li>&nbsp; &nbsp; list-&gt;elements[<span class="Constant">3</span>] = datum4;<br/></li>
<li>&nbsp; &nbsp; list-&gt;elements[<span class="Constant">4</span>] = datum5;<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Make room for a new head cell in the given (non-NIL) list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The data in the new head cell is undefined; the caller should be<br/></li>
<li></span><span class="Comment"> * sure to fill it in<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L305">&#x200c;</a></span><span class="linkable">new_head_cell</span>(List *list)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Enlarge array if necessary */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list-&gt;length &gt;= list-&gt;max_length)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L155" title="nodes/list.c:155">enlarge_list</a>(list, list-&gt;length + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now shove the existing data over */<br/></li>
<li></span>&nbsp; &nbsp; memmove(&amp;list-&gt;elements[<span class="Constant">1</span>], &amp;list-&gt;elements[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list-&gt;length * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell));<br/></li>
<li>&nbsp; &nbsp; list-&gt;length++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Make room for a new tail cell in the given (non-NIL) list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The data in the new tail cell is undefined; the caller should be<br/></li>
<li></span><span class="Comment"> * sure to fill it in<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L323">&#x200c;</a></span><span class="linkable">new_tail_cell</span>(List *list)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Enlarge array if necessary */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list-&gt;length &gt;= list-&gt;max_length)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L155" title="nodes/list.c:155">enlarge_list</a>(list, list-&gt;length + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; list-&gt;length++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Append a pointer to the list. A pointer to the modified list is<br/></li>
<li></span><span class="Comment"> * returned. Note that this function may or may not destructively<br/></li>
<li></span><span class="Comment"> * modify the list; callers should always use this function's return<br/></li>
<li></span><span class="Comment"> * value, rather than continuing to use the pointer passed as the<br/></li>
<li></span><span class="Comment"> * first argument.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L339">&#x200c;</a><span class="linkable">lappend</span>(List *list, <span class="Type">void</span> *datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L55" title="nodes/list.c:55">IsPointerList</a>(list));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; list = <a href="#L91" title="nodes/list.c:91">new_list</a>(T_List, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="nodes/list.c:323">new_tail_cell</a>(list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; llast(list) = datum;<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Append an integer to the specified list. See <a href="#L339" title="nodes/list.c:339">lappend</a>()<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L357">&#x200c;</a><span class="linkable">lappend_int</span>(List *list, <span class="Type">int</span> datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L56" title="nodes/list.c:56">IsIntegerList</a>(list));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; list = <a href="#L91" title="nodes/list.c:91">new_list</a>(T_IntList, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="nodes/list.c:323">new_tail_cell</a>(list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; llast_int(list) = datum;<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Append an OID to the specified list. See <a href="#L339" title="nodes/list.c:339">lappend</a>()<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L375">&#x200c;</a><span class="linkable">lappend_oid</span>(List *list, Oid datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L57" title="nodes/list.c:57">IsOidList</a>(list));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; list = <a href="#L91" title="nodes/list.c:91">new_list</a>(T_OidList, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="nodes/list.c:323">new_tail_cell</a>(list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; llast_oid(list) = datum;<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Append a TransactionId to the specified list. See <a href="#L339" title="nodes/list.c:339">lappend</a>()<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L393">&#x200c;</a><span class="linkable">lappend_xid</span>(List *list, TransactionId datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L58" title="nodes/list.c:58">IsXidList</a>(list));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; list = <a href="#L91" title="nodes/list.c:91">new_list</a>(T_XidList, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="nodes/list.c:323">new_tail_cell</a>(list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; llast_xid(list) = datum;<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Make room for a new cell at position 'pos' (measured from 0).<br/></li>
<li></span><span class="Comment"> * The data in the cell is left undefined, and must be filled in by the<br/></li>
<li></span><span class="Comment"> * caller. 'list' is assumed to be non-NIL, and 'pos' must be a valid<br/></li>
<li></span><span class="Comment"> * list position, ie, 0 &lt;= pos &lt;= list's length.<br/></li>
<li></span><span class="Comment"> * Returns address of the new cell.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ListCell *<br/></li>
<li><a id="L415">&#x200c;</a><span class="linkable">insert_new_cell</span>(List *list, <span class="Type">int</span> pos)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(pos &gt;= <span class="Constant">0</span> &amp;&amp; pos &lt;= list-&gt;length);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Enlarge array if necessary */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list-&gt;length &gt;= list-&gt;max_length)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L155" title="nodes/list.c:155">enlarge_list</a>(list, list-&gt;length + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now shove the existing data over */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pos &lt; list-&gt;length)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memmove(&amp;list-&gt;elements[pos + <span class="Constant">1</span>], &amp;list-&gt;elements[pos],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (list-&gt;length - pos) * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell));<br/></li>
<li>&nbsp; &nbsp; list-&gt;length++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> &amp;list-&gt;elements[pos];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> the given datum at position 'pos' (measured from 0) in the list.<br/></li>
<li></span><span class="Comment"> * 'pos' must be valid, ie, 0 &lt;= pos &lt;= list's length.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this takes time proportional to the distance to the end of the<br/></li>
<li></span><span class="Comment"> * list, since the following entries must be moved.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L439">&#x200c;</a><span class="linkable">list_insert_nth</span>(List *list, <span class="Type">int</span> pos, <span class="Type">void</span> *datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list == NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(pos == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> list_make1(datum);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L55" title="nodes/list.c:55">IsPointerList</a>(list));<br/></li>
<li>&nbsp; &nbsp; lfirst(<a href="#L415" title="nodes/list.c:415">insert_new_cell</a>(list, pos)) = datum;<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>List *<br/></li>
<li><a id="L453">&#x200c;</a><span class="linkable">list_insert_nth_int</span>(List *list, <span class="Type">int</span> pos, <span class="Type">int</span> datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list == NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(pos == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> list_make1_int(datum);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L56" title="nodes/list.c:56">IsIntegerList</a>(list));<br/></li>
<li>&nbsp; &nbsp; lfirst_int(<a href="#L415" title="nodes/list.c:415">insert_new_cell</a>(list, pos)) = datum;<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>List *<br/></li>
<li><a id="L467">&#x200c;</a><span class="linkable">list_insert_nth_oid</span>(List *list, <span class="Type">int</span> pos, Oid datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list == NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(pos == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> list_make1_oid(datum);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L57" title="nodes/list.c:57">IsOidList</a>(list));<br/></li>
<li>&nbsp; &nbsp; lfirst_oid(<a href="#L415" title="nodes/list.c:415">insert_new_cell</a>(list, pos)) = datum;<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepend a new <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> to the list. A pointer to the modified list<br/></li>
<li></span><span class="Comment"> * is returned. Note that this function may or may not destructively<br/></li>
<li></span><span class="Comment"> * modify the list; callers should always use this function's return<br/></li>
<li></span><span class="Comment"> * value, rather than continuing to use the pointer passed as the<br/></li>
<li></span><span class="Comment"> * second argument.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this takes time proportional to the length of the list,<br/></li>
<li></span><span class="Comment"> * since the existing entries must be moved.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caution: <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> Postgres 8.0, the original List was unmodified and<br/></li>
<li></span><span class="Comment"> * could be considered to retain its separate identity.&nbsp; This is no longer<br/></li>
<li></span><span class="Comment"> * the case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L495">&#x200c;</a><span class="linkable">lcons</span>(<span class="Type">void</span> *datum, List *list)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L55" title="nodes/list.c:55">IsPointerList</a>(list));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; list = <a href="#L91" title="nodes/list.c:91">new_list</a>(T_List, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L305" title="nodes/list.c:305">new_head_cell</a>(list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; linitial(list) = datum;<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepend an integer to the list. See <a href="#L495" title="nodes/list.c:495">lcons</a>()<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L513">&#x200c;</a><span class="linkable">lcons_int</span>(<span class="Type">int</span> datum, List *list)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L56" title="nodes/list.c:56">IsIntegerList</a>(list));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; list = <a href="#L91" title="nodes/list.c:91">new_list</a>(T_IntList, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L305" title="nodes/list.c:305">new_head_cell</a>(list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; linitial_int(list) = datum;<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepend an OID to the list. See <a href="#L495" title="nodes/list.c:495">lcons</a>()<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L531">&#x200c;</a><span class="linkable">lcons_oid</span>(Oid datum, List *list)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L57" title="nodes/list.c:57">IsOidList</a>(list));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; list = <a href="#L91" title="nodes/list.c:91">new_list</a>(T_OidList, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L305" title="nodes/list.c:305">new_head_cell</a>(list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; linitial_oid(list) = datum;<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Concatenate list2 to the end of list1, and return list1.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is equivalent to <a href="#L339" title="nodes/list.c:339">lappend</a>'ing each <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of list2, in order, to list1.<br/></li>
<li></span><span class="Comment"> * list1 is destructively changed, list2 is not.&nbsp; (However, in the case of<br/></li>
<li></span><span class="Comment"> * pointer lists, list1 and list2 will point to the same structures.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Callers should be sure to use the return value as the new pointer to the<br/></li>
<li></span><span class="Comment"> * concatenated list: the 'list1' input pointer may or may not be the same<br/></li>
<li></span><span class="Comment"> * as the returned pointer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this takes at least time proportional to the length of list2.<br/></li>
<li></span><span class="Comment"> * It'd typically be the case that we have to enlarge list1's storage,<br/></li>
<li></span><span class="Comment"> * probably adding time proportional to the length of list1.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L561">&#x200c;</a><span class="linkable">list_concat</span>(List *list1, <span class="Type">const</span> List *list2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list1 == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1573" title="nodes/list.c:1573">list_copy</a>(list2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list2 == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> list1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(list1-&gt;type == list2-&gt;type);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; new_len = list1-&gt;length + list2-&gt;length;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Enlarge array if necessary */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (new_len &gt; list1-&gt;max_length)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L155" title="nodes/list.c:155">enlarge_list</a>(list1, new_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Even if list1 == list2, using memcpy should be safe here */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(&amp;list1-&gt;elements[list1-&gt;length], &amp;list2-&gt;elements[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list2-&gt;length * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell));<br/></li>
<li>&nbsp; &nbsp; list1-&gt;length = new_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> list1;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Form a new list by concatenating the elements of list1 and list2.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Neither input list is modified.&nbsp; (However, if they are pointer lists,<br/></li>
<li></span><span class="Comment"> * the output list will point to the same structures.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is equivalent to, but more efficient than,<br/></li>
<li></span><span class="Comment"> * <a href="#L561" title="nodes/list.c:561">list_concat</a>(<a href="#L1573" title="nodes/list.c:1573">list_copy</a>(list1), list2).<br/></li>
<li></span><span class="Comment"> * Note that some pre-v13 code might <a href="#L1573" title="nodes/list.c:1573">list_copy</a> list2 as well, but that's<br/></li>
<li></span><span class="Comment"> * pointless <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L598">&#x200c;</a><span class="linkable">list_concat_copy</span>(<span class="Type">const</span> List *list1, <span class="Type">const</span> List *list2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list1 == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1573" title="nodes/list.c:1573">list_copy</a>(list2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list2 == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1573" title="nodes/list.c:1573">list_copy</a>(list1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(list1-&gt;type == list2-&gt;type);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; new_len = list1-&gt;length + list2-&gt;length;<br/></li>
<li>&nbsp; &nbsp; result = <a href="#L91" title="nodes/list.c:91">new_list</a>(list1-&gt;type, new_len);<br/></li>
<li>&nbsp; &nbsp; memcpy(result-&gt;elements, list1-&gt;elements,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list1-&gt;length * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell));<br/></li>
<li>&nbsp; &nbsp; memcpy(result-&gt;elements + list1-&gt;length, list2-&gt;elements,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list2-&gt;length * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Truncate 'list' to contain no more than 'new_size' elements. This<br/></li>
<li></span><span class="Comment"> * modifies the list in-place! Despite this, callers should use the<br/></li>
<li></span><span class="Comment"> * pointer returned by this function to refer to the newly truncated<br/></li>
<li></span><span class="Comment"> * list -- it may or may not be the same as the pointer that was<br/></li>
<li></span><span class="Comment"> * passed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> cells removed by <a href="#L631" title="nodes/list.c:631">list_truncate</a>() are NOT <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>'d.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L631">&#x200c;</a><span class="linkable">list_truncate</span>(List *list, <span class="Type">int</span> new_size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (new_size &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* truncate to zero length */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If asked to effectively extend the list, do nothing */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (new_size &lt; list_length(list))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; list-&gt;length = new_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: unlike the individual-list-cell deletion <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, we don't move<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the list cells to new storage, even in <a href="#L44" title="nodes/list.c:44">DEBUG_LIST_MEMORY_USAGE</a> mode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is because <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of them can move in this operation, so just like<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the old cons-cell-based implementation, this function doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * invalidate <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pointers to cells of the list.&nbsp; This is also the reason<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for not wiping the memory of the deleted cells: the old code didn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * free them either.&nbsp; Perhaps later we'll tighten this up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return true iff 'datum' is a member of the list. Equality is<br/></li>
<li></span><span class="Comment"> * determined via <a href="equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(), so callers should ensure that they pass a<br/></li>
<li></span><span class="Comment"> * Node as 'datum'.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This does a simple linear search --- avoid using it on long lists.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L661">&#x200c;</a></span><span class="linkable">list_member</span>(<span class="Type">const</span> List *list, <span class="Type">const</span> <span class="Type">void</span> *datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> ListCell *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L55" title="nodes/list.c:55">IsPointerList</a>(list));<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cell, list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(lfirst(cell), datum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return true iff 'datum' is a member of the list. Equality is<br/></li>
<li></span><span class="Comment"> * determined by using simple pointer comparison.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L682">&#x200c;</a></span><span class="linkable">list_member_ptr</span>(<span class="Type">const</span> List *list, <span class="Type">const</span> <span class="Type">void</span> *datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> ListCell *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L55" title="nodes/list.c:55">IsPointerList</a>(list));<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cell, list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lfirst(cell) == datum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return true iff the integer 'datum' is a member of the list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L702">&#x200c;</a></span><span class="linkable">list_member_int</span>(<span class="Type">const</span> List *list, <span class="Type">int</span> datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> ListCell *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L56" title="nodes/list.c:56">IsIntegerList</a>(list));<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cell, list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lfirst_int(cell) == datum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return true iff the OID 'datum' is a member of the list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L722">&#x200c;</a></span><span class="linkable">list_member_oid</span>(<span class="Type">const</span> List *list, Oid datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> ListCell *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L57" title="nodes/list.c:57">IsOidList</a>(list));<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cell, list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lfirst_oid(cell) == datum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return true iff the TransactionId 'datum' is a member of the list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L742">&#x200c;</a></span><span class="linkable">list_member_xid</span>(<span class="Type">const</span> List *list, TransactionId datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> ListCell *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L58" title="nodes/list.c:58">IsXidList</a>(list));<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cell, list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lfirst_xid(cell) == datum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> the n'th cell (counting from 0) in list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The List is <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>'d if this was the last member.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this takes time proportional to the distance to the end of the<br/></li>
<li></span><span class="Comment"> * list, since the following entries must be moved.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L767">&#x200c;</a><span class="linkable">list_delete_nth_cell</span>(List *list, <span class="Type">int</span> n)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(n &gt;= <span class="Constant">0</span> &amp;&amp; n &lt; list-&gt;length);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're about to delete the last node from the list, free the whole<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list instead and return NIL, which is the only valid representation of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a zero-length list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list-&gt;length == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1546" title="nodes/list.c:1546">list_free</a>(list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, we normally just collapse out the removed <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.&nbsp; But for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * debugging purposes, move the whole list contents someplace else.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Note that we *must* keep the contents in the same memory context.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L44" title="nodes/list.c:44">DEBUG_LIST_MEMORY_USAGE</a><br/></li>
<li></span>&nbsp; &nbsp; memmove(&amp;list-&gt;elements[n], &amp;list-&gt;elements[n + <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (list-&gt;length - <span class="Constant">1</span> - n) * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell));<br/></li>
<li>&nbsp; &nbsp; list-&gt;length--;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *newelems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newmaxlen = list-&gt;length - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newelems = (ListCell *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../utils/mmgr/mcxt.c.html#L707" title="utils/mmgr/mcxt.c:707">GetMemoryChunkContext</a>(list),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newmaxlen * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(newelems, list-&gt;elements, n * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;newelems[n], &amp;list-&gt;elements[n + <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (list-&gt;length - <span class="Constant">1</span> - n) * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list-&gt;elements != list-&gt;initial_elements)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(list-&gt;elements);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As in <a href="#L155" title="nodes/list.c:155">enlarge_list</a>(), clear the initial_elements[] space and/or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mark it inaccessible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef CLOBBER_FREED_MEMORY<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wipe_mem(list-&gt;initial_elements,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list-&gt;max_length * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell));<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS(list-&gt;initial_elements,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list-&gt;max_length * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; list-&gt;elements = newelems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; list-&gt;max_length = newmaxlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; list-&gt;length--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> 'cell' from 'list'.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The List is <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>'d if this was the last member.&nbsp; However, we do not<br/></li>
<li></span><span class="Comment"> * touch <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data the cell might've been pointing to.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this takes time proportional to the distance to the end of the<br/></li>
<li></span><span class="Comment"> * list, since the following entries must be moved.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L841">&#x200c;</a><span class="linkable">list_delete_cell</span>(List *list, ListCell *cell)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L767" title="nodes/list.c:767">list_delete_nth_cell</a>(list, cell - list-&gt;elements);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> the first cell in list that matches datum, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> * Equality is determined via <a href="equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This does a simple linear search --- avoid using it on long lists.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L853">&#x200c;</a><span class="linkable">list_delete</span>(List *list, <span class="Type">void</span> *datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L55" title="nodes/list.c:55">IsPointerList</a>(list));<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cell, list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(lfirst(cell), datum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L841" title="nodes/list.c:841">list_delete_cell</a>(list, cell);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Didn't <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a match: return the list unmodified */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* As above, but use simple pointer equality */<br/></li>
<li></span>List *<br/></li>
<li><a id="L872">&#x200c;</a><span class="linkable">list_delete_ptr</span>(List *list, <span class="Type">void</span> *datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L55" title="nodes/list.c:55">IsPointerList</a>(list));<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cell, list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lfirst(cell) == datum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L841" title="nodes/list.c:841">list_delete_cell</a>(list, cell);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Didn't <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a match: return the list unmodified */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* As above, but for integers */<br/></li>
<li></span>List *<br/></li>
<li><a id="L891">&#x200c;</a><span class="linkable">list_delete_int</span>(List *list, <span class="Type">int</span> datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L56" title="nodes/list.c:56">IsIntegerList</a>(list));<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cell, list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lfirst_int(cell) == datum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L841" title="nodes/list.c:841">list_delete_cell</a>(list, cell);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Didn't <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a match: return the list unmodified */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* As above, but for OIDs */<br/></li>
<li></span>List *<br/></li>
<li><a id="L910">&#x200c;</a><span class="linkable">list_delete_oid</span>(List *list, Oid datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L57" title="nodes/list.c:57">IsOidList</a>(list));<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cell, list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lfirst_oid(cell) == datum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L841" title="nodes/list.c:841">list_delete_cell</a>(list, cell);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Didn't <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a match: return the list unmodified */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> the first <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of the list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is useful to replace the Lisp-y code &quot;list = lnext(list);&quot; in cases<br/></li>
<li></span><span class="Comment"> * where the intent is to alter the list rather than just traverse it.<br/></li>
<li></span><span class="Comment"> * Beware that the list is modified, whereas the Lisp-y coding leaves<br/></li>
<li></span><span class="Comment"> * the original list head intact in case there's another pointer to it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this takes time proportional to the length of the list,<br/></li>
<li></span><span class="Comment"> * since the remaining entries must be moved.&nbsp; Consider reversing the<br/></li>
<li></span><span class="Comment"> * list order so that you can use <a href="#L957" title="nodes/list.c:957">list_delete_last</a>() instead.&nbsp; However,<br/></li>
<li></span><span class="Comment"> * if that causes you to replace <a href="#L339" title="nodes/list.c:339">lappend</a>() with <a href="#L495" title="nodes/list.c:495">lcons</a>(), you haven't<br/></li>
<li></span><span class="Comment"> * improved matters.&nbsp; (In short, you can make an efficient stack from<br/></li>
<li></span><span class="Comment"> * a List, but not an efficient FIFO queue.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L943">&#x200c;</a><span class="linkable">list_delete_first</span>(List *list)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* would an error be better? */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L767" title="nodes/list.c:767">list_delete_nth_cell</a>(list, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> the last <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of the list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L957">&#x200c;</a><span class="linkable">list_delete_last</span>(List *list)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* would an error be better? */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L631" title="nodes/list.c:631">list_truncate</a> won't free list if it goes to empty, but this should */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(list) &lt;= <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1546" title="nodes/list.c:1546">list_free</a>(list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L631" title="nodes/list.c:631">list_truncate</a>(list, list_length(list) - <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> the first N cells of the list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The List is <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>'d if the request causes all cells to be deleted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this takes time proportional to the distance to the end of the<br/></li>
<li></span><span class="Comment"> * list, since the following entries must be moved.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L983">&#x200c;</a><span class="linkable">list_delete_first_n</span>(List *list, <span class="Type">int</span> n)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No-op request? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (n &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> whole list? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (n &gt;= list_length(list))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1546" title="nodes/list.c:1546">list_free</a>(list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, we normally just collapse out the removed elements.&nbsp; But for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * debugging purposes, move the whole list contents someplace else.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Note that we *must* keep the contents in the same memory context.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L44" title="nodes/list.c:44">DEBUG_LIST_MEMORY_USAGE</a><br/></li>
<li></span>&nbsp; &nbsp; memmove(&amp;list-&gt;elements[<span class="Constant">0</span>], &amp;list-&gt;elements[n],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (list-&gt;length - n) * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell));<br/></li>
<li>&nbsp; &nbsp; list-&gt;length -= n;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *newelems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newmaxlen = list-&gt;length - n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newelems = (ListCell *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../utils/mmgr/mcxt.c.html#L707" title="utils/mmgr/mcxt.c:707">GetMemoryChunkContext</a>(list),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newmaxlen * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(newelems, &amp;list-&gt;elements[n], newmaxlen * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list-&gt;elements != list-&gt;initial_elements)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(list-&gt;elements);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As in <a href="#L155" title="nodes/list.c:155">enlarge_list</a>(), clear the initial_elements[] space and/or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mark it inaccessible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef CLOBBER_FREED_MEMORY<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wipe_mem(list-&gt;initial_elements,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list-&gt;max_length * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell));<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS(list-&gt;initial_elements,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list-&gt;max_length * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; list-&gt;elements = newelems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; list-&gt;max_length = newmaxlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; list-&gt;length = newmaxlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generate the union of two lists. This is calculated by copying<br/></li>
<li></span><span class="Comment"> * list1 via <a href="#L1573" title="nodes/list.c:1573">list_copy</a>(), then adding to it all the members of list2<br/></li>
<li></span><span class="Comment"> * that aren't already in list1.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Whether an <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is already a member of the list is determined<br/></li>
<li></span><span class="Comment"> * via <a href="equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned list is newly-allocated, although the content of the<br/></li>
<li></span><span class="Comment"> * cells is the same (i.e. <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pointed-to objects are not copied).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: this function will NOT remove <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> duplicates that are present<br/></li>
<li></span><span class="Comment"> * in list1 (so it only performs a &quot;union&quot; if list1 is known unique to<br/></li>
<li></span><span class="Comment"> * start with).&nbsp; Also, if you are about to write &quot;x = <a href="#L1066" title="nodes/list.c:1066">list_union</a>(x, y)&quot;<br/></li>
<li></span><span class="Comment"> * you probably want to use <a href="#L1405" title="nodes/list.c:1405">list_concat_unique</a>() instead to avoid wasting<br/></li>
<li></span><span class="Comment"> * the storage of the old x list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this takes time proportional to the product of the list<br/></li>
<li></span><span class="Comment"> * lengths, so beware of using it on long lists.&nbsp; (We could probably<br/></li>
<li></span><span class="Comment"> * improve that, but really you should be using some other data structure<br/></li>
<li></span><span class="Comment"> * if this'd be a performance bottleneck.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1066">&#x200c;</a><span class="linkable">list_union</span>(<span class="Type">const</span> List *list1, <span class="Type">const</span> List *list2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> ListCell *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L55" title="nodes/list.c:55">IsPointerList</a>(list1));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L55" title="nodes/list.c:55">IsPointerList</a>(list2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L1573" title="nodes/list.c:1573">list_copy</a>(list1);<br/></li>
<li>&nbsp; &nbsp; foreach(cell, list2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L661" title="nodes/list.c:661">list_member</a>(result, lfirst(cell)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L339" title="nodes/list.c:339">lappend</a>(result, lfirst(cell));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This variant of <a href="#L1066" title="nodes/list.c:1066">list_union</a>() determines duplicates via simple<br/></li>
<li></span><span class="Comment"> * pointer comparison.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1090">&#x200c;</a><span class="linkable">list_union_ptr</span>(<span class="Type">const</span> List *list1, <span class="Type">const</span> List *list2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> ListCell *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L55" title="nodes/list.c:55">IsPointerList</a>(list1));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L55" title="nodes/list.c:55">IsPointerList</a>(list2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L1573" title="nodes/list.c:1573">list_copy</a>(list1);<br/></li>
<li>&nbsp; &nbsp; foreach(cell, list2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L682" title="nodes/list.c:682">list_member_ptr</a>(result, lfirst(cell)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L339" title="nodes/list.c:339">lappend</a>(result, lfirst(cell));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This variant of <a href="#L1066" title="nodes/list.c:1066">list_union</a>() operates upon lists of integers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1113">&#x200c;</a><span class="linkable">list_union_int</span>(<span class="Type">const</span> List *list1, <span class="Type">const</span> List *list2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> ListCell *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L56" title="nodes/list.c:56">IsIntegerList</a>(list1));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L56" title="nodes/list.c:56">IsIntegerList</a>(list2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L1573" title="nodes/list.c:1573">list_copy</a>(list1);<br/></li>
<li>&nbsp; &nbsp; foreach(cell, list2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L702" title="nodes/list.c:702">list_member_int</a>(result, lfirst_int(cell)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L357" title="nodes/list.c:357">lappend_int</a>(result, lfirst_int(cell));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This variant of <a href="#L1066" title="nodes/list.c:1066">list_union</a>() operates upon lists of OIDs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1136">&#x200c;</a><span class="linkable">list_union_oid</span>(<span class="Type">const</span> List *list1, <span class="Type">const</span> List *list2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> ListCell *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L57" title="nodes/list.c:57">IsOidList</a>(list1));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L57" title="nodes/list.c:57">IsOidList</a>(list2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L1573" title="nodes/list.c:1573">list_copy</a>(list1);<br/></li>
<li>&nbsp; &nbsp; foreach(cell, list2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L722" title="nodes/list.c:722">list_member_oid</a>(result, lfirst_oid(cell)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L375" title="nodes/list.c:375">lappend_oid</a>(result, lfirst_oid(cell));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return a list that contains all the cells that are in both list1 and<br/></li>
<li></span><span class="Comment"> * list2.&nbsp; The returned list is freshly allocated via <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(), but the<br/></li>
<li></span><span class="Comment"> * cells themselves point to the same objects as the cells of the<br/></li>
<li></span><span class="Comment"> * input lists.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Duplicate entries in list1 will not be suppressed, so it's only a true<br/></li>
<li></span><span class="Comment"> * &quot;intersection&quot; if list1 is known unique beforehand.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This variant works on lists of pointers, and determines list<br/></li>
<li></span><span class="Comment"> * membership via <a href="equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>().&nbsp; Note that the list1 member will be pointed<br/></li>
<li></span><span class="Comment"> * to in the result.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this takes time proportional to the product of the list<br/></li>
<li></span><span class="Comment"> * lengths, so beware of using it on long lists.&nbsp; (We could probably<br/></li>
<li></span><span class="Comment"> * improve that, but really you should be using some other data structure<br/></li>
<li></span><span class="Comment"> * if this'd be a performance bottleneck.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1174">&#x200c;</a><span class="linkable">list_intersection</span>(<span class="Type">const</span> List *list1, <span class="Type">const</span> List *list2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> ListCell *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list1 == NIL || list2 == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L55" title="nodes/list.c:55">IsPointerList</a>(list1));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L55" title="nodes/list.c:55">IsPointerList</a>(list2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(cell, list1)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L661" title="nodes/list.c:661">list_member</a>(list2, lfirst(cell)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L339" title="nodes/list.c:339">lappend</a>(result, lfirst(cell));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * As <a href="#L1174" title="nodes/list.c:1174">list_intersection</a> but operates on lists of integers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1200">&#x200c;</a><span class="linkable">list_intersection_int</span>(<span class="Type">const</span> List *list1, <span class="Type">const</span> List *list2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> ListCell *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list1 == NIL || list2 == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L56" title="nodes/list.c:56">IsIntegerList</a>(list1));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L56" title="nodes/list.c:56">IsIntegerList</a>(list2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(cell, list1)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L702" title="nodes/list.c:702">list_member_int</a>(list2, lfirst_int(cell)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L357" title="nodes/list.c:357">lappend_int</a>(result, lfirst_int(cell));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return a list that contains all the cells in list1 that are not in<br/></li>
<li></span><span class="Comment"> * list2. The returned list is freshly allocated via <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(), but the<br/></li>
<li></span><span class="Comment"> * cells themselves point to the same objects as the cells of the<br/></li>
<li></span><span class="Comment"> * input lists.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This variant works on lists of pointers, and determines list<br/></li>
<li></span><span class="Comment"> * membership via <a href="equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this takes time proportional to the product of the list<br/></li>
<li></span><span class="Comment"> * lengths, so beware of using it on long lists.&nbsp; (We could probably<br/></li>
<li></span><span class="Comment"> * improve that, but really you should be using some other data structure<br/></li>
<li></span><span class="Comment"> * if this'd be a performance bottleneck.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1237">&#x200c;</a><span class="linkable">list_difference</span>(<span class="Type">const</span> List *list1, <span class="Type">const</span> List *list2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> ListCell *cell;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L55" title="nodes/list.c:55">IsPointerList</a>(list1));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L55" title="nodes/list.c:55">IsPointerList</a>(list2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list2 == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1573" title="nodes/list.c:1573">list_copy</a>(list1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cell, list1)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L661" title="nodes/list.c:661">list_member</a>(list2, lfirst(cell)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L339" title="nodes/list.c:339">lappend</a>(result, lfirst(cell));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This variant of <a href="#L1237" title="nodes/list.c:1237">list_difference</a>() determines list membership via<br/></li>
<li></span><span class="Comment"> * simple pointer equality.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1263">&#x200c;</a><span class="linkable">list_difference_ptr</span>(<span class="Type">const</span> List *list1, <span class="Type">const</span> List *list2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> ListCell *cell;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L55" title="nodes/list.c:55">IsPointerList</a>(list1));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L55" title="nodes/list.c:55">IsPointerList</a>(list2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list2 == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1573" title="nodes/list.c:1573">list_copy</a>(list1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cell, list1)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L682" title="nodes/list.c:682">list_member_ptr</a>(list2, lfirst(cell)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L339" title="nodes/list.c:339">lappend</a>(result, lfirst(cell));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This variant of <a href="#L1237" title="nodes/list.c:1237">list_difference</a>() operates upon lists of integers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1288">&#x200c;</a><span class="linkable">list_difference_int</span>(<span class="Type">const</span> List *list1, <span class="Type">const</span> List *list2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> ListCell *cell;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L56" title="nodes/list.c:56">IsIntegerList</a>(list1));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L56" title="nodes/list.c:56">IsIntegerList</a>(list2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list2 == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1573" title="nodes/list.c:1573">list_copy</a>(list1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cell, list1)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L702" title="nodes/list.c:702">list_member_int</a>(list2, lfirst_int(cell)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L357" title="nodes/list.c:357">lappend_int</a>(result, lfirst_int(cell));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This variant of <a href="#L1237" title="nodes/list.c:1237">list_difference</a>() operates upon lists of OIDs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1313">&#x200c;</a><span class="linkable">list_difference_oid</span>(<span class="Type">const</span> List *list1, <span class="Type">const</span> List *list2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> ListCell *cell;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L57" title="nodes/list.c:57">IsOidList</a>(list1));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L57" title="nodes/list.c:57">IsOidList</a>(list2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list2 == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1573" title="nodes/list.c:1573">list_copy</a>(list1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cell, list1)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L722" title="nodes/list.c:722">list_member_oid</a>(list2, lfirst_oid(cell)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L375" title="nodes/list.c:375">lappend_oid</a>(result, lfirst_oid(cell));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Append datum to list, but only if it isn't already in the list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Whether an <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is already a member of the list is determined<br/></li>
<li></span><span class="Comment"> * via <a href="equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This does a simple linear search --- avoid using it on long lists.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1343">&#x200c;</a><span class="linkable">list_append_unique</span>(List *list, <span class="Type">void</span> *datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L661" title="nodes/list.c:661">list_member</a>(list, datum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L339" title="nodes/list.c:339">lappend</a>(list, datum);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This variant of <a href="#L1343" title="nodes/list.c:1343">list_append_unique</a>() determines list membership via<br/></li>
<li></span><span class="Comment"> * simple pointer equality.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1356">&#x200c;</a><span class="linkable">list_append_unique_ptr</span>(List *list, <span class="Type">void</span> *datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L682" title="nodes/list.c:682">list_member_ptr</a>(list, datum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L339" title="nodes/list.c:339">lappend</a>(list, datum);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This variant of <a href="#L1343" title="nodes/list.c:1343">list_append_unique</a>() operates upon lists of integers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1368">&#x200c;</a><span class="linkable">list_append_unique_int</span>(List *list, <span class="Type">int</span> datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L702" title="nodes/list.c:702">list_member_int</a>(list, datum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L357" title="nodes/list.c:357">lappend_int</a>(list, datum);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This variant of <a href="#L1343" title="nodes/list.c:1343">list_append_unique</a>() operates upon lists of OIDs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1380">&#x200c;</a><span class="linkable">list_append_unique_oid</span>(List *list, Oid datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L722" title="nodes/list.c:722">list_member_oid</a>(list, datum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> list;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L375" title="nodes/list.c:375">lappend_oid</a>(list, datum);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Append to list1 each member of list2 that isn't already in list1.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Whether an <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is already a member of the list is determined<br/></li>
<li></span><span class="Comment"> * via <a href="equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is almost the same functionality as <a href="#L1066" title="nodes/list.c:1066">list_union</a>(), but list1 is<br/></li>
<li></span><span class="Comment"> * modified in-place rather than being copied. However, callers of this<br/></li>
<li></span><span class="Comment"> * function may have strict ordering expectations -- i.e. that the relative<br/></li>
<li></span><span class="Comment"> * order of those list2 elements that are not duplicates is preserved.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this takes time proportional to the product of the list<br/></li>
<li></span><span class="Comment"> * lengths, so beware of using it on long lists.&nbsp; (We could probably<br/></li>
<li></span><span class="Comment"> * improve that, but really you should be using some other data structure<br/></li>
<li></span><span class="Comment"> * if this'd be a performance bottleneck.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1405">&#x200c;</a><span class="linkable">list_concat_unique</span>(List *list1, <span class="Type">const</span> List *list2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L55" title="nodes/list.c:55">IsPointerList</a>(list1));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L55" title="nodes/list.c:55">IsPointerList</a>(list2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cell, list2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L661" title="nodes/list.c:661">list_member</a>(list1, lfirst(cell)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list1 = <a href="#L339" title="nodes/list.c:339">lappend</a>(list1, lfirst(cell));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> list1;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This variant of <a href="#L1405" title="nodes/list.c:1405">list_concat_unique</a>() determines list membership via<br/></li>
<li></span><span class="Comment"> * simple pointer equality.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1427">&#x200c;</a><span class="linkable">list_concat_unique_ptr</span>(List *list1, <span class="Type">const</span> List *list2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L55" title="nodes/list.c:55">IsPointerList</a>(list1));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L55" title="nodes/list.c:55">IsPointerList</a>(list2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cell, list2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L682" title="nodes/list.c:682">list_member_ptr</a>(list1, lfirst(cell)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list1 = <a href="#L339" title="nodes/list.c:339">lappend</a>(list1, lfirst(cell));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> list1;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This variant of <a href="#L1405" title="nodes/list.c:1405">list_concat_unique</a>() operates upon lists of integers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1448">&#x200c;</a><span class="linkable">list_concat_unique_int</span>(List *list1, <span class="Type">const</span> List *list2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L56" title="nodes/list.c:56">IsIntegerList</a>(list1));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L56" title="nodes/list.c:56">IsIntegerList</a>(list2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cell, list2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L702" title="nodes/list.c:702">list_member_int</a>(list1, lfirst_int(cell)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list1 = <a href="#L357" title="nodes/list.c:357">lappend_int</a>(list1, lfirst_int(cell));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> list1;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This variant of <a href="#L1405" title="nodes/list.c:1405">list_concat_unique</a>() operates upon lists of OIDs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1469">&#x200c;</a><span class="linkable">list_concat_unique_oid</span>(List *list1, <span class="Type">const</span> List *list2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L57" title="nodes/list.c:57">IsOidList</a>(list1));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L57" title="nodes/list.c:57">IsOidList</a>(list2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cell, list2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L722" title="nodes/list.c:722">list_member_oid</a>(list1, lfirst_oid(cell)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list1 = <a href="#L375" title="nodes/list.c:375">lappend_oid</a>(list1, lfirst_oid(cell));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> list1;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove adjacent duplicates in a list of OIDs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is caller's responsibility to have sorted the list to bring duplicates<br/></li>
<li></span><span class="Comment"> * together, perhaps via <a href="#L1674" title="nodes/list.c:1674">list_sort</a>(list, <a href="#L1703" title="nodes/list.c:1703">list_oid_cmp</a>).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this takes time proportional to the length of the list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1495">&#x200c;</a></span><span class="linkable">list_deduplicate_oid</span>(List *list)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L57" title="nodes/list.c:57">IsOidList</a>(list));<br/></li>
<li>&nbsp; &nbsp; len = list_length(list);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *elements = list-&gt;elements;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> j = <span class="Constant">1</span>; j &lt; len; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (elements[i].oid_value != elements[j].oid_value)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elements[++i].oid_value = elements[j].oid_value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; list-&gt;length = i + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Free all storage in a list, and optionally the pointed-to elements<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1520">&#x200c;</a></span><span class="linkable">list_free_private</span>(List *list, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> deep)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (deep)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; list-&gt;length; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(lfirst(&amp;list-&gt;elements[i]));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list-&gt;elements != list-&gt;initial_elements)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(list-&gt;elements);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(list);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Free all the cells of the list, as well as the list itself. Any<br/></li>
<li></span><span class="Comment"> * objects that are pointed-to by the cells of the list are NOT<br/></li>
<li></span><span class="Comment"> * free'd.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On return, the argument to this function has been freed, so the<br/></li>
<li></span><span class="Comment"> * caller would be wise to set it to NIL for safety's sake.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1546">&#x200c;</a></span><span class="linkable">list_free</span>(List *list)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1520" title="nodes/list.c:1520">list_free_private</a>(list, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Free all the cells of the list, the list itself, and all the<br/></li>
<li></span><span class="Comment"> * objects pointed-to by the cells of the list (each <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> in the<br/></li>
<li></span><span class="Comment"> * list must contain a pointer to a <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>()'d region of memory!)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On return, the argument to this function has been freed, so the<br/></li>
<li></span><span class="Comment"> * caller would be wise to set it to NIL for safety's sake.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1560">&#x200c;</a></span><span class="linkable">list_free_deep</span>(List *list)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A &quot;deep&quot; free operation only makes sense on a list of pointers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L55" title="nodes/list.c:55">IsPointerList</a>(list));<br/></li>
<li>&nbsp; &nbsp; <a href="#L1520" title="nodes/list.c:1520">list_free_private</a>(list, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return a shallow copy of the specified list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1573">&#x200c;</a><span class="linkable">list_copy</span>(<span class="Type">const</span> List *oldlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (oldlist == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newlist = <a href="#L91" title="nodes/list.c:91">new_list</a>(oldlist-&gt;type, oldlist-&gt;length);<br/></li>
<li>&nbsp; &nbsp; memcpy(newlist-&gt;elements, oldlist-&gt;elements,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newlist-&gt;length * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(newlist);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newlist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return a shallow copy of the specified list containing only the first 'len'<br/></li>
<li></span><span class="Comment"> * elements.&nbsp; If oldlist is shorter than 'len' then we copy the entire list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1593">&#x200c;</a><span class="linkable">list_copy_head</span>(<span class="Type">const</span> List *oldlist, <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (oldlist == NIL || len &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(oldlist-&gt;length, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newlist = <a href="#L91" title="nodes/list.c:91">new_list</a>(oldlist-&gt;type, len);<br/></li>
<li>&nbsp; &nbsp; memcpy(newlist-&gt;elements, oldlist-&gt;elements, len * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(newlist);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newlist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return a shallow copy of the specified list, without the first N elements.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1613">&#x200c;</a><span class="linkable">list_copy_tail</span>(<span class="Type">const</span> List *oldlist, <span class="Type">int</span> nskip)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nskip &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nskip = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* would it be better to elog? */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (oldlist == NIL || nskip &gt;= oldlist-&gt;length)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newlist = <a href="#L91" title="nodes/list.c:91">new_list</a>(oldlist-&gt;type, oldlist-&gt;length - nskip);<br/></li>
<li>&nbsp; &nbsp; memcpy(newlist-&gt;elements, &amp;oldlist-&gt;elements[nskip],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newlist-&gt;length * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(newlist);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newlist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return a deep copy of the specified list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The list elements are copied via copyObject(), so that this function's<br/></li>
<li></span><span class="Comment"> * idea of a &quot;deep&quot; copy is considerably deeper than what <a href="#L1560" title="nodes/list.c:1560">list_free_deep</a>()<br/></li>
<li></span><span class="Comment"> * means by the same <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1639">&#x200c;</a><span class="linkable">list_copy_deep</span>(<span class="Type">const</span> List *oldlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (oldlist == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This is only sensible for pointer Lists */<br/></li>
<li></span>&nbsp; &nbsp; Assert(IsA(oldlist, List));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newlist = <a href="#L91" title="nodes/list.c:91">new_list</a>(oldlist-&gt;type, oldlist-&gt;length);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; newlist-&gt;length; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lfirst(&amp;newlist-&gt;elements[i]) =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="copyfuncs.c.html#L177" title="nodes/copyfuncs.c:177">copyObjectImpl</a>(lfirst(&amp;oldlist-&gt;elements[i]));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(newlist);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newlist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sort a list according to the specified comparator function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The list is sorted in-place.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The comparator function is declared to receive arguments of type<br/></li>
<li></span><span class="Comment"> * const ListCell *; this allows it to use lfirst() and variants<br/></li>
<li></span><span class="Comment"> * without casting its arguments.&nbsp; Otherwise it behaves the same as<br/></li>
<li></span><span class="Comment"> * the comparator function for standard qsort().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Like qsort(), this provides no guarantees about sort stability<br/></li>
<li></span><span class="Comment"> * for <a href="equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> keys.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is based on qsort(), so it likewise has O(N log N) runtime.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1674">&#x200c;</a></span><span class="linkable">list_sort</span>(List *list, list_sort_comparator <a href="../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">typedef</span> <span class="Type">int</span> (*qsort_comparator) (<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="nodes/list.c:65">check_list_invariants</a>(list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do if there's less than two elements */<br/></li>
<li></span>&nbsp; &nbsp; len = list_length(list);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qsort(list-&gt;elements, len, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListCell), (qsort_comparator) <a href="../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1674" title="nodes/list.c:1674">list_sort</a> comparator for sorting a list into ascending int order.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1691">&#x200c;</a></span><span class="linkable">list_int_cmp</span>(<span class="Type">const</span> ListCell *p1, <span class="Type">const</span> ListCell *p2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v1 = lfirst_int(p1);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v2 = lfirst_int(p2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_cmp_s32(v1, v2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1674" title="nodes/list.c:1674">list_sort</a> comparator for sorting a list into ascending OID order.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1703">&#x200c;</a></span><span class="linkable">list_oid_cmp</span>(<span class="Type">const</span> ListCell *p1, <span class="Type">const</span> ListCell *p2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v1 = lfirst_oid(p1);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v2 = lfirst_oid(p2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_cmp_u32(v1, v2);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
