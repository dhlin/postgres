<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>nodes/read.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>nodes/read.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L32">pg_strtok_ptr</a></li>
<li><a href="#L36">restore_location_fields</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L214">debackslash</a></li>
<li><a href="#L320">nodeRead</a></li>
<li><a href="#L246">nodeTokenType</a></li>
<li><a href="#L153">pg_strtok</a></li>
<li><a href="#L90">stringToNode</a></li>
<li><a href="#L49">stringToNodeInternal</a></li>
<li><a href="#L98">stringToNodeWithLocations</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L232">LEFT_BRACE</a></li>
<li><a href="#L231">LEFT_PAREN</a></li>
<li><a href="#L233">OTHER_TOKEN</a></li>
<li><a href="#L230">RIGHT_PAREN</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * read.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; routines to convert a string (legal <a href="../utils/adt/oracle_compat.c.html#L925" title="utils/adt/oracle_compat.c:925">ascii</a> representation of node) back<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; to nodes<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/nodes/read.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * HISTORY<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; AUTHOR&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DATE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MAJOR EVENT<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Andrew Yu&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Nov 2, 1994&nbsp; &nbsp; &nbsp; &nbsp; file creation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;ctype.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;common/string.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/bitmapset.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/pg_list.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/readfuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/value.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* Static state for <a href="#L153" title="nodes/read.c:153">pg_strtok</a> */<br/></li>
<li><a id="L32">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<span class="linkable">pg_strtok_ptr</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* State flag that determines how readfuncs.c should treat location fields */<br/></li>
<li></span><span class="PreProc">#ifdef WRITE_READ_PARSE_PLAN_TREES<br/></li>
<li><a id="L36">&#x200c;</a></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">restore_location_fields</span> = <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L90" title="nodes/read.c:90">stringToNode</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; builds a Node tree from its string representation (assumed valid)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * restore_loc_fields instructs readfuncs.c whether to restore location<br/></li>
<li></span><span class="Comment"> * fields rather than set them to -1.&nbsp; This is currently only supported<br/></li>
<li></span><span class="Comment"> * in builds with the WRITE_READ_PARSE_PLAN_TREES debugging flag set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> *<br/></li>
<li><a id="L49">&#x200c;</a><span class="linkable">stringToNodeInternal</span>(<span class="Type">const</span> <span class="Type">char</span> *str, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> restore_loc_fields)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *retval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *save_strtok;<br/></li>
<li><span class="PreProc">#ifdef WRITE_READ_PARSE_PLAN_TREES<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; save_restore_location_fields;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We save and restore the pre-existing state of <a href="#L153" title="nodes/read.c:153">pg_strtok</a>. This makes the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * world safe for re-entrant invocation of <a href="#L90" title="nodes/read.c:90">stringToNode</a>, without incurring<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a lot of notational overhead by having to pass the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-character<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pointer around through all the readfuncs.c code.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; save_strtok = <a href="#L32" title="nodes/read.c:32">pg_strtok_ptr</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L32" title="nodes/read.c:32">pg_strtok_ptr</a> = str;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* point <a href="#L153" title="nodes/read.c:153">pg_strtok</a> at the string to read */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If enabled, likewise save/restore the location field handling flag.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef WRITE_READ_PARSE_PLAN_TREES<br/></li>
<li></span>&nbsp; &nbsp; save_restore_location_fields = <a href="#L36" title="nodes/read.c:36">restore_location_fields</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L36" title="nodes/read.c:36">restore_location_fields</a> = restore_loc_fields;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; retval = <a href="#L320" title="nodes/read.c:320">nodeRead</a>(<span class="Constant">NULL</span>, <span class="Constant">0</span>); <span class="Comment">/* do the reading */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L32" title="nodes/read.c:32">pg_strtok_ptr</a> = save_strtok;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WRITE_READ_PARSE_PLAN_TREES<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L36" title="nodes/read.c:36">restore_location_fields</a> = save_restore_location_fields;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> retval;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Externally visible entry points<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L90">&#x200c;</a><span class="linkable">stringToNode</span>(<span class="Type">const</span> <span class="Type">char</span> *str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L49" title="nodes/read.c:49">stringToNodeInternal</a>(str, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WRITE_READ_PARSE_PLAN_TREES<br/></li>
<li></span><br/></li>
<li><span class="Type">void</span> *<br/></li>
<li><a id="L98">&#x200c;</a><span class="linkable">stringToNodeWithLocations</span>(<span class="Type">const</span> <span class="Type">char</span> *str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L49" title="nodes/read.c:49">stringToNodeInternal</a>(str, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * the lisp token parser<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L153" title="nodes/read.c:153">pg_strtok</a> --- retrieve <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> &quot;token&quot; from a string.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Works kinda like strtok, except it never modifies the source string.<br/></li>
<li></span><span class="Comment"> * (Instead of storing nulls into the string, the length of the token<br/></li>
<li></span><span class="Comment"> * is returned to the caller.)<br/></li>
<li></span><span class="Comment"> * Also, the rules about what is a token are hard-wired rather than being<br/></li>
<li></span><span class="Comment"> * configured by passing a set of terminating characters.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The string is assumed to have been initialized already by <a href="#L90" title="nodes/read.c:90">stringToNode</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The rules for tokens are:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * Whitespace (space, tab, <a href="../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a>) always separates tokens.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * The characters '(', ')', '{', '}' form individual tokens even<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; without <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> whitespace around them.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * Otherwise, a token is all the characters up to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> whitespace<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; or occurrence of one of the four special characters.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * A backslash '\' can be used to quote whitespace or one of the four<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; special characters, so that it is treated as a plain token character.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Backslashes themselves must also be backslashed for consistency.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Any other character can be, but need not be, backslashed as well.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * If the resulting token is '&lt;&gt;' (with no backslash), it is returned<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; as a non-NULL pointer to the token but with length == 0.&nbsp; Note that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; there is no other way to get a zero-length token.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a pointer to the start of the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> token, and the length of the<br/></li>
<li></span><span class="Comment"> * token (including <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> embedded backslashes!) in *length.&nbsp; If there are<br/></li>
<li></span><span class="Comment"> * no more tokens, NULL and 0 are returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: this routine doesn't remove backslashes; the caller must do so<br/></li>
<li></span><span class="Comment"> * if necessary (see &quot;<a href="#L214" title="nodes/read.c:214">debackslash</a>&quot;).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: prior to release 7.0, this routine also had a special case to treat<br/></li>
<li></span><span class="Comment"> * a token starting with '&quot;' as extending to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> '&quot;'.&nbsp; This code was<br/></li>
<li></span><span class="Comment"> * broken, however, since it would fail to cope with a string containing an<br/></li>
<li></span><span class="Comment"> * embedded '&quot;'.&nbsp; I have therefore removed this special case, and instead<br/></li>
<li></span><span class="Comment"> * introduced rules for using backslashes to quote characters.&nbsp; Higher-level<br/></li>
<li></span><span class="Comment"> * code should add backslashes to a string constant to ensure it is treated<br/></li>
<li></span><span class="Comment"> * as a single token.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L153">&#x200c;</a><span class="linkable">pg_strtok</span>(<span class="Type">int</span> *length)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *local_str;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* working pointer to string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *ret_str;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* start of token to return */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; local_str = <a href="#L32" title="nodes/read.c:32">pg_strtok_ptr</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (*local_str == <span class="Constant">' '</span> || *local_str == <span class="Special">'\n'</span> || *local_str == <span class="Special">'\t'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_str++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*local_str == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *length = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L32" title="nodes/read.c:32">pg_strtok_ptr</a> = local_str;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no more tokens */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now pointing at start of <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> token.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ret_str = local_str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*local_str == <span class="Constant">'('</span> || *local_str == <span class="Constant">')'</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *local_str == <span class="Constant">'{'</span> || *local_str == <span class="Constant">'}'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* special 1-character token */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; local_str++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Normal token, possibly containing backslashes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (*local_str != <span class="Special">'\0'</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *local_str != <span class="Constant">' '</span> &amp;&amp; *local_str != <span class="Special">'\n'</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *local_str != <span class="Special">'\t'</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *local_str != <span class="Constant">'('</span> &amp;&amp; *local_str != <span class="Constant">')'</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *local_str != <span class="Constant">'{'</span> &amp;&amp; *local_str != <span class="Constant">'}'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*local_str == <span class="Special">'\\'</span> &amp;&amp; local_str[<span class="Constant">1</span>] != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local_str += <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local_str++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *length = local_str - ret_str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Recognize special case for &quot;empty&quot; token */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*length == <span class="Constant">2</span> &amp;&amp; ret_str[<span class="Constant">0</span>] == <span class="Constant">'&lt;'</span> &amp;&amp; ret_str[<span class="Constant">1</span>] == <span class="Constant">'&gt;'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *length = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L32" title="nodes/read.c:32">pg_strtok_ptr</a> = local_str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret_str;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L214" title="nodes/read.c:214">debackslash</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; create a <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d string holding the given token.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> protective backslashes in the token are removed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L214">&#x200c;</a><span class="linkable">debackslash</span>(<span class="Type">const</span> <span class="Type">char</span> *token, <span class="Type">int</span> length)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(length + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr = result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (length &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*token == <span class="Special">'\\'</span> &amp;&amp; length &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; token++, length--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *ptr++ = *token++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; length--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *ptr = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L230">&#x200c;</a><span class="PreProc">#define <span class="linkable">RIGHT_PAREN</span> (</span><span class="Constant">1000000</span><span class="PreProc"> + </span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li><a id="L231">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LEFT_PAREN</span>&nbsp; &nbsp; (</span><span class="Constant">1000000</span><span class="PreProc"> + </span><span class="Constant">2</span><span class="PreProc">)<br/></li>
<li><a id="L232">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LEFT_BRACE</span>&nbsp; &nbsp; (</span><span class="Constant">1000000</span><span class="PreProc"> + </span><span class="Constant">3</span><span class="PreProc">)<br/></li>
<li><a id="L233">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">OTHER_TOKEN</span> (</span><span class="Constant">1000000</span><span class="PreProc"> + </span><span class="Constant">4</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L246" title="nodes/read.c:246">nodeTokenType</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; returns the type of the node token contained in token.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; It returns one of the following valid NodeTags:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; T_Integer, T_Float, T_Boolean, T_String, T_BitString<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; and some of its own:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L230" title="nodes/read.c:230">RIGHT_PAREN</a>, <a href="#L231" title="nodes/read.c:231">LEFT_PAREN</a>, <a href="#L232" title="nodes/read.c:232">LEFT_BRACE</a>, <a href="#L233" title="nodes/read.c:233">OTHER_TOKEN</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Assumption: the <a href="../utils/adt/oracle_compat.c.html#L925" title="utils/adt/oracle_compat.c:925">ascii</a> representation is legal<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> NodeTag<br/></li>
<li><a id="L246">&#x200c;</a><span class="linkable">nodeTokenType</span>(<span class="Type">const</span> <span class="Type">char</span> *token, <span class="Type">int</span> length)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; NodeTag&nbsp; &nbsp; &nbsp; &nbsp; retval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *numptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if the token is a number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; numptr = token;<br/></li>
<li>&nbsp; &nbsp; numlen = length;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*numptr == <span class="Constant">'+'</span> || *numptr == <span class="Constant">'-'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numptr++, numlen--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((numlen &gt; <span class="Constant">0</span> &amp;&amp; isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *numptr)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (numlen &gt; <span class="Constant">1</span> &amp;&amp; *numptr == <span class="Constant">'.'</span> &amp;&amp; isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) numptr[<span class="Constant">1</span>])))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Yes.&nbsp; Figure out whether it is integral or float; this requires<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * both a syntax check and a <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> check. strtoint() can do both for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * us. We know the token will end at a character that strtoint will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stop at, so we do not need to modify the string.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *endptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) strtoint(numptr, &amp;endptr, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (endptr != token + length || errno == <span class="Constant">ERANGE</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> T_Float;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> T_Integer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * these three cases do not need length checks, since <a href="#L153" title="nodes/read.c:153">pg_strtok</a>() will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * always treat them as single-byte tokens<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*token == <span class="Constant">'('</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; retval = <a href="#L231" title="nodes/read.c:231">LEFT_PAREN</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*token == <span class="Constant">')'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; retval = <a href="#L230" title="nodes/read.c:230">RIGHT_PAREN</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*token == <span class="Constant">'{'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; retval = <a href="#L232" title="nodes/read.c:232">LEFT_BRACE</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((length == <span class="Constant">4</span> &amp;&amp; strncmp(token, <span class="Constant">&quot;true&quot;</span>, <span class="Constant">4</span>) == <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (length == <span class="Constant">5</span> &amp;&amp; strncmp(token, <span class="Constant">&quot;false&quot;</span>, <span class="Constant">5</span>) == <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; retval = T_Boolean;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*token == <span class="Constant">'&quot;'</span> &amp;&amp; length &gt; <span class="Constant">1</span> &amp;&amp; token[length - <span class="Constant">1</span>] == <span class="Constant">'&quot;'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; retval = T_String;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*token == <span class="Constant">'b'</span> || *token == <span class="Constant">'x'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; retval = T_BitString;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; retval = <a href="#L233" title="nodes/read.c:233">OTHER_TOKEN</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> retval;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L320" title="nodes/read.c:320">nodeRead</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Slightly higher-level reader.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine applies some semantic knowledge on top of the purely<br/></li>
<li></span><span class="Comment"> * lexical tokenizer <a href="#L153" title="nodes/read.c:153">pg_strtok</a>().&nbsp;&nbsp; It can read<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * Value token nodes (integers, floats, booleans, or strings);<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * General nodes (via <a href="readfuncs.c.html#L562" title="nodes/readfuncs.c:562">parseNodeString</a>() from readfuncs.c);<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * Lists of the above;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * Lists of integers, OIDs, or TransactionIds.<br/></li>
<li></span><span class="Comment"> * The return value is declared void *, not Node *, to avoid having to<br/></li>
<li></span><span class="Comment"> * cast it explicitly in callers that assign to fields of different types.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * External callers should always pass NULL/0 for the arguments.&nbsp; Internally<br/></li>
<li></span><span class="Comment"> * a non-NULL token may be passed when the <a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> recursion level has already<br/></li>
<li></span><span class="Comment"> * scanned the first token of a node's representation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We assume <a href="#L153" title="nodes/read.c:153">pg_strtok</a> is already initialized with a string to read (hence<br/></li>
<li></span><span class="Comment"> * this should only be invoked from within a <a href="#L90" title="nodes/read.c:90">stringToNode</a> operation).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L320">&#x200c;</a><span class="linkable">nodeRead</span>(<span class="Type">const</span> <span class="Type">char</span> *token, <span class="Type">int</span> tok_len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; NodeTag&nbsp; &nbsp; &nbsp; &nbsp; type;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (token == <span class="Constant">NULL</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* need to read a token? */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; token = <a href="#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;tok_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (token == <span class="Constant">NULL</span>)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of input */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; type = <a href="#L246" title="nodes/read.c:246">nodeTokenType</a>(token, tok_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> ((<span class="Type">int</span>) type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L232" title="nodes/read.c:232">LEFT_BRACE</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="readfuncs.c.html#L562" title="nodes/readfuncs.c:562">parseNodeString</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; token = <a href="#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;tok_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (token == <span class="Constant">NULL</span> || token[<span class="Constant">0</span>] != <span class="Constant">'}'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;did not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> '}' at end of input node&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L231" title="nodes/read.c:231">LEFT_PAREN</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *l = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Could be an integer list:&nbsp; &nbsp; (i int int ...)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or an OID list:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (o int int ...)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or an XID list:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (x int int ...)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or a bitmapset:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (b int int ...)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or a list of nodes/<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>:&nbsp; &nbsp; (node node ...)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; token = <a href="#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;tok_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (token == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unterminated List structure&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tok_len == <span class="Constant">1</span> &amp;&amp; token[<span class="Constant">0</span>] == <span class="Constant">'i'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* List of integers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *endptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; token = <a href="#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;tok_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (token == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unterminated List structure&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (token[<span class="Constant">0</span>] == <span class="Constant">')'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = (<span class="Type">int</span>) strtol(token, &amp;endptr, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (endptr != token + tok_len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized integer: </span><span class="Special">\&quot;%.*s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tok_len, token);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l = <a href="list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(l, val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (Node *) l;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (tok_len == <span class="Constant">1</span> &amp;&amp; token[<span class="Constant">0</span>] == <span class="Constant">'o'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* List of OIDs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *endptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; token = <a href="#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;tok_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (token == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unterminated List structure&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (token[<span class="Constant">0</span>] == <span class="Constant">')'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = (Oid) strtoul(token, &amp;endptr, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (endptr != token + tok_len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized OID: </span><span class="Special">\&quot;%.*s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tok_len, token);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l = <a href="list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(l, val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (Node *) l;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (tok_len == <span class="Constant">1</span> &amp;&amp; token[<span class="Constant">0</span>] == <span class="Constant">'x'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* List of TransactionIds */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *endptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; token = <a href="#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;tok_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (token == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unterminated List structure&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (token[<span class="Constant">0</span>] == <span class="Constant">')'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = (TransactionId) strtoul(token, &amp;endptr, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (endptr != token + tok_len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized Xid: </span><span class="Special">\&quot;%.*s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tok_len, token);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l = <a href="list.c.html#L393" title="nodes/list.c:393">lappend_xid</a>(l, val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (Node *) l;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (tok_len == <span class="Constant">1</span> &amp;&amp; token[<span class="Constant">0</span>] == <span class="Constant">'b'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Bitmapset -- see also <a href="readfuncs.c.html#L203" title="nodes/readfuncs.c:203">_readBitmapset</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *bms = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *endptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; token = <a href="#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;tok_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (token == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unterminated Bitmapset structure&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tok_len == <span class="Constant">1</span> &amp;&amp; token[<span class="Constant">0</span>] == <span class="Constant">')'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = (<span class="Type">int</span>) strtol(token, &amp;endptr, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (endptr != token + tok_len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized integer: </span><span class="Special">\&quot;%.*s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tok_len, token);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bms = <a href="bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(bms, val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (Node *) bms;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* List of other node types */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We have already scanned <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> token... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (token[<span class="Constant">0</span>] == <span class="Constant">')'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l = <a href="list.c.html#L339" title="nodes/list.c:339">lappend</a>(l, <a href="#L320" title="nodes/read.c:320">nodeRead</a>(token, tok_len));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; token = <a href="#L153" title="nodes/read.c:153">pg_strtok</a>(&amp;tok_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (token == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unterminated List structure&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (Node *) l;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L230" title="nodes/read.c:230">RIGHT_PAREN</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected right parenthesis&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler happy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L233" title="nodes/read.c:233">OTHER_TOKEN</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tok_len == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must be &quot;&lt;&gt;&quot; --- represents a null pointer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized token: </span><span class="Special">\&quot;%.*s\&quot;</span><span class="Constant">&quot;</span>, tok_len, token);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* keep compiler happy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Integer:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we know that the token terminates on a char atoi will stop at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (Node *) <a href="value.c.html#L23" title="nodes/value.c:23">makeInteger</a>(atoi(token));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Float:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *fval = (<span class="Type">char</span> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(tok_len + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(fval, token, tok_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fval[tok_len] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (Node *) <a href="value.c.html#L37" title="nodes/value.c:37">makeFloat</a>(fval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Boolean:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (Node *) <a href="value.c.html#L49" title="nodes/value.c:49">makeBoolean</a>(token[<span class="Constant">0</span>] == <span class="Constant">'t'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_String:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* need to remove leading and trailing quotes, and backslashes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (Node *) <a href="value.c.html#L63" title="nodes/value.c:63">makeString</a>(<a href="#L214" title="nodes/read.c:214">debackslash</a>(token + <span class="Constant">1</span>, tok_len - <span class="Constant">2</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_BitString:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* need to remove backslashes, but there are no quotes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (Node *) <a href="value.c.html#L77" title="nodes/value.c:77">makeBitString</a>(<a href="#L214" title="nodes/read.c:214">debackslash</a>(token, tok_len));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler happy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">void</span> *) result;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
