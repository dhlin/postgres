<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>nodes/bitmapset.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>nodes/bitmapset.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1432">bitmap_hash</a></li>
<li><a href="#L1442">bitmap_match</a></li>
<li><a href="#L815">bms_add_member</a></li>
<li><a href="#L917">bms_add_members</a></li>
<li><a href="#L1019">bms_add_range</a></li>
<li><a href="#L183">bms_compare</a></li>
<li><a href="#L122">bms_copy</a></li>
<li><a href="#L109">bms_copy_and_free</a></li>
<li><a href="#L868">bms_del_member</a></li>
<li><a href="#L1161">bms_del_members</a></li>
<li><a href="#L346">bms_difference</a></li>
<li><a href="#L142">bms_equal</a></li>
<li><a href="#L239">bms_free</a></li>
<li><a href="#L715">bms_get_singleton_member</a></li>
<li><a href="#L1416">bms_hash_value</a></li>
<li><a href="#L1109">bms_int_members</a></li>
<li><a href="#L292">bms_intersect</a></li>
<li><a href="#L510">bms_is_member</a></li>
<li><a href="#L412">bms_is_subset</a></li>
<li><a href="#L79">bms_is_valid_set</a></li>
<li><a href="#L1230">bms_join</a></li>
<li><a href="#L216">bms_make_singleton</a></li>
<li><a href="#L539">bms_member_index</a></li>
<li><a href="#L781">bms_membership</a></li>
<li><a href="#L1306">bms_next_member</a></li>
<li><a href="#L641">bms_nonempty_difference</a></li>
<li><a href="#L751">bms_num_members</a></li>
<li><a href="#L582">bms_overlap</a></li>
<li><a href="#L608">bms_overlap_list</a></li>
<li><a href="#L1367">bms_prev_member</a></li>
<li><a href="#L972">bms_replace_members</a></li>
<li><a href="#L672">bms_singleton_member</a></li>
<li><a href="#L445">bms_subset_compare</a></li>
<li><a href="#L251">bms_union</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L50">BITMAPSET_SIZE</a></li>
<li><a href="#L48">BITNUM</a></li>
<li><a href="#L72">HAS_MULTIPLE_ONES</a></li>
<li><a href="#L70">RIGHTMOST_ONE</a></li>
<li><a href="#L47">WORDNUM</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * bitmapset.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; PostgreSQL generic bitmap set package<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A bitmap set can represent <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> set of nonnegative integers, although<br/></li>
<li></span><span class="Comment"> * it is mainly intended for sets where the maximum value is not large,<br/></li>
<li></span><span class="Comment"> * say at most a few hundred.&nbsp; By convention, we always represent a set with<br/></li>
<li></span><span class="Comment"> * the minimum possible number of words, i.e, there are never <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> trailing<br/></li>
<li></span><span class="Comment"> * zero words.&nbsp; Enforcing this requires that an empty set is represented as<br/></li>
<li></span><span class="Comment"> * NULL.&nbsp; Because an empty Bitmapset is represented as NULL, a non-NULL<br/></li>
<li></span><span class="Comment"> * Bitmapset always has at least 1 Bitmapword.&nbsp; We can exploit this fact to<br/></li>
<li></span><span class="Comment"> * speed up various loops over the Bitmapset's words array by using &quot;do while&quot;<br/></li>
<li></span><span class="Comment"> * loops instead of &quot;for&quot; loops.&nbsp; This means the code does not waste time<br/></li>
<li></span><span class="Comment"> * checking the loop condition <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the first iteration.&nbsp; For Bitmapsets<br/></li>
<li></span><span class="Comment"> * containing only a single <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> (likely the majority of them) this halves the<br/></li>
<li></span><span class="Comment"> * number of loop condition checks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Callers must ensure that the set returned by <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in this file which<br/></li>
<li></span><span class="Comment"> * adjust the members of an existing set is assigned to all pointers pointing<br/></li>
<li></span><span class="Comment"> * to that existing set.&nbsp; No guarantees are made that we'll ever modify the<br/></li>
<li></span><span class="Comment"> * existing set in-place and return it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To <a href="../main/main.c.html#L320" title="main/main.c:320">help</a> <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> bugs caused by callers failing to record the return value of<br/></li>
<li></span><span class="Comment"> * the function which manipulates an existing set, we support building with<br/></li>
<li></span><span class="Comment"> * REALLOCATE_BITMAPSETS.&nbsp; This results in the set being reallocated each time<br/></li>
<li></span><span class="Comment"> * the set is altered and the existing being pfreed.&nbsp; This is useful as if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * references still exist to the old set, we're more likely to notice as<br/></li>
<li></span><span class="Comment"> * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> users of the old set will be accessing <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>'d memory.&nbsp; This option is<br/></li>
<li></span><span class="Comment"> * only intended to be used for debugging.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2003-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/nodes/bitmapset.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;common/hashfn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/bitmapset.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/pg_list.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bitutils.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L47">&#x200c;</a><span class="PreProc">#define <span class="linkable">WORDNUM</span>(x)&nbsp; &nbsp; ((x) / BITS_PER_BITMAPWORD)<br/></li>
<li><a id="L48">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BITNUM</span>(x)&nbsp; &nbsp; ((x) % BITS_PER_BITMAPWORD)<br/></li>
<li></span><br/></li>
<li><a id="L50">&#x200c;</a><span class="PreProc">#define <span class="linkable">BITMAPSET_SIZE</span>(nwords)&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (offsetof(Bitmapset, words) + (nwords) * </span><span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(bitmapword))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*----------<br/></li>
<li></span><span class="Comment"> * This is a well-known cute trick for isolating the rightmost one-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment"> * in a <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>.&nbsp; It assumes two's complement arithmetic.&nbsp; Consider <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * nonzero value, and focus attention on the rightmost one.&nbsp; The value is<br/></li>
<li></span><span class="Comment"> * then something like<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xxxxxx10000<br/></li>
<li></span><span class="Comment"> * where x's are unspecified bits.&nbsp; The two's complement negative is formed<br/></li>
<li></span><span class="Comment"> * by inverting all the bits and adding one.&nbsp; Inversion gives<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyyyyy01111<br/></li>
<li></span><span class="Comment"> * where each y is the inverse of the corresponding x.&nbsp; Incrementing gives<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyyyyy10000<br/></li>
<li></span><span class="Comment"> * and then ANDing with the original value gives<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 00000010000<br/></li>
<li></span><span class="Comment"> * This works for all cases except original value = zero, where of course<br/></li>
<li></span><span class="Comment"> * we get zero.<br/></li>
<li></span><span class="Comment"> *----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L70">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RIGHTMOST_ONE</span>(x) ((signedbitmapword) (x) &amp; -((signedbitmapword) (x)))<br/></li>
<li></span><br/></li>
<li><a id="L72">&#x200c;</a><span class="PreProc">#define <span class="linkable">HAS_MULTIPLE_ONES</span>(x)&nbsp; &nbsp; ((bitmapword) <a href="#L70" title="nodes/bitmapset.c:70">RIGHTMOST_ONE</a>(x) != (x))<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a> - for cassert builds to check for valid sets<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L79">&#x200c;</a></span><span class="linkable">bms_is_valid_set</span>(<span class="Type">const</span> Bitmapset *a)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* NULL is the correct representation of an empty set */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check the node tag is set correctly.&nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>'d pointer, maybe? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IsA(a, Bitmapset))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* trailing zero words are not allowed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;words[a-&gt;nwords - <span class="Constant">1</span>] == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef REALLOCATE_BITMAPSETS<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L109" title="nodes/bitmapset.c:109">bms_copy_and_free</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Only required in REALLOCATE_BITMAPSETS builds.&nbsp; Provide a simple way<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; to return a freshly allocated set and <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> the original.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: callers which <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> multiple sets must be careful when calling this<br/></li>
<li></span><span class="Comment"> * function to clone one parameter as other parameters may point to the same<br/></li>
<li></span><span class="Comment"> * set.&nbsp; A good option is to call this just <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> returning the resulting<br/></li>
<li></span><span class="Comment"> * set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Bitmapset *<br/></li>
<li><a id="L109">&#x200c;</a><span class="linkable">bms_copy_and_free</span>(Bitmapset *a)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *c = <a href="#L122" title="nodes/bitmapset.c:122">bms_copy</a>(a);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L239" title="nodes/bitmapset.c:239">bms_free</a>(a);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> c;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L122" title="nodes/bitmapset.c:122">bms_copy</a> - make a <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d copy of a bitmapset<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Bitmapset *<br/></li>
<li><a id="L122">&#x200c;</a><span class="linkable">bms_copy</span>(<span class="Type">const</span> Bitmapset *a)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = <a href="#L50" title="nodes/bitmapset.c:50">BITMAPSET_SIZE</a>(a-&gt;nwords);<br/></li>
<li>&nbsp; &nbsp; result = (Bitmapset *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(size);<br/></li>
<li>&nbsp; &nbsp; memcpy(result, a, size);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L142" title="nodes/bitmapset.c:142">bms_equal</a> - are two bitmapsets <a href="equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>? or both NULL?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L142">&#x200c;</a></span><span class="linkable">bms_equal</span>(<span class="Type">const</span> Bitmapset *a, <span class="Type">const</span> Bitmapset *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(b));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle cases where either input is NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (b == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (b == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* can't be <a href="equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> if the <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> counts don't match */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;nwords != b-&gt;nwords)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check each <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> matches */<br/></li>
<li></span>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;words[i] != b-&gt;words[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (++i &lt; a-&gt;nwords);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L183" title="nodes/bitmapset.c:183">bms_compare</a> - qsort-style comparator for bitmapsets<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This guarantees to report <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> as <a href="equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> iff <a href="#L142" title="nodes/bitmapset.c:142">bms_equal</a> would say they are<br/></li>
<li></span><span class="Comment"> * <a href="equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>.&nbsp; Otherwise, the highest-numbered <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> that is set in one value but<br/></li>
<li></span><span class="Comment"> * not the other determines the result.&nbsp; (This rule means that, for example,<br/></li>
<li></span><span class="Comment"> * {6} is greater than {5}, which seems plausible.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L183">&#x200c;</a></span><span class="linkable">bms_compare</span>(<span class="Type">const</span> Bitmapset *a, <span class="Type">const</span> Bitmapset *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(b));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle cases where either input is NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (b == <span class="Constant">NULL</span>) ? <span class="Constant">0</span> : -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (b == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> +<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the set with the most words must be greater */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;nwords != b-&gt;nwords)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (a-&gt;nwords &gt; b-&gt;nwords) ? +<span class="Constant">1</span> : -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i = a-&gt;nwords - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitmapword&nbsp; &nbsp; aw = a-&gt;words[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitmapword&nbsp; &nbsp; bw = b-&gt;words[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aw != bw)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (aw &gt; bw) ? +<span class="Constant">1</span> : -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (--i &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L216" title="nodes/bitmapset.c:216">bms_make_singleton</a> - build a bitmapset containing a single member<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Bitmapset *<br/></li>
<li><a id="L216">&#x200c;</a><span class="linkable">bms_make_singleton</span>(<span class="Type">int</span> x)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wordnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (x &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;negative bitmapset member not allowed&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; wordnum = <a href="../access/common/tidstore.c.html#L31" title="access/common/tidstore.c:31">WORDNUM</a>(x);<br/></li>
<li>&nbsp; &nbsp; bitnum = <a href="../access/common/tidstore.c.html#L32" title="access/common/tidstore.c:32">BITNUM</a>(x);<br/></li>
<li>&nbsp; &nbsp; result = (Bitmapset *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<a href="#L50" title="nodes/bitmapset.c:50">BITMAPSET_SIZE</a>(wordnum + <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; result-&gt;type = T_Bitmapset;<br/></li>
<li>&nbsp; &nbsp; result-&gt;nwords = wordnum + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;words[wordnum] = ((bitmapword) <span class="Constant">1</span> &lt;&lt; bitnum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L239" title="nodes/bitmapset.c:239">bms_free</a> - free a bitmapset<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Same as <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> except for allowing NULL input<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L239">&#x200c;</a></span><span class="linkable">bms_free</span>(Bitmapset *a)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(a);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L251" title="nodes/bitmapset.c:251">bms_union</a> - create and return a new set containing all members from both<br/></li>
<li></span><span class="Comment"> * input sets.&nbsp; Both inputs are left unmodified.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Bitmapset *<br/></li>
<li><a id="L251">&#x200c;</a><span class="linkable">bms_union</span>(<span class="Type">const</span> Bitmapset *a, <span class="Type">const</span> Bitmapset *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> Bitmapset *other;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(b));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle cases where either input is NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L122" title="nodes/bitmapset.c:122">bms_copy</a>(b);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (b == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L122" title="nodes/bitmapset.c:122">bms_copy</a>(a);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Identify shorter and longer input; copy the longer one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;nwords &lt;= b-&gt;nwords)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L122" title="nodes/bitmapset.c:122">bms_copy</a>(b);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; other = a;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L122" title="nodes/bitmapset.c:122">bms_copy</a>(a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; other = b;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And union the shorter input into the result */<br/></li>
<li></span>&nbsp; &nbsp; otherlen = other-&gt;nwords;<br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;words[i] |= other-&gt;words[i];<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (++i &lt; otherlen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L292" title="nodes/bitmapset.c:292">bms_intersect</a> - create and return a new set containing members which both<br/></li>
<li></span><span class="Comment"> * input sets have in common.&nbsp; Both inputs are left unmodified.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Bitmapset *<br/></li>
<li><a id="L292">&#x200c;</a><span class="linkable">bms_intersect</span>(<span class="Type">const</span> Bitmapset *a, <span class="Type">const</span> Bitmapset *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> Bitmapset *other;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastnonzero;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(b));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle cases where either input is NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span> || b == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Identify shorter and longer input; copy the shorter one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;nwords &lt;= b-&gt;nwords)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L122" title="nodes/bitmapset.c:122">bms_copy</a>(a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; other = b;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L122" title="nodes/bitmapset.c:122">bms_copy</a>(b);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; other = a;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And intersect the longer input with the result */<br/></li>
<li></span>&nbsp; &nbsp; resultlen = result-&gt;nwords;<br/></li>
<li>&nbsp; &nbsp; lastnonzero = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;words[i] &amp;= other-&gt;words[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result-&gt;words[i] != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastnonzero = i;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (++i &lt; resultlen);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we computed an empty result, we must return NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lastnonzero == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* get rid of trailing zero words */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;nwords = lastnonzero + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L346" title="nodes/bitmapset.c:346">bms_difference</a> - create and return a new set containing all the members of<br/></li>
<li></span><span class="Comment"> * 'a' without the members of 'b'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Bitmapset *<br/></li>
<li><a id="L346">&#x200c;</a><span class="linkable">bms_difference</span>(<span class="Type">const</span> Bitmapset *a, <span class="Type">const</span> Bitmapset *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(b));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle cases where either input is NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (b == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L122" title="nodes/bitmapset.c:122">bms_copy</a>(a);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In Postgres' usage, an empty result is a very common case, so it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worth optimizing for that by testing <a href="#L641" title="nodes/bitmapset.c:641">bms_nonempty_difference</a>().&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * saves us a <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>/<a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> cycle compared to checking after-the-fact.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L641" title="nodes/bitmapset.c:641">bms_nonempty_difference</a>(a, b))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy the left input */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="#L122" title="nodes/bitmapset.c:122">bms_copy</a>(a);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And remove b's bits from result */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result-&gt;nwords &gt; b-&gt;nwords)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We'll never need to remove trailing zero words when 'a' has more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * words than 'b' as the additional words must be non-zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;words[i] &amp;= ~b-&gt;words[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (++i &lt; b-&gt;nwords);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastnonzero = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we may need to remove trailing zero words from the result. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;words[i] &amp;= ~b-&gt;words[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remember the last non-zero <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result-&gt;words[i] != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastnonzero = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (++i &lt; result-&gt;nwords);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* trim off trailing zero words */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;nwords = lastnonzero + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(result-&gt;nwords != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Need not check for empty result, since we handled that case above */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L412" title="nodes/bitmapset.c:412">bms_is_subset</a> - is A a <a href="../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of B?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L412">&#x200c;</a></span><span class="linkable">bms_is_subset</span>(<span class="Type">const</span> Bitmapset *a, <span class="Type">const</span> Bitmapset *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(b));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle cases where either input is NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* empty set is a <a href="../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of anything */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (b == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* 'a' can't be a <a href="../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of 'b' if it contains more words */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;nwords &gt; b-&gt;nwords)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check all 'a' members are set in 'b' */<br/></li>
<li></span>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((a-&gt;words[i] &amp; ~b-&gt;words[i]) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (++i &lt; a-&gt;nwords);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L445" title="nodes/bitmapset.c:445">bms_subset_compare</a> - <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> A and B for equality/<a href="../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> relationships<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is more efficient than testing <a href="#L412" title="nodes/bitmapset.c:412">bms_is_subset</a> in both directions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BMS_Comparison<br/></li>
<li><a id="L445">&#x200c;</a><span class="linkable">bms_subset_compare</span>(<span class="Type">const</span> Bitmapset *a, <span class="Type">const</span> Bitmapset *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BMS_Comparison result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shortlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(b));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle cases where either input is NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (b == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> BMS_EQUAL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> BMS_SUBSET1;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (b == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> BMS_SUBSET2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check common words */<br/></li>
<li></span>&nbsp; &nbsp; result = BMS_EQUAL;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* status so far */<br/></li>
<li></span>&nbsp; &nbsp; shortlen = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(a-&gt;nwords, b-&gt;nwords);<br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitmapword&nbsp; &nbsp; aword = a-&gt;words[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitmapword&nbsp; &nbsp; bword = b-&gt;words[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((aword &amp; ~bword) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* a is not a <a href="../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of b */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result == BMS_SUBSET1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> BMS_DIFFERENT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = BMS_SUBSET2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((bword &amp; ~aword) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* b is not a <a href="../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of a */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result == BMS_SUBSET2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> BMS_DIFFERENT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = BMS_SUBSET1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (++i &lt; shortlen);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check extra words */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;nwords &gt; b-&gt;nwords)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if a has more words then a is not a <a href="../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of b */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result == BMS_SUBSET1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> BMS_DIFFERENT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> BMS_SUBSET2;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (a-&gt;nwords &lt; b-&gt;nwords)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if b has more words then b is not a <a href="../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of a */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result == BMS_SUBSET2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> BMS_DIFFERENT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> BMS_SUBSET1;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L510" title="nodes/bitmapset.c:510">bms_is_member</a> - is X a member of A?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L510">&#x200c;</a></span><span class="linkable">bms_is_member</span>(<span class="Type">int</span> x, <span class="Type">const</span> Bitmapset *a)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wordnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> better to just return false for x&lt;0 ? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (x &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;negative bitmapset member not allowed&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; wordnum = <a href="../access/common/tidstore.c.html#L31" title="access/common/tidstore.c:31">WORDNUM</a>(x);<br/></li>
<li>&nbsp; &nbsp; bitnum = <a href="../access/common/tidstore.c.html#L32" title="access/common/tidstore.c:32">BITNUM</a>(x);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (wordnum &gt;= a-&gt;nwords)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((a-&gt;words[wordnum] &amp; ((bitmapword) <span class="Constant">1</span> &lt;&lt; bitnum)) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L539" title="nodes/bitmapset.c:539">bms_member_index</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; determine 0-based index of member x in the bitmap<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns (-1) when x is not a member.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L539">&#x200c;</a></span><span class="linkable">bms_member_index</span>(Bitmapset *a, <span class="Type">int</span> x)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitnum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wordnum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; bitmapword&nbsp; &nbsp; mask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* return -1 if not a member of the bitmap */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(x, a))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; wordnum = <a href="../access/common/tidstore.c.html#L31" title="access/common/tidstore.c:31">WORDNUM</a>(x);<br/></li>
<li>&nbsp; &nbsp; bitnum = <a href="../access/common/tidstore.c.html#L32" title="access/common/tidstore.c:32">BITNUM</a>(x);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* count bits in preceding words */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; wordnum; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitmapword&nbsp; &nbsp; w = a-&gt;words[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No need to count the bits in a zero <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (w != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result += bmw_popcount(w);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now add bits of the last <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>, but only those <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the item. We can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do that by applying a mask and then using popcount again. To get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 0-based index, we want to count only preceding bits, not the item<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * itself, so we subtract 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; mask = ((bitmapword) <span class="Constant">1</span> &lt;&lt; bitnum) - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; result += bmw_popcount(a-&gt;words[wordnum] &amp; mask);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L582" title="nodes/bitmapset.c:582">bms_overlap</a> - do sets overlap (ie, have a nonempty intersection)?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L582">&#x200c;</a></span><span class="linkable">bms_overlap</span>(<span class="Type">const</span> Bitmapset *a, <span class="Type">const</span> Bitmapset *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shortlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(b));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle cases where either input is NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span> || b == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check words in common */<br/></li>
<li></span>&nbsp; &nbsp; shortlen = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(a-&gt;nwords, b-&gt;nwords);<br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((a-&gt;words[i] &amp; b-&gt;words[i]) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (++i &lt; shortlen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L608" title="nodes/bitmapset.c:608">bms_overlap_list</a> - does a set overlap an integer list?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L608">&#x200c;</a></span><span class="linkable">bms_overlap_list</span>(<span class="Type">const</span> Bitmapset *a, <span class="Type">const</span> List *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wordnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span> || b == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, b)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x = lfirst_int(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (x &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;negative bitmapset member not allowed&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; wordnum = <a href="../access/common/tidstore.c.html#L31" title="access/common/tidstore.c:31">WORDNUM</a>(x);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitnum = <a href="../access/common/tidstore.c.html#L32" title="access/common/tidstore.c:32">BITNUM</a>(x);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (wordnum &lt; a-&gt;nwords)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((a-&gt;words[wordnum] &amp; ((bitmapword) <span class="Constant">1</span> &lt;&lt; bitnum)) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L641" title="nodes/bitmapset.c:641">bms_nonempty_difference</a> - do sets have a nonempty difference?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * i.e., are <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> members set in 'a' that are not also set in 'b'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L641">&#x200c;</a></span><span class="linkable">bms_nonempty_difference</span>(<span class="Type">const</span> Bitmapset *a, <span class="Type">const</span> Bitmapset *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(b));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle cases where either input is NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (b == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if 'a' has more words then it must contain additional members */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;nwords &gt; b-&gt;nwords)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check all 'a' members are set in 'b' */<br/></li>
<li></span>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((a-&gt;words[i] &amp; ~b-&gt;words[i]) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (++i &lt; a-&gt;nwords);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L672" title="nodes/bitmapset.c:672">bms_singleton_member</a> - return the sole integer member of set<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Raises error if |a| is not 1.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L672">&#x200c;</a></span><span class="linkable">bms_singleton_member</span>(<span class="Type">const</span> Bitmapset *a)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nwords;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wordnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;bitmapset is empty&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nwords = a-&gt;nwords;<br/></li>
<li>&nbsp; &nbsp; wordnum = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitmapword&nbsp; &nbsp; w = a-&gt;words[wordnum];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (w != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result &gt;= <span class="Constant">0</span> || <a href="#L72" title="nodes/bitmapset.c:72">HAS_MULTIPLE_ONES</a>(w))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;bitmapset has multiple members&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = wordnum * BITS_PER_BITMAPWORD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result += bmw_rightmost_one_pos(w);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (++wordnum &lt; nwords);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we don't expect non-NULL sets to be empty */<br/></li>
<li></span>&nbsp; &nbsp; Assert(result &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L715" title="nodes/bitmapset.c:715">bms_get_singleton_member</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Test whether the given set is a singleton.<br/></li>
<li></span><span class="Comment"> * If so, set *member to the value of its sole member, and return true.<br/></li>
<li></span><span class="Comment"> * If not, return false, without changing *member.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is more convenient and faster than calling <a href="#L781" title="nodes/bitmapset.c:781">bms_membership</a>() and then<br/></li>
<li></span><span class="Comment"> * <a href="#L672" title="nodes/bitmapset.c:672">bms_singleton_member</a>(), if we don't care about distinguishing empty sets<br/></li>
<li></span><span class="Comment"> * from multiple-member sets.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L715">&#x200c;</a></span><span class="linkable">bms_get_singleton_member</span>(<span class="Type">const</span> Bitmapset *a, <span class="Type">int</span> *member)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nwords;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wordnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nwords = a-&gt;nwords;<br/></li>
<li>&nbsp; &nbsp; wordnum = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitmapword&nbsp; &nbsp; w = a-&gt;words[wordnum];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (w != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result &gt;= <span class="Constant">0</span> || <a href="#L72" title="nodes/bitmapset.c:72">HAS_MULTIPLE_ONES</a>(w))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = wordnum * BITS_PER_BITMAPWORD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result += bmw_rightmost_one_pos(w);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (++wordnum &lt; nwords);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we don't expect non-NULL sets to be empty */<br/></li>
<li></span>&nbsp; &nbsp; Assert(result &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; *member = result;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L751" title="nodes/bitmapset.c:751">bms_num_members</a> - count members of set<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L751">&#x200c;</a></span><span class="linkable">bms_num_members</span>(<span class="Type">const</span> Bitmapset *a)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nwords;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wordnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nwords = a-&gt;nwords;<br/></li>
<li>&nbsp; &nbsp; wordnum = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitmapword&nbsp; &nbsp; w = a-&gt;words[wordnum];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No need to count the bits in a zero <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (w != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result += bmw_popcount(w);<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (++wordnum &lt; nwords);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L781" title="nodes/bitmapset.c:781">bms_membership</a> - does a set have zero, one, or multiple members?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is faster than making an exact count with <a href="#L751" title="nodes/bitmapset.c:751">bms_num_members</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BMS_Membership<br/></li>
<li><a id="L781">&#x200c;</a><span class="linkable">bms_membership</span>(<span class="Type">const</span> Bitmapset *a)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BMS_Membership result = BMS_EMPTY_SET;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nwords;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wordnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> BMS_EMPTY_SET;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nwords = a-&gt;nwords;<br/></li>
<li>&nbsp; &nbsp; wordnum = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitmapword&nbsp; &nbsp; w = a-&gt;words[wordnum];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (w != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result != BMS_EMPTY_SET || <a href="#L72" title="nodes/bitmapset.c:72">HAS_MULTIPLE_ONES</a>(w))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> BMS_MULTIPLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = BMS_SINGLETON;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (++wordnum &lt; nwords);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L815" title="nodes/bitmapset.c:815">bms_add_member</a> - add a specified member to set<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'a' is recycled when possible.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Bitmapset *<br/></li>
<li><a id="L815">&#x200c;</a><span class="linkable">bms_add_member</span>(Bitmapset *a, <span class="Type">int</span> x)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wordnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (x &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;negative bitmapset member not allowed&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L216" title="nodes/bitmapset.c:216">bms_make_singleton</a>(x);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; wordnum = <a href="../access/common/tidstore.c.html#L31" title="access/common/tidstore.c:31">WORDNUM</a>(x);<br/></li>
<li>&nbsp; &nbsp; bitnum = <a href="../access/common/tidstore.c.html#L32" title="access/common/tidstore.c:32">BITNUM</a>(x);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* enlarge the set if necessary */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (wordnum &gt;= a-&gt;nwords)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldnwords = a-&gt;nwords;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a = (Bitmapset *) <a href="../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(a, <a href="#L50" title="nodes/bitmapset.c:50">BITMAPSET_SIZE</a>(wordnum + <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a-&gt;nwords = wordnum + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* zero out the enlarged portion */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; i = oldnwords;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a-&gt;words[i] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (++i &lt; a-&gt;nwords);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; a-&gt;words[wordnum] |= ((bitmapword) <span class="Constant">1</span> &lt;&lt; bitnum);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef REALLOCATE_BITMAPSETS<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There's no guarantee that the <a href="../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a> returned a new pointer, so copy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and free unconditionally here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; a = <a href="#L109" title="nodes/bitmapset.c:109">bms_copy_and_free</a>(a);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> a;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L868" title="nodes/bitmapset.c:868">bms_del_member</a> - remove a specified member from set<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * No error if x is not currently a member of set<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'a' is recycled when possible.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Bitmapset *<br/></li>
<li><a id="L868">&#x200c;</a><span class="linkable">bms_del_member</span>(Bitmapset *a, <span class="Type">int</span> x)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wordnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (x &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;negative bitmapset member not allowed&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; wordnum = <a href="../access/common/tidstore.c.html#L31" title="access/common/tidstore.c:31">WORDNUM</a>(x);<br/></li>
<li>&nbsp; &nbsp; bitnum = <a href="../access/common/tidstore.c.html#L32" title="access/common/tidstore.c:32">BITNUM</a>(x);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef REALLOCATE_BITMAPSETS<br/></li>
<li></span>&nbsp; &nbsp; a = <a href="#L109" title="nodes/bitmapset.c:109">bms_copy_and_free</a>(a);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* member can't exist.&nbsp; Return 'a' unmodified */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(wordnum &gt;= a-&gt;nwords))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; a-&gt;words[wordnum] &amp;= ~((bitmapword) <span class="Constant">1</span> &lt;&lt; bitnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* when last <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> becomes empty, trim off all trailing empty words */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;words[wordnum] == <span class="Constant">0</span> &amp;&amp; wordnum == a-&gt;nwords - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the last non-empty <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> and make that the new final <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = wordnum - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;words[i] != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a-&gt;nwords = i + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> a;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the set is <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> empty */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> a;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L917" title="nodes/bitmapset.c:917">bms_add_members</a> - like <a href="#L251" title="nodes/bitmapset.c:251">bms_union</a>, but left input is recycled when possible<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Bitmapset *<br/></li>
<li><a id="L917">&#x200c;</a><span class="linkable">bms_add_members</span>(Bitmapset *a, <span class="Type">const</span> Bitmapset *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> Bitmapset *other;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(b));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle cases where either input is NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L122" title="nodes/bitmapset.c:122">bms_copy</a>(b);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (b == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef REALLOCATE_BITMAPSETS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; a = <a href="#L109" title="nodes/bitmapset.c:109">bms_copy_and_free</a>(a);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> a;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Identify shorter and longer input; copy the longer one if needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;nwords &lt; b-&gt;nwords)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L122" title="nodes/bitmapset.c:122">bms_copy</a>(b);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; other = a;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = a;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; other = b;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And union the shorter input into the result */<br/></li>
<li></span>&nbsp; &nbsp; otherlen = other-&gt;nwords;<br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;words[i] |= other-&gt;words[i];<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (++i &lt; otherlen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result != a)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(a);<br/></li>
<li><span class="PreProc">#ifdef REALLOCATE_BITMAPSETS<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L109" title="nodes/bitmapset.c:109">bms_copy_and_free</a>(result);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L972" title="nodes/bitmapset.c:972">bms_replace_members</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Remove all existing members from 'a' and repopulate the set with members<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; from 'b', recycling 'a', when possible.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Bitmapset *<br/></li>
<li><a id="L972">&#x200c;</a><span class="linkable">bms_replace_members</span>(Bitmapset *a, <span class="Type">const</span> Bitmapset *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(b));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L122" title="nodes/bitmapset.c:122">bms_copy</a>(b);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (b == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;nwords &lt; b-&gt;nwords)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a = (Bitmapset *) <a href="../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(a, <a href="#L50" title="nodes/bitmapset.c:50">BITMAPSET_SIZE</a>(b-&gt;nwords));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a-&gt;words[i] = b-&gt;words[i];<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (++i &lt; b-&gt;nwords);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; a-&gt;nwords = b-&gt;nwords;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef REALLOCATE_BITMAPSETS<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There's no guarantee that the <a href="../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a> returned a new pointer, so copy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and free unconditionally here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; a = <a href="#L109" title="nodes/bitmapset.c:109">bms_copy_and_free</a>(a);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> a;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1019" title="nodes/bitmapset.c:1019">bms_add_range</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Add members in the <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of '<a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>' to '<a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>' to the set.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note this could also be done by calling <a href="#L815" title="nodes/bitmapset.c:815">bms_add_member</a> in a loop, however,<br/></li>
<li></span><span class="Comment"> * using this function will be faster when the <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is large as we work at<br/></li>
<li></span><span class="Comment"> * the bitmapword level rather than at <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> level.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Bitmapset *<br/></li>
<li><a id="L1019">&#x200c;</a><span class="linkable">bms_add_range</span>(Bitmapset *a, <span class="Type">int</span> <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, <span class="Type">int</span> <a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lwordnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lbitnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uwordnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ushiftbits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wordnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do nothing if nothing is called for, without further checking */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> &lt; <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef REALLOCATE_BITMAPSETS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; a = <a href="#L109" title="nodes/bitmapset.c:109">bms_copy_and_free</a>(a);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> a;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;negative bitmapset member not allowed&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; uwordnum = <a href="../access/common/tidstore.c.html#L31" title="access/common/tidstore.c:31">WORDNUM</a>(<a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a = (Bitmapset *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<a href="#L50" title="nodes/bitmapset.c:50">BITMAPSET_SIZE</a>(uwordnum + <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a-&gt;type = T_Bitmapset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a-&gt;nwords = uwordnum + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (uwordnum &gt;= a-&gt;nwords)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldnwords = a-&gt;nwords;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ensure we have enough words to store the <a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; a = (Bitmapset *) <a href="../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(a, <a href="#L50" title="nodes/bitmapset.c:50">BITMAPSET_SIZE</a>(uwordnum + <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a-&gt;nwords = uwordnum + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* zero out the enlarged portion */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; i = oldnwords;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a-&gt;words[i] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (++i &lt; a-&gt;nwords);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; wordnum = lwordnum = <a href="../access/common/tidstore.c.html#L31" title="access/common/tidstore.c:31">WORDNUM</a>(<a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lbitnum = <a href="../access/common/tidstore.c.html#L32" title="access/common/tidstore.c:32">BITNUM</a>(<a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>);<br/></li>
<li>&nbsp; &nbsp; ushiftbits = BITS_PER_BITMAPWORD - (<a href="../access/common/tidstore.c.html#L32" title="access/common/tidstore.c:32">BITNUM</a>(<a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>) + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Special case when lwordnum is the same as uwordnum we must perform the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> and <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> masking on the <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lwordnum == uwordnum)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a-&gt;words[lwordnum] |= ~(bitmapword) (((bitmapword) <span class="Constant">1</span> &lt;&lt; lbitnum) - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp; (~(bitmapword) <span class="Constant">0</span>) &gt;&gt; ushiftbits;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* turn on lbitnum and all bits left of it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; a-&gt;words[wordnum++] |= ~(bitmapword) (((bitmapword) <span class="Constant">1</span> &lt;&lt; lbitnum) - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* turn on all bits for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> intermediate words */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (wordnum &lt; uwordnum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a-&gt;words[wordnum++] = ~(bitmapword) <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* turn on <a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>'s <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> and all bits right of it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; a-&gt;words[uwordnum] |= (~(bitmapword) <span class="Constant">0</span>) &gt;&gt; ushiftbits;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef REALLOCATE_BITMAPSETS<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There's no guarantee that the <a href="../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a> returned a new pointer, so copy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and free unconditionally here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; a = <a href="#L109" title="nodes/bitmapset.c:109">bms_copy_and_free</a>(a);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> a;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1109" title="nodes/bitmapset.c:1109">bms_int_members</a> - like <a href="#L292" title="nodes/bitmapset.c:292">bms_intersect</a>, but left input is recycled when<br/></li>
<li></span><span class="Comment"> * possible<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Bitmapset *<br/></li>
<li><a id="L1109">&#x200c;</a><span class="linkable">bms_int_members</span>(Bitmapset *a, <span class="Type">const</span> Bitmapset *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastnonzero;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shortlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(b));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle cases where either input is NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (b == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Intersect b into a; we need never copy */<br/></li>
<li></span>&nbsp; &nbsp; shortlen = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(a-&gt;nwords, b-&gt;nwords);<br/></li>
<li>&nbsp; &nbsp; lastnonzero = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a-&gt;words[i] &amp;= b-&gt;words[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;words[i] != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastnonzero = i;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (++i &lt; shortlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we computed an empty result, we must return NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lastnonzero == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* get rid of trailing zero words */<br/></li>
<li></span>&nbsp; &nbsp; a-&gt;nwords = lastnonzero + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef REALLOCATE_BITMAPSETS<br/></li>
<li></span>&nbsp; &nbsp; a = <a href="#L109" title="nodes/bitmapset.c:109">bms_copy_and_free</a>(a);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> a;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1161" title="nodes/bitmapset.c:1161">bms_del_members</a> - delete members in 'a' that are set in 'b'.&nbsp; 'a' is<br/></li>
<li></span><span class="Comment"> * recycled when possible.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Bitmapset *<br/></li>
<li><a id="L1161">&#x200c;</a><span class="linkable">bms_del_members</span>(Bitmapset *a, <span class="Type">const</span> Bitmapset *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(b));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle cases where either input is NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (b == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef REALLOCATE_BITMAPSETS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; a = <a href="#L109" title="nodes/bitmapset.c:109">bms_copy_and_free</a>(a);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> a;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove b's bits from a; we need never copy */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;nwords &gt; b-&gt;nwords)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We'll never need to remove trailing zero words when 'a' has more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * words than 'b'.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a-&gt;words[i] &amp;= ~b-&gt;words[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (++i &lt; b-&gt;nwords);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastnonzero = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we may need to remove trailing zero words from the result. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a-&gt;words[i] &amp;= ~b-&gt;words[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remember the last non-zero <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;words[i] != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastnonzero = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (++i &lt; a-&gt;nwords);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check if 'a' has become empty */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lastnonzero == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* trim off <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> trailing zero words */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; a-&gt;nwords = lastnonzero + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef REALLOCATE_BITMAPSETS<br/></li>
<li></span>&nbsp; &nbsp; a = <a href="#L109" title="nodes/bitmapset.c:109">bms_copy_and_free</a>(a);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> a;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1230" title="nodes/bitmapset.c:1230">bms_join</a> - like <a href="#L251" title="nodes/bitmapset.c:251">bms_union</a>, but *either* input *may* be recycled<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Bitmapset *<br/></li>
<li><a id="L1230">&#x200c;</a><span class="linkable">bms_join</span>(Bitmapset *a, Bitmapset *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *other;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(b));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle cases where either input is NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef REALLOCATE_BITMAPSETS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; b = <a href="#L109" title="nodes/bitmapset.c:109">bms_copy_and_free</a>(b);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> b;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (b == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef REALLOCATE_BITMAPSETS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; a = <a href="#L109" title="nodes/bitmapset.c:109">bms_copy_and_free</a>(a);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> a;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Identify shorter and longer input; use longer one as result */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;nwords &lt; b-&gt;nwords)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = b;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; other = a;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = a;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; other = b;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And union the shorter input into the result */<br/></li>
<li></span>&nbsp; &nbsp; otherlen = other-&gt;nwords;<br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;words[i] |= other-&gt;words[i];<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (++i &lt; otherlen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (other != result)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pure paranoia */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(other);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef REALLOCATE_BITMAPSETS<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="#L109" title="nodes/bitmapset.c:109">bms_copy_and_free</a>(result);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a> - <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> member of a set<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns smallest member greater than &quot;prevbit&quot;, or -2 if there is <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>.<br/></li>
<li></span><span class="Comment"> * &quot;prevbit&quot; must NOT be less than -1, or the behavior is unpredictable.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is intended as support for iterating through the members of a set.<br/></li>
<li></span><span class="Comment"> * The typical pattern is<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x = -1;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while ((x = <a href="#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(inputset, x)) &gt;= 0)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; process member x;<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Notice that when there are no more members, we return -2, not -1 as you<br/></li>
<li></span><span class="Comment"> * might expect.&nbsp; The rationale for that is to allow distinguishing the<br/></li>
<li></span><span class="Comment"> * loop-not-started state (x == -1) from the loop-completed state (x == -2).<br/></li>
<li></span><span class="Comment"> * It makes no difference in simple loop usage, but complex iteration logic<br/></li>
<li></span><span class="Comment"> * might need such an ability.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1306">&#x200c;</a></span><span class="linkable">bms_next_member</span>(<span class="Type">const</span> Bitmapset *a, <span class="Type">int</span> prevbit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nwords;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wordnum;<br/></li>
<li>&nbsp; &nbsp; bitmapword&nbsp; &nbsp; mask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; nwords = a-&gt;nwords;<br/></li>
<li>&nbsp; &nbsp; prevbit++;<br/></li>
<li>&nbsp; &nbsp; mask = (~(bitmapword) <span class="Constant">0</span>) &lt;&lt; <a href="../access/common/tidstore.c.html#L32" title="access/common/tidstore.c:32">BITNUM</a>(prevbit);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (wordnum = <a href="../access/common/tidstore.c.html#L31" title="access/common/tidstore.c:31">WORDNUM</a>(prevbit); wordnum &lt; nwords; wordnum++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitmapword&nbsp; &nbsp; w = a-&gt;words[wordnum];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore bits <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> prevbit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; w &amp;= mask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (w != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = wordnum * BITS_PER_BITMAPWORD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result += bmw_rightmost_one_pos(w);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* in subsequent words, consider all bits */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mask = (~(bitmapword) <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">2</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1367" title="nodes/bitmapset.c:1367">bms_prev_member</a> - <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> prev member of a set<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns largest member less than &quot;prevbit&quot;, or -2 if there is <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>.<br/></li>
<li></span><span class="Comment"> * &quot;prevbit&quot; must NOT be more than one above the highest possible <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> that can<br/></li>
<li></span><span class="Comment"> * be set at the Bitmapset at its current size.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To ease finding the highest set <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> for the initial loop, the special<br/></li>
<li></span><span class="Comment"> * prevbit value of -1 can be passed to have the function <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the highest<br/></li>
<li></span><span class="Comment"> * valued member in the set.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is intended as support for iterating through the members of a set in<br/></li>
<li></span><span class="Comment"> * reverse.&nbsp; The typical pattern is<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x = -1;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while ((x = <a href="#L1367" title="nodes/bitmapset.c:1367">bms_prev_member</a>(inputset, x)) &gt;= 0)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; process member x;<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Notice that when there are no more members, we return -2, not -1 as you<br/></li>
<li></span><span class="Comment"> * might expect.&nbsp; The rationale for that is to allow distinguishing the<br/></li>
<li></span><span class="Comment"> * loop-not-started state (x == -1) from the loop-completed state (x == -2).<br/></li>
<li></span><span class="Comment"> * It makes no difference in simple loop usage, but complex iteration logic<br/></li>
<li></span><span class="Comment"> * might need such an ability.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">int<br/></li>
<li><a id="L1367">&#x200c;</a></span><span class="linkable">bms_prev_member</span>(<span class="Type">const</span> Bitmapset *a, <span class="Type">int</span> prevbit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wordnum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ushiftbits;<br/></li>
<li>&nbsp; &nbsp; bitmapword&nbsp; &nbsp; mask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If set is NULL or if there are no more bits to the right then we've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nothing to do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span> || prevbit == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transform -1 to the highest possible <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> we could have set */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (prevbit == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prevbit = a-&gt;nwords * BITS_PER_BITMAPWORD - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; prevbit--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ushiftbits = BITS_PER_BITMAPWORD - (<a href="../access/common/tidstore.c.html#L32" title="access/common/tidstore.c:32">BITNUM</a>(prevbit) + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; mask = (~(bitmapword) <span class="Constant">0</span>) &gt;&gt; ushiftbits;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (wordnum = <a href="../access/common/tidstore.c.html#L31" title="access/common/tidstore.c:31">WORDNUM</a>(prevbit); wordnum &gt;= <span class="Constant">0</span>; wordnum--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitmapword&nbsp; &nbsp; w = a-&gt;words[wordnum];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mask out bits left of prevbit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; w &amp;= mask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (w != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = wordnum * BITS_PER_BITMAPWORD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result += bmw_leftmost_one_pos(w);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* in subsequent words, consider all bits */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mask = (~(bitmapword) <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">2</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1416" title="nodes/bitmapset.c:1416">bms_hash_value</a> - compute a <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key for a Bitmapset<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>uint32<br/></li>
<li><a id="L1416">&#x200c;</a><span class="linkable">bms_hash_value</span>(<span class="Type">const</span> Bitmapset *a)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L79" title="nodes/bitmapset.c:79">bms_is_valid_set</a>(a));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* All empty sets <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> to 0 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetUInt32(hash_any((<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span> *) a-&gt;words,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; a-&gt;nwords * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(bitmapword)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1432" title="nodes/bitmapset.c:1432">bitmap_hash</a> - <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function for keys that are (pointers to) Bitmapsets<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: don't forget to specify <a href="#L1442" title="nodes/bitmapset.c:1442">bitmap_match</a> as the match function!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>uint32<br/></li>
<li><a id="L1432">&#x200c;</a><span class="linkable">bitmap_hash</span>(<span class="Type">const</span> <span class="Type">void</span> *key, Size keysize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(keysize == <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Bitmapset *));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1416" title="nodes/bitmapset.c:1416">bms_hash_value</a>(*((<span class="Type">const</span> Bitmapset *<span class="Type">const</span> *) key));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1442" title="nodes/bitmapset.c:1442">bitmap_match</a> - match function to use with <a href="#L1432" title="nodes/bitmapset.c:1432">bitmap_hash</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1442">&#x200c;</a></span><span class="linkable">bitmap_match</span>(<span class="Type">const</span> <span class="Type">void</span> *key1, <span class="Type">const</span> <span class="Type">void</span> *key2, Size keysize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(keysize == <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Bitmapset *));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> !<a href="#L142" title="nodes/bitmapset.c:142">bms_equal</a>(*((<span class="Type">const</span> Bitmapset *<span class="Type">const</span> *) key1),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *((<span class="Type">const</span> Bitmapset *<span class="Type">const</span> *) key2));<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
