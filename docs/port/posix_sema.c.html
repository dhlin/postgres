<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>port/posix_sema.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>port/posix_sema.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L67">maxSems</a></li>
<li><a href="#L62">mySemPointers</a></li>
<li><a href="#L68">nextSemKey</a></li>
<li><a href="#L66">numSems</a></li>
<li><a href="#L64">sharedSemas</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L52">PGSemaphoreData</a></li>
<li><a href="#L55">PGSemaphoreData</a></li>
<li><a href="#L45">SemTPadded</a></li>
<li><a href="#L49">SemTPadded</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L196">PGReserveSemaphores</a></li>
<li><a href="#L262">PGSemaphoreCreate</a></li>
<li><a href="#L320">PGSemaphoreLock</a></li>
<li><a href="#L295">PGSemaphoreReset</a></li>
<li><a href="#L165">PGSemaphoreShmemSize</a></li>
<li><a href="#L365">PGSemaphoreTryLock</a></li>
<li><a href="#L340">PGSemaphoreUnlock</a></li>
<li><a href="#L86">PosixSemaphoreCreate</a></li>
<li><a href="#L135">PosixSemaphoreCreate</a></li>
<li><a href="#L147">PosixSemaphoreKill</a></li>
<li><a href="#L240">ReleaseSemaphores</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L59">IPCProtection</a></li>
<li><a href="#L57">PG_SEM_REF</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * posix_sema.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Implement PGSemaphores using POSIX semaphore facilities<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We prefer the unnamed style of POSIX semaphore (the kind made with<br/></li>
<li></span><span class="Comment"> * sem_init).&nbsp; We can cope with the kind made with sem_open, however.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In either implementation, typedef PGSemaphore is equivalent to &quot;sem_t *&quot;.<br/></li>
<li></span><span class="Comment"> * With unnamed semaphores, the sem_t structs live in an array in shared<br/></li>
<li></span><span class="Comment"> * memory.&nbsp; With named semaphores, that's not true because we cannot persuade<br/></li>
<li></span><span class="Comment"> * sem_open to do its allocation there.&nbsp; Therefore, the named-semaphore code<br/></li>
<li></span><span class="Comment"> * *does not cope with EXEC_BACKEND*.&nbsp; The sem_t structs will just be in the<br/></li>
<li></span><span class="Comment"> * postmaster's private memory, where they are successfully inherited by<br/></li>
<li></span><span class="Comment"> * forked backends, but they could not be accessed by exec'd backends.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/port/posix_sema.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;semaphore.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;signal.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/pg_sema.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/shmem.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* see file header comment */<br/></li>
<li></span><span class="PreProc">#if defined(USE_NAMED_POSIX_SEMAPHORES) &amp;&amp; defined(EXEC_BACKEND)<br/></li>
<li></span><span class="PreProc">#error cannot use named POSIX semaphores with EXEC_BACKEND<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L45">&#x200c;</a><span class="Type">typedef</span> <span class="Type">union</span> <span class="linkable">SemTPadded</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; sem_t&nbsp; &nbsp; &nbsp; &nbsp; pgsem;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; pad[PG_CACHE_LINE_SIZE];<br/></li>
<li><a id="L49">&#x200c;</a>} <span class="linkable">SemTPadded</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* typedef PGSemaphore is equivalent to pointer to sem_t */<br/></li>
<li><a id="L52">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">PGSemaphoreData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L45" title="port/posix_sema.c:45">SemTPadded</a>&nbsp; &nbsp; sem_padded;<br/></li>
<li><a id="L55">&#x200c;</a>} <span class="linkable">PGSemaphoreData</span>;<br/></li>
<li><br/></li>
<li><a id="L57">&#x200c;</a><span class="PreProc">#define <span class="linkable">PG_SEM_REF</span>(x)&nbsp; &nbsp; (&amp;(x)-&gt;sem_padded.pgsem)<br/></li>
<li></span><br/></li>
<li><a id="L59">&#x200c;</a><span class="PreProc">#define <span class="linkable">IPCProtection</span>&nbsp; &nbsp; (0</span><span class="Constant">600</span><span class="PreProc">)&nbsp; &nbsp; </span><span class="Comment">/* access/modify by user only */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef USE_NAMED_POSIX_SEMAPHORES<br/></li>
<li><a id="L62">&#x200c;</a></span><span class="Type">static</span> sem_t **<span class="linkable">mySemPointers</span>;&nbsp; &nbsp; <span class="Comment">/* keep track of created semaphores */<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li><a id="L64">&#x200c;</a></span><span class="Type">static</span> PGSemaphore <span class="linkable">sharedSemas</span>; <span class="Comment">/* array of <a href="#L52" title="port/posix_sema.c:52">PGSemaphoreData</a> in shared memory */<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li><a id="L66">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">numSems</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of semas acquired so far */<br/></li>
<li><a id="L67">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">maxSems</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allocated size of above arrays */<br/></li>
<li><a id="L68">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">nextSemKey</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> name to try */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L240" title="port/posix_sema.c:240">ReleaseSemaphores</a>(<span class="Type">int</span> status, Datum arg);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_NAMED_POSIX_SEMAPHORES<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L86" title="port/posix_sema.c:86">PosixSemaphoreCreate</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Attempt to create a new named semaphore.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If we fail with a failure code other than collision-with-existing-sema,<br/></li>
<li></span><span class="Comment"> * <a href="../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> out an error and abort.&nbsp; Other types of errors suggest nonrecoverable<br/></li>
<li></span><span class="Comment"> * problems.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> sem_t *<br/></li>
<li><a id="L86">&#x200c;</a><span class="linkable">PosixSemaphoreCreate</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; semKey;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; semname[<span class="Constant">64</span>];<br/></li>
<li>&nbsp; &nbsp; sem_t&nbsp; &nbsp; &nbsp;&nbsp; *mySem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; semKey = <a href="#L68" title="port/posix_sema.c:68">nextSemKey</a>++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(semname, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(semname), <span class="Constant">&quot;/pgsql-</span><span class="Special">%d</span><span class="Constant">&quot;</span>, semKey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mySem = sem_open(semname, O_CREAT | O_EXCL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (mode_t) <a href="#L59" title="port/posix_sema.c:59">IPCProtection</a>, (<span class="Type">unsigned</span>) <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef SEM_FAILED<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mySem != (sem_t *) SEM_FAILED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mySem != (sem_t *) (-<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Loop if error indicates a collision */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EEXIST</span> || errno == <span class="Constant">EACCES</span> || errno == <span class="Constant">EINTR</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Else complain and abort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;sem_open(</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">) failed: %m&quot;</span>, semname);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unlink the semaphore immediately, so it can't be accessed externally.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This also ensures that it will go away if we crash.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sem_unlink(semname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> mySem;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* !USE_NAMED_POSIX_SEMAPHORES */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L86" title="port/posix_sema.c:86">PosixSemaphoreCreate</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Attempt to create a new unnamed semaphore.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L135">&#x200c;</a></span><span class="linkable">PosixSemaphoreCreate</span>(sem_t *sem)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sem_init(sem, <span class="Constant">1</span>, <span class="Constant">1</span>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;sem_init failed: %m&quot;</span>);<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_NAMED_POSIX_SEMAPHORES */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L147" title="port/posix_sema.c:147">PosixSemaphoreKill</a>&nbsp; &nbsp; - removes a semaphore<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L147">&#x200c;</a></span><span class="linkable">PosixSemaphoreKill</span>(sem_t *sem)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_NAMED_POSIX_SEMAPHORES<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Got to use sem_close for named semaphores */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sem_close(sem) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;sem_close failed: %m&quot;</span>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Got to use sem_destroy for unnamed semaphores */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sem_destroy(sem) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;sem_destroy failed: %m&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Report amount of shared memory needed for semaphores<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L165">&#x200c;</a><span class="linkable">PGSemaphoreShmemSize</span>(<span class="Type">int</span> maxSemas)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_NAMED_POSIX_SEMAPHORES<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* No shared memory needed in this case */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Need a <a href="#L52" title="port/posix_sema.c:52">PGSemaphoreData</a> per semaphore */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(maxSemas, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L52" title="port/posix_sema.c:52">PGSemaphoreData</a>));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L196" title="port/posix_sema.c:196">PGReserveSemaphores</a> --- <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> semaphore support<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called during postmaster start or shared memory reinitialization.<br/></li>
<li></span><span class="Comment"> * It should do whatever is needed to be able to support up to maxSemas<br/></li>
<li></span><span class="Comment"> * subsequent <a href="#L262" title="port/posix_sema.c:262">PGSemaphoreCreate</a> calls.&nbsp; Also, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> system resources<br/></li>
<li></span><span class="Comment"> * are acquired here or in <a href="#L262" title="port/posix_sema.c:262">PGSemaphoreCreate</a>, register an <a href="../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a><br/></li>
<li></span><span class="Comment"> * callback to release them.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the Posix implementation, we acquire semaphores on-demand; the<br/></li>
<li></span><span class="Comment"> * maxSemas parameter is just used to size the arrays.&nbsp; For unnamed<br/></li>
<li></span><span class="Comment"> * semaphores, there is an array of <a href="#L52" title="port/posix_sema.c:52">PGSemaphoreData</a> structs in shared memory.<br/></li>
<li></span><span class="Comment"> * For named semaphores, we keep a postmaster-local array of sem_t pointers,<br/></li>
<li></span><span class="Comment"> * which we use for releasing the semaphores when done.<br/></li>
<li></span><span class="Comment"> * (This design minimizes the dependency of postmaster shutdown on the<br/></li>
<li></span><span class="Comment"> * contents of shared memory, which a failed backend might have clobbered.<br/></li>
<li></span><span class="Comment"> * We can't do much about the possibility of sem_destroy() crashing, but<br/></li>
<li></span><span class="Comment"> * we don't have to expose the counters to other processes.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L196">&#x200c;</a></span><span class="linkable">PGReserveSemaphores</span>(<span class="Type">int</span> maxSemas)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> stat statbuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use the data directory's inode number to seed the search for free<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * semaphore keys.&nbsp; This minimizes the odds of collision with other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * postmasters, while maximizing the odds that we will detect and clean up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * semaphores left over from a crashed postmaster in our own directory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stat(<a href="../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>, &amp;statbuf) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not stat data directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>)));<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_NAMED_POSIX_SEMAPHORES<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L62" title="port/posix_sema.c:62">mySemPointers</a> = (sem_t **) malloc(maxSemas * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(sem_t *));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L62" title="port/posix_sema.c:62">mySemPointers</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;out of memory&quot;</span>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must use <a href="../storage/ipc/shmem.c.html#L238" title="storage/ipc/shmem.c:238">ShmemAllocUnlocked</a>(), since the spinlock protecting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../storage/ipc/shmem.c.html#L152" title="storage/ipc/shmem.c:152">ShmemAlloc</a>() won't be ready yet.&nbsp; (This ordering is necessary when we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are emulating spinlocks with semaphores.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L64" title="port/posix_sema.c:64">sharedSemas</a> = (PGSemaphore)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/shmem.c.html#L238" title="storage/ipc/shmem.c:238">ShmemAllocUnlocked</a>(<a href="#L165" title="port/posix_sema.c:165">PGSemaphoreShmemSize</a>(maxSemas));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="port/posix_sema.c:66">numSems</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L67" title="port/posix_sema.c:67">maxSems</a> = maxSemas;<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="port/posix_sema.c:68">nextSemKey</a> = statbuf.st_ino;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a>(<a href="#L240" title="port/posix_sema.c:240">ReleaseSemaphores</a>, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Release semaphores at shutdown or shmem reinitialization<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (called as an <a href="../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a> callback, hence funny argument list)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L240">&#x200c;</a></span><span class="linkable">ReleaseSemaphores</span>(<span class="Type">int</span> status, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_NAMED_POSIX_SEMAPHORES<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L66" title="port/posix_sema.c:66">numSems</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L147" title="port/posix_sema.c:147">PosixSemaphoreKill</a>(<a href="#L62" title="port/posix_sema.c:62">mySemPointers</a>[i]);<br/></li>
<li>&nbsp; &nbsp; free(<a href="#L62" title="port/posix_sema.c:62">mySemPointers</a>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef USE_UNNAMED_POSIX_SEMAPHORES<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L66" title="port/posix_sema.c:66">numSems</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L147" title="port/posix_sema.c:147">PosixSemaphoreKill</a>(<a href="#L57" title="port/posix_sema.c:57">PG_SEM_REF</a>(<a href="#L64" title="port/posix_sema.c:64">sharedSemas</a> + i));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L262" title="port/posix_sema.c:262">PGSemaphoreCreate</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Allocate a PGSemaphore structure with initial count 1<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PGSemaphore<br/></li>
<li><a id="L262">&#x200c;</a><span class="linkable">PGSemaphoreCreate</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGSemaphore sema;<br/></li>
<li>&nbsp; &nbsp; sem_t&nbsp; &nbsp; &nbsp;&nbsp; *newsem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't do this in a backend, because static state is postmaster's */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!<a href="../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L66" title="port/posix_sema.c:66">numSems</a> &gt;= <a href="#L67" title="port/posix_sema.c:67">maxSems</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;too many semaphores created&quot;</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_NAMED_POSIX_SEMAPHORES<br/></li>
<li></span>&nbsp; &nbsp; newsem = <a href="#L86" title="port/posix_sema.c:86">PosixSemaphoreCreate</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remember new sema for <a href="#L240" title="port/posix_sema.c:240">ReleaseSemaphores</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L62" title="port/posix_sema.c:62">mySemPointers</a>[<a href="#L66" title="port/posix_sema.c:66">numSems</a>] = newsem;<br/></li>
<li>&nbsp; &nbsp; sema = (PGSemaphore) newsem;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; sema = &amp;<a href="#L64" title="port/posix_sema.c:64">sharedSemas</a>[<a href="#L66" title="port/posix_sema.c:66">numSems</a>];<br/></li>
<li>&nbsp; &nbsp; newsem = <a href="#L57" title="port/posix_sema.c:57">PG_SEM_REF</a>(sema);<br/></li>
<li>&nbsp; &nbsp; <a href="#L86" title="port/posix_sema.c:86">PosixSemaphoreCreate</a>(newsem);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="port/posix_sema.c:66">numSems</a>++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> sema;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L295" title="port/posix_sema.c:295">PGSemaphoreReset</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Reset a previously-initialized PGSemaphore to have count 0<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L295">&#x200c;</a></span><span class="linkable">PGSemaphoreReset</span>(PGSemaphore sema)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There's no direct API for this in POSIX, so we have to ratchet the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * semaphore down to 0 with repeated trywait's.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sem_trywait(<a href="#L57" title="port/posix_sema.c:57">PG_SEM_REF</a>(sema)) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EAGAIN</span> || errno == <span class="Constant">EDEADLK</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* got it down to 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EINTR</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can this happen? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;sem_trywait failed: %m&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L320" title="port/posix_sema.c:320">PGSemaphoreLock</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Lock a semaphore (decrement count), blocking if count would be &lt; 0<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L320">&#x200c;</a></span><span class="linkable">PGSemaphoreLock</span>(PGSemaphore sema)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errStatus;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* See notes in sysv_sema.c's implementation of <a href="#L320" title="port/posix_sema.c:320">PGSemaphoreLock</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errStatus = sem_wait(<a href="#L57" title="port/posix_sema.c:57">PG_SEM_REF</a>(sema));<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (errStatus &lt; <span class="Constant">0</span> &amp;&amp; errno == <span class="Constant">EINTR</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errStatus &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;sem_wait failed: %m&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L340" title="port/posix_sema.c:340">PGSemaphoreUnlock</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlock a semaphore (increment count)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L340">&#x200c;</a></span><span class="linkable">PGSemaphoreUnlock</span>(PGSemaphore sema)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errStatus;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: if errStatus is -1 and errno == EINTR then it means we returned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the operation prematurely because we were sent a signal.&nbsp; So we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * try and unlock the semaphore again. Not clear this can really happen,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but might as well cope.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errStatus = sem_post(<a href="#L57" title="port/posix_sema.c:57">PG_SEM_REF</a>(sema));<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (errStatus &lt; <span class="Constant">0</span> &amp;&amp; errno == <span class="Constant">EINTR</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errStatus &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;sem_post failed: %m&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L365" title="port/posix_sema.c:365">PGSemaphoreTryLock</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Lock a semaphore only if able to do so without blocking<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L365">&#x200c;</a></span><span class="linkable">PGSemaphoreTryLock</span>(PGSemaphore sema)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errStatus;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: if errStatus is -1 and errno == EINTR then it means we returned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the operation prematurely because we were sent a signal.&nbsp; So we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * try and lock the semaphore again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errStatus = sem_trywait(<a href="#L57" title="port/posix_sema.c:57">PG_SEM_REF</a>(sema));<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (errStatus &lt; <span class="Constant">0</span> &amp;&amp; errno == <span class="Constant">EINTR</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errStatus &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EAGAIN</span> || errno == <span class="Constant">EDEADLK</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* failed to lock it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise we got trouble */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;sem_trywait failed: %m&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
