<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>port/atomics.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>port/atomics.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L89">pg_atomic_clear_flag_impl</a></li>
<li><a href="#L137">pg_atomic_compare_exchange_u32_impl</a></li>
<li><a href="#L200">pg_atomic_compare_exchange_u64_impl</a></li>
<li><a href="#L165">pg_atomic_fetch_add_u32_impl</a></li>
<li><a href="#L228">pg_atomic_fetch_add_u64_impl</a></li>
<li><a href="#L55">pg_atomic_init_flag_impl</a></li>
<li><a href="#L106">pg_atomic_init_u32_impl</a></li>
<li><a href="#L182">pg_atomic_init_u64_impl</a></li>
<li><a href="#L76">pg_atomic_test_set_flag_impl</a></li>
<li><a href="#L97">pg_atomic_unlocked_test_flag_impl</a></li>
<li><a href="#L124">pg_atomic_write_u32_impl</a></li>
<li><a href="#L45">pg_extern_compiler_barrier</a></li>
<li><a href="#L29">pg_spinlock_barrier</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * atomics.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; Non-Inline parts of the atomics implementation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 2013-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/port/atomics.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/atomics.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/spin.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef PG_HAVE_MEMORY_BARRIER_EMULATION<br/></li>
<li></span><span class="PreProc">#ifdef WIN32<br/></li>
<li></span><span class="PreProc">#error </span><span class="Constant">&quot;barriers are required (and provided) on WIN32 platforms&quot;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;signal.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef PG_HAVE_MEMORY_BARRIER_EMULATION<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L29">&#x200c;</a></span><span class="linkable">pg_spinlock_barrier</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: we have to be reentrant here, some barriers are placed in signal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handlers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use kill(0) for the fallback barrier as we assume that kernels on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * systems old enough to require fallback barrier support will include an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * appropriate barrier while checking the existence of the postmaster pid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) kill(<a href="../utils/init/globals.c.html#L103" title="utils/init/globals.c:103">PostmasterPid</a>, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef PG_HAVE_COMPILER_BARRIER_EMULATION<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L45">&#x200c;</a></span><span class="linkable">pg_extern_compiler_barrier</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do nothing */<br/></li>
<li></span>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef PG_HAVE_ATOMIC_FLAG_SIMULATION<br/></li>
<li></span><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L55">&#x200c;</a></span><span class="linkable">pg_atomic_init_flag_impl</span>(<span class="Type">volatile</span> pg_atomic_flag *ptr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StaticAssertDecl(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ptr-&gt;sema) &gt;= <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(slock_t),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;size mismatch of atomic_flag vs slock_t&quot;</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef HAVE_SPINLOCKS<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: If we're using semaphore based TAS emulation, be careful to use a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * separate set of semaphores. Otherwise we'd get in trouble if an atomic<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * var would be manipulated while spinlock is held.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/spin.c.html#L121" title="storage/lmgr/spin.c:121">s_init_lock_sema</a>((slock_t *) &amp;ptr-&gt;sema, <span class="Constant">true</span>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; SpinLockInit((slock_t *) &amp;ptr-&gt;sema);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; ptr-&gt;value = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L76">&#x200c;</a></span><span class="linkable">pg_atomic_test_set_flag_impl</span>(<span class="Type">volatile</span> pg_atomic_flag *ptr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; oldval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire((slock_t *) &amp;ptr-&gt;sema);<br/></li>
<li>&nbsp; &nbsp; oldval = ptr-&gt;value;<br/></li>
<li>&nbsp; &nbsp; ptr-&gt;value = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease((slock_t *) &amp;ptr-&gt;sema);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> oldval == <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L89">&#x200c;</a></span><span class="linkable">pg_atomic_clear_flag_impl</span>(<span class="Type">volatile</span> pg_atomic_flag *ptr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire((slock_t *) &amp;ptr-&gt;sema);<br/></li>
<li>&nbsp; &nbsp; ptr-&gt;value = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease((slock_t *) &amp;ptr-&gt;sema);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L97">&#x200c;</a></span><span class="linkable">pg_atomic_unlocked_test_flag_impl</span>(<span class="Type">volatile</span> pg_atomic_flag *ptr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ptr-&gt;value == <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* PG_HAVE_ATOMIC_FLAG_SIMULATION */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef PG_HAVE_ATOMIC_U32_SIMULATION<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L106">&#x200c;</a></span><span class="linkable">pg_atomic_init_u32_impl</span>(<span class="Type">volatile</span> pg_atomic_uint32 *ptr, uint32 val_)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StaticAssertDecl(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ptr-&gt;sema) &gt;= <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(slock_t),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;size mismatch of atomic_uint32 vs slock_t&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're using semaphore based atomic flags, be careful about nested<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * usage of atomics while a spinlock is held.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifndef HAVE_SPINLOCKS<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/spin.c.html#L121" title="storage/lmgr/spin.c:121">s_init_lock_sema</a>((slock_t *) &amp;ptr-&gt;sema, <span class="Constant">true</span>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; SpinLockInit((slock_t *) &amp;ptr-&gt;sema);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; ptr-&gt;value = val_;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L124">&#x200c;</a></span><span class="linkable">pg_atomic_write_u32_impl</span>(<span class="Type">volatile</span> pg_atomic_uint32 *ptr, uint32 val)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * One might think that an unlocked write doesn't need to acquire the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * spinlock, but one would be wrong. Even an unlocked write has to cause a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * concurrent pg_atomic_compare_exchange_u32() (et al) to fail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire((slock_t *) &amp;ptr-&gt;sema);<br/></li>
<li>&nbsp; &nbsp; ptr-&gt;value = val;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease((slock_t *) &amp;ptr-&gt;sema);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L137">&#x200c;</a></span><span class="linkable">pg_atomic_compare_exchange_u32_impl</span>(<span class="Type">volatile</span> pg_atomic_uint32 *ptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 *expected, uint32 <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do atomic op under a spinlock. It might look like we could just <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the cmpxchg if the lock isn't available, but that'd just emulate a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'weak' <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> and swap. I.e. one that allows spurious failures. Since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * several algorithms rely on a strong variant and that is efficiently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * implementable on most major architectures let's emulate it here as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire((slock_t *) &amp;ptr-&gt;sema);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* perform <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>/exchange logic */<br/></li>
<li></span>&nbsp; &nbsp; ret = ptr-&gt;value == *expected;<br/></li>
<li>&nbsp; &nbsp; *expected = ptr-&gt;value;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ret)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr-&gt;value = <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and release lock */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockRelease((slock_t *) &amp;ptr-&gt;sema);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>uint32<br/></li>
<li><a id="L165">&#x200c;</a><span class="linkable">pg_atomic_fetch_add_u32_impl</span>(<span class="Type">volatile</span> pg_atomic_uint32 *ptr, int32 add_)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; oldval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire((slock_t *) &amp;ptr-&gt;sema);<br/></li>
<li>&nbsp; &nbsp; oldval = ptr-&gt;value;<br/></li>
<li>&nbsp; &nbsp; ptr-&gt;value += add_;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease((slock_t *) &amp;ptr-&gt;sema);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> oldval;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* PG_HAVE_ATOMIC_U32_SIMULATION */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef PG_HAVE_ATOMIC_U64_SIMULATION<br/></li>
<li></span><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L182">&#x200c;</a></span><span class="linkable">pg_atomic_init_u64_impl</span>(<span class="Type">volatile</span> pg_atomic_uint64 *ptr, uint64 val_)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StaticAssertDecl(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ptr-&gt;sema) &gt;= <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(slock_t),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;size mismatch of atomic_uint64 vs slock_t&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're using semaphore based atomic flags, be careful about nested<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * usage of atomics while a spinlock is held.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifndef HAVE_SPINLOCKS<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/spin.c.html#L121" title="storage/lmgr/spin.c:121">s_init_lock_sema</a>((slock_t *) &amp;ptr-&gt;sema, <span class="Constant">true</span>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; SpinLockInit((slock_t *) &amp;ptr-&gt;sema);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; ptr-&gt;value = val_;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L200">&#x200c;</a></span><span class="linkable">pg_atomic_compare_exchange_u64_impl</span>(<span class="Type">volatile</span> pg_atomic_uint64 *ptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint64 *expected, uint64 <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do atomic op under a spinlock. It might look like we could just <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the cmpxchg if the lock isn't available, but that'd just emulate a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'weak' <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> and swap. I.e. one that allows spurious failures. Since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * several algorithms rely on a strong variant and that is efficiently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * implementable on most major architectures let's emulate it here as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire((slock_t *) &amp;ptr-&gt;sema);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* perform <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>/exchange logic */<br/></li>
<li></span>&nbsp; &nbsp; ret = ptr-&gt;value == *expected;<br/></li>
<li>&nbsp; &nbsp; *expected = ptr-&gt;value;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ret)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr-&gt;value = <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and release lock */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockRelease((slock_t *) &amp;ptr-&gt;sema);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>uint64<br/></li>
<li><a id="L228">&#x200c;</a><span class="linkable">pg_atomic_fetch_add_u64_impl</span>(<span class="Type">volatile</span> pg_atomic_uint64 *ptr, int64 add_)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; oldval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire((slock_t *) &amp;ptr-&gt;sema);<br/></li>
<li>&nbsp; &nbsp; oldval = ptr-&gt;value;<br/></li>
<li>&nbsp; &nbsp; ptr-&gt;value += add_;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease((slock_t *) &amp;ptr-&gt;sema);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> oldval;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* PG_HAVE_ATOMIC_U64_SIMULATION */<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
