<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>port/win32_shmem.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>port/win32_shmem.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L42">ShmemProtectiveRegion</a></li>
<li><a href="#L45">UsedShmemSegAddr</a></li>
<li><a href="#L44">UsedShmemSegID</a></li>
<li><a href="#L46">UsedShmemSegSize</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L137">EnableLockPagesPrivilege</a></li>
<li><a href="#L630">GetHugePageSize</a></li>
<li><a href="#L65">GetSharedMemName</a></li>
<li><a href="#L207">PGSharedMemoryCreate</a></li>
<li><a href="#L505">PGSharedMemoryDetach</a></li>
<li><a href="#L113">PGSharedMemoryIsInUse</a></li>
<li><a href="#L472">PGSharedMemoryNoReAttach</a></li>
<li><a href="#L424">PGSharedMemoryReAttach</a></li>
<li><a href="#L642">check_huge_page_size</a></li>
<li><a href="#L573">pgwin32_ReserveSharedMemoryRegion</a></li>
<li><a href="#L549">pgwin32_SharedMemoryDelete</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L41">PROTECTIVE_REGION_SIZE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * win32_shmem.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Implement shared memory using win32 facilities<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/port/win32_shmem.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/dsm.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/pg_shmem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc_hooks.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Early in a process's life, Windows asynchronously creates threads for the<br/></li>
<li></span><span class="Comment"> * process's &quot;default thread pool&quot;<br/></li>
<li></span><span class="Comment"> * (https://docs.microsoft.com/en-us/windows/desktop/ProcThread/thread-pools).<br/></li>
<li></span><span class="Comment"> * Occasionally, thread creation allocates a stack after<br/></li>
<li></span><span class="Comment"> * <a href="#L424" title="port/win32_shmem.c:424">PGSharedMemoryReAttach</a>() has released <a href="#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a> and <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it has<br/></li>
<li></span><span class="Comment"> * mapped shared memory at <a href="#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a>.&nbsp; This would cause mapping to fail<br/></li>
<li></span><span class="Comment"> * if the allocator preferred the just-released region for allocating the new<br/></li>
<li></span><span class="Comment"> * thread stack.&nbsp; We observed such failures in some Windows Server 2016<br/></li>
<li></span><span class="Comment"> * configurations.&nbsp; To give the system another region to prefer, reserve and<br/></li>
<li></span><span class="Comment"> * release an additional, protective region immediately <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> reserving or<br/></li>
<li></span><span class="Comment"> * releasing shared memory.&nbsp; The idea is that, if the allocator handed out<br/></li>
<li></span><span class="Comment"> * REGION1 pages <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> REGION2 pages at one occasion, it will do so whenever<br/></li>
<li></span><span class="Comment"> * both regions are free.&nbsp; Windows Server 2016 exhibits that behavior, and a<br/></li>
<li></span><span class="Comment"> * system behaving differently would have less need to protect<br/></li>
<li></span><span class="Comment"> * <a href="#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a>.&nbsp; The protective region must be at least large enough for<br/></li>
<li></span><span class="Comment"> * one thread stack.&nbsp; However, ten times as much is less than 2% of the 32-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment"> * address space and is negligible relative to the 64-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> address space.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L41">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PROTECTIVE_REGION_SIZE</span> (</span><span class="Constant">10</span><span class="PreProc"> * WIN32_STACK_RLIMIT)<br/></li>
<li><a id="L42">&#x200c;</a></span><span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">ShmemProtectiveRegion</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><a id="L44">&#x200c;</a>HANDLE&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">UsedShmemSegID</span> = INVALID_HANDLE_VALUE;<br/></li>
<li><a id="L45">&#x200c;</a><span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">UsedShmemSegAddr</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L46">&#x200c;</a><span class="Type">static</span> Size <span class="linkable">UsedShmemSegSize</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L137" title="port/win32_shmem.c:137">EnableLockPagesPrivilege</a>(<span class="Type">int</span> elevel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L549" title="port/win32_shmem.c:549">pgwin32_SharedMemoryDelete</a>(<span class="Type">int</span> status, Datum shmId);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generate shared memory segment name. Expand the data directory, to generate<br/></li>
<li></span><span class="Comment"> * an identifier unique for this data directory. Then replace all backslashes<br/></li>
<li></span><span class="Comment"> * with forward slashes, since backslashes aren't permitted in global object names.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Store the shared memory segment in the Global\ namespace (requires NT2 TSE or<br/></li>
<li></span><span class="Comment"> * 2000, but that's all we support for other reasons as well), to make sure you can't<br/></li>
<li></span><span class="Comment"> * open two postmasters in different sessions against the same data directory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment">: What happens with junctions? It's only someone breaking things on purpose,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and this is still better than <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>, but we might want to do something about<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; that sometime in the future.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L65">&#x200c;</a><span class="linkable">GetSharedMemName</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *retptr;<br/></li>
<li>&nbsp; &nbsp; DWORD&nbsp; &nbsp; &nbsp; &nbsp; bufsize;<br/></li>
<li>&nbsp; &nbsp; DWORD&nbsp; &nbsp; &nbsp; &nbsp; r;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bufsize = GetFullPathName(<a href="../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>, <span class="Constant">0</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bufsize == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;could not get size for full pathname of datadir </span><span class="Special">%s</span><span class="Constant">: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>, GetLastError());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; retptr = malloc(bufsize + <span class="Constant">18</span>);&nbsp; &nbsp; <span class="Comment">/* 18 for Global\PostgreSQL: */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (retptr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;could not allocate memory for shared memory name&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; strcpy(retptr, <span class="Constant">&quot;Global</span><span class="Special">\\</span><span class="Constant">PostgreSQL:&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; r = GetFullPathName(<a href="../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>, bufsize, retptr + <span class="Constant">18</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (r == <span class="Constant">0</span> || r &gt; bufsize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;could not generate full pathname for datadir </span><span class="Special">%s</span><span class="Constant">: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>, GetLastError());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: Intentionally overwriting the Global\ part here. This was not the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * original approach, but putting it in the actual Global\ namespace<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * causes permission errors in a lot of cases, so we leave it in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * default namespace for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (cp = retptr; *cp; cp++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cp == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp = <span class="Constant">'/'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> retptr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L113" title="port/win32_shmem.c:113">PGSharedMemoryIsInUse</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Is a previously-existing shmem segment still existing and in use?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The point of this exercise is to detect the case where a prior postmaster<br/></li>
<li></span><span class="Comment"> * crashed, but it left child backends that are still running.&nbsp; Therefore<br/></li>
<li></span><span class="Comment"> * we only care about shmem segments that are associated with the intended<br/></li>
<li></span><span class="Comment"> * <a href="../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>.&nbsp; This is an important consideration since accidental matches of<br/></li>
<li></span><span class="Comment"> * shmem segment IDs are reasonably common.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L113">&#x200c;</a></span><span class="linkable">PGSharedMemoryIsInUse</span>(<span class="Type">unsigned</span> <span class="Type">long</span> id1, <span class="Type">unsigned</span> <span class="Type">long</span> id2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *szShareMem;<br/></li>
<li>&nbsp; &nbsp; HANDLE&nbsp; &nbsp; &nbsp; &nbsp; hmap;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; szShareMem = <a href="#L65" title="port/win32_shmem.c:65">GetSharedMemName</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hmap = OpenFileMapping(FILE_MAP_READ, FALSE, szShareMem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; free(szShareMem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hmap == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; CloseHandle(hmap);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L137" title="port/win32_shmem.c:137">EnableLockPagesPrivilege</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Try to acquire SeLockMemoryPrivilege so we can use large pages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L137">&#x200c;</a></span><span class="linkable">EnableLockPagesPrivilege</span>(<span class="Type">int</span> elevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HANDLE&nbsp; &nbsp; &nbsp; &nbsp; hToken;<br/></li>
<li>&nbsp; &nbsp; TOKEN_PRIVILEGES tp;<br/></li>
<li>&nbsp; &nbsp; LUID&nbsp; &nbsp; &nbsp; &nbsp; luid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not enable user right </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>,<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * translator: This is a term from Windows and should be translated to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * match the Windows localization.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;Lock pages in memory&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GetLastError()),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failed system call was </span><span class="Special">%s</span><span class="Constant">.&quot;</span>, <span class="Constant">&quot;OpenProcessToken&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> FALSE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!LookupPrivilegeValue(<span class="Constant">NULL</span>, SE_LOCK_MEMORY_NAME, &amp;luid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not enable user right </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>, <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;Lock pages in memory&quot;</span>), GetLastError()),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failed system call was </span><span class="Special">%s</span><span class="Constant">.&quot;</span>, <span class="Constant">&quot;LookupPrivilegeValue&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CloseHandle(hToken);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> FALSE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; tp.PrivilegeCount = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; tp.Privileges[<span class="Constant">0</span>].Luid = luid;<br/></li>
<li>&nbsp; &nbsp; tp.Privileges[<span class="Constant">0</span>].Attributes = SE_PRIVILEGE_ENABLED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!AdjustTokenPrivileges(hToken, FALSE, &amp;tp, <span class="Constant">0</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not enable user right </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>, <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;Lock pages in memory&quot;</span>), GetLastError()),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failed system call was </span><span class="Special">%s</span><span class="Constant">.&quot;</span>, <span class="Constant">&quot;AdjustTokenPrivileges&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CloseHandle(hToken);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> FALSE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (GetLastError() != ERROR_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GetLastError() == ERROR_NOT_ALL_ASSIGNED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not enable user right </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;Lock pages in memory&quot;</span>)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Assign user right </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> to the Windows user account which runs PostgreSQL.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;Lock pages in memory&quot;</span>))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not enable user right </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>, <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;Lock pages in memory&quot;</span>), GetLastError()),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failed system call was </span><span class="Special">%s</span><span class="Constant">.&quot;</span>, <span class="Constant">&quot;AdjustTokenPrivileges&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CloseHandle(hToken);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> FALSE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; CloseHandle(hToken);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> TRUE;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L207" title="port/win32_shmem.c:207">PGSharedMemoryCreate</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Create a shared memory segment of the given size and <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> its<br/></li>
<li></span><span class="Comment"> * standard header.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PGShmemHeader *<br/></li>
<li><a id="L207">&#x200c;</a><span class="linkable">PGSharedMemoryCreate</span>(Size size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PGShmemHeader **shim)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *memAddress;<br/></li>
<li>&nbsp; &nbsp; PGShmemHeader *hdr;<br/></li>
<li>&nbsp; &nbsp; HANDLE&nbsp; &nbsp; &nbsp; &nbsp; hmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hmap2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *szShareMem;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; DWORD&nbsp; &nbsp; &nbsp; &nbsp; size_high;<br/></li>
<li>&nbsp; &nbsp; DWORD&nbsp; &nbsp; &nbsp; &nbsp; size_low;<br/></li>
<li>&nbsp; &nbsp; SIZE_T&nbsp; &nbsp; &nbsp; &nbsp; largePageSize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; orig_size = size;<br/></li>
<li>&nbsp; &nbsp; DWORD&nbsp; &nbsp; &nbsp; &nbsp; flProtect = PAGE_READWRITE;<br/></li>
<li>&nbsp; &nbsp; DWORD&nbsp; &nbsp; &nbsp; &nbsp; desiredAccess;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L42" title="port/win32_shmem.c:42">ShmemProtectiveRegion</a> = VirtualAlloc(<span class="Constant">NULL</span>, <a href="#L41" title="port/win32_shmem.c:41">PROTECTIVE_REGION_SIZE</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MEM_RESERVE, PAGE_NOACCESS);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L42" title="port/win32_shmem.c:42">ShmemProtectiveRegion</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;could not reserve memory region: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GetLastError());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Room for a header? */<br/></li>
<li></span>&nbsp; &nbsp; Assert(size &gt; MAXALIGN(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PGShmemHeader)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; szShareMem = <a href="#L65" title="port/win32_shmem.c:65">GetSharedMemName</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L565" title="utils/misc/guc_tables.c:565">huge_pages</a> == HUGE_PAGES_ON || <a href="../utils/misc/guc_tables.c.html#L565" title="utils/misc/guc_tables.c:565">huge_pages</a> == HUGE_PAGES_TRY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Does the processor support large pages? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; largePageSize = GetLargePageMinimum();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (largePageSize == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(<a href="../utils/misc/guc_tables.c.html#L565" title="utils/misc/guc_tables.c:565">huge_pages</a> == HUGE_PAGES_ON ? FATAL : DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;the processor does not support large pages&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;disabling huge pages&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="#L137" title="port/win32_shmem.c:137">EnableLockPagesPrivilege</a>(<a href="../utils/misc/guc_tables.c.html#L565" title="utils/misc/guc_tables.c:565">huge_pages</a> == HUGE_PAGES_ON ? FATAL : DEBUG1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;disabling huge pages&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Huge pages available and privilege enabled, so turn on */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flProtect = PAGE_READWRITE | SEC_COMMIT | SEC_LARGE_PAGES;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Round size up as appropriate. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (size % largePageSize != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size += largePageSize - (size % largePageSize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="Statement">retry</span><span class="cUserCont">:<br/></li>
<li></span><span class="PreProc">#ifdef _WIN64<br/></li>
<li></span>&nbsp; &nbsp; size_high = size &gt;&gt; <span class="Constant">32</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; size_high = <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; size_low = (DWORD) size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When recycling a shared memory segment, it may take a short while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it gets dropped from the global namespace. So re-try after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sleeping for a second, and continue retrying 10 times. (both the 1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * second time and the 10 retries are completely arbitrary)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <span class="Constant">10</span>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In case CreateFileMapping() doesn't set the error code to 0 on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * success<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SetLastError(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hmap = CreateFileMapping(INVALID_HANDLE_VALUE,&nbsp; &nbsp; <span class="Comment">/* Use the pagefile */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,&nbsp; &nbsp; <span class="Comment">/* Default security attrs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; flProtect,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; size_high, <span class="Comment">/* Size Upper 32 Bits&nbsp; &nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; size_low,&nbsp; &nbsp; <span class="Comment">/* Size Lower 32 bits */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; szShareMem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!hmap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GetLastError() == ERROR_NO_SYSTEM_RESOURCES &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc_tables.c.html#L565" title="utils/misc/guc_tables.c:565">huge_pages</a> == HUGE_PAGES_TRY &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (flProtect &amp; SEC_LARGE_PAGES) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;CreateFileMapping(</span><span class="Special">%zu</span><span class="Constant">) with SEC_LARGE_PAGES failed, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;huge pages disabled&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use the original size, not the rounded-up value, when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * falling back to non-huge pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size = orig_size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flProtect = PAGE_READWRITE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> retry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create shared memory segment: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>, GetLastError()),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failed system call was CreateFileMapping(size=</span><span class="Special">%zu</span><span class="Constant">, name=</span><span class="Special">%s</span><span class="Constant">).&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; size, szShareMem)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the segment already existed, CreateFileMapping() will return a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * handle to the existing one and set ERROR_ALREADY_EXISTS.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GetLastError() == ERROR_ALREADY_EXISTS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CloseHandle(hmap);&nbsp; &nbsp; <span class="Comment">/* Close the handle, since we got a valid one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the previous segment. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hmap = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sleep(<span class="Constant">1000</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the last call in the loop still returned ERROR_ALREADY_EXISTS, this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shared memory segment exists and we assume it belongs to somebody else.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!hmap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;pre-existing shared memory block is still in use&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Check if there are <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> old server processes still running, and terminate them.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; free(szShareMem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make the handle inheritable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!DuplicateHandle(GetCurrentProcess(), hmap, GetCurrentProcess(), &amp;hmap2, <span class="Constant">0</span>, TRUE, DUPLICATE_SAME_ACCESS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create shared memory segment: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>, GetLastError()),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failed system call was DuplicateHandle.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Close the old, non-inheritable handle. If this fails we don't really<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * care.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!CloseHandle(hmap))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;could not close handle to shared memory: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>, GetLastError());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; desiredAccess = FILE_MAP_WRITE | FILE_MAP_READ;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef FILE_MAP_LARGE_PAGES<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Set large pages if wanted. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((flProtect &amp; SEC_LARGE_PAGES) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; desiredAccess |= FILE_MAP_LARGE_PAGES;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get a pointer to the new shared memory segment. Map the whole segment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * at once, and let the system decide on the initial address.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; memAddress = MapViewOfFileEx(hmap2, desiredAccess, <span class="Constant">0</span>, <span class="Constant">0</span>, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!memAddress)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create shared memory segment: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>, GetLastError()),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failed system call was MapViewOfFileEx.&quot;</span>)));<br/></li>
<li><br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK, we created a new segment.&nbsp; Mark it as created by this process. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * order of assignments here is critical so that another Postgres process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't see the header as valid but belonging to an invalid PID!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hdr = (PGShmemHeader *) memAddress;<br/></li>
<li>&nbsp; &nbsp; hdr-&gt;creatorPID = getpid();<br/></li>
<li>&nbsp; &nbsp; hdr-&gt;magic = PGShmemMagic;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize space allocation status for segment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hdr-&gt;totalsize = size;<br/></li>
<li>&nbsp; &nbsp; hdr-&gt;freeoffset = MAXALIGN(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PGShmemHeader));<br/></li>
<li>&nbsp; &nbsp; hdr-&gt;<a href="../storage/ipc/dsm.c.html#L140" title="storage/ipc/dsm.c:140">dsm_control</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save info for possible future use */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a> = memAddress;<br/></li>
<li>&nbsp; &nbsp; <a href="#L46" title="port/win32_shmem.c:46">UsedShmemSegSize</a> = size;<br/></li>
<li>&nbsp; &nbsp; <a href="#L44" title="port/win32_shmem.c:44">UsedShmemSegID</a> = hmap2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Register on-exit routine to delete the new segment */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a>(<a href="#L549" title="port/win32_shmem.c:549">pgwin32_SharedMemoryDelete</a>, PointerGetDatum(hmap2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *shim = hdr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report whether huge pages are in use */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;<a href="../utils/misc/guc_tables.c.html#L567" title="utils/misc/guc_tables.c:567">huge_pages_status</a>&quot;</span>, (flProtect &amp; SEC_LARGE_PAGES) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;on&quot;</span> : <span class="Constant">&quot;off&quot;</span>, PGC_INTERNAL, PGC_S_DYNAMIC_DEFAULT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> hdr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L424" title="port/win32_shmem.c:424">PGSharedMemoryReAttach</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called during startup of a postmaster child process to re-attach to<br/></li>
<li></span><span class="Comment"> * an already existing shared memory segment, using the handle inherited from<br/></li>
<li></span><span class="Comment"> * the postmaster.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L42" title="port/win32_shmem.c:42">ShmemProtectiveRegion</a>, <a href="#L44" title="port/win32_shmem.c:44">UsedShmemSegID</a> and <a href="#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a> are implicit<br/></li>
<li></span><span class="Comment"> * parameters to this routine.&nbsp; The caller must have already restored them to<br/></li>
<li></span><span class="Comment"> * the postmaster's <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L424">&#x200c;</a></span><span class="linkable">PGSharedMemoryReAttach</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGShmemHeader *hdr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *origUsedShmemSegAddr = <a href="#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L42" title="port/win32_shmem.c:42">ShmemProtectiveRegion</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release memory region reservations made by the postmaster<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (VirtualFree(<a href="#L42" title="port/win32_shmem.c:42">ShmemProtectiveRegion</a>, <span class="Constant">0</span>, MEM_RELEASE) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;failed to release reserved memory region (addr=</span><span class="Special">%p</span><span class="Constant">): error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L42" title="port/win32_shmem.c:42">ShmemProtectiveRegion</a>, GetLastError());<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (VirtualFree(<a href="#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a>, <span class="Constant">0</span>, MEM_RELEASE) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;failed to release reserved memory region (addr=</span><span class="Special">%p</span><span class="Constant">): error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a>, GetLastError());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hdr = (PGShmemHeader *) MapViewOfFileEx(<a href="#L44" title="port/win32_shmem.c:44">UsedShmemSegID</a>, FILE_MAP_READ | FILE_MAP_WRITE, <span class="Constant">0</span>, <span class="Constant">0</span>, <span class="Constant">0</span>, <a href="#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!hdr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;could not reattach to shared memory (key=</span><span class="Special">%p</span><span class="Constant">, addr=</span><span class="Special">%p</span><span class="Constant">): error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L44" title="port/win32_shmem.c:44">UsedShmemSegID</a>, <a href="#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a>, GetLastError());<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hdr != origUsedShmemSegAddr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;reattaching to shared memory returned unexpected address (got </span><span class="Special">%p</span><span class="Constant">, expected </span><span class="Special">%p</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hdr, origUsedShmemSegAddr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hdr-&gt;magic != PGShmemMagic)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;reattaching to shared memory returned non-PostgreSQL memory&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/dsm.c.html#L459" title="storage/ipc/dsm.c:459">dsm_set_control_handle</a>(hdr-&gt;<a href="../storage/ipc/dsm.c.html#L140" title="storage/ipc/dsm.c:140">dsm_control</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a> = hdr;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* probably redundant */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L472" title="port/win32_shmem.c:472">PGSharedMemoryNoReAttach</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called during startup of a postmaster child process when we choose<br/></li>
<li></span><span class="Comment"> * *not* to re-attach to the existing shared memory segment.&nbsp; We must clean up<br/></li>
<li></span><span class="Comment"> * to leave things in the appropriate state.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The child process startup logic might or might not call <a href="#L505" title="port/win32_shmem.c:505">PGSharedMemoryDetach</a><br/></li>
<li></span><span class="Comment"> * after this; make sure that it will be a no-op if called.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L42" title="port/win32_shmem.c:42">ShmemProtectiveRegion</a>, <a href="#L44" title="port/win32_shmem.c:44">UsedShmemSegID</a> and <a href="#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a> are implicit<br/></li>
<li></span><span class="Comment"> * parameters to this routine.&nbsp; The caller must have already restored them to<br/></li>
<li></span><span class="Comment"> * the postmaster's <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L472">&#x200c;</a></span><span class="linkable">PGSharedMemoryNoReAttach</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L42" title="port/win32_shmem.c:42">ShmemProtectiveRegion</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Under Windows we will not have mapped the segment, so we don't need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * un-map it.&nbsp; Just reset <a href="#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a> to show we're not attached.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We *must* close the inherited shmem segment handle, else Windows will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consider the existence of this process to mean it can't release the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shmem segment yet.&nbsp; We can <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> use <a href="#L505" title="port/win32_shmem.c:505">PGSharedMemoryDetach</a> to do that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L505" title="port/win32_shmem.c:505">PGSharedMemoryDetach</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L505" title="port/win32_shmem.c:505">PGSharedMemoryDetach</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Detach from the shared memory segment, if still attached.&nbsp; This is not<br/></li>
<li></span><span class="Comment"> * intended to be called explicitly by the process that originally created the<br/></li>
<li></span><span class="Comment"> * segment (it will have an <a href="../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a> callback registered to do that).<br/></li>
<li></span><span class="Comment"> * Rather, this is for subprocesses that have inherited an attachment and want<br/></li>
<li></span><span class="Comment"> * to get rid of it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L42" title="port/win32_shmem.c:42">ShmemProtectiveRegion</a>, <a href="#L44" title="port/win32_shmem.c:44">UsedShmemSegID</a> and <a href="#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a> are implicit<br/></li>
<li></span><span class="Comment"> * parameters to this routine.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L505">&#x200c;</a></span><span class="linkable">PGSharedMemoryDetach</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Releasing the protective region liberates an unimportant quantity of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * address space, but be tidy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L42" title="port/win32_shmem.c:42">ShmemProtectiveRegion</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (VirtualFree(<a href="#L42" title="port/win32_shmem.c:42">ShmemProtectiveRegion</a>, <span class="Constant">0</span>, MEM_RELEASE) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;failed to release reserved memory region (addr=</span><span class="Special">%p</span><span class="Constant">): error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L42" title="port/win32_shmem.c:42">ShmemProtectiveRegion</a>, GetLastError());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L42" title="port/win32_shmem.c:42">ShmemProtectiveRegion</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Unmap the view, if it's mapped */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!UnmapViewOfFile(<a href="#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;could not unmap view of shared memory: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GetLastError());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And close the shmem handle, if we have one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L44" title="port/win32_shmem.c:44">UsedShmemSegID</a> != INVALID_HANDLE_VALUE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!CloseHandle(<a href="#L44" title="port/win32_shmem.c:44">UsedShmemSegID</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;could not close handle to shared memory: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GetLastError());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L44" title="port/win32_shmem.c:44">UsedShmemSegID</a> = INVALID_HANDLE_VALUE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L549" title="port/win32_shmem.c:549">pgwin32_SharedMemoryDelete</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Detach from and delete the shared memory segment<br/></li>
<li></span><span class="Comment"> * (called as an <a href="../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a> callback, hence funny argument list)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L549">&#x200c;</a></span><span class="linkable">pgwin32_SharedMemoryDelete</span>(<span class="Type">int</span> status, Datum shmId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(DatumGetPointer(shmId) == <a href="#L44" title="port/win32_shmem.c:44">UsedShmemSegID</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L505" title="port/win32_shmem.c:505">PGSharedMemoryDetach</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L573" title="port/win32_shmem.c:573">pgwin32_ReserveSharedMemoryRegion</a>(hChild)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Reserve the memory region that will be used for shared memory in a child<br/></li>
<li></span><span class="Comment"> * process. It is called <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the child process starts, to make sure the<br/></li>
<li></span><span class="Comment"> * memory is available.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Once the child starts, DLLs loading in different order or threads getting<br/></li>
<li></span><span class="Comment"> * scheduled differently may allocate memory which can conflict with the<br/></li>
<li></span><span class="Comment"> * address space we need for our shared memory. By reserving the shared<br/></li>
<li></span><span class="Comment"> * memory region <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the child starts, and freeing it only just <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we<br/></li>
<li></span><span class="Comment"> * attempt to get access to the shared memory forces these allocations to<br/></li>
<li></span><span class="Comment"> * be given different address ranges that don't conflict.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>! This function executes in the postmaster, and should for this<br/></li>
<li></span><span class="Comment"> * reason not use elog(FATAL) since that would take down the postmaster.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L573">&#x200c;</a></span><span class="linkable">pgwin32_ReserveSharedMemoryRegion</span>(HANDLE hChild)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *address;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L42" title="port/win32_shmem.c:42">ShmemProtectiveRegion</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L46" title="port/win32_shmem.c:46">UsedShmemSegSize</a> != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L42" title="port/win32_shmem.c:42">ShmemProtectiveRegion</a> */<br/></li>
<li></span>&nbsp; &nbsp; address = VirtualAllocEx(hChild, <a href="#L42" title="port/win32_shmem.c:42">ShmemProtectiveRegion</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L41" title="port/win32_shmem.c:41">PROTECTIVE_REGION_SIZE</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MEM_RESERVE, PAGE_NOACCESS);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (address == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't use FATAL since we're running in the postmaster */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;could not reserve shared memory region (addr=</span><span class="Special">%p</span><span class="Constant">) for child </span><span class="Special">%p</span><span class="Constant">: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L42" title="port/win32_shmem.c:42">ShmemProtectiveRegion</a>, hChild, GetLastError());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (address != <a href="#L42" title="port/win32_shmem.c:42">ShmemProtectiveRegion</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Should never happen - in theory if allocation granularity causes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * strange effects it could, so check just in case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't use FATAL since we're running in the postmaster.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;reserved shared memory region got incorrect address </span><span class="Special">%p</span><span class="Constant">, expected </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; address, <a href="#L42" title="port/win32_shmem.c:42">ShmemProtectiveRegion</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a> */<br/></li>
<li></span>&nbsp; &nbsp; address = VirtualAllocEx(hChild, <a href="#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a>, <a href="#L46" title="port/win32_shmem.c:46">UsedShmemSegSize</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MEM_RESERVE, PAGE_READWRITE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (address == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;could not reserve shared memory region (addr=</span><span class="Special">%p</span><span class="Constant">) for child </span><span class="Special">%p</span><span class="Constant">: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a>, hChild, GetLastError());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (address != <a href="#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;reserved shared memory region got incorrect address </span><span class="Special">%p</span><span class="Constant">, expected </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; address, <a href="#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This function is provided for consistency with sysv_shmem.c and does not<br/></li>
<li></span><span class="Comment"> * provide <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> useful information for Windows.&nbsp; To obtain the large page size,<br/></li>
<li></span><span class="Comment"> * use GetLargePageMinimum() instead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L630">&#x200c;</a></span><span class="linkable">GetHugePageSize</span>(Size *hugepagesize, <span class="Type">int</span> *mmap_flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hugepagesize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *hugepagesize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mmap_flags)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *mmap_flags = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for <a href="../utils/misc/guc_tables.c.html#L566" title="utils/misc/guc_tables.c:566">huge_page_size</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L642">&#x200c;</a></span><span class="linkable">check_huge_page_size</span>(<span class="Type">int</span> *<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GUC_check_errdetail(<span class="Constant">&quot;<a href="../utils/misc/guc_tables.c.html#L566" title="utils/misc/guc_tables.c:566">huge_page_size</a> must be 0 on this platform.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
