<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>port/sysv_sema.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>port/sysv_sema.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L66">maxSemaSets</a></li>
<li><a href="#L63">maxSharedSemas</a></li>
<li><a href="#L64">mySemaSets</a></li>
<li><a href="#L67">nextSemaKey</a></li>
<li><a href="#L68">nextSemaNumber</a></li>
<li><a href="#L65">numSemaSets</a></li>
<li><a href="#L62">numSharedSemas</a></li>
<li><a href="#L61">sharedSemas</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L46">IpcSemaphoreId</a></li>
<li><a href="#L45">IpcSemaphoreKey</a></li>
<li><a href="#L30">PGSemaphoreData</a></li>
<li><a href="#L34">PGSemaphoreData</a></li>
<li><a href="#L37">semun</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L93">InternalIpcSemaphoreCreate</a></li>
<li><a href="#L208">IpcSemaphoreCreate</a></li>
<li><a href="#L188">IpcSemaphoreGetLastPID</a></li>
<li><a href="#L177">IpcSemaphoreGetValue</a></li>
<li><a href="#L142">IpcSemaphoreInitialize</a></li>
<li><a href="#L165">IpcSemaphoreKill</a></li>
<li><a href="#L310">PGReserveSemaphores</a></li>
<li><a href="#L369">PGSemaphoreCreate</a></li>
<li><a href="#L415">PGSemaphoreLock</a></li>
<li><a href="#L404">PGSemaphoreReset</a></li>
<li><a href="#L287">PGSemaphoreShmemSize</a></li>
<li><a href="#L478">PGSemaphoreTryLock</a></li>
<li><a href="#L448">PGSemaphoreUnlock</a></li>
<li><a href="#L354">ReleaseSemaphores</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L56">IPCProtection</a></li>
<li><a href="#L58">PGSemaMagic</a></li>
<li><a href="#L54">SEMAS_PER_SET</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * sysv_sema.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Implement PGSemaphores using SysV semaphore facilities<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/port/sysv_sema.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;signal.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/file.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/ipc.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/sem.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/pg_sema.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/shmem.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L30">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">PGSemaphoreData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; semId;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* semaphore set identifier */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; semNum;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* semaphore number within set */<br/></li>
<li><a id="L34">&#x200c;</a></span>} <span class="linkable">PGSemaphoreData</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef HAVE_UNION_SEMUN<br/></li>
<li><a id="L37">&#x200c;</a></span><span class="Type">union</span> <span class="linkable">semun</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> semid_ds *buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">short</span> *array;<br/></li>
<li>};<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L45">&#x200c;</a><span class="Type">typedef</span> key_t <span class="linkable">IpcSemaphoreKey</span>;&nbsp; &nbsp; <span class="Comment">/* semaphore key passed to semget(2) */<br/></li>
<li><a id="L46">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">int</span> <span class="linkable">IpcSemaphoreId</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* semaphore ID returned by semget(2) */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L54" title="port/sysv_sema.c:54">SEMAS_PER_SET</a> is the number of useful semaphores in each semaphore set<br/></li>
<li></span><span class="Comment"> * we allocate.&nbsp; It must be *less than* your kernel's SEMMSL (max semaphores<br/></li>
<li></span><span class="Comment"> * per set) parameter, which is often around 25.&nbsp; (Less than, because we<br/></li>
<li></span><span class="Comment"> * allocate one extra sema in each set for identification purposes.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L54">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SEMAS_PER_SET</span>&nbsp; &nbsp; </span><span class="Constant">16<br/></li>
<li></span><br/></li>
<li><a id="L56">&#x200c;</a><span class="PreProc">#define <span class="linkable">IPCProtection</span>&nbsp; &nbsp; (0</span><span class="Constant">600</span><span class="PreProc">)&nbsp; &nbsp; </span><span class="Comment">/* access/modify by user only */<br/></li>
<li></span><br/></li>
<li><a id="L58">&#x200c;</a><span class="PreProc">#define <span class="linkable">PGSemaMagic</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">537</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* must be less than SEMVMX */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L61">&#x200c;</a><span class="Type">static</span> PGSemaphore <span class="linkable">sharedSemas</span>; <span class="Comment">/* array of <a href="posix_sema.c.html#L52" title="port/posix_sema.c:52">PGSemaphoreData</a> in shared memory */<br/></li>
<li><a id="L62">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">numSharedSemas</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of PGSemaphoreDatas used so far */<br/></li>
<li><a id="L63">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">maxSharedSemas</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allocated size of <a href="posix_sema.c.html#L52" title="port/posix_sema.c:52">PGSemaphoreData</a> array */<br/></li>
<li><a id="L64">&#x200c;</a></span><span class="Type">static</span> <a href="#L46" title="port/sysv_sema.c:46">IpcSemaphoreId</a> *<span class="linkable">mySemaSets</span>;&nbsp; &nbsp; <span class="Comment">/* IDs of sema sets acquired so far */<br/></li>
<li><a id="L65">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">numSemaSets</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of sema sets acquired so far */<br/></li>
<li><a id="L66">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">maxSemaSets</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allocated size of <a href="#L64" title="port/sysv_sema.c:64">mySemaSets</a> array */<br/></li>
<li><a id="L67">&#x200c;</a></span><span class="Type">static</span> <a href="#L45" title="port/sysv_sema.c:45">IpcSemaphoreKey</a> <span class="linkable">nextSemaKey</span>; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> key to try using */<br/></li>
<li><a id="L68">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">nextSemaNumber</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> free sem num in last sema set */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L46" title="port/sysv_sema.c:46">IpcSemaphoreId</a> <a href="#L93" title="port/sysv_sema.c:93">InternalIpcSemaphoreCreate</a>(<a href="#L45" title="port/sysv_sema.c:45">IpcSemaphoreKey</a> semKey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> <a href="posix_sema.c.html#L66" title="port/posix_sema.c:66">numSems</a>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L142" title="port/sysv_sema.c:142">IpcSemaphoreInitialize</a>(<a href="#L46" title="port/sysv_sema.c:46">IpcSemaphoreId</a> semId, <span class="Type">int</span> semNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> value);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L165" title="port/sysv_sema.c:165">IpcSemaphoreKill</a>(<a href="#L46" title="port/sysv_sema.c:46">IpcSemaphoreId</a> semId);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L177" title="port/sysv_sema.c:177">IpcSemaphoreGetValue</a>(<a href="#L46" title="port/sysv_sema.c:46">IpcSemaphoreId</a> semId, <span class="Type">int</span> semNum);<br/></li>
<li><span class="Type">static</span> pid_t <a href="#L188" title="port/sysv_sema.c:188">IpcSemaphoreGetLastPID</a>(<a href="#L46" title="port/sysv_sema.c:46">IpcSemaphoreId</a> semId, <span class="Type">int</span> semNum);<br/></li>
<li><span class="Type">static</span> <a href="#L46" title="port/sysv_sema.c:46">IpcSemaphoreId</a> <a href="#L208" title="port/sysv_sema.c:208">IpcSemaphoreCreate</a>(<span class="Type">int</span> <a href="posix_sema.c.html#L66" title="port/posix_sema.c:66">numSems</a>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="posix_sema.c.html#L240" title="port/posix_sema.c:240">ReleaseSemaphores</a>(<span class="Type">int</span> status, Datum arg);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L93" title="port/sysv_sema.c:93">InternalIpcSemaphoreCreate</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Attempt to create a new semaphore set with the specified key.<br/></li>
<li></span><span class="Comment"> * Will fail (return -1) if such a set already exists.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If we fail with a failure code other than collision-with-existing-set,<br/></li>
<li></span><span class="Comment"> * <a href="../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> out an error and abort.&nbsp; Other types of errors suggest nonrecoverable<br/></li>
<li></span><span class="Comment"> * problems.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L46" title="port/sysv_sema.c:46">IpcSemaphoreId</a><br/></li>
<li><a id="L93">&#x200c;</a><span class="linkable">InternalIpcSemaphoreCreate</span>(<a href="#L45" title="port/sysv_sema.c:45">IpcSemaphoreKey</a> semKey, <span class="Type">int</span> <a href="posix_sema.c.html#L66" title="port/posix_sema.c:66">numSems</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; semId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; semId = semget(semKey, <a href="posix_sema.c.html#L66" title="port/posix_sema.c:66">numSems</a>, IPC_CREAT | IPC_EXCL | <a href="posix_sema.c.html#L59" title="port/posix_sema.c:59">IPCProtection</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (semId &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saved_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fail quietly if error indicates a collision with existing set. One<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would expect EEXIST, given that we said IPC_EXCL, but perhaps we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could get a permission violation instead?&nbsp; Also, EIDRM might occur<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if an old set is slated for destruction but not gone yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (saved_errno == <span class="Constant">EEXIST</span> || saved_errno == <span class="Constant">EACCES<br/></li>
<li></span><span class="PreProc">#ifdef EIDRM<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || saved_errno == <span class="Constant">EIDRM<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Else complain and abort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create semaphores: %m&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failed system call was semget(</span><span class="Special">%lu</span><span class="Constant">, </span><span class="Special">%d</span><span class="Constant">, 0</span><span class="Special">%o</span><span class="Constant">).&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">unsigned</span> <span class="Type">long</span>) semKey, <a href="posix_sema.c.html#L66" title="port/posix_sema.c:66">numSems</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IPC_CREAT | IPC_EXCL | <a href="posix_sema.c.html#L59" title="port/posix_sema.c:59">IPCProtection</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (saved_errno == <span class="Constant">ENOSPC</span>) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;This error does *not* mean that you have run out of disk space.&nbsp; &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;It occurs when either the system limit for the maximum number of &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;semaphore sets (SEMMNI), or the system wide maximum number of &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;semaphores (SEMMNS), would be exceeded.&nbsp; You need to raise the &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;respective kernel parameter.&nbsp; Alternatively, reduce PostgreSQL's &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;consumption of semaphores by reducing its max_connections parameter.</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;The PostgreSQL documentation contains more information about &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;configuring your system for PostgreSQL.&quot;</span>) : <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> semId;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize a semaphore to the specified value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L142">&#x200c;</a></span><span class="linkable">IpcSemaphoreInitialize</span>(<a href="#L46" title="port/sysv_sema.c:46">IpcSemaphoreId</a> semId, <span class="Type">int</span> semNum, <span class="Type">int</span> value)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">union</span> <a href="#L37" title="port/sysv_sema.c:37">semun</a> <a href="#L37" title="port/sysv_sema.c:37">semun</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L37" title="port/sysv_sema.c:37">semun</a>.val = value;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (semctl(semId, semNum, SETVAL, <a href="#L37" title="port/sysv_sema.c:37">semun</a>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saved_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;semctl(</span><span class="Special">%d</span><span class="Constant">, </span><span class="Special">%d</span><span class="Constant">, SETVAL, </span><span class="Special">%d</span><span class="Constant">) failed: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; semId, semNum, value),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (saved_errno == <span class="Constant">ERANGE</span>) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You possibly need to raise your kernel's SEMVMX value to be at least &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">.&nbsp; Look into the PostgreSQL documentation for details.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; value) : <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L165" title="port/sysv_sema.c:165">IpcSemaphoreKill</a>(semId)&nbsp; &nbsp; - removes a semaphore set<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L165">&#x200c;</a></span><span class="linkable">IpcSemaphoreKill</span>(<a href="#L46" title="port/sysv_sema.c:46">IpcSemaphoreId</a> semId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">union</span> <a href="#L37" title="port/sysv_sema.c:37">semun</a> <a href="#L37" title="port/sysv_sema.c:37">semun</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L37" title="port/sysv_sema.c:37">semun</a>.val = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* unused, but keep compiler quiet */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (semctl(semId, <span class="Constant">0</span>, IPC_RMID, <a href="#L37" title="port/sysv_sema.c:37">semun</a>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;semctl(</span><span class="Special">%d</span><span class="Constant">, 0, IPC_RMID, ...) failed: %m&quot;</span>, semId);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Get the current value (semval) of the semaphore */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L177">&#x200c;</a></span><span class="linkable">IpcSemaphoreGetValue</span>(<a href="#L46" title="port/sysv_sema.c:46">IpcSemaphoreId</a> semId, <span class="Type">int</span> semNum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">union</span> <a href="#L37" title="port/sysv_sema.c:37">semun</a> dummy;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for Solaris */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; dummy.val = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* unused */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> semctl(semId, semNum, GETVAL, dummy);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Get the PID of the last process to do semop() on the semaphore */<br/></li>
<li></span><span class="Type">static</span> pid_t<br/></li>
<li><a id="L188">&#x200c;</a><span class="linkable">IpcSemaphoreGetLastPID</span>(<a href="#L46" title="port/sysv_sema.c:46">IpcSemaphoreId</a> semId, <span class="Type">int</span> semNum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">union</span> <a href="#L37" title="port/sysv_sema.c:37">semun</a> dummy;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for Solaris */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; dummy.val = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* unused */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> semctl(semId, semNum, GETPID, dummy);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a semaphore set with the given number of useful semaphores<br/></li>
<li></span><span class="Comment"> * (an additional sema is actually allocated to serve as identifier).<br/></li>
<li></span><span class="Comment"> * Dead Postgres sema sets are recycled if found, but we do not fail<br/></li>
<li></span><span class="Comment"> * upon collision with non-Postgres sema sets.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The idea here is to detect and re-use keys that may have been assigned<br/></li>
<li></span><span class="Comment"> * by a crashed postmaster or backend.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L46" title="port/sysv_sema.c:46">IpcSemaphoreId</a><br/></li>
<li><a id="L208">&#x200c;</a><span class="linkable">IpcSemaphoreCreate</span>(<span class="Type">int</span> <a href="posix_sema.c.html#L66" title="port/posix_sema.c:66">numSems</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L46" title="port/sysv_sema.c:46">IpcSemaphoreId</a> semId;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">union</span> <a href="#L37" title="port/sysv_sema.c:37">semun</a> <a href="#L37" title="port/sysv_sema.c:37">semun</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="posix_sema.c.html#L52" title="port/posix_sema.c:52">PGSemaphoreData</a> mysema;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Loop till we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a free IPC key */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<a href="#L67" title="port/sysv_sema.c:67">nextSemaKey</a>++;; <a href="#L67" title="port/sysv_sema.c:67">nextSemaKey</a>++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; creatorPID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to create new semaphore set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; semId = <a href="#L93" title="port/sysv_sema.c:93">InternalIpcSemaphoreCreate</a>(<a href="#L67" title="port/sysv_sema.c:67">nextSemaKey</a>, <a href="posix_sema.c.html#L66" title="port/posix_sema.c:66">numSems</a> + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (semId &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* successful create */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See if it looks to be leftover from a dead Postgres process */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; semId = semget(<a href="#L67" title="port/sysv_sema.c:67">nextSemaKey</a>, <a href="posix_sema.c.html#L66" title="port/posix_sema.c:66">numSems</a> + <span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (semId &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* failed: must be some other app's */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L177" title="port/sysv_sema.c:177">IpcSemaphoreGetValue</a>(semId, <a href="posix_sema.c.html#L66" title="port/posix_sema.c:66">numSems</a>) != <a href="#L58" title="port/sysv_sema.c:58">PGSemaMagic</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* sema belongs to a non-Postgres app */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the creator PID is my own PID or does not belong to <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> extant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * process, it's safe to zap it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; creatorPID = <a href="#L188" title="port/sysv_sema.c:188">IpcSemaphoreGetLastPID</a>(semId, <a href="posix_sema.c.html#L66" title="port/posix_sema.c:66">numSems</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (creatorPID &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* oops, GETPID failed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (creatorPID != getpid())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (kill(creatorPID, <span class="Constant">0</span>) == <span class="Constant">0</span> || errno != <span class="Constant">ESRCH</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* sema belongs to a live process */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The sema set appears to be from a dead Postgres process, or from a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * previous cycle of life in this same process.&nbsp; Zap it, if possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This probably shouldn't fail, but if it does, assume the sema set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * belongs to someone else after all, and continue quietly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L37" title="port/sysv_sema.c:37">semun</a>.val = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* unused, but keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (semctl(semId, <span class="Constant">0</span>, IPC_RMID, <a href="#L37" title="port/sysv_sema.c:37">semun</a>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now try again to create the sema set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; semId = <a href="#L93" title="port/sysv_sema.c:93">InternalIpcSemaphoreCreate</a>(<a href="#L67" title="port/sysv_sema.c:67">nextSemaKey</a>, <a href="posix_sema.c.html#L66" title="port/posix_sema.c:66">numSems</a> + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (semId &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* successful create */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Can only get here if some other process managed to create the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sema key <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we did.&nbsp; Let him have that one, loop around to try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> key.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK, we created a new sema set.&nbsp; Mark it as created by this process. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do this by setting the spare semaphore to <a href="#L58" title="port/sysv_sema.c:58">PGSemaMagic</a>-1 and then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * incrementing it with semop().&nbsp; That leaves it with value <a href="#L58" title="port/sysv_sema.c:58">PGSemaMagic</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and sempid referencing this process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L142" title="port/sysv_sema.c:142">IpcSemaphoreInitialize</a>(semId, <a href="posix_sema.c.html#L66" title="port/posix_sema.c:66">numSems</a>, <a href="#L58" title="port/sysv_sema.c:58">PGSemaMagic</a> - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; mysema.semId = semId;<br/></li>
<li>&nbsp; &nbsp; mysema.semNum = <a href="posix_sema.c.html#L66" title="port/posix_sema.c:66">numSems</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="posix_sema.c.html#L340" title="port/posix_sema.c:340">PGSemaphoreUnlock</a>(&amp;mysema);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> semId;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Report amount of shared memory needed for semaphores<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L287">&#x200c;</a><span class="linkable">PGSemaphoreShmemSize</span>(<span class="Type">int</span> maxSemas)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(maxSemas, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="posix_sema.c.html#L52" title="port/posix_sema.c:52">PGSemaphoreData</a>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="posix_sema.c.html#L196" title="port/posix_sema.c:196">PGReserveSemaphores</a> --- <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> semaphore support<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called during postmaster start or shared memory reinitialization.<br/></li>
<li></span><span class="Comment"> * It should do whatever is needed to be able to support up to maxSemas<br/></li>
<li></span><span class="Comment"> * subsequent <a href="posix_sema.c.html#L262" title="port/posix_sema.c:262">PGSemaphoreCreate</a> calls.&nbsp; Also, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> system resources<br/></li>
<li></span><span class="Comment"> * are acquired here or in <a href="posix_sema.c.html#L262" title="port/posix_sema.c:262">PGSemaphoreCreate</a>, register an <a href="../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a><br/></li>
<li></span><span class="Comment"> * callback to release them.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the SysV implementation, we acquire semaphore sets on-demand; the<br/></li>
<li></span><span class="Comment"> * maxSemas parameter is just used to size the arrays.&nbsp; There is an array<br/></li>
<li></span><span class="Comment"> * of <a href="posix_sema.c.html#L52" title="port/posix_sema.c:52">PGSemaphoreData</a> structs in shared memory, and a postmaster-local array<br/></li>
<li></span><span class="Comment"> * with one entry per SysV semaphore set, which we use for releasing the<br/></li>
<li></span><span class="Comment"> * semaphore sets when done.&nbsp; (This design ensures that postmaster shutdown<br/></li>
<li></span><span class="Comment"> * doesn't rely on the contents of shared memory, which a failed backend might<br/></li>
<li></span><span class="Comment"> * have clobbered.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L310">&#x200c;</a></span><span class="linkable">PGReserveSemaphores</span>(<span class="Type">int</span> maxSemas)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> stat statbuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use the data directory's inode number to seed the search for free<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * semaphore keys.&nbsp; This minimizes the odds of collision with other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * postmasters, while maximizing the odds that we will detect and clean up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * semaphores left over from a crashed postmaster in our own directory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stat(<a href="../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>, &amp;statbuf) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not stat data directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must use <a href="../storage/ipc/shmem.c.html#L238" title="storage/ipc/shmem.c:238">ShmemAllocUnlocked</a>(), since the spinlock protecting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../storage/ipc/shmem.c.html#L152" title="storage/ipc/shmem.c:152">ShmemAlloc</a>() won't be ready yet.&nbsp; (This ordering is necessary when we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are emulating spinlocks with semaphores.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="posix_sema.c.html#L64" title="port/posix_sema.c:64">sharedSemas</a> = (PGSemaphore)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/shmem.c.html#L238" title="storage/ipc/shmem.c:238">ShmemAllocUnlocked</a>(<a href="posix_sema.c.html#L165" title="port/posix_sema.c:165">PGSemaphoreShmemSize</a>(maxSemas));<br/></li>
<li>&nbsp; &nbsp; <a href="#L62" title="port/sysv_sema.c:62">numSharedSemas</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L63" title="port/sysv_sema.c:63">maxSharedSemas</a> = maxSemas;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="port/sysv_sema.c:66">maxSemaSets</a> = (maxSemas + <a href="#L54" title="port/sysv_sema.c:54">SEMAS_PER_SET</a> - <span class="Constant">1</span>) / <a href="#L54" title="port/sysv_sema.c:54">SEMAS_PER_SET</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L64" title="port/sysv_sema.c:64">mySemaSets</a> = (<a href="#L46" title="port/sysv_sema.c:46">IpcSemaphoreId</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; malloc(<a href="#L66" title="port/sysv_sema.c:66">maxSemaSets</a> * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L46" title="port/sysv_sema.c:46">IpcSemaphoreId</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L64" title="port/sysv_sema.c:64">mySemaSets</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;out of memory&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="port/sysv_sema.c:65">numSemaSets</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L67" title="port/sysv_sema.c:67">nextSemaKey</a> = statbuf.st_ino;<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="port/sysv_sema.c:68">nextSemaNumber</a> = <a href="#L54" title="port/sysv_sema.c:54">SEMAS_PER_SET</a>; <span class="Comment">/* force sema set alloc on 1st call */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a>(<a href="posix_sema.c.html#L240" title="port/posix_sema.c:240">ReleaseSemaphores</a>, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Release semaphores at shutdown or shmem reinitialization<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (called as an <a href="../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a> callback, hence funny argument list)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L354">&#x200c;</a></span><span class="linkable">ReleaseSemaphores</span>(<span class="Type">int</span> status, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L65" title="port/sysv_sema.c:65">numSemaSets</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L165" title="port/sysv_sema.c:165">IpcSemaphoreKill</a>(<a href="#L64" title="port/sysv_sema.c:64">mySemaSets</a>[i]);<br/></li>
<li>&nbsp; &nbsp; free(<a href="#L64" title="port/sysv_sema.c:64">mySemaSets</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="posix_sema.c.html#L262" title="port/posix_sema.c:262">PGSemaphoreCreate</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Allocate a PGSemaphore structure with initial count 1<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PGSemaphore<br/></li>
<li><a id="L369">&#x200c;</a><span class="linkable">PGSemaphoreCreate</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGSemaphore sema;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't do this in a backend, because static state is postmaster's */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!<a href="../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L68" title="port/sysv_sema.c:68">nextSemaNumber</a> &gt;= <a href="#L54" title="port/sysv_sema.c:54">SEMAS_PER_SET</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Time to allocate another semaphore set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L65" title="port/sysv_sema.c:65">numSemaSets</a> &gt;= <a href="#L66" title="port/sysv_sema.c:66">maxSemaSets</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;too many semaphores created&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L64" title="port/sysv_sema.c:64">mySemaSets</a>[<a href="#L65" title="port/sysv_sema.c:65">numSemaSets</a>] = <a href="#L208" title="port/sysv_sema.c:208">IpcSemaphoreCreate</a>(<a href="#L54" title="port/sysv_sema.c:54">SEMAS_PER_SET</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L65" title="port/sysv_sema.c:65">numSemaSets</a>++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L68" title="port/sysv_sema.c:68">nextSemaNumber</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> shared <a href="posix_sema.c.html#L52" title="port/posix_sema.c:52">PGSemaphoreData</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L62" title="port/sysv_sema.c:62">numSharedSemas</a> &gt;= <a href="#L63" title="port/sysv_sema.c:63">maxSharedSemas</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;too many semaphores created&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; sema = &amp;<a href="posix_sema.c.html#L64" title="port/posix_sema.c:64">sharedSemas</a>[<a href="#L62" title="port/sysv_sema.c:62">numSharedSemas</a>++];<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assign the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> free semaphore in the current set */<br/></li>
<li></span>&nbsp; &nbsp; sema-&gt;semId = <a href="#L64" title="port/sysv_sema.c:64">mySemaSets</a>[<a href="#L65" title="port/sysv_sema.c:65">numSemaSets</a> - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; sema-&gt;semNum = <a href="#L68" title="port/sysv_sema.c:68">nextSemaNumber</a>++;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize it to count 1 */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L142" title="port/sysv_sema.c:142">IpcSemaphoreInitialize</a>(sema-&gt;semId, sema-&gt;semNum, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> sema;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="posix_sema.c.html#L295" title="port/posix_sema.c:295">PGSemaphoreReset</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Reset a previously-initialized PGSemaphore to have count 0<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L404">&#x200c;</a></span><span class="linkable">PGSemaphoreReset</span>(PGSemaphore sema)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L142" title="port/sysv_sema.c:142">IpcSemaphoreInitialize</a>(sema-&gt;semId, sema-&gt;semNum, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="posix_sema.c.html#L320" title="port/posix_sema.c:320">PGSemaphoreLock</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Lock a semaphore (decrement count), blocking if count would be &lt; 0<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L415">&#x200c;</a></span><span class="linkable">PGSemaphoreLock</span>(PGSemaphore sema)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errStatus;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> sembuf sops;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sops.sem_op = -<span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* decrement */<br/></li>
<li></span>&nbsp; &nbsp; sops.sem_flg = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; sops.sem_num = sema-&gt;semNum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: if errStatus is -1 and errno == EINTR then it means we returned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the operation prematurely because we were sent a signal.&nbsp; So we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * try and lock the semaphore again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We used to check interrupts here, but that required servicing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interrupts directly from signal handlers. Which is hard to do safely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and portably.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errStatus = semop(sema-&gt;semId, &amp;sops, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (errStatus &lt; <span class="Constant">0</span> &amp;&amp; errno == <span class="Constant">EINTR</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errStatus &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;semop(id=</span><span class="Special">%d</span><span class="Constant">) failed: %m&quot;</span>, sema-&gt;semId);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="posix_sema.c.html#L340" title="port/posix_sema.c:340">PGSemaphoreUnlock</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlock a semaphore (increment count)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L448">&#x200c;</a></span><span class="linkable">PGSemaphoreUnlock</span>(PGSemaphore sema)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errStatus;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> sembuf sops;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sops.sem_op = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* increment */<br/></li>
<li></span>&nbsp; &nbsp; sops.sem_flg = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; sops.sem_num = sema-&gt;semNum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: if errStatus is -1 and errno == EINTR then it means we returned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the operation prematurely because we were sent a signal.&nbsp; So we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * try and unlock the semaphore again. Not clear this can really happen,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but might as well cope.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errStatus = semop(sema-&gt;semId, &amp;sops, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (errStatus &lt; <span class="Constant">0</span> &amp;&amp; errno == <span class="Constant">EINTR</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errStatus &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;semop(id=</span><span class="Special">%d</span><span class="Constant">) failed: %m&quot;</span>, sema-&gt;semId);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="posix_sema.c.html#L365" title="port/posix_sema.c:365">PGSemaphoreTryLock</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Lock a semaphore only if able to do so without blocking<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L478">&#x200c;</a></span><span class="linkable">PGSemaphoreTryLock</span>(PGSemaphore sema)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errStatus;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> sembuf sops;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sops.sem_op = -<span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* decrement */<br/></li>
<li></span>&nbsp; &nbsp; sops.sem_flg = IPC_NOWAIT;&nbsp; &nbsp; <span class="Comment">/* but don't block */<br/></li>
<li></span>&nbsp; &nbsp; sops.sem_num = sema-&gt;semNum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: if errStatus is -1 and errno == EINTR then it means we returned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the operation prematurely because we were sent a signal.&nbsp; So we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * try and lock the semaphore again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errStatus = semop(sema-&gt;semId, &amp;sops, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (errStatus &lt; <span class="Constant">0</span> &amp;&amp; errno == <span class="Constant">EINTR</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errStatus &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Expect EAGAIN or EWOULDBLOCK (platform-dependent) */<br/></li>
<li></span><span class="PreProc">#ifdef EAGAIN<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EAGAIN</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* failed to lock it */<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#if defined(</span><span class="Constant">EWOULDBLOCK</span><span class="PreProc">) &amp;&amp; (!defined(</span><span class="Constant">EAGAIN</span><span class="PreProc">) || (</span><span class="Constant">EWOULDBLOCK</span><span class="PreProc"> != </span><span class="Constant">EAGAIN</span><span class="PreProc">))<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EWOULDBLOCK</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* failed to lock it */<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise we got trouble */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;semop(id=</span><span class="Special">%d</span><span class="Constant">) failed: %m&quot;</span>, sema-&gt;semId);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
