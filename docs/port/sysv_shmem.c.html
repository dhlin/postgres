<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>port/sysv_shmem.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>port/sysv_shmem.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L98">AnonymousShmem</a></li>
<li><a href="#L97">AnonymousShmemSize</a></li>
<li><a href="#L95">UsedShmemSegAddr</a></li>
<li><a href="#L94">UsedShmemSegID</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L71">IpcMemoryId</a></li>
<li><a href="#L70">IpcMemoryKey</a></li>
<li><a href="#L91">IpcMemoryState</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L675">AnonymousShmemDetach</a></li>
<li><a href="#L599">CreateAnonymousSegment</a></li>
<li><a href="#L479">GetHugePageSize</a></li>
<li><a href="#L121">InternalIpcMemoryCreate</a></li>
<li><a href="#L298">IpcMemoryDelete</a></li>
<li><a href="#L286">IpcMemoryDetach</a></li>
<li><a href="#L347">PGSharedMemoryAttach</a></li>
<li><a href="#L700">PGSharedMemoryCreate</a></li>
<li><a href="#L970">PGSharedMemoryDetach</a></li>
<li><a href="#L317">PGSharedMemoryIsInUse</a></li>
<li><a href="#L939">PGSharedMemoryNoReAttach</a></li>
<li><a href="#L890">PGSharedMemoryReAttach</a></li>
<li><a href="#L578">check_huge_page_size</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * sysv_shmem.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Implement shared memory using SysV facilities<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These routines used to be a fairly thin layer on top of SysV shared<br/></li>
<li></span><span class="Comment"> * memory functionality.&nbsp; With the addition of anonymous-shmem logic,<br/></li>
<li></span><span class="Comment"> * they're a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> fatter <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; We still require a SysV shmem block to<br/></li>
<li></span><span class="Comment"> * exist, though, because mmap'd shmem provides no way to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out how<br/></li>
<li></span><span class="Comment"> * many processes are attached, which we need for interlocking purposes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/port/sysv_shmem.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;signal.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/file.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/ipc.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/mman.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/shm.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bitutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;portability/mem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/dsm.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/pg_shmem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc_hooks.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pidfile.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * As of PostgreSQL 9.3, we normally allocate only a very small amount of<br/></li>
<li></span><span class="Comment"> * System V shared memory, and only for the purposes of providing an<br/></li>
<li></span><span class="Comment"> * interlock to protect the data directory.&nbsp; The real shared memory block<br/></li>
<li></span><span class="Comment"> * is allocated using mmap().&nbsp; This works around the problem that many<br/></li>
<li></span><span class="Comment"> * systems have very low limits on the amount of System V shared memory<br/></li>
<li></span><span class="Comment"> * that can be allocated.&nbsp; Even a limit of a few megabytes will be enough<br/></li>
<li></span><span class="Comment"> * to run many copies of PostgreSQL without needing to adjust system settings.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We assume that no one will attempt to run PostgreSQL 9.3 or later on<br/></li>
<li></span><span class="Comment"> * systems that are ancient enough that anonymous shared memory is not<br/></li>
<li></span><span class="Comment"> * supported, such as pre-2.4 versions of Linux.&nbsp; If that turns out to be<br/></li>
<li></span><span class="Comment"> * false, we might need to add compile and/or run-time tests here and do this<br/></li>
<li></span><span class="Comment"> * only if the running kernel supports it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * However, we must always disable this logic in the EXEC_BACKEND case, and<br/></li>
<li></span><span class="Comment"> * fall back to the old method of allocating the entire segment using System V<br/></li>
<li></span><span class="Comment"> * shared memory, because there's no way to attach an anonymous mmap'd segment<br/></li>
<li></span><span class="Comment"> * to a process after exec().&nbsp; Since EXEC_BACKEND is intended only for<br/></li>
<li></span><span class="Comment"> * developer use, this shouldn't be a big problem.&nbsp; Because of this, we do<br/></li>
<li></span><span class="Comment"> * not worry about supporting anonymous shmem in the EXEC_BACKEND cases below.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As of PostgreSQL 12, we regained the ability to use a large System V shared<br/></li>
<li></span><span class="Comment"> * memory region even in non-EXEC_BACKEND builds, if <a href="../storage/ipc/ipci.c.html#L57" title="storage/ipc/ipci.c:57">shared_memory_type</a> is set<br/></li>
<li></span><span class="Comment"> * to sysv (though this is not the default).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L70">&#x200c;</a><span class="Type">typedef</span> key_t <span class="linkable">IpcMemoryKey</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shared memory key passed to shmget(2) */<br/></li>
<li><a id="L71">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">int</span> <span class="linkable">IpcMemoryId</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shared memory ID returned by shmget(2) */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * How does a given <a href="#L71" title="port/sysv_shmem.c:71">IpcMemoryId</a> relate to this PostgreSQL process?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * One could recycle unattached segments of different data directories if we<br/></li>
<li></span><span class="Comment"> * distinguished that case from other SHMSTATE_FOREIGN cases.&nbsp; Doing so would<br/></li>
<li></span><span class="Comment"> * cause us to visit less of the key space, making us less likely to detect a<br/></li>
<li></span><span class="Comment"> * SHMSTATE_ATTACHED key.&nbsp; It would also complicate the concurrency analysis,<br/></li>
<li></span><span class="Comment"> * in that postmasters of different data directories could simultaneously<br/></li>
<li></span><span class="Comment"> * attempt to recycle a given key.&nbsp; We'll waste keys longer in some cases, but<br/></li>
<li></span><span class="Comment"> * avoiding the problems of the alternative justifies that loss.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; SHMSTATE_ANALYSIS_FAILURE,&nbsp; &nbsp; <span class="Comment">/* unexpected failure to <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a> the ID */<br/></li>
<li></span>&nbsp; &nbsp; SHMSTATE_ATTACHED,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pertinent to <a href="../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>, has attached PIDs */<br/></li>
<li></span>&nbsp; &nbsp; SHMSTATE_ENOENT,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no segment of that ID */<br/></li>
<li></span>&nbsp; &nbsp; SHMSTATE_FOREIGN,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* exists, but not pertinent to <a href="../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a> */<br/></li>
<li></span>&nbsp; &nbsp; SHMSTATE_UNATTACHED,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pertinent to <a href="../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>, no attached PIDs */<br/></li>
<li><a id="L91">&#x200c;</a></span>} <span class="linkable">IpcMemoryState</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L94">&#x200c;</a><span class="Type">unsigned</span> <span class="Type">long</span> <span class="linkable">UsedShmemSegID</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L95">&#x200c;</a><span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">UsedShmemSegAddr</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><a id="L97">&#x200c;</a><span class="Type">static</span> Size <span class="linkable">AnonymousShmemSize</span>;<br/></li>
<li><a id="L98">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> *<span class="linkable">AnonymousShmem</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> *<a href="#L121" title="port/sysv_shmem.c:121">InternalIpcMemoryCreate</a>(<a href="#L70" title="port/sysv_shmem.c:70">IpcMemoryKey</a> memKey, Size size);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L286" title="port/sysv_shmem.c:286">IpcMemoryDetach</a>(<span class="Type">int</span> status, Datum shmaddr);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L298" title="port/sysv_shmem.c:298">IpcMemoryDelete</a>(<span class="Type">int</span> status, Datum shmId);<br/></li>
<li><span class="Type">static</span> <a href="#L91" title="port/sysv_shmem.c:91">IpcMemoryState</a> <a href="#L347" title="port/sysv_shmem.c:347">PGSharedMemoryAttach</a>(<a href="#L71" title="port/sysv_shmem.c:71">IpcMemoryId</a> shmId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *attachAt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PGShmemHeader **addr);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L121" title="port/sysv_shmem.c:121">InternalIpcMemoryCreate</a>(memKey, size)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Attempt to create a new shared memory segment with the specified key.<br/></li>
<li></span><span class="Comment"> * Will fail (return NULL) if such a segment already exists.&nbsp; If successful,<br/></li>
<li></span><span class="Comment"> * attach the segment to the current process and return its attached address.<br/></li>
<li></span><span class="Comment"> * On success, callbacks are registered with <a href="../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a> to detach and<br/></li>
<li></span><span class="Comment"> * delete the segment when <a href="../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a> is called.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If we fail with a failure code other than collision-with-existing-segment,<br/></li>
<li></span><span class="Comment"> * <a href="../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> out an error and abort.&nbsp; Other types of errors are not recoverable.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> *<br/></li>
<li><a id="L121">&#x200c;</a><span class="linkable">InternalIpcMemoryCreate</span>(<a href="#L70" title="port/sysv_shmem.c:70">IpcMemoryKey</a> memKey, Size size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="port/sysv_shmem.c:71">IpcMemoryId</a> shmid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *requestedAddress = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *memAddress;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Normally we just pass requestedAddress = NULL to shmat(), allowing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * system to choose where the segment gets mapped.&nbsp; But in an EXEC_BACKEND<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * build, it's possible for whatever is chosen in the postmaster to not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * work for backends, due to variations in address space layout.&nbsp; As a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rather klugy workaround, allow the user to specify the address to use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * via setting the environment variable PG_SHMEM_ADDR.&nbsp; (If this were of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interest for anything except debugging, we'd probably create a cleaner<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and better-documented way to set it, such as a GUC.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *pg_shmem_addr = getenv(<span class="Constant">&quot;PG_SHMEM_ADDR&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_shmem_addr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; requestedAddress = (<span class="Type">void</span> *) strtoul(pg_shmem_addr, <span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#if defined(__darwin__) &amp;&amp; SIZEOF_VOID_P == </span><span class="Constant">8<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Provide a default value that is believed to avoid problems with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ASLR on the current macOS release.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; requestedAddress = (<span class="Type">void</span> *) <span class="Constant">0x80000000000</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; shmid = shmget(memKey, size, IPC_CREAT | IPC_EXCL | <a href="posix_sema.c.html#L59" title="port/posix_sema.c:59">IPCProtection</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (shmid &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shmget_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fail quietly if error indicates a collision with existing segment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * One would expect EEXIST, given that we said IPC_EXCL, but perhaps<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we could get a permission violation instead?&nbsp; Also, EIDRM might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * occur if an old seg is slated for destruction but not gone yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shmget_errno == <span class="Constant">EEXIST</span> || shmget_errno == <span class="Constant">EACCES<br/></li>
<li></span><span class="PreProc">#ifdef EIDRM<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || shmget_errno == <span class="Constant">EIDRM<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Some BSD-derived kernels are known to return EINVAL, not EEXIST, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there is an existing segment but it's smaller than &quot;size&quot; (this is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a result of poorly-thought-out ordering of error tests). To<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * distinguish between collision and invalid size in such cases, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * make a second try with size = 0.&nbsp; These kernels do not test size<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * against SHMMIN in the preexisting-segment case, so we will not get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * EINVAL a second time if there is such a segment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shmget_errno == <span class="Constant">EINVAL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shmid = shmget(memKey, <span class="Constant">0</span>, IPC_CREAT | IPC_EXCL | <a href="posix_sema.c.html#L59" title="port/posix_sema.c:59">IPCProtection</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shmid &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* As above, fail quietly if we verify a collision */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EEXIST</span> || errno == <span class="Constant">EACCES<br/></li>
<li></span><span class="PreProc">#ifdef EIDRM<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || errno == <span class="Constant">EIDRM<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise, fall through to report the original error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * On most platforms we cannot get here because SHMMIN is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * greater than zero.&nbsp; However, if we do succeed in creating a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * zero-size segment, free it and then fall through to report<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the original error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shmctl(shmid, IPC_RMID, <span class="Constant">NULL</span>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;shmctl(</span><span class="Special">%d</span><span class="Constant">, </span><span class="Special">%d</span><span class="Constant">, 0) failed: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) shmid, IPC_RMID);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Else complain and abort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: at this point EINVAL should mean that either SHMMIN or SHMMAX<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is violated.&nbsp; SHMALL violation might be reported as either ENOMEM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (BSDen) or ENOSPC (Linux); the Single Unix Spec fails to say which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it should be.&nbsp; SHMMNI violation is ENOSPC, per spec.&nbsp; Just plain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not-enough-RAM is ENOMEM.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; errno = shmget_errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create shared memory segment: %m&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failed system call was shmget(key=</span><span class="Special">%lu</span><span class="Constant">, size=</span><span class="Special">%zu</span><span class="Constant">, 0</span><span class="Special">%o</span><span class="Constant">).&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">unsigned</span> <span class="Type">long</span>) memKey, size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IPC_CREAT | IPC_EXCL | <a href="posix_sema.c.html#L59" title="port/posix_sema.c:59">IPCProtection</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (shmget_errno == <span class="Constant">EINVAL</span>) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;This error usually means that PostgreSQL's request for a shared memory &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;segment exceeded your kernel's SHMMAX parameter, or possibly that &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;it is less than &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;your kernel's SHMMIN parameter.</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;The PostgreSQL documentation contains more information about shared &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;memory configuration.&quot;</span>) : <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (shmget_errno == <span class="Constant">ENOMEM</span>) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;This error usually means that PostgreSQL's request for a shared &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;memory segment exceeded your kernel's SHMALL parameter.&nbsp; You might need &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;to reconfigure the kernel with larger SHMALL.</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;The PostgreSQL documentation contains more information about shared &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;memory configuration.&quot;</span>) : <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (shmget_errno == <span class="Constant">ENOSPC</span>) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;This error does *not* mean that you have run out of disk space.&nbsp; &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;It occurs either if all available shared memory IDs have been taken, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;in which case you need to raise the SHMMNI parameter in your kernel, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;or because the system's overall limit for shared memory has been &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;reached.</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;The PostgreSQL documentation contains more information about shared &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;memory configuration.&quot;</span>) : <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Register on-exit routine to delete the new segment */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a>(<a href="#L298" title="port/sysv_shmem.c:298">IpcMemoryDelete</a>, Int32GetDatum(shmid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, should be able to attach to the segment */<br/></li>
<li></span>&nbsp; &nbsp; memAddress = shmat(shmid, requestedAddress, PG_SHMAT_FLAGS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (memAddress == (<span class="Type">void</span> *) -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;shmat(id=</span><span class="Special">%d</span><span class="Constant">, addr=</span><span class="Special">%p</span><span class="Constant">, flags=0x</span><span class="Special">%x</span><span class="Constant">) failed: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; shmid, requestedAddress, PG_SHMAT_FLAGS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Register on-exit routine to detach new segment <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> deleting */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a>(<a href="#L286" title="port/sysv_shmem.c:286">IpcMemoryDetach</a>, PointerGetDatum(memAddress));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Store shmem key and ID in data directory lockfile.&nbsp; Format to try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * keep it the same length always (trailing junk in the lockfile won't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hurt, but might confuse humans).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; line[<span class="Constant">64</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sprintf(line, <span class="Constant">&quot;</span><span class="Special">%9lu</span><span class="Constant"> </span><span class="Special">%9lu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">long</span>) memKey, (<span class="Type">unsigned</span> <span class="Type">long</span>) shmid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L1511" title="utils/init/miscinit.c:1511">AddToDataDirLockFile</a>(LOCK_FILE_LINE_SHMEM_KEY, line);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> memAddress;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/****************************************************************************/<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; <a href="#L286" title="port/sysv_shmem.c:286">IpcMemoryDetach</a>(status, shmaddr)&nbsp; &nbsp; removes a shared memory segment&nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; from process' address space&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; (called as an <a href="../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a> callback, hence funny argument list)&nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/****************************************************************************/<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L286">&#x200c;</a></span><span class="linkable">IpcMemoryDetach</span>(<span class="Type">int</span> status, Datum shmaddr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Detach System V shared memory block. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (shmdt((<span class="Type">void</span> *) DatumGetPointer(shmaddr)) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;shmdt(</span><span class="Special">%p</span><span class="Constant">) failed: %m&quot;</span>, DatumGetPointer(shmaddr));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/****************************************************************************/<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; <a href="#L298" title="port/sysv_shmem.c:298">IpcMemoryDelete</a>(status, shmId)&nbsp; &nbsp; &nbsp; &nbsp; deletes a shared memory segment&nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; (called as an <a href="../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a> callback, hence funny argument list)&nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/****************************************************************************/<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L298">&#x200c;</a></span><span class="linkable">IpcMemoryDelete</span>(<span class="Type">int</span> status, Datum shmId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (shmctl(DatumGetInt32(shmId), IPC_RMID, <span class="Constant">NULL</span>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;shmctl(</span><span class="Special">%d</span><span class="Constant">, </span><span class="Special">%d</span><span class="Constant">, 0) failed: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DatumGetInt32(shmId), IPC_RMID);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="win32_shmem.c.html#L113" title="port/win32_shmem.c:113">PGSharedMemoryIsInUse</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Is a previously-existing shmem segment still existing and in use?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The point of this exercise is to detect the case where a prior postmaster<br/></li>
<li></span><span class="Comment"> * crashed, but it left child backends that are still running.&nbsp; Therefore<br/></li>
<li></span><span class="Comment"> * we only care about shmem segments that are associated with the intended<br/></li>
<li></span><span class="Comment"> * <a href="../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>.&nbsp; This is an important consideration since accidental matches of<br/></li>
<li></span><span class="Comment"> * shmem segment IDs are reasonably common.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L317">&#x200c;</a></span><span class="linkable">PGSharedMemoryIsInUse</span>(<span class="Type">unsigned</span> <span class="Type">long</span> id1, <span class="Type">unsigned</span> <span class="Type">long</span> id2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGShmemHeader *memAddress;<br/></li>
<li>&nbsp; &nbsp; <a href="#L91" title="port/sysv_shmem.c:91">IpcMemoryState</a> state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = <a href="#L347" title="port/sysv_shmem.c:347">PGSharedMemoryAttach</a>((<a href="#L71" title="port/sysv_shmem.c:71">IpcMemoryId</a>) id2, <span class="Constant">NULL</span>, &amp;memAddress);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (memAddress &amp;&amp; shmdt((<span class="Type">void</span> *) memAddress) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;shmdt(</span><span class="Special">%p</span><span class="Constant">) failed: %m&quot;</span>, memAddress);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (state)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SHMSTATE_ENOENT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SHMSTATE_FOREIGN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SHMSTATE_UNATTACHED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SHMSTATE_ANALYSIS_FAILURE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SHMSTATE_ATTACHED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Test for a segment with id shmId; see comment at <a href="#L91" title="port/sysv_shmem.c:91">IpcMemoryState</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the segment exists, we'll attempt to attach to it, using attachAt<br/></li>
<li></span><span class="Comment"> * if that's not NULL (but it's best to pass NULL if possible).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *addr is set to the segment memory address if we attached to it, else NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L91" title="port/sysv_shmem.c:91">IpcMemoryState</a><br/></li>
<li><a id="L347">&#x200c;</a><span class="linkable">PGSharedMemoryAttach</span>(<a href="#L71" title="port/sysv_shmem.c:71">IpcMemoryId</a> shmId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *attachAt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PGShmemHeader **addr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> shmid_ds shmStat;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> stat statbuf;<br/></li>
<li>&nbsp; &nbsp; PGShmemHeader *hdr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *addr = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, try to stat the shm segment ID, to see if it exists at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (shmctl(shmId, IPC_STAT, &amp;shmStat) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * EINVAL actually has multiple possible causes documented in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shmctl man page, but we assume it must mean the segment no longer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EINVAL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SHMSTATE_ENOENT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * EACCES implies we have no read permission, which means it is not a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Postgres shmem segment (or at least, not one that is relevant to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * our data directory).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EACCES</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SHMSTATE_FOREIGN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Some Linux kernel versions (in fact, all of them as of July 2007)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sometimes return EIDRM when EINVAL is correct.&nbsp; The Linux kernel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * actually does not have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> state that would justify<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * returning EIDRM, so we can get away with assuming that EIDRM is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * equivalent to EINVAL on that platform.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef HAVE_LINUX_EIDRM_BUG<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EIDRM</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SHMSTATE_ENOENT;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, we had better assume that the segment is in use.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only likely case is (non-Linux, assumed spec-compliant) EIDRM,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which implies that the segment has been IPC_RMID'd but there are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * still processes attached to it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SHMSTATE_ANALYSIS_FAILURE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to attach to the segment and see if it matches our data directory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This avoids <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> risk of duplicate-shmem-key conflicts on machines that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are running several postmasters under the same userid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (When we're called from <a href="win32_shmem.c.html#L207" title="port/win32_shmem.c:207">PGSharedMemoryCreate</a>, this stat call is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * duplicative; but since this isn't a high-traffic case it's not worth<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trying to <a href="../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stat(<a href="../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>, &amp;statbuf) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SHMSTATE_ANALYSIS_FAILURE;&nbsp; &nbsp; <span class="Comment">/* can't stat; be conservative */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; hdr = (PGShmemHeader *) shmat(shmId, attachAt, PG_SHMAT_FLAGS);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hdr == (PGShmemHeader *) -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Attachment failed.&nbsp; The cases we're interested in are the same as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for the shmctl() call above.&nbsp; In particular, note that the owning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * postmaster could have terminated and removed the segment between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shmctl() and shmat().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If attachAt isn't NULL, it's possible that EINVAL reflects a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * problem with that address not a vanished segment, so it's best to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pass NULL when probing for conflicting segments.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EINVAL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SHMSTATE_ENOENT; <span class="Comment">/* segment disappeared */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EACCES</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SHMSTATE_FOREIGN;&nbsp; &nbsp; <span class="Comment">/* must be non-Postgres */<br/></li>
<li></span><span class="PreProc">#ifdef HAVE_LINUX_EIDRM_BUG<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EIDRM</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SHMSTATE_ENOENT; <span class="Comment">/* segment disappeared */<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise, be conservative. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SHMSTATE_ANALYSIS_FAILURE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *addr = hdr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hdr-&gt;magic != PGShmemMagic ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hdr-&gt;device != statbuf.st_dev ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hdr-&gt;inode != statbuf.st_ino)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's either not a Postgres segment, or not one for my data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * directory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SHMSTATE_FOREIGN;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It does match our data directory, so <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> test whether <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> processes are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * still attached to it.&nbsp; (We are, <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, but the shm_nattch result is from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we attached to it.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> shmStat.shm_nattch == <span class="Constant">0</span> ? SHMSTATE_UNATTACHED : SHMSTATE_ATTACHED;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Identify the huge page size to use, and compute the related mmap flags.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Some Linux kernel versions have a bug causing mmap() to fail on requests<br/></li>
<li></span><span class="Comment"> * that are not a multiple of the hugepage size.&nbsp; Versions without that bug<br/></li>
<li></span><span class="Comment"> * instead silently round the request up to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> hugepage multiple ---<br/></li>
<li></span><span class="Comment"> * and then munmap() fails when we give it a size different from that.<br/></li>
<li></span><span class="Comment"> * So we have to round our request up to a multiple of the actual hugepage<br/></li>
<li></span><span class="Comment"> * size to avoid trouble.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Doing the round-up ourselves also lets us make use of the extra memory,<br/></li>
<li></span><span class="Comment"> * rather than just wasting it.&nbsp; Currently, we just increase the available<br/></li>
<li></span><span class="Comment"> * space recorded in the shmem header, which will make the extra usable for<br/></li>
<li></span><span class="Comment"> * purposes such as additional locktable entries.&nbsp; Someday, for very large<br/></li>
<li></span><span class="Comment"> * hugepage sizes, we might want to think about more invasive strategies,<br/></li>
<li></span><span class="Comment"> * such as increasing shared_buffers to absorb the extra space.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the (real, assumed or config provided) page size into<br/></li>
<li></span><span class="Comment"> * *hugepagesize, and the hugepage-related mmap flags to use into<br/></li>
<li></span><span class="Comment"> * *mmap_flags if requested by the caller.&nbsp; If huge pages are not supported,<br/></li>
<li></span><span class="Comment"> * *hugepagesize and *mmap_flags are set to 0.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L479">&#x200c;</a></span><span class="linkable">GetHugePageSize</span>(Size *hugepagesize, <span class="Type">int</span> *mmap_flags)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef MAP_HUGETLB<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; default_hugepagesize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; hugepagesize_local = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mmap_flags_local = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * System-dependent code to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out the default huge page size.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On Linux, read /proc/meminfo looking for a line like &quot;Hugepagesize:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nnnn kB&quot;.&nbsp; Ignore <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> failures, falling back to the preset default.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef __linux__<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">FILE</span>&nbsp; &nbsp; &nbsp;&nbsp; *fp = <a href="../storage/file/fd.c.html#L2583" title="storage/file/fd.c:2583">AllocateFile</a>(<span class="Constant">&quot;/proc/meminfo&quot;</span>, <span class="Constant">&quot;r&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[<span class="Constant">128</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> sz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; ch;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (fgets(buf, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buf), fp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sscanf(buf, <span class="Constant">&quot;Hugepagesize: </span><span class="Special">%u</span><span class="Constant"> </span><span class="Special">%c</span><span class="Constant">&quot;</span>, &amp;sz, &amp;ch) == <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ch == <span class="Constant">'k'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; default_hugepagesize = sz * (Size) <span class="Constant">1024</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We could <a href="win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> other units besides kB, if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/file/fd.c.html#L2781" title="storage/file/fd.c:2781">FreeFile</a>(fp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* __linux__ */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L566" title="utils/misc/guc_tables.c:566">huge_page_size</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If huge page size is requested explicitly, use that. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hugepagesize_local = (Size) <a href="../utils/misc/guc_tables.c.html#L566" title="utils/misc/guc_tables.c:566">huge_page_size</a> * <span class="Constant">1024</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (default_hugepagesize != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise use the system default, if we have it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hugepagesize_local = default_hugepagesize;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we fail to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out the system's default huge page size, or no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * huge page size is requested explicitly, assume it is 2MB. This will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * work fine when the actual size is less.&nbsp; If it's more, we might get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mmap() or munmap() failures due to unaligned requests; but at this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * writing, there are no reports of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-Linux systems being picky<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * about that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hugepagesize_local = <span class="Constant">2</span> * <span class="Constant">1024</span> * <span class="Constant">1024</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mmap_flags_local = MAP_HUGETLB;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On recent enough Linux, also include the explicit page size, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#if defined(MAP_HUGE_MASK) &amp;&amp; defined(MAP_HUGE_SHIFT)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (hugepagesize_local != default_hugepagesize)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shift = pg_ceil_log2_64(hugepagesize_local);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mmap_flags_local |= (shift &amp; MAP_HUGE_MASK) &lt;&lt; MAP_HUGE_SHIFT;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* assign the results found */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (mmap_flags)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *mmap_flags = mmap_flags_local;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hugepagesize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *hugepagesize = hugepagesize_local;<br/></li>
<li><br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hugepagesize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *hugepagesize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mmap_flags)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *mmap_flags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* MAP_HUGETLB */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for <a href="../utils/misc/guc_tables.c.html#L566" title="utils/misc/guc_tables.c:566">huge_page_size</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L578">&#x200c;</a></span><span class="linkable">check_huge_page_size</span>(<span class="Type">int</span> *<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#if !(defined(MAP_HUGE_MASK) &amp;&amp; defined(MAP_HUGE_SHIFT))<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Recent enough Linux only, for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; See <a href="win32_shmem.c.html#L630" title="port/win32_shmem.c:630">GetHugePageSize</a>(). */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GUC_check_errdetail(<span class="Constant">&quot;<a href="../utils/misc/guc_tables.c.html#L566" title="utils/misc/guc_tables.c:566">huge_page_size</a> must be 0 on this platform.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Creates an anonymous mmap()ed shared memory segment.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Pass the requested size in *size.&nbsp; This function will modify *size to the<br/></li>
<li></span><span class="Comment"> * actual size of the allocation, if it ends up allocating a segment that is<br/></li>
<li></span><span class="Comment"> * larger than requested.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> *<br/></li>
<li><a id="L599">&#x200c;</a><span class="linkable">CreateAnonymousSegment</span>(Size *size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; allocsize = *size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr = MAP_FAILED;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mmap_errno = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef MAP_HUGETLB<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* <a href="win32_shmem.c.html#L207" title="port/win32_shmem.c:207">PGSharedMemoryCreate</a> should have dealt with this case */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../utils/misc/guc_tables.c.html#L565" title="utils/misc/guc_tables.c:565">huge_pages</a> != HUGE_PAGES_ON);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L565" title="utils/misc/guc_tables.c:565">huge_pages</a> == HUGE_PAGES_ON || <a href="../utils/misc/guc_tables.c.html#L565" title="utils/misc/guc_tables.c:565">huge_pages</a> == HUGE_PAGES_TRY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Round up the request size to a suitable large value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; hugepagesize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mmap_flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="win32_shmem.c.html#L630" title="port/win32_shmem.c:630">GetHugePageSize</a>(&amp;hugepagesize, &amp;mmap_flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (allocsize % hugepagesize != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allocsize += hugepagesize - (allocsize % hugepagesize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr = mmap(<span class="Constant">NULL</span>, allocsize, PROT_READ | PROT_WRITE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_MMAP_FLAGS | mmap_flags, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mmap_errno = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L565" title="utils/misc/guc_tables.c:565">huge_pages</a> == HUGE_PAGES_TRY &amp;&amp; ptr == MAP_FAILED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;mmap(</span><span class="Special">%zu</span><span class="Constant">) with MAP_HUGETLB failed, huge pages disabled: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; allocsize);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Report whether huge pages are in use.&nbsp; This needs to be tracked <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the second mmap() call if attempting to use huge pages failed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * previously.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;<a href="../utils/misc/guc_tables.c.html#L567" title="utils/misc/guc_tables.c:567">huge_pages_status</a>&quot;</span>, (ptr == MAP_FAILED) ? <span class="Constant">&quot;off&quot;</span> : <span class="Constant">&quot;on&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGC_INTERNAL, PGC_S_DYNAMIC_DEFAULT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ptr == MAP_FAILED &amp;&amp; <a href="../utils/misc/guc_tables.c.html#L565" title="utils/misc/guc_tables.c:565">huge_pages</a> != HUGE_PAGES_ON)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use the original size, not the rounded-up value, when falling back<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to non-huge pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; allocsize = *size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr = mmap(<span class="Constant">NULL</span>, allocsize, PROT_READ | PROT_WRITE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_MMAP_FLAGS, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mmap_errno = errno;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ptr == MAP_FAILED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = mmap_errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not map anonymous shared memory: %m&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (mmap_errno == <span class="Constant">ENOMEM</span>) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;This error usually means that PostgreSQL's request &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;for a shared memory segment exceeded available memory, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;swap space, or huge pages. To reduce the request size &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;(currently </span><span class="Special">%zu</span><span class="Constant"> bytes), reduce PostgreSQL's shared &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;memory usage, perhaps by reducing shared_buffers or &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;max_connections.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; allocsize) : <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *size = allocsize;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ptr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L675" title="port/sysv_shmem.c:675">AnonymousShmemDetach</a> --- detach from an anonymous mmap'd block<br/></li>
<li></span><span class="Comment"> * (called as an <a href="../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a> callback, hence funny argument list)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L675">&#x200c;</a></span><span class="linkable">AnonymousShmemDetach</span>(<span class="Type">int</span> status, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release anonymous shared memory block, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L98" title="port/sysv_shmem.c:98">AnonymousShmem</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (munmap(<a href="#L98" title="port/sysv_shmem.c:98">AnonymousShmem</a>, <a href="#L97" title="port/sysv_shmem.c:97">AnonymousShmemSize</a>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;munmap(</span><span class="Special">%p</span><span class="Constant">, </span><span class="Special">%zu</span><span class="Constant">) failed: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L98" title="port/sysv_shmem.c:98">AnonymousShmem</a>, <a href="#L97" title="port/sysv_shmem.c:97">AnonymousShmemSize</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L98" title="port/sysv_shmem.c:98">AnonymousShmem</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="win32_shmem.c.html#L207" title="port/win32_shmem.c:207">PGSharedMemoryCreate</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Create a shared memory segment of the given size and <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> its<br/></li>
<li></span><span class="Comment"> * standard header.&nbsp; Also, register an <a href="../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a> callback to release<br/></li>
<li></span><span class="Comment"> * the storage.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Dead Postgres segments pertinent to this <a href="../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a> are recycled if found, but<br/></li>
<li></span><span class="Comment"> * we do not fail upon collision with foreign shmem segments.&nbsp; The idea here<br/></li>
<li></span><span class="Comment"> * is to detect and re-use keys that may have been assigned by a crashed<br/></li>
<li></span><span class="Comment"> * postmaster or backend.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PGShmemHeader *<br/></li>
<li><a id="L700">&#x200c;</a><span class="linkable">PGSharedMemoryCreate</span>(Size size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PGShmemHeader **shim)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L70" title="port/sysv_shmem.c:70">IpcMemoryKey</a> NextShmemSegID;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *memAddress;<br/></li>
<li>&nbsp; &nbsp; PGShmemHeader *hdr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> stat statbuf;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; sysvsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use the data directory's ID info (inode and device numbers) to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * positively identify shmem segments associated with this data dir, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * also as seeds for searching for a free shmem key.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stat(<a href="../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>, &amp;statbuf) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not stat data directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Complain if hugepages demanded but we can't possibly support them */<br/></li>
<li></span><span class="PreProc">#if !defined(MAP_HUGETLB)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L565" title="utils/misc/guc_tables.c:565">huge_pages</a> == HUGE_PAGES_ON)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;huge pages not supported on this platform&quot;</span>)));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we don't support huge pages in SysV memory */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L565" title="utils/misc/guc_tables.c:565">huge_pages</a> == HUGE_PAGES_ON &amp;&amp; <a href="../storage/ipc/ipci.c.html#L57" title="storage/ipc/ipci.c:57">shared_memory_type</a> != SHMEM_TYPE_MMAP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;huge pages not supported with the current <a href="../storage/ipc/ipci.c.html#L57" title="storage/ipc/ipci.c:57">shared_memory_type</a> setting&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Room for a header? */<br/></li>
<li></span>&nbsp; &nbsp; Assert(size &gt; MAXALIGN(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PGShmemHeader)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../storage/ipc/ipci.c.html#L57" title="storage/ipc/ipci.c:57">shared_memory_type</a> == SHMEM_TYPE_MMAP)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L98" title="port/sysv_shmem.c:98">AnonymousShmem</a> = <a href="#L599" title="port/sysv_shmem.c:599">CreateAnonymousSegment</a>(&amp;size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="port/sysv_shmem.c:97">AnonymousShmemSize</a> = size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Register on-exit routine to unmap the anonymous segment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a>(<a href="#L675" title="port/sysv_shmem.c:675">AnonymousShmemDetach</a>, (Datum) <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now we need only allocate a minimal-sized SysV shmem block. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sysvsize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PGShmemHeader);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sysvsize = size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* huge pages are only available with mmap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;<a href="../utils/misc/guc_tables.c.html#L567" title="utils/misc/guc_tables.c:567">huge_pages_status</a>&quot;</span>, <span class="Constant">&quot;off&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGC_INTERNAL, PGC_S_DYNAMIC_DEFAULT);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop till we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a free IPC key.&nbsp; Trust <a href="../utils/init/miscinit.c.html#L1455" title="utils/init/miscinit.c:1455">CreateDataDirLockFile</a>() to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensure no more than one postmaster per data directory can enter this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * loop simultaneously.&nbsp; (<a href="../utils/init/miscinit.c.html#L1455" title="utils/init/miscinit.c:1455">CreateDataDirLockFile</a>() does not entirely ensure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that, but prefer fixing it over coping here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; NextShmemSegID = statbuf.st_ino;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="port/sysv_shmem.c:71">IpcMemoryId</a> shmid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGShmemHeader *oldhdr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L91" title="port/sysv_shmem.c:91">IpcMemoryState</a> state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to create new segment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memAddress = <a href="#L121" title="port/sysv_shmem.c:121">InternalIpcMemoryCreate</a>(NextShmemSegID, sysvsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (memAddress)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* successful create and attach */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check shared memory and possibly remove and recreate */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shmget() failure is typically EACCES, hence SHMSTATE_FOREIGN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ENOENT, a narrow possibility, implies SHMSTATE_ENOENT, but one can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * safely treat SHMSTATE_ENOENT like SHMSTATE_FOREIGN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; shmid = shmget(NextShmemSegID, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PGShmemHeader), <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shmid &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldhdr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state = SHMSTATE_FOREIGN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state = <a href="#L347" title="port/sysv_shmem.c:347">PGSharedMemoryAttach</a>(shmid, <span class="Constant">NULL</span>, &amp;oldhdr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (state)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SHMSTATE_ANALYSIS_FAILURE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SHMSTATE_ATTACHED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_LOCK_FILE_EXISTS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;pre-existing shared memory block (key </span><span class="Special">%lu</span><span class="Constant">, ID </span><span class="Special">%lu</span><span class="Constant">) is still in use&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">long</span>) NextShmemSegID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">long</span>) shmid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Terminate <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> old server processes associated with data directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SHMSTATE_ENOENT:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To our surprise, some other process deleted since our last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L121" title="port/sysv_shmem.c:121">InternalIpcMemoryCreate</a>().&nbsp; Moments earlier, we would have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * seen SHMSTATE_FOREIGN.&nbsp; Try that same ID again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;shared memory block (key </span><span class="Special">%lu</span><span class="Constant">, ID </span><span class="Special">%lu</span><span class="Constant">) deleted during startup&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">unsigned</span> <span class="Type">long</span>) NextShmemSegID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">unsigned</span> <span class="Type">long</span>) shmid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SHMSTATE_FOREIGN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NextShmemSegID++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SHMSTATE_UNATTACHED:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The segment pertains to <a href="../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>, and every process that had<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * used it has died or detached.&nbsp; Zap it, if possible, and <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * associated dynamic shared memory segments, as well.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shouldn't fail, but if it does, assume the segment belongs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to someone else after all, and try the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> candidate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, try again to create the segment.&nbsp; That may fail<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if some other process creates the same shmem key <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do, in which case we'll try the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> key.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldhdr-&gt;<a href="../storage/ipc/dsm.c.html#L140" title="storage/ipc/dsm.c:140">dsm_control</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/dsm.c.html#L238" title="storage/ipc/dsm.c:238">dsm_cleanup_using_control_segment</a>(oldhdr-&gt;<a href="../storage/ipc/dsm.c.html#L140" title="storage/ipc/dsm.c:140">dsm_control</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shmctl(shmid, IPC_RMID, <span class="Constant">NULL</span>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NextShmemSegID++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldhdr &amp;&amp; shmdt((<span class="Type">void</span> *) oldhdr) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;shmdt(</span><span class="Special">%p</span><span class="Constant">) failed: %m&quot;</span>, oldhdr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize new segment. */<br/></li>
<li></span>&nbsp; &nbsp; hdr = (PGShmemHeader *) memAddress;<br/></li>
<li>&nbsp; &nbsp; hdr-&gt;creatorPID = getpid();<br/></li>
<li>&nbsp; &nbsp; hdr-&gt;magic = PGShmemMagic;<br/></li>
<li>&nbsp; &nbsp; hdr-&gt;<a href="../storage/ipc/dsm.c.html#L140" title="storage/ipc/dsm.c:140">dsm_control</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fill in the data directory ID info, too */<br/></li>
<li></span>&nbsp; &nbsp; hdr-&gt;device = statbuf.st_dev;<br/></li>
<li>&nbsp; &nbsp; hdr-&gt;inode = statbuf.st_ino;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize space allocation status for segment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hdr-&gt;totalsize = size;<br/></li>
<li>&nbsp; &nbsp; hdr-&gt;freeoffset = MAXALIGN(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PGShmemHeader));<br/></li>
<li>&nbsp; &nbsp; *shim = hdr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save info for possible future use */<br/></li>
<li></span>&nbsp; &nbsp; <a href="win32_shmem.c.html#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a> = memAddress;<br/></li>
<li>&nbsp; &nbsp; <a href="win32_shmem.c.html#L44" title="port/win32_shmem.c:44">UsedShmemSegID</a> = (<span class="Type">unsigned</span> <span class="Type">long</span>) NextShmemSegID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="#L98" title="port/sysv_shmem.c:98">AnonymousShmem</a> is NULL here, then we're not using anonymous shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory, and should return a pointer to the System V shared memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * block. Otherwise, the System V shared memory block is only a shim, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we must return a pointer to the real block.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L98" title="port/sysv_shmem.c:98">AnonymousShmem</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> hdr;<br/></li>
<li>&nbsp; &nbsp; memcpy(<a href="#L98" title="port/sysv_shmem.c:98">AnonymousShmem</a>, hdr, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PGShmemHeader));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (PGShmemHeader *) <a href="#L98" title="port/sysv_shmem.c:98">AnonymousShmem</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="win32_shmem.c.html#L424" title="port/win32_shmem.c:424">PGSharedMemoryReAttach</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called during startup of a postmaster child process to re-attach to<br/></li>
<li></span><span class="Comment"> * an already existing shared memory segment.&nbsp; This is needed only in the<br/></li>
<li></span><span class="Comment"> * EXEC_BACKEND case; otherwise postmaster children inherit the shared memory<br/></li>
<li></span><span class="Comment"> * segment attachment via fork().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="win32_shmem.c.html#L44" title="port/win32_shmem.c:44">UsedShmemSegID</a> and <a href="win32_shmem.c.html#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a> are implicit parameters to this<br/></li>
<li></span><span class="Comment"> * routine.&nbsp; The caller must have already restored them to the postmaster's<br/></li>
<li></span><span class="Comment"> * <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L890">&#x200c;</a></span><span class="linkable">PGSharedMemoryReAttach</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="port/sysv_shmem.c:71">IpcMemoryId</a> shmid;<br/></li>
<li>&nbsp; &nbsp; PGShmemHeader *hdr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L91" title="port/sysv_shmem.c:91">IpcMemoryState</a> state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *origUsedShmemSegAddr = <a href="win32_shmem.c.html#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="win32_shmem.c.html#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef __CYGWIN__<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* cygipc (currently) appears to not detach on exec. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="win32_shmem.c.html#L505" title="port/win32_shmem.c:505">PGSharedMemoryDetach</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="win32_shmem.c.html#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a> = origUsedShmemSegAddr;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG3, <span class="Constant">&quot;attaching to </span><span class="Special">%p</span><span class="Constant">&quot;</span>, <a href="win32_shmem.c.html#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a>);<br/></li>
<li>&nbsp; &nbsp; shmid = shmget(<a href="win32_shmem.c.html#L44" title="port/win32_shmem.c:44">UsedShmemSegID</a>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PGShmemHeader), <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (shmid &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state = SHMSTATE_FOREIGN;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state = <a href="#L347" title="port/sysv_shmem.c:347">PGSharedMemoryAttach</a>(shmid, <a href="win32_shmem.c.html#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a>, &amp;hdr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state != SHMSTATE_ATTACHED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;could not reattach to shared memory (key=</span><span class="Special">%d</span><span class="Constant">, addr=</span><span class="Special">%p</span><span class="Constant">): %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) <a href="win32_shmem.c.html#L44" title="port/win32_shmem.c:44">UsedShmemSegID</a>, <a href="win32_shmem.c.html#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hdr != origUsedShmemSegAddr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;reattaching to shared memory returned unexpected address (got </span><span class="Special">%p</span><span class="Constant">, expected </span><span class="Special">%p</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hdr, origUsedShmemSegAddr);<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/dsm.c.html#L459" title="storage/ipc/dsm.c:459">dsm_set_control_handle</a>(hdr-&gt;<a href="../storage/ipc/dsm.c.html#L140" title="storage/ipc/dsm.c:140">dsm_control</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="win32_shmem.c.html#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a> = hdr;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* probably redundant */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="win32_shmem.c.html#L472" title="port/win32_shmem.c:472">PGSharedMemoryNoReAttach</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called during startup of a postmaster child process when we choose<br/></li>
<li></span><span class="Comment"> * *not* to re-attach to the existing shared memory segment.&nbsp; We must clean up<br/></li>
<li></span><span class="Comment"> * to leave things in the appropriate state.&nbsp; This is not used in the non<br/></li>
<li></span><span class="Comment"> * EXEC_BACKEND case, either.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The child process startup logic might or might not call <a href="win32_shmem.c.html#L505" title="port/win32_shmem.c:505">PGSharedMemoryDetach</a><br/></li>
<li></span><span class="Comment"> * after this; make sure that it will be a no-op if called.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="win32_shmem.c.html#L44" title="port/win32_shmem.c:44">UsedShmemSegID</a> and <a href="win32_shmem.c.html#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a> are implicit parameters to this<br/></li>
<li></span><span class="Comment"> * routine.&nbsp; The caller must have already restored them to the postmaster's<br/></li>
<li></span><span class="Comment"> * <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L939">&#x200c;</a></span><span class="linkable">PGSharedMemoryNoReAttach</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="win32_shmem.c.html#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef __CYGWIN__<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* cygipc (currently) appears to not detach on exec. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="win32_shmem.c.html#L505" title="port/win32_shmem.c:505">PGSharedMemoryDetach</a>();<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For cleanliness, reset <a href="win32_shmem.c.html#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a> to show we're not attached. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="win32_shmem.c.html#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And the same for <a href="win32_shmem.c.html#L44" title="port/win32_shmem.c:44">UsedShmemSegID</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="win32_shmem.c.html#L44" title="port/win32_shmem.c:44">UsedShmemSegID</a> = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* EXEC_BACKEND */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="win32_shmem.c.html#L505" title="port/win32_shmem.c:505">PGSharedMemoryDetach</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Detach from the shared memory segment, if still attached.&nbsp; This is not<br/></li>
<li></span><span class="Comment"> * intended to be called explicitly by the process that originally created the<br/></li>
<li></span><span class="Comment"> * segment (it will have <a href="../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a> callback(s) registered to do that).<br/></li>
<li></span><span class="Comment"> * Rather, this is for subprocesses that have inherited an attachment and want<br/></li>
<li></span><span class="Comment"> * to get rid of it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="win32_shmem.c.html#L44" title="port/win32_shmem.c:44">UsedShmemSegID</a> and <a href="win32_shmem.c.html#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a> are implicit parameters to this<br/></li>
<li></span><span class="Comment"> * routine, also <a href="#L98" title="port/sysv_shmem.c:98">AnonymousShmem</a> and <a href="#L97" title="port/sysv_shmem.c:97">AnonymousShmemSize</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L970">&#x200c;</a></span><span class="linkable">PGSharedMemoryDetach</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="win32_shmem.c.html#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((shmdt(<a href="win32_shmem.c.html#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a>) &lt; <span class="Constant">0</span>)<br/></li>
<li><span class="PreProc">#if defined(EXEC_BACKEND) &amp;&amp; defined(__CYGWIN__)<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Work-around for cygipc exec bug */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; shmdt(<span class="Constant">NULL</span>) &lt; <span class="Constant">0<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;shmdt(</span><span class="Special">%p</span><span class="Constant">) failed: %m&quot;</span>, <a href="win32_shmem.c.html#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="win32_shmem.c.html#L45" title="port/win32_shmem.c:45">UsedShmemSegAddr</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L98" title="port/sysv_shmem.c:98">AnonymousShmem</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (munmap(<a href="#L98" title="port/sysv_shmem.c:98">AnonymousShmem</a>, <a href="#L97" title="port/sysv_shmem.c:97">AnonymousShmemSize</a>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;munmap(</span><span class="Special">%p</span><span class="Constant">, </span><span class="Special">%zu</span><span class="Constant">) failed: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L98" title="port/sysv_shmem.c:98">AnonymousShmem</a>, <a href="#L97" title="port/sysv_shmem.c:97">AnonymousShmemSize</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L98" title="port/sysv_shmem.c:98">AnonymousShmem</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
