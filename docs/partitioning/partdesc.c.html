<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>partitioning/partdesc.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>partitioning/partdesc.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L34">PartitionDirectoryData</a></li>
<li><a href="#L39">PartitionDirectoryData</a></li>
<li><a href="#L41">PartitionDirectoryEntry</a></li>
<li><a href="#L46">PartitionDirectoryEntry</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L381">CreatePartitionDirectory</a></li>
<li><a href="#L442">DestroyPartitionDirectory</a></li>
<li><a href="#L414">PartitionDirectoryLookup</a></li>
<li><a href="#L133">RelationBuildPartitionDesc</a></li>
<li><a href="#L70">RelationGetPartitionDesc</a></li>
<li><a href="#L459">get_default_oid_from_partdesc</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * partdesc.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Support routines for manipulating partition descriptors<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src/backend/partitioning/partdesc.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/genam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/partition.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_inherits.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;partitioning/partbounds.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;partitioning/partdesc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgroids.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/hsearch.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/partcache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L34">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">PartitionDirectoryData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext pdir_mcxt;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a>&nbsp; &nbsp; &nbsp;&nbsp; *pdir_hash;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; omit_detached;<br/></li>
<li><a id="L39">&#x200c;</a>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">PartitionDirectoryData</span>;<br/></li>
<li><br/></li>
<li><a id="L41">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">PartitionDirectoryEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reloid;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; PartitionDesc pd;<br/></li>
<li><a id="L46">&#x200c;</a>} <span class="linkable">PartitionDirectoryEntry</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> PartitionDesc <a href="#L133" title="partitioning/partdesc.c:133">RelationBuildPartitionDesc</a>(Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> omit_detached);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L70" title="partitioning/partdesc.c:70">RelationGetPartitionDesc</a> -- get partition descriptor, if relation is partitioned<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We keep two partdescs in relcache: rd_partdesc includes all partitions<br/></li>
<li></span><span class="Comment"> * (even those being concurrently marked detached), while rd_partdesc_nodetached<br/></li>
<li></span><span class="Comment"> * omits (some of) those.&nbsp; We store the pg_inherits.xmin value for the latter,<br/></li>
<li></span><span class="Comment"> * to determine whether it can be validly reused in each case, since that<br/></li>
<li></span><span class="Comment"> * depends on the active snapshot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we arrange for partition descriptors to not get freed until the<br/></li>
<li></span><span class="Comment"> * relcache entry's refcount goes to zero (see hacks in <a href="../utils/cache/relcache.c.html#L2193" title="utils/cache/relcache.c:2193">RelationClose</a>,<br/></li>
<li></span><span class="Comment"> * <a href="../utils/cache/relcache.c.html#L2535" title="utils/cache/relcache.c:2535">RelationClearRelation</a>, and <a href="#L133" title="partitioning/partdesc.c:133">RelationBuildPartitionDesc</a>).&nbsp; Therefore, even<br/></li>
<li></span><span class="Comment"> * though we hand back a direct pointer into the relcache entry, it's safe<br/></li>
<li></span><span class="Comment"> * for callers to continue to use that pointer as long as (a) they hold the<br/></li>
<li></span><span class="Comment"> * relation open, and (b) they hold a relation lock strong enough to ensure<br/></li>
<li></span><span class="Comment"> * that the data doesn't become stale.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PartitionDesc<br/></li>
<li><a id="L70">&#x200c;</a><span class="linkable">RelationGetPartitionDesc</span>(Relation rel, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> omit_detached)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If relcache has a partition descriptor, use that.&nbsp; However, we can only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do so when we are asked to include all partitions including detached;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and also when we know that there are no detached partitions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is no active snapshot, detached partitions aren't omitted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * either, so we can use the cached descriptor too in that case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (likely(rel-&gt;rd_partdesc &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (!rel-&gt;rd_partdesc-&gt;detached_exist || !omit_detached ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../utils/time/snapmgr.c.html#L782" title="utils/time/snapmgr.c:782">ActiveSnapshotSet</a>())))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> rel-&gt;rd_partdesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're asked to omit detached partitions, we may be able to use a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cached descriptor too.&nbsp; We determine that based on the pg_inherits.xmin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that was saved alongside that descriptor: if the xmin that was not in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * progress for that active snapshot is also not in progress for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current active snapshot, then we can use it.&nbsp; Otherwise build one from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scratch.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (omit_detached &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_partdesc_nodetached &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L782" title="utils/time/snapmgr.c:782">ActiveSnapshotSet</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Snapshot&nbsp; &nbsp; activesnap;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(TransactionIdIsValid(rel-&gt;rd_partdesc_nodetached_xmin));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; activesnap = <a href="../utils/time/snapmgr.c.html#L770" title="utils/time/snapmgr.c:770">GetActiveSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/time/snapmgr.c.html#L1856" title="utils/time/snapmgr.c:1856">XidInMVCCSnapshot</a>(rel-&gt;rd_partdesc_nodetached_xmin, activesnap))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> rel-&gt;rd_partdesc_nodetached;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L133" title="partitioning/partdesc.c:133">RelationBuildPartitionDesc</a>(rel, omit_detached);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L133" title="partitioning/partdesc.c:133">RelationBuildPartitionDesc</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Form rel's partition descriptor, and store in relcache entry<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Partition descriptor is a complex structure; to avoid complicated logic to<br/></li>
<li></span><span class="Comment"> * free individual elements whenever the relcache entry is flushed, we give it<br/></li>
<li></span><span class="Comment"> * its own memory context, a child of <a href="../utils/mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>, which can easily be<br/></li>
<li></span><span class="Comment"> * deleted on its own.&nbsp; To avoid leaking memory in that context in case of an<br/></li>
<li></span><span class="Comment"> * error partway through this function, the context is initially created as a<br/></li>
<li></span><span class="Comment"> * child of <a href="../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a> and only re-parented to <a href="../utils/mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a><br/></li>
<li></span><span class="Comment"> * at the end, when no further errors are possible.&nbsp; Also, we don't make this<br/></li>
<li></span><span class="Comment"> * context the current context except in very brief code sections, out of fear<br/></li>
<li></span><span class="Comment"> * that some of our callees allocate memory on their own which would be leaked<br/></li>
<li></span><span class="Comment"> * permanently.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As a special case, partition descriptors that are requested to omit<br/></li>
<li></span><span class="Comment"> * partitions being detached (and which contain such partitions) are transient<br/></li>
<li></span><span class="Comment"> * and are not associated with the relcache entry.&nbsp; Such descriptors only last<br/></li>
<li></span><span class="Comment"> * through the requesting Portal, so we use the corresponding memory context<br/></li>
<li></span><span class="Comment"> * for them.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> PartitionDesc<br/></li>
<li><a id="L133">&#x200c;</a><span class="linkable">RelationBuildPartitionDesc</span>(Relation rel, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> omit_detached)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PartitionDesc partdesc;<br/></li>
<li>&nbsp; &nbsp; PartitionBoundInfo boundinfo = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *inhoids;<br/></li>
<li>&nbsp; &nbsp; PartitionBoundSpec **boundspecs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *oids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *is_leaf = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; detached_exist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_omit;<br/></li>
<li>&nbsp; &nbsp; TransactionId detached_xmin;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nparts;<br/></li>
<li>&nbsp; &nbsp; PartitionKey key = <a href="../utils/cache/partcache.c.html#L51" title="utils/cache/partcache.c:51">RelationGetPartitionKey</a>(rel);<br/></li>
<li>&nbsp; &nbsp; MemoryContext new_pdcxt;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *mapping;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get partition oids from pg_inherits.&nbsp; This uses a single snapshot to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fetch the list of children, so while more children may be getting added<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * concurrently, whatever this function returns will be accurate as of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some well-defined point in time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; detached_exist = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; detached_xmin = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; inhoids = <a href="../catalog/pg_inherits.c.html#L82" title="catalog/pg_inherits.c:82">find_inheritance_children_extended</a>(RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; omit_detached, NoLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;detached_exist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;detached_xmin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nparts = list_length(inhoids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate working arrays for OIDs, leaf flags, and boundspecs. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nparts &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oids = (Oid *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nparts * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; is_leaf = (<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nparts * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; boundspecs = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nparts * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PartitionBoundSpec *));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Collect bound spec nodes for each partition. */<br/></li>
<li></span>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(cell, inhoids)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inhrelid = lfirst_oid(cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PartitionBoundSpec *boundspec = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try fetching the tuple from the catcache, for speed. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID, ObjectIdGetDatum(inhrelid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum = <a href="../utils/cache/syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(RELOID, tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_class_relpartbound,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; boundspec = <a href="../nodes/read.c.html#L90" title="nodes/read.c:90">stringToNode</a>(TextDatumGetCString(datum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The system cache may be out of date; if so, we may <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> no pg_class<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple or an old one where relpartbound is NULL.&nbsp; In that case, try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the table directly.&nbsp; We can't just <a href="../utils/cache/inval.c.html#L806" title="utils/cache/inval.c:806">AcceptInvalidationMessages</a>() and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * retry the system cache lookup because it's possible that a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * concurrent ATTACH PARTITION operation has removed itself from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ProcArray but not yet added invalidation messages to the shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * queue; <a href="../utils/cache/inval.c.html#L792" title="utils/cache/inval.c:792">InvalidateSystemCaches</a>() would work, but seems excessive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that this algorithm assumes that PartitionBoundSpec we manage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to fetch is the right one -- so this is only good enough for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * concurrent ATTACH PARTITION, not concurrent DETACH PARTITION or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * some hypothetical operation that changes the partition bounds.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (boundspec == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; pg_class;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanKeyData key[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_class = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_class_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(inhrelid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(pg_class, ClassOidIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">1</span>, key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum = heap_getattr(tuple, Anum_pg_class_relpartbound,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetDescr(pg_class), &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; boundspec = <a href="../nodes/read.c.html#L90" title="nodes/read.c:90">stringToNode</a>(TextDatumGetCString(datum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_class, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sanity checks. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!boundspec)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing relpartbound for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, inhrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsA(boundspec, PartitionBoundSpec))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid relpartbound for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, inhrelid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the PartitionBoundSpec says this is the default partition, its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OID should match pg_partitioned_table.partdefid; if not, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * catalog is corrupt.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (boundspec-&gt;is_default)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partdefid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partdefid = <a href="../catalog/partition.c.html#L315" title="catalog/partition.c:315">get_default_partition_oid</a>(RelationGetRelid(rel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (partdefid != inhrelid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;expected partdefid </span><span class="Special">%u</span><span class="Constant">, but got </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inhrelid, partdefid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Save results. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oids[i] = inhrelid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; is_leaf[i] = (<a href="../utils/cache/lsyscache.c.html#L2003" title="utils/cache/lsyscache.c:2003">get_rel_relkind</a>(inhrelid) != RELKIND_PARTITIONED_TABLE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; boundspecs[i] = boundspec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ++i;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create PartitionBoundInfo and mapping, working in the caller's context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This could fail, but we haven't done <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> damage if so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nparts &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; boundinfo = <a href="partbounds.c.html#L299" title="partitioning/partbounds.c:299">partition_bounds_create</a>(boundspecs, nparts, key, &amp;mapping);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now build the actual relcache partition descriptor, copying all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data into a new, small context.&nbsp; As per above comment, we don't make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this a long-lived context until it's finished.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; new_pdcxt = AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;partition descriptor&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_SMALL_SIZES);<br/></li>
<li>&nbsp; &nbsp; MemoryContextCopyAndSetIdentifier(new_pdcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; partdesc = (PartitionDescData *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(new_pdcxt, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PartitionDescData));<br/></li>
<li>&nbsp; &nbsp; partdesc-&gt;nparts = nparts;<br/></li>
<li>&nbsp; &nbsp; partdesc-&gt;detached_exist = detached_exist;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there are no partitions, the rest of the partdesc can stay zero */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nparts &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(new_pdcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partdesc-&gt;boundinfo = <a href="partbounds.c.html#L1002" title="partitioning/partbounds.c:1002">partition_bounds_copy</a>(boundinfo, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize caching fields for speeding up <a href="../executor/execPartition.c.html#L262" title="executor/execPartition.c:262">ExecFindPartition</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; partdesc-&gt;last_found_datum_index = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partdesc-&gt;last_found_part_index = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partdesc-&gt;last_found_count = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partdesc-&gt;oids = (Oid *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nparts * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partdesc-&gt;is_leaf = (<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nparts * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Assign OIDs from the original array into mapped indexes of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result array.&nbsp; The order of OIDs in the former is defined by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * catalog scan that retrieved them, whereas that in the latter is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * defined by canonicalized representation of the partition bounds.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also save leaf-ness of each partition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nparts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index = mapping[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partdesc-&gt;oids[index] = oids[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partdesc-&gt;is_leaf[index] = is_leaf[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Are we working with the partdesc that omits the detached partition, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the one that includes it?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that if a partition was found by the catalog's scan to have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * detached, but the pg_inherit tuple saying so was not visible to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * active snapshot (<a href="../catalog/pg_inherits.c.html#L82" title="catalog/pg_inherits.c:82">find_inheritance_children_extended</a> will not have set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * detached_xmin in that case), we consider there to be no &quot;omittable&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * detached partitions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; is_omit = omit_detached &amp;&amp; detached_exist &amp;&amp; <a href="../utils/time/snapmgr.c.html#L782" title="utils/time/snapmgr.c:782">ActiveSnapshotSet</a>() &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionIdIsValid(detached_xmin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have a fully valid partdesc.&nbsp; Reparent it so that it has the right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lifespan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L637" title="utils/mmgr/mcxt.c:637">MemoryContextSetParent</a>(new_pdcxt, <a href="../utils/mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Store it into relcache.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * But first, a kluge: if there's an old context for this type of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * descriptor, it contains an old partition descriptor that may still be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * referenced somewhere.&nbsp; Preserve it, while not leaking it, by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reattaching it as a child context of the new one.&nbsp; Eventually it will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get dropped by either <a href="../utils/cache/relcache.c.html#L2193" title="utils/cache/relcache.c:2193">RelationClose</a> or <a href="../utils/cache/relcache.c.html#L2535" title="utils/cache/relcache.c:2535">RelationClearRelation</a>. (We keep<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the regular partdesc in rd_pdcxt, and the partdesc-excluding-<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * detached-partitions in rd_pddcxt.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (is_omit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_pddcxt != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L637" title="utils/mmgr/mcxt.c:637">MemoryContextSetParent</a>(rel-&gt;rd_pddcxt, new_pdcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_pddcxt = new_pdcxt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_partdesc_nodetached = partdesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For partdescs built excluding detached partitions, which we save<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * separately, we also record the pg_inherits.xmin of the detached<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partition that was omitted; this informs a future potential user of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * such a cached partdesc to only use it after cross-checking that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xmin is indeed visible to the snapshot it is going to be working<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(TransactionIdIsValid(detached_xmin));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_partdesc_nodetached_xmin = detached_xmin;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_pdcxt != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L637" title="utils/mmgr/mcxt.c:637">MemoryContextSetParent</a>(rel-&gt;rd_pdcxt, new_pdcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_pdcxt = new_pdcxt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_partdesc = partdesc;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> partdesc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L381" title="partitioning/partdesc.c:381">CreatePartitionDirectory</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Create a new partition directory object.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PartitionDirectory<br/></li>
<li><a id="L381">&#x200c;</a><span class="linkable">CreatePartitionDirectory</span>(MemoryContext mcxt, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> omit_detached)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext = MemoryContextSwitchTo(mcxt);<br/></li>
<li>&nbsp; &nbsp; PartitionDirectory pdir;<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pdir = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L34" title="partitioning/partdesc.c:34">PartitionDirectoryData</a>));<br/></li>
<li>&nbsp; &nbsp; pdir-&gt;pdir_mcxt = mcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctl.keysize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid);<br/></li>
<li>&nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L41" title="partitioning/partdesc.c:41">PartitionDirectoryEntry</a>);<br/></li>
<li>&nbsp; &nbsp; ctl.hcxt = mcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pdir-&gt;pdir_hash = <a href="../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;partition directory&quot;</span>, <span class="Constant">256</span>, &amp;ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);<br/></li>
<li>&nbsp; &nbsp; pdir-&gt;omit_detached = omit_detached;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pdir;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L414" title="partitioning/partdesc.c:414">PartitionDirectoryLookup</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Look up the partition descriptor for a relation in the directory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The purpose of this function is to ensure that we get the same<br/></li>
<li></span><span class="Comment"> * PartitionDesc for each relation every time we look it up.&nbsp; In the<br/></li>
<li></span><span class="Comment"> * face of concurrent DDL, different PartitionDescs may be constructed with<br/></li>
<li></span><span class="Comment"> * different views of the catalog state, but <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> single particular OID<br/></li>
<li></span><span class="Comment"> * will always get the same PartitionDesc for as long as the same<br/></li>
<li></span><span class="Comment"> * PartitionDirectory is used.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PartitionDesc<br/></li>
<li><a id="L414">&#x200c;</a><span class="linkable">PartitionDirectoryLookup</span>(PartitionDirectory pdir, Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L41" title="partitioning/partdesc.c:41">PartitionDirectoryEntry</a> *pde;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = RelationGetRelid(rel);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pde = <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(pdir-&gt;pdir_hash, &amp;relid, HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must keep a reference count on the relation so that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PartitionDesc to which we are pointing can't get destroyed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/relcache.c.html#L2160" title="utils/cache/relcache.c:2160">RelationIncrementReferenceCount</a>(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pde-&gt;rel = rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pde-&gt;pd = <a href="#L70" title="partitioning/partdesc.c:70">RelationGetPartitionDesc</a>(rel, pdir-&gt;omit_detached);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(pde-&gt;pd != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pde-&gt;pd;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L442" title="partitioning/partdesc.c:442">DestroyPartitionDirectory</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Destroy a partition directory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Release the reference counts we're holding.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L442">&#x200c;</a></span><span class="linkable">DestroyPartitionDirectory</span>(PartitionDirectory pdir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L41" title="partitioning/partdesc.c:41">PartitionDirectoryEntry</a> *pde;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, pdir-&gt;pdir_hash);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((pde = <a href="../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/relcache.c.html#L2173" title="utils/cache/relcache.c:2173">RelationDecrementReferenceCount</a>(pde-&gt;rel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L459" title="partitioning/partdesc.c:459">get_default_oid_from_partdesc</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given a partition descriptor, return the OID of the default partition, if<br/></li>
<li></span><span class="Comment"> * one exists; else, return InvalidOid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L459">&#x200c;</a><span class="linkable">get_default_oid_from_partdesc</span>(PartitionDesc partdesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (partdesc &amp;&amp; partdesc-&gt;boundinfo &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partition_bound_has_default(partdesc-&gt;boundinfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> partdesc-&gt;oids[partdesc-&gt;boundinfo-&gt;default_index];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
