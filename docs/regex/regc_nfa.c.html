<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>regex/regc_nfa.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>regex/regc_nfa.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L368">allocarc</a></li>
<li><a href="#L3016">analyze</a></li>
<li><a href="#L2551">breakconstraintloop</a></li>
<li><a href="#L3577">carc_cmp</a></li>
<li><a href="#L3570">carcsort</a></li>
<li><a href="#L489">changearcsource</a></li>
<li><a href="#L533">changearctarget</a></li>
<li><a href="#L3434">check_in_colors_match</a></li>
<li><a href="#L3380">check_out_colors_match</a></li>
<li><a href="#L3062">checkmatchall</a></li>
<li><a href="#L3242">checkmatchall_recurse</a></li>
<li><a href="#L2929">cleanup</a></li>
<li><a href="#L1487">cleartraverse</a></li>
<li><a href="#L1256">cloneouts</a></li>
<li><a href="#L2697">clonesuccessorstates</a></li>
<li><a href="#L1980">combine</a></li>
<li><a href="#L3479">compact</a></li>
<li><a href="#L882">copyins</a></li>
<li><a href="#L1167">copyouts</a></li>
<li><a href="#L608">cparc</a></li>
<li><a href="#L323">createarc</a></li>
<li><a href="#L1281">delsub</a></li>
<li><a href="#L1304">deltraverse</a></li>
<li><a href="#L226">dropstate</a></li>
<li><a href="#L3716">dumparc</a></li>
<li><a href="#L3684">dumparcs</a></li>
<li><a href="#L3783">dumpcnfa</a></li>
<li><a href="#L3820">dumpcstate</a></li>
<li><a href="#L3611">dumpnfa</a></li>
<li><a href="#L3658">dumpstate</a></li>
<li><a href="#L1355">dupnfa</a></li>
<li><a href="#L1379">duptraverse</a></li>
<li><a href="#L2296">emptyreachable</a></li>
<li><a href="#L592">findarc</a></li>
<li><a href="#L2462">findconstraintloop</a></li>
<li><a href="#L2363">fixconstraintloops</a></li>
<li><a href="#L2069">fixempties</a></li>
<li><a href="#L418">freearc</a></li>
<li><a href="#L3598">freecnfa</a></li>
<li><a href="#L107">freenfa</a></li>
<li><a href="#L242">freestate</a></li>
<li><a href="#L2342">hasconstraintout</a></li>
<li><a href="#L575">hasnonemptyout</a></li>
<li><a href="#L2324">isconstraintarc</a></li>
<li><a href="#L2990">markcanreach</a></li>
<li><a href="#L2964">markreachable</a></li>
<li><a href="#L971">mergeins</a></li>
<li><a href="#L778">moveins</a></li>
<li><a href="#L1066">moveouts</a></li>
<li><a href="#L281">newarc</a></li>
<li><a href="#L212">newfstate</a></li>
<li><a href="#L47">newnfa</a></li>
<li><a href="#L137">newstate</a></li>
<li><a href="#L1593">optimize</a></li>
<li><a href="#L1713">pull</a></li>
<li><a href="#L1633">pullback</a></li>
<li><a href="#L1884">push</a></li>
<li><a href="#L1804">pushfwd</a></li>
<li><a href="#L1419">removeconstraints</a></li>
<li><a href="#L1438">removetraverse</a></li>
<li><a href="#L1524">single_color_transition</a></li>
<li><a href="#L620">sortins</a></li>
<li><a href="#L662">sortins_cmp</a></li>
<li><a href="#L687">sortouts</a></li>
<li><a href="#L729">sortouts_cmp</a></li>
<li><a href="#L1554">specialcolors</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L758">BULK_ARC_OP_USE_SORT</a></li>
<li><a href="#L1984">CA</a></li>
<li><a href="#L40">NERR</a></li>
<li><a href="#L39">NISERR</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * NFA utilities.<br/></li>
<li></span><span class="Comment"> * This file is #included by regcomp.c.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 1998, 1999 Henry Spencer.&nbsp; All rights reserved.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Development of this software was funded, in part, by Cray Research Inc.,<br/></li>
<li></span><span class="Comment"> * UUNET Communications Services Inc., Sun Microsystems Inc., and Scriptics<br/></li>
<li></span><span class="Comment"> * Corporation, <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of whom are responsible for the results.&nbsp; The author<br/></li>
<li></span><span class="Comment"> * thanks all of them.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Redistribution and use in source and binary forms -- with or without<br/></li>
<li></span><span class="Comment"> * modification -- are permitted for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> purpose, provided that<br/></li>
<li></span><span class="Comment"> * redistributions in source form retain this entire copyright notice and<br/></li>
<li></span><span class="Comment"> * indicate the origin and nature of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> modifications.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * I'd appreciate being given credit for this package in the documentation<br/></li>
<li></span><span class="Comment"> * of software which uses it, but that is not a requirement.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,<br/></li>
<li></span><span class="Comment"> * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY<br/></li>
<li></span><span class="Comment"> * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.&nbsp; IN NO EVENT SHALL<br/></li>
<li></span><span class="Comment"> * HENRY SPENCER BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,<br/></li>
<li></span><span class="Comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,<br/></li>
<li></span><span class="Comment"> * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;<br/></li>
<li></span><span class="Comment"> * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,<br/></li>
<li></span><span class="Comment"> * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR<br/></li>
<li></span><span class="Comment"> * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF<br/></li>
<li></span><span class="Comment"> * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * src/backend/regex/regc_nfa.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * One or two things that technically ought to be in here<br/></li>
<li></span><span class="Comment"> * are actually in color.c, thanks to some incestuous relationships in<br/></li>
<li></span><span class="Comment"> * the color chains.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L39">&#x200c;</a><span class="PreProc">#define <span class="linkable">NISERR</span>()&nbsp; &nbsp; <a href="regexec.c.html#L126" title="regex/regexec.c:126">VISERR</a>(nfa-&gt;v)<br/></li>
<li><a id="L40">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NERR</span>(e)&nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L128" title="regex/regexec.c:128">VERR</a>(nfa-&gt;v, (e))<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L47" title="regex/regc_nfa.c:47">newnfa</a> - set up an NFA<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">struct</span> nfa *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the NFA, or NULL */<br/></li>
<li><a id="L47">&#x200c;</a></span><span class="linkable">newnfa</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> colormap *cm,<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> nfa *parent)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NULL if primary NFA */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> nfa *nfa;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nfa = (<span class="Type">struct</span> nfa *) MALLOC(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> nfa));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nfa == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L129" title="regex/regexec.c:129">ERR</a>(REG_ESPACE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make the NFA minimally valid, so <a href="#L107" title="regex/regc_nfa.c:107">freenfa</a>() will behave sanely */<br/></li>
<li></span>&nbsp; &nbsp; nfa-&gt;states = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; nfa-&gt;slast = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; nfa-&gt;freestates = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; nfa-&gt;freearcs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; nfa-&gt;lastsb = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; nfa-&gt;lastab = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; nfa-&gt;lastsbused = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; nfa-&gt;lastabused = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; nfa-&gt;nstates = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; nfa-&gt;cm = cm;<br/></li>
<li>&nbsp; &nbsp; nfa-&gt;v = v;<br/></li>
<li>&nbsp; &nbsp; nfa-&gt;bos[<span class="Constant">0</span>] = nfa-&gt;bos[<span class="Constant">1</span>] = COLORLESS;<br/></li>
<li>&nbsp; &nbsp; nfa-&gt;eos[<span class="Constant">0</span>] = nfa-&gt;eos[<span class="Constant">1</span>] = COLORLESS;<br/></li>
<li>&nbsp; &nbsp; nfa-&gt;flags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; nfa-&gt;minmatchall = nfa-&gt;maxmatchall = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; nfa-&gt;parent = parent;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Precedes <a href="#L212" title="regex/regc_nfa.c:212">newfstate</a> so parent is valid. */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create required infrastructure */<br/></li>
<li></span>&nbsp; &nbsp; nfa-&gt;post = <a href="#L212" title="regex/regc_nfa.c:212">newfstate</a>(nfa, <span class="Constant">'@'</span>);&nbsp; &nbsp; <span class="Comment">/* number 0 */<br/></li>
<li></span>&nbsp; &nbsp; nfa-&gt;pre = <a href="#L212" title="regex/regc_nfa.c:212">newfstate</a>(nfa, <span class="Constant">'&gt;'</span>); <span class="Comment">/* number 1 */<br/></li>
<li></span>&nbsp; &nbsp; nfa-&gt;init = <a href="#L137" title="regex/regc_nfa.c:137">newstate</a>(nfa);&nbsp; &nbsp; <span class="Comment">/* may become invalid later */<br/></li>
<li></span>&nbsp; &nbsp; nfa-&gt;final = <a href="#L137" title="regex/regc_nfa.c:137">newstate</a>(nfa);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="regexec.c.html#L127" title="regex/regexec.c:127">ISERR</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="regex/regc_nfa.c:107">freenfa</a>(nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="regc_color.c.html#L1031" title="regex/regc_color.c:1031">rainbow</a>(nfa, nfa-&gt;cm, <a href="regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a>, COLORLESS, nfa-&gt;pre, nfa-&gt;init);<br/></li>
<li>&nbsp; &nbsp; <a href="#L281" title="regex/regc_nfa.c:281">newarc</a>(nfa, <span class="Constant">'^'</span>, <span class="Constant">1</span>, nfa-&gt;pre, nfa-&gt;init);<br/></li>
<li>&nbsp; &nbsp; <a href="#L281" title="regex/regc_nfa.c:281">newarc</a>(nfa, <span class="Constant">'^'</span>, <span class="Constant">0</span>, nfa-&gt;pre, nfa-&gt;init);<br/></li>
<li>&nbsp; &nbsp; <a href="regc_color.c.html#L1031" title="regex/regc_color.c:1031">rainbow</a>(nfa, nfa-&gt;cm, <a href="regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a>, COLORLESS, nfa-&gt;final, nfa-&gt;post);<br/></li>
<li>&nbsp; &nbsp; <a href="#L281" title="regex/regc_nfa.c:281">newarc</a>(nfa, <span class="Constant">'$'</span>, <span class="Constant">1</span>, nfa-&gt;final, nfa-&gt;post);<br/></li>
<li>&nbsp; &nbsp; <a href="#L281" title="regex/regc_nfa.c:281">newarc</a>(nfa, <span class="Constant">'$'</span>, <span class="Constant">0</span>, nfa-&gt;final, nfa-&gt;post);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="regexec.c.html#L127" title="regex/regexec.c:127">ISERR</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="regex/regc_nfa.c:107">freenfa</a>(nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nfa;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L107" title="regex/regc_nfa.c:107">freenfa</a> - free an entire NFA<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L107">&#x200c;</a></span><span class="linkable">freenfa</span>(<span class="Type">struct</span> nfa *nfa)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> statebatch *sb;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> statebatch *sbnext;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arcbatch *ab;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arcbatch *abnext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (sb = nfa-&gt;lastsb; sb != <span class="Constant">NULL</span>; sb = sbnext)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sbnext = sb-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nfa-&gt;v-&gt;spaceused -= STATEBATCHSIZE(sb-&gt;nstates);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FREE(sb);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; nfa-&gt;lastsb = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (ab = nfa-&gt;lastab; ab != <span class="Constant">NULL</span>; ab = abnext)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; abnext = ab-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nfa-&gt;v-&gt;spaceused -= ARCBATCHSIZE(ab-&gt;narcs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FREE(ab);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; nfa-&gt;lastab = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nfa-&gt;nstates = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; FREE(nfa);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L137" title="regex/regc_nfa.c:137">newstate</a> - allocate an NFA state, with zero flag value<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">struct</span> state *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NULL on error */<br/></li>
<li><a id="L137">&#x200c;</a></span><span class="linkable">newstate</span>(<span class="Type">struct</span> nfa *nfa)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is a handy place to check for operation cancel during regex<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * compilation, since no code path will go very long without making a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * state or arc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; INTERRUPT(nfa-&gt;v-&gt;re);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* first, recycle anything that's on the freelist */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nfa-&gt;freestates != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s = nfa-&gt;freestates;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nfa-&gt;freestates = s-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* otherwise, is there anything left in the last statebatch? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (nfa-&gt;lastsb != <span class="Constant">NULL</span> &amp;&amp; nfa-&gt;lastsbused &lt; nfa-&gt;lastsb-&gt;nstates)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s = &amp;nfa-&gt;lastsb-&gt;s[nfa-&gt;lastsbused++];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* otherwise, need to allocate a new statebatch */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> statebatch *newSb;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; nstates;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nfa-&gt;v-&gt;spaceused &gt;= REG_MAX_COMPILE_SPACE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L40" title="regex/regc_nfa.c:40">NERR</a>(REG_ETOOBIG);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nstates = (nfa-&gt;lastsb != <span class="Constant">NULL</span>) ? nfa-&gt;lastsb-&gt;nstates * <span class="Constant">2</span> : FIRSTSBSIZE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nstates &gt; MAXSBSIZE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nstates = MAXSBSIZE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newSb = (<span class="Type">struct</span> statebatch *) MALLOC(STATEBATCHSIZE(nstates));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newSb == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L40" title="regex/regc_nfa.c:40">NERR</a>(REG_ESPACE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nfa-&gt;v-&gt;spaceused += STATEBATCHSIZE(nstates);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newSb-&gt;nstates = nstates;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newSb-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = nfa-&gt;lastsb;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nfa-&gt;lastsb = newSb;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nfa-&gt;lastsbused = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s = &amp;newSb-&gt;s[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(nfa-&gt;nstates &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; s-&gt;no = nfa-&gt;nstates++;<br/></li>
<li>&nbsp; &nbsp; s-&gt;flag = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nfa-&gt;states == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nfa-&gt;states = s;<br/></li>
<li>&nbsp; &nbsp; s-&gt;nins = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;ins = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;nouts = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;outs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;tmp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nfa-&gt;slast != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(nfa-&gt;slast-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nfa-&gt;slast-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = s;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; s-&gt;prev = nfa-&gt;slast;<br/></li>
<li>&nbsp; &nbsp; nfa-&gt;slast = s;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> s;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L212" title="regex/regc_nfa.c:212">newfstate</a> - allocate an NFA state with a specified flag value<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">struct</span> state *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NULL on error */<br/></li>
<li><a id="L212">&#x200c;</a></span><span class="linkable">newfstate</span>(<span class="Type">struct</span> nfa *nfa, <span class="Type">int</span> flag)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s = <a href="#L137" title="regex/regc_nfa.c:137">newstate</a>(nfa);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s-&gt;flag = (<span class="Type">char</span>) flag;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> s;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L226" title="regex/regc_nfa.c:226">dropstate</a> - delete a state's inarcs and outarcs and free it<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L226">&#x200c;</a></span><span class="linkable">dropstate</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((a = s-&gt;ins) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, a);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((a = s-&gt;outs) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, a);<br/></li>
<li>&nbsp; &nbsp; <a href="#L242" title="regex/regc_nfa.c:242">freestate</a>(nfa, s);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L242" title="regex/regc_nfa.c:242">freestate</a> - free a state, which has no in-arcs or out-arcs<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L242">&#x200c;</a></span><span class="linkable">freestate</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; assert(s != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; assert(s-&gt;nins == <span class="Constant">0</span> &amp;&amp; s-&gt;nouts == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s-&gt;no = <a href="../utils/sort/tuplesort.c.html#L402" title="utils/sort/tuplesort.c:402">FREESTATE</a>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;flag = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-&gt;prev = s-&gt;prev;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(s == nfa-&gt;slast);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nfa-&gt;slast = s-&gt;prev;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;prev != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s-&gt;prev-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = s-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(s == nfa-&gt;states);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nfa-&gt;states = s-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; s-&gt;prev = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = nfa-&gt;freestates;&nbsp; &nbsp; <span class="Comment">/* don't delete it, put it on the free list */<br/></li>
<li></span>&nbsp; &nbsp; nfa-&gt;freestates = s;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L281" title="regex/regc_nfa.c:281">newarc</a> - set up a new arc within an NFA<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function checks to make sure that no duplicate arcs are created.<br/></li>
<li></span><span class="Comment"> * In general we never want duplicates.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * However: in principle, a RAINBOW arc is redundant with <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> plain arc<br/></li>
<li></span><span class="Comment"> * (unless that arc is for a <a href="regc_color.c.html#L312" title="regex/regc_color.c:312">pseudocolor</a>).&nbsp; But we don't try to recognize<br/></li>
<li></span><span class="Comment"> * that redundancy, either here or in allied operations such as <a href="#L778" title="regex/regc_nfa.c:778">moveins</a>().<br/></li>
<li></span><span class="Comment"> * The <a href="regc_color.c.html#L312" title="regex/regc_color.c:312">pseudocolor</a> consideration makes that more costly than it seems worth.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L281">&#x200c;</a></span><span class="linkable">newarc</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> t,<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; color co,<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *from,<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *to)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(from != <span class="Constant">NULL</span> &amp;&amp; to != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is a handy place to check for operation cancel during regex<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * compilation, since no code path will go very long without making a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * state or arc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; INTERRUPT(nfa-&gt;v-&gt;re);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check for duplicate arc, using whichever chain is shorter */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (from-&gt;nouts &lt;= to-&gt;nins)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (a = from-&gt;outs; a != <span class="Constant">NULL</span>; a = a-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;to == to &amp;&amp; a-&gt;co == co &amp;&amp; a-&gt;type == t)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (a = to-&gt;ins; a != <span class="Constant">NULL</span>; a = a-&gt;inchain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;from == from &amp;&amp; a-&gt;co == co &amp;&amp; a-&gt;type == t)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no dup, so create the arc */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L323" title="regex/regc_nfa.c:323">createarc</a>(nfa, t, co, from, to);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L323" title="regex/regc_nfa.c:323">createarc</a> - create a new arc within an NFA<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function must *only* be used after verifying that there is no existing<br/></li>
<li></span><span class="Comment"> * identical arc (same type/color/from/to).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L323">&#x200c;</a></span><span class="linkable">createarc</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> t,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; color co,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *from,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *to)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; a = <a href="#L368" title="regex/regc_nfa.c:368">allocarc</a>(nfa);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; assert(a != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; a-&gt;type = t;<br/></li>
<li>&nbsp; &nbsp; a-&gt;co = co;<br/></li>
<li>&nbsp; &nbsp; a-&gt;to = to;<br/></li>
<li>&nbsp; &nbsp; a-&gt;from = from;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Put the new arc on the beginning, not the end, of the chains; it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * simpler here, and <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>() is the same cost either way.&nbsp; See also the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * logic in <a href="#L778" title="regex/regc_nfa.c:778">moveins</a>() and its cohorts, as well as <a href="#L2069" title="regex/regc_nfa.c:2069">fixempties</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; a-&gt;inchain = to-&gt;ins;<br/></li>
<li>&nbsp; &nbsp; a-&gt;inchainRev = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (to-&gt;ins)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; to-&gt;ins-&gt;inchainRev = a;<br/></li>
<li>&nbsp; &nbsp; to-&gt;ins = a;<br/></li>
<li>&nbsp; &nbsp; a-&gt;outchain = from-&gt;outs;<br/></li>
<li>&nbsp; &nbsp; a-&gt;outchainRev = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (from-&gt;outs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; from-&gt;outs-&gt;outchainRev = a;<br/></li>
<li>&nbsp; &nbsp; from-&gt;outs = a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; from-&gt;nouts++;<br/></li>
<li>&nbsp; &nbsp; to-&gt;nins++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="regcomp.c.html#L350" title="regex/regcomp.c:350">COLORED</a>(a) &amp;&amp; nfa-&gt;parent == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_color.c.html#L984" title="regex/regc_color.c:984">colorchain</a>(nfa-&gt;cm, a);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L368" title="regex/regc_nfa.c:368">allocarc</a> - allocate a new arc within an NFA<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">struct</span> arc *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NULL for failure */<br/></li>
<li><a id="L368">&#x200c;</a></span><span class="linkable">allocarc</span>(<span class="Type">struct</span> nfa *nfa)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* first, recycle anything that's on the freelist */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nfa-&gt;freearcs != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a = nfa-&gt;freearcs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nfa-&gt;freearcs = a-&gt;freechain;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* otherwise, is there anything left in the last arcbatch? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (nfa-&gt;lastab != <span class="Constant">NULL</span> &amp;&amp; nfa-&gt;lastabused &lt; nfa-&gt;lastab-&gt;narcs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a = &amp;nfa-&gt;lastab-&gt;a[nfa-&gt;lastabused++];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* otherwise, need to allocate a new arcbatch */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arcbatch *newAb;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; narcs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nfa-&gt;v-&gt;spaceused &gt;= REG_MAX_COMPILE_SPACE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L40" title="regex/regc_nfa.c:40">NERR</a>(REG_ETOOBIG);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; narcs = (nfa-&gt;lastab != <span class="Constant">NULL</span>) ? nfa-&gt;lastab-&gt;narcs * <span class="Constant">2</span> : FIRSTABSIZE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (narcs &gt; MAXABSIZE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; narcs = MAXABSIZE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newAb = (<span class="Type">struct</span> arcbatch *) MALLOC(ARCBATCHSIZE(narcs));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newAb == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L40" title="regex/regc_nfa.c:40">NERR</a>(REG_ESPACE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nfa-&gt;v-&gt;spaceused += ARCBATCHSIZE(narcs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newAb-&gt;narcs = narcs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newAb-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = nfa-&gt;lastab;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nfa-&gt;lastab = newAb;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nfa-&gt;lastabused = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a = &amp;newAb-&gt;a[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> a;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L418" title="regex/regc_nfa.c:418">freearc</a> - free an arc<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L418">&#x200c;</a></span><span class="linkable">freearc</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *victim)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *from = victim-&gt;from;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *to = victim-&gt;to;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *predecessor;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(victim-&gt;type != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* take it off color chain if necessary */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="regcomp.c.html#L350" title="regex/regcomp.c:350">COLORED</a>(victim) &amp;&amp; nfa-&gt;parent == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_color.c.html#L1001" title="regex/regc_color.c:1001">uncolorchain</a>(nfa-&gt;cm, victim);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* take it off source's out-chain */<br/></li>
<li></span>&nbsp; &nbsp; assert(from != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; predecessor = victim-&gt;outchainRev;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (predecessor == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(from-&gt;outs == victim);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; from-&gt;outs = victim-&gt;outchain;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(predecessor-&gt;outchain == victim);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; predecessor-&gt;outchain = victim-&gt;outchain;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (victim-&gt;outchain != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(victim-&gt;outchain-&gt;outchainRev == victim);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; victim-&gt;outchain-&gt;outchainRev = predecessor;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; from-&gt;nouts--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* take it off target's in-chain */<br/></li>
<li></span>&nbsp; &nbsp; assert(to != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; predecessor = victim-&gt;inchainRev;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (predecessor == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(to-&gt;ins == victim);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; to-&gt;ins = victim-&gt;inchain;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(predecessor-&gt;inchain == victim);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; predecessor-&gt;inchain = victim-&gt;inchain;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (victim-&gt;inchain != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(victim-&gt;inchain-&gt;inchainRev == victim);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; victim-&gt;inchain-&gt;inchainRev = predecessor;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; to-&gt;nins--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* clean up and place on NFA's free list */<br/></li>
<li></span>&nbsp; &nbsp; victim-&gt;type = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; victim-&gt;from = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* precautions... */<br/></li>
<li></span>&nbsp; &nbsp; victim-&gt;to = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; victim-&gt;inchain = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; victim-&gt;inchainRev = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; victim-&gt;outchain = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; victim-&gt;outchainRev = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; victim-&gt;freechain = nfa-&gt;freearcs;<br/></li>
<li>&nbsp; &nbsp; nfa-&gt;freearcs = victim;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L489" title="regex/regc_nfa.c:489">changearcsource</a> - flip an arc to have a different from state<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must have verified that there is no pre-existing duplicate arc.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L489">&#x200c;</a></span><span class="linkable">changearcsource</span>(<span class="Type">struct</span> arc *a, <span class="Type">struct</span> state *newfrom)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *oldfrom = a-&gt;from;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *predecessor;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(oldfrom != newfrom);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* take it off old source's out-chain */<br/></li>
<li></span>&nbsp; &nbsp; assert(oldfrom != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; predecessor = a-&gt;outchainRev;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (predecessor == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(oldfrom-&gt;outs == a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldfrom-&gt;outs = a-&gt;outchain;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(predecessor-&gt;outchain == a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; predecessor-&gt;outchain = a-&gt;outchain;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;outchain != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(a-&gt;outchain-&gt;outchainRev == a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a-&gt;outchain-&gt;outchainRev = predecessor;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; oldfrom-&gt;nouts--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; a-&gt;from = newfrom;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* prepend it to new source's out-chain */<br/></li>
<li></span>&nbsp; &nbsp; a-&gt;outchain = newfrom-&gt;outs;<br/></li>
<li>&nbsp; &nbsp; a-&gt;outchainRev = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newfrom-&gt;outs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newfrom-&gt;outs-&gt;outchainRev = a;<br/></li>
<li>&nbsp; &nbsp; newfrom-&gt;outs = a;<br/></li>
<li>&nbsp; &nbsp; newfrom-&gt;nouts++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L533" title="regex/regc_nfa.c:533">changearctarget</a> - flip an arc to have a different to state<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must have verified that there is no pre-existing duplicate arc.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L533">&#x200c;</a></span><span class="linkable">changearctarget</span>(<span class="Type">struct</span> arc *a, <span class="Type">struct</span> state *newto)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *oldto = a-&gt;to;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *predecessor;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(oldto != newto);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* take it off old target's in-chain */<br/></li>
<li></span>&nbsp; &nbsp; assert(oldto != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; predecessor = a-&gt;inchainRev;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (predecessor == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(oldto-&gt;ins == a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldto-&gt;ins = a-&gt;inchain;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(predecessor-&gt;inchain == a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; predecessor-&gt;inchain = a-&gt;inchain;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;inchain != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(a-&gt;inchain-&gt;inchainRev == a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a-&gt;inchain-&gt;inchainRev = predecessor;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; oldto-&gt;nins--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; a-&gt;to = newto;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* prepend it to new target's in-chain */<br/></li>
<li></span>&nbsp; &nbsp; a-&gt;inchain = newto-&gt;ins;<br/></li>
<li>&nbsp; &nbsp; a-&gt;inchainRev = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newto-&gt;ins)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newto-&gt;ins-&gt;inchainRev = a;<br/></li>
<li>&nbsp; &nbsp; newto-&gt;ins = a;<br/></li>
<li>&nbsp; &nbsp; newto-&gt;nins++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L575" title="regex/regc_nfa.c:575">hasnonemptyout</a> - Does state have a non-<a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> out arc?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L575">&#x200c;</a></span><span class="linkable">hasnonemptyout</span>(<span class="Type">struct</span> state *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (a = s-&gt;outs; a != <span class="Constant">NULL</span>; a = a-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;type != <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L592" title="regex/regc_nfa.c:592">findarc</a> - <a href="regexec.c.html#L419" title="regex/regexec.c:419">find</a> arc, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, from given source with given type and color<br/></li>
<li></span><span class="Comment"> * If there is more than one such arc, the result is random.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">struct</span> arc *<br/></li>
<li><a id="L592">&#x200c;</a><span class="linkable">findarc</span>(<span class="Type">struct</span> state *s,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; color co)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (a = s-&gt;outs; a != <span class="Constant">NULL</span>; a = a-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;type == type &amp;&amp; a-&gt;co == co)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> a;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L608" title="regex/regc_nfa.c:608">cparc</a> - allocate a new arc within an NFA, copying details from old one<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L608">&#x200c;</a></span><span class="linkable">cparc</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *oa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *from,<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *to)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L281" title="regex/regc_nfa.c:281">newarc</a>(nfa, oa-&gt;type, oa-&gt;co, from, to);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L620" title="regex/regc_nfa.c:620">sortins</a> - sort the in arcs of a state by from/color/type<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L620">&#x200c;</a></span><span class="linkable">sortins</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc **sortarray;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = s-&gt;nins;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (n &lt;= <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* make an array of arc pointers ... */<br/></li>
<li></span>&nbsp; &nbsp; sortarray = (<span class="Type">struct</span> arc **) MALLOC(n * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> arc *));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sortarray == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L40" title="regex/regc_nfa.c:40">NERR</a>(REG_ESPACE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (a = s-&gt;ins; a != <span class="Constant">NULL</span>; a = a-&gt;inchain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortarray[i++] = a;<br/></li>
<li>&nbsp; &nbsp; assert(i == n);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... sort the array */<br/></li>
<li></span>&nbsp; &nbsp; qsort(sortarray, n, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> arc *), <a href="#L662" title="regex/regc_nfa.c:662">sortins_cmp</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... and rebuild arc list in order */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* it seems worth special-casing first and last items to simplify loop */<br/></li>
<li></span>&nbsp; &nbsp; a = sortarray[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; s-&gt;ins = a;<br/></li>
<li>&nbsp; &nbsp; a-&gt;inchain = sortarray[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; a-&gt;inchainRev = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; n - <span class="Constant">1</span>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a = sortarray[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a-&gt;inchain = sortarray[i + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a-&gt;inchainRev = sortarray[i - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; a = sortarray[i];<br/></li>
<li>&nbsp; &nbsp; a-&gt;inchain = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; a-&gt;inchainRev = sortarray[i - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; FREE(sortarray);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L662">&#x200c;</a></span><span class="linkable">sortins_cmp</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">struct</span> arc *aa = *((<span class="Type">const</span> <span class="Type">struct</span> arc *<span class="Type">const</span> *) a);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">struct</span> arc *bb = *((<span class="Type">const</span> <span class="Type">struct</span> arc *<span class="Type">const</span> *) b);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we check the fields in the order they are most likely to be different */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (aa-&gt;from-&gt;no &lt; bb-&gt;from-&gt;no)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aa-&gt;from-&gt;no &gt; bb-&gt;from-&gt;no)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aa-&gt;co &lt; bb-&gt;co)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aa-&gt;co &gt; bb-&gt;co)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aa-&gt;type &lt; bb-&gt;type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aa-&gt;type &gt; bb-&gt;type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L687" title="regex/regc_nfa.c:687">sortouts</a> - sort the out arcs of a state by to/color/type<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L687">&#x200c;</a></span><span class="linkable">sortouts</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc **sortarray;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = s-&gt;nouts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (n &lt;= <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* make an array of arc pointers ... */<br/></li>
<li></span>&nbsp; &nbsp; sortarray = (<span class="Type">struct</span> arc **) MALLOC(n * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> arc *));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sortarray == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L40" title="regex/regc_nfa.c:40">NERR</a>(REG_ESPACE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (a = s-&gt;outs; a != <span class="Constant">NULL</span>; a = a-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortarray[i++] = a;<br/></li>
<li>&nbsp; &nbsp; assert(i == n);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... sort the array */<br/></li>
<li></span>&nbsp; &nbsp; qsort(sortarray, n, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> arc *), <a href="#L729" title="regex/regc_nfa.c:729">sortouts_cmp</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... and rebuild arc list in order */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* it seems worth special-casing first and last items to simplify loop */<br/></li>
<li></span>&nbsp; &nbsp; a = sortarray[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; s-&gt;outs = a;<br/></li>
<li>&nbsp; &nbsp; a-&gt;outchain = sortarray[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; a-&gt;outchainRev = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; n - <span class="Constant">1</span>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a = sortarray[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a-&gt;outchain = sortarray[i + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a-&gt;outchainRev = sortarray[i - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; a = sortarray[i];<br/></li>
<li>&nbsp; &nbsp; a-&gt;outchain = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; a-&gt;outchainRev = sortarray[i - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; FREE(sortarray);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L729">&#x200c;</a></span><span class="linkable">sortouts_cmp</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">struct</span> arc *aa = *((<span class="Type">const</span> <span class="Type">struct</span> arc *<span class="Type">const</span> *) a);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">struct</span> arc *bb = *((<span class="Type">const</span> <span class="Type">struct</span> arc *<span class="Type">const</span> *) b);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we check the fields in the order they are most likely to be different */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (aa-&gt;to-&gt;no &lt; bb-&gt;to-&gt;no)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aa-&gt;to-&gt;no &gt; bb-&gt;to-&gt;no)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aa-&gt;co &lt; bb-&gt;co)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aa-&gt;co &gt; bb-&gt;co)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aa-&gt;type &lt; bb-&gt;type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aa-&gt;type &gt; bb-&gt;type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Common decision logic about whether to use arc-by-arc operations or<br/></li>
<li></span><span class="Comment"> * sort/<a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>.&nbsp; If there's just a few source arcs we cannot recoup the<br/></li>
<li></span><span class="Comment"> * cost of sorting the destination arc list, no matter how large it is.<br/></li>
<li></span><span class="Comment"> * Otherwise, limit the number of arc-by-arc comparisons to about 1000<br/></li>
<li></span><span class="Comment"> * (a somewhat arbitrary choice, but the breakeven point would probably<br/></li>
<li></span><span class="Comment"> * be machine dependent anyway).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L758">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BULK_ARC_OP_USE_SORT</span>(nsrcarcs, ndestarcs) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((nsrcarcs) &lt; </span><span class="Constant">4</span><span class="PreProc"> ? </span><span class="Constant">0</span><span class="PreProc"> : ((nsrcarcs) &gt; </span><span class="Constant">32</span><span class="PreProc"> || (ndestarcs) &gt; </span><span class="Constant">32</span><span class="PreProc">))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L778" title="regex/regc_nfa.c:778">moveins</a> - move all in arcs of a state to another state<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * You might think this could be done better by just updating the<br/></li>
<li></span><span class="Comment"> * existing arcs, and you would be right if it weren't for the need<br/></li>
<li></span><span class="Comment"> * for duplicate suppression, which makes it easier to just make new<br/></li>
<li></span><span class="Comment"> * ones to exploit the suppression built into <a href="#L281" title="regex/regc_nfa.c:281">newarc</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * However, if we have a whole lot of arcs to deal with, retail duplicate<br/></li>
<li></span><span class="Comment"> * checks become too slow.&nbsp; In that case we proceed by sorting and merging<br/></li>
<li></span><span class="Comment"> * the arc lists, and then we can indeed just update the arcs in-place.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On the other hand, it's also true that this is frequently called with<br/></li>
<li></span><span class="Comment"> * a brand-new newState that has no existing in-arcs.&nbsp; In that case,<br/></li>
<li></span><span class="Comment"> * de-duplication is unnecessary, so we can just blindly move all the arcs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L778">&#x200c;</a></span><span class="linkable">moveins</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *oldState,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *newState)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; assert(oldState != newState);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newState-&gt;nins == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No need for de-duplication */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((a = oldState-&gt;ins) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="regex/regc_nfa.c:323">createarc</a>(nfa, a-&gt;type, a-&gt;co, a-&gt;from, newState);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="#L758" title="regex/regc_nfa.c:758">BULK_ARC_OP_USE_SORT</a>(oldState-&gt;nins, newState-&gt;nins))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* With not too many arcs, just do them one at a time */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((a = oldState-&gt;ins) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L608" title="regex/regc_nfa.c:608">cparc</a>(nfa, a, a-&gt;from, newState);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * With many arcs, use a sort-<a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> approach.&nbsp; Note <a href="#L533" title="regex/regc_nfa.c:533">changearctarget</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will put the arc onto the front of newState's chain, so it does not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * break our walk through the sorted part of the chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *oa;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *na;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Because we bypass <a href="#L281" title="regex/regc_nfa.c:281">newarc</a>() in this code path, we'd better include a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cancel check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; INTERRUPT(nfa-&gt;v-&gt;re);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L620" title="regex/regc_nfa.c:620">sortins</a>(nfa, oldState);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L620" title="regex/regc_nfa.c:620">sortins</a>(nfa, newState);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* might have failed to sort */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oa = oldState-&gt;ins;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; na = newState-&gt;ins;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (oa != <span class="Constant">NULL</span> &amp;&amp; na != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *a = oa;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L662" title="regex/regc_nfa.c:662">sortins_cmp</a>(&amp;oa, &amp;na))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> -<span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* newState does not have anything matching oa */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oa = oa-&gt;inchain;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Rather than doing <a href="#L323" title="regex/regc_nfa.c:323">createarc</a>+<a href="#L418" title="regex/regc_nfa.c:418">freearc</a>, we can just unlink<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and relink the existing arc struct.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L533" title="regex/regc_nfa.c:533">changearctarget</a>(a, newState);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">0</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* match, advance in both lists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oa = oa-&gt;inchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; na = na-&gt;inchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and drop duplicate arc from oldState */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> +<span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* advance only na; oa might have a match later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; na = na-&gt;inchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(NOTREACHED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (oa != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* newState does not have anything matching oa */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *a = oa;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oa = oa-&gt;inchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L533" title="regex/regc_nfa.c:533">changearctarget</a>(a, newState);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(oldState-&gt;nins == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; assert(oldState-&gt;ins == <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L882" title="regex/regc_nfa.c:882">copyins</a> - copy in arcs of a state to another state<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The comments for <a href="#L778" title="regex/regc_nfa.c:778">moveins</a>() apply here as well.&nbsp; However, in current<br/></li>
<li></span><span class="Comment"> * usage, this is *only* called with brand-new target states, so that<br/></li>
<li></span><span class="Comment"> * only the &quot;no need for de-duplication&quot; code path is ever reached.<br/></li>
<li></span><span class="Comment"> * We keep the rest #ifdef'd out in case it's needed in the future.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L882">&#x200c;</a></span><span class="linkable">copyins</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *oldState,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *newState)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; assert(oldState != newState);<br/></li>
<li>&nbsp; &nbsp; assert(newState-&gt;nins == <span class="Constant">0</span>);&nbsp; &nbsp; <span class="Comment">/* see comment above */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newState-&gt;nins == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No need for de-duplication */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (a = oldState-&gt;ins; a != <span class="Constant">NULL</span>; a = a-&gt;inchain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="regex/regc_nfa.c:323">createarc</a>(nfa, a-&gt;type, a-&gt;co, a-&gt;from, newState);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#ifdef NOT_USED&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* see comment above */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="#L758" title="regex/regc_nfa.c:758">BULK_ARC_OP_USE_SORT</a>(oldState-&gt;nins, newState-&gt;nins))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* With not too many arcs, just do them one at a time */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (a = oldState-&gt;ins; a != <span class="Constant">NULL</span>; a = a-&gt;inchain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L608" title="regex/regc_nfa.c:608">cparc</a>(nfa, a, a-&gt;from, newState);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * With many arcs, use a sort-<a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> approach.&nbsp; Note that <a href="#L323" title="regex/regc_nfa.c:323">createarc</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will put new arcs onto the front of newState's chain, so it does<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not break our walk through the sorted part of the chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *oa;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *na;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Because we bypass <a href="#L281" title="regex/regc_nfa.c:281">newarc</a>() in this code path, we'd better include a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cancel check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; INTERRUPT(nfa-&gt;v-&gt;re);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L620" title="regex/regc_nfa.c:620">sortins</a>(nfa, oldState);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L620" title="regex/regc_nfa.c:620">sortins</a>(nfa, newState);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* might have failed to sort */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oa = oldState-&gt;ins;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; na = newState-&gt;ins;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (oa != <span class="Constant">NULL</span> &amp;&amp; na != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *a = oa;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L662" title="regex/regc_nfa.c:662">sortins_cmp</a>(&amp;oa, &amp;na))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> -<span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* newState does not have anything matching oa */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oa = oa-&gt;inchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="regex/regc_nfa.c:323">createarc</a>(nfa, a-&gt;type, a-&gt;co, a-&gt;from, newState);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">0</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* match, advance in both lists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oa = oa-&gt;inchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; na = na-&gt;inchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> +<span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* advance only na; oa might have a match later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; na = na-&gt;inchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(NOTREACHED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (oa != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* newState does not have anything matching oa */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *a = oa;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oa = oa-&gt;inchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="regex/regc_nfa.c:323">createarc</a>(nfa, a-&gt;type, a-&gt;co, a-&gt;from, newState);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NOT_USED */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L971" title="regex/regc_nfa.c:971">mergeins</a> - <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> a list of inarcs into a state<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is much like <a href="#L882" title="regex/regc_nfa.c:882">copyins</a>, but the source arcs are listed in an array,<br/></li>
<li></span><span class="Comment"> * and are not guaranteed unique.&nbsp; It's okay to clobber the array contents.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L971">&#x200c;</a></span><span class="linkable">mergeins</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *s,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> arc **arcarray,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> arccount)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *na;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arccount &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Because we bypass <a href="#L281" title="regex/regc_nfa.c:281">newarc</a>() in this code path, we'd better include a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cancel check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; INTERRUPT(nfa-&gt;v-&gt;re);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort existing inarcs as well as proposed new ones */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L620" title="regex/regc_nfa.c:620">sortins</a>(nfa, s);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* might have failed to sort */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; qsort(arcarray, arccount, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> arc *), <a href="#L662" title="regex/regc_nfa.c:662">sortins_cmp</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * arcarray very likely includes dups, so we must eliminate them.&nbsp; (This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * could be folded into the <a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> loop, but it's not worth the trouble.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; j = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; arccount; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L662" title="regex/regc_nfa.c:662">sortins_cmp</a>(&amp;arcarray[j], &amp;arcarray[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> -<span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* non-dup */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arcarray[++j] = arcarray[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">0</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dup */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* trouble */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(NOTREACHED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; arccount = j + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> into s' inchain.&nbsp; Note that <a href="#L323" title="regex/regc_nfa.c:323">createarc</a>() will put new arcs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * onto the front of s's chain, so it does not break our walk through the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sorted part of the chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; na = s-&gt;ins;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (i &lt; arccount &amp;&amp; na != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *a = arcarray[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L662" title="regex/regc_nfa.c:662">sortins_cmp</a>(&amp;a, &amp;na))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> -<span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* s does not have anything matching a */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="regex/regc_nfa.c:323">createarc</a>(nfa, a-&gt;type, a-&gt;co, a-&gt;from, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">0</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* match, advance in both lists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; na = na-&gt;inchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> +<span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* advance only na; array might have a match later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; na = na-&gt;inchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(NOTREACHED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (i &lt; arccount)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* s does not have anything matching a */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *a = arcarray[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="regex/regc_nfa.c:323">createarc</a>(nfa, a-&gt;type, a-&gt;co, a-&gt;from, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1066" title="regex/regc_nfa.c:1066">moveouts</a> - move all out arcs of a state to another state<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See comments for <a href="#L778" title="regex/regc_nfa.c:778">moveins</a>()<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1066">&#x200c;</a></span><span class="linkable">moveouts</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *oldState,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *newState)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; assert(oldState != newState);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newState-&gt;nouts == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No need for de-duplication */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((a = oldState-&gt;outs) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="regex/regc_nfa.c:323">createarc</a>(nfa, a-&gt;type, a-&gt;co, newState, a-&gt;to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="#L758" title="regex/regc_nfa.c:758">BULK_ARC_OP_USE_SORT</a>(oldState-&gt;nouts, newState-&gt;nouts))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* With not too many arcs, just do them one at a time */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((a = oldState-&gt;outs) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L608" title="regex/regc_nfa.c:608">cparc</a>(nfa, a, newState, a-&gt;to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * With many arcs, use a sort-<a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> approach.&nbsp; Note <a href="#L489" title="regex/regc_nfa.c:489">changearcsource</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will put the arc onto the front of newState's chain, so it does not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * break our walk through the sorted part of the chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *oa;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *na;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Because we bypass <a href="#L281" title="regex/regc_nfa.c:281">newarc</a>() in this code path, we'd better include a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cancel check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; INTERRUPT(nfa-&gt;v-&gt;re);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L687" title="regex/regc_nfa.c:687">sortouts</a>(nfa, oldState);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L687" title="regex/regc_nfa.c:687">sortouts</a>(nfa, newState);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* might have failed to sort */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oa = oldState-&gt;outs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; na = newState-&gt;outs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (oa != <span class="Constant">NULL</span> &amp;&amp; na != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *a = oa;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L729" title="regex/regc_nfa.c:729">sortouts_cmp</a>(&amp;oa, &amp;na))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> -<span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* newState does not have anything matching oa */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oa = oa-&gt;outchain;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Rather than doing <a href="#L323" title="regex/regc_nfa.c:323">createarc</a>+<a href="#L418" title="regex/regc_nfa.c:418">freearc</a>, we can just unlink<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and relink the existing arc struct.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L489" title="regex/regc_nfa.c:489">changearcsource</a>(a, newState);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">0</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* match, advance in both lists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oa = oa-&gt;outchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; na = na-&gt;outchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and drop duplicate arc from oldState */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> +<span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* advance only na; oa might have a match later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; na = na-&gt;outchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(NOTREACHED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (oa != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* newState does not have anything matching oa */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *a = oa;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oa = oa-&gt;outchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L489" title="regex/regc_nfa.c:489">changearcsource</a>(a, newState);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(oldState-&gt;nouts == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; assert(oldState-&gt;outs == <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1167" title="regex/regc_nfa.c:1167">copyouts</a> - copy out arcs of a state to another state<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See comments for <a href="#L882" title="regex/regc_nfa.c:882">copyins</a>()<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1167">&#x200c;</a></span><span class="linkable">copyouts</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *oldState,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *newState)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; assert(oldState != newState);<br/></li>
<li>&nbsp; &nbsp; assert(newState-&gt;nouts == <span class="Constant">0</span>);&nbsp; &nbsp; <span class="Comment">/* see comment above */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newState-&gt;nouts == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No need for de-duplication */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (a = oldState-&gt;outs; a != <span class="Constant">NULL</span>; a = a-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="regex/regc_nfa.c:323">createarc</a>(nfa, a-&gt;type, a-&gt;co, newState, a-&gt;to);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#ifdef NOT_USED&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* see comment above */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="#L758" title="regex/regc_nfa.c:758">BULK_ARC_OP_USE_SORT</a>(oldState-&gt;nouts, newState-&gt;nouts))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* With not too many arcs, just do them one at a time */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (a = oldState-&gt;outs; a != <span class="Constant">NULL</span>; a = a-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L608" title="regex/regc_nfa.c:608">cparc</a>(nfa, a, newState, a-&gt;to);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * With many arcs, use a sort-<a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> approach.&nbsp; Note that <a href="#L323" title="regex/regc_nfa.c:323">createarc</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will put new arcs onto the front of newState's chain, so it does<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not break our walk through the sorted part of the chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *oa;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *na;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Because we bypass <a href="#L281" title="regex/regc_nfa.c:281">newarc</a>() in this code path, we'd better include a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cancel check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; INTERRUPT(nfa-&gt;v-&gt;re);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L687" title="regex/regc_nfa.c:687">sortouts</a>(nfa, oldState);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L687" title="regex/regc_nfa.c:687">sortouts</a>(nfa, newState);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* might have failed to sort */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oa = oldState-&gt;outs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; na = newState-&gt;outs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (oa != <span class="Constant">NULL</span> &amp;&amp; na != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *a = oa;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L729" title="regex/regc_nfa.c:729">sortouts_cmp</a>(&amp;oa, &amp;na))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> -<span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* newState does not have anything matching oa */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oa = oa-&gt;outchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="regex/regc_nfa.c:323">createarc</a>(nfa, a-&gt;type, a-&gt;co, newState, a-&gt;to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">0</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* match, advance in both lists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oa = oa-&gt;outchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; na = na-&gt;outchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> +<span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* advance only na; oa might have a match later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; na = na-&gt;outchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(NOTREACHED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (oa != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* newState does not have anything matching oa */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *a = oa;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oa = oa-&gt;outchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="regex/regc_nfa.c:323">createarc</a>(nfa, a-&gt;type, a-&gt;co, newState, a-&gt;to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NOT_USED */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1256" title="regex/regc_nfa.c:1256">cloneouts</a> - copy out arcs of a state to another state pair, modifying type<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is only used to convert <a href="regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a> arcs to <a href="regcomp.c.html#L341" title="regex/regcomp.c:341">AHEAD</a>/<a href="regcomp.c.html#L342" title="regex/regcomp.c:342">BEHIND</a> arcs, which share<br/></li>
<li></span><span class="Comment"> * the same interpretation of &quot;co&quot;.&nbsp; It wouldn't be sensible with LACONs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1256">&#x200c;</a></span><span class="linkable">cloneouts</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *old,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *from,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *to,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> type)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(old != from);<br/></li>
<li>&nbsp; &nbsp; assert(type == <a href="regcomp.c.html#L341" title="regex/regcomp.c:341">AHEAD</a> || type == <a href="regcomp.c.html#L342" title="regex/regcomp.c:342">BEHIND</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (a = old-&gt;outs; a != <span class="Constant">NULL</span>; a = a-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(a-&gt;type == <a href="regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L281" title="regex/regc_nfa.c:281">newarc</a>(nfa, type, a-&gt;co, from, to);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1281" title="regex/regc_nfa.c:1281">delsub</a> - delete a sub-NFA, updating <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> pointers if necessary<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This uses a recursive traversal of the sub-NFA, marking already-seen<br/></li>
<li></span><span class="Comment"> * states using their tmp pointer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1281">&#x200c;</a></span><span class="linkable">delsub</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *lp,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the sub-NFA goes from here... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *rp)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ...to here, *not* inclusive */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; assert(lp != rp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rp-&gt;tmp = rp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mark end */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L1304" title="regex/regc_nfa.c:1304">deltraverse</a>(nfa, lp, lp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* asserts might not hold after failure */<br/></li>
<li></span>&nbsp; &nbsp; assert(lp-&gt;nouts == <span class="Constant">0</span> &amp;&amp; rp-&gt;nins == <span class="Constant">0</span>);&nbsp; &nbsp; <span class="Comment">/* did the job */<br/></li>
<li></span>&nbsp; &nbsp; assert(lp-&gt;no != <a href="../utils/sort/tuplesort.c.html#L402" title="utils/sort/tuplesort.c:402">FREESTATE</a> &amp;&amp; rp-&gt;no != <a href="../utils/sort/tuplesort.c.html#L402" title="utils/sort/tuplesort.c:402">FREESTATE</a>); <span class="Comment">/* no more */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; rp-&gt;tmp = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* unmark end */<br/></li>
<li></span>&nbsp; &nbsp; lp-&gt;tmp = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and begin, marked by <a href="#L1304" title="regex/regc_nfa.c:1304">deltraverse</a> */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1304" title="regex/regc_nfa.c:1304">deltraverse</a> - the recursive heart of <a href="#L1281" title="regex/regc_nfa.c:1281">delsub</a><br/></li>
<li></span><span class="Comment"> * This routine's basic job is to destroy all out-arcs of the state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1304">&#x200c;</a></span><span class="linkable">deltraverse</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *leftend,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *to;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Since this is recursive, it could be driven to stack overflow */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (STACK_TOO_DEEP(nfa-&gt;v-&gt;re))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L40" title="regex/regc_nfa.c:40">NERR</a>(REG_ETOOBIG);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;nouts == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;tmp != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* already in progress */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; s-&gt;tmp = s;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mark as in progress */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((a = s-&gt;outs) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; to = a-&gt;to;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1304" title="regex/regc_nfa.c:1304">deltraverse</a>(nfa, leftend, to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* asserts might not hold after failure */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; assert(to-&gt;nouts == <span class="Constant">0</span> || to-&gt;tmp != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (to-&gt;nins == <span class="Constant">0</span> &amp;&amp; to-&gt;tmp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(to-&gt;nouts == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L242" title="regex/regc_nfa.c:242">freestate</a>(nfa, to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(s-&gt;no != <a href="../utils/sort/tuplesort.c.html#L402" title="utils/sort/tuplesort.c:402">FREESTATE</a>); <span class="Comment">/* we're still here */<br/></li>
<li></span>&nbsp; &nbsp; assert(s == leftend || s-&gt;nins != <span class="Constant">0</span>);&nbsp; &nbsp; <span class="Comment">/* and still reachable */<br/></li>
<li></span>&nbsp; &nbsp; assert(s-&gt;nouts == <span class="Constant">0</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* but have no outarcs */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; s-&gt;tmp = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we're done here */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1355" title="regex/regc_nfa.c:1355">dupnfa</a> - duplicate sub-NFA<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Another recursive traversal, this time using tmp to point to duplicates<br/></li>
<li></span><span class="Comment"> * as well as mark already-seen states.&nbsp; (You knew there was a reason why<br/></li>
<li></span><span class="Comment"> * it's a state pointer, didn't you? :-))<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1355">&#x200c;</a></span><span class="linkable">dupnfa</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *start,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* duplicate of subNFA starting here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *stop,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and stopping here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *from,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* stringing duplicate from here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *to)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* to here */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (start == stop)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L281" title="regex/regc_nfa.c:281">newarc</a>(nfa, <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a>, <span class="Constant">0</span>, from, to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stop-&gt;tmp = to;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1379" title="regex/regc_nfa.c:1379">duptraverse</a>(nfa, start, from);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* done, except for clearing out the tmp pointers */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; stop-&gt;tmp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1487" title="regex/regc_nfa.c:1487">cleartraverse</a>(nfa, start);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1379" title="regex/regc_nfa.c:1379">duptraverse</a> - recursive heart of <a href="#L1355" title="regex/regc_nfa.c:1355">dupnfa</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1379">&#x200c;</a></span><span class="linkable">duptraverse</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *s,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *stmp) <span class="Comment">/* s's duplicate, or NULL */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Since this is recursive, it could be driven to stack overflow */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (STACK_TOO_DEEP(nfa-&gt;v-&gt;re))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L40" title="regex/regc_nfa.c:40">NERR</a>(REG_ETOOBIG);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;tmp != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* already done */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; s-&gt;tmp = (stmp == <span class="Constant">NULL</span>) ? <a href="#L137" title="regex/regc_nfa.c:137">newstate</a>(nfa) : stmp;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;tmp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (a = s-&gt;outs; a != <span class="Constant">NULL</span> &amp;&amp; !<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>(); a = a-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1379" title="regex/regc_nfa.c:1379">duptraverse</a>(nfa, a-&gt;to, (<span class="Type">struct</span> state *) <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(a-&gt;to-&gt;tmp != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L608" title="regex/regc_nfa.c:608">cparc</a>(nfa, a, s-&gt;tmp, a-&gt;to-&gt;tmp);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1419" title="regex/regc_nfa.c:1419">removeconstraints</a> - remove <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> constraints in an NFA<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Constraint arcs are replaced by empty arcs, essentially treating all<br/></li>
<li></span><span class="Comment"> * constraints as automatically satisfied.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1419">&#x200c;</a></span><span class="linkable">removeconstraints</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *start,&nbsp; &nbsp; <span class="Comment">/* process subNFA starting here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *stop)&nbsp; &nbsp; <span class="Comment">/* and stopping here */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (start == stop)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stop-&gt;tmp = stop;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1438" title="regex/regc_nfa.c:1438">removetraverse</a>(nfa, start);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* done, except for clearing out the tmp pointers */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; stop-&gt;tmp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1487" title="regex/regc_nfa.c:1487">cleartraverse</a>(nfa, start);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1438" title="regex/regc_nfa.c:1438">removetraverse</a> - recursive heart of <a href="#L1419" title="regex/regc_nfa.c:1419">removeconstraints</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1438">&#x200c;</a></span><span class="linkable">removetraverse</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *oa;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Since this is recursive, it could be driven to stack overflow */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (STACK_TOO_DEEP(nfa-&gt;v-&gt;re))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L40" title="regex/regc_nfa.c:40">NERR</a>(REG_ETOOBIG);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;tmp != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* already done */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; s-&gt;tmp = s;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (a = s-&gt;outs; a != <span class="Constant">NULL</span> &amp;&amp; !<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>(); a = oa)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1438" title="regex/regc_nfa.c:1438">removetraverse</a>(nfa, a-&gt;to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oa = a-&gt;outchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (a-&gt;type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="regcomp.c.html#L341" title="regex/regcomp.c:341">AHEAD</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="regcomp.c.html#L342" title="regex/regcomp.c:342">BEHIND</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'^'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'$'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="regcomp.c.html#L340" title="regex/regcomp.c:340">LACON</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* replace it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L281" title="regex/regc_nfa.c:281">newarc</a>(nfa, <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a>, <span class="Constant">0</span>, s, a-&gt;to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L40" title="regex/regc_nfa.c:40">NERR</a>(REG_ASSERT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1487" title="regex/regc_nfa.c:1487">cleartraverse</a> - recursive <a href="#L2929" title="regex/regc_nfa.c:2929">cleanup</a> for algorithms that leave tmp ptrs set<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1487">&#x200c;</a></span><span class="linkable">cleartraverse</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Since this is recursive, it could be driven to stack overflow */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (STACK_TOO_DEEP(nfa-&gt;v-&gt;re))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L40" title="regex/regc_nfa.c:40">NERR</a>(REG_ETOOBIG);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;tmp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;tmp = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (a = s-&gt;outs; a != <span class="Constant">NULL</span>; a = a-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1487" title="regex/regc_nfa.c:1487">cleartraverse</a>(nfa, a-&gt;to);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1524" title="regex/regc_nfa.c:1524">single_color_transition</a> - does getting from s1 to s2 cross one <a href="regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a> arc?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If traversing from s1 to s2 requires a single <a href="regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a> match (possibly of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * of a set of colors), return a state whose outarc list contains only <a href="regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a><br/></li>
<li></span><span class="Comment"> * arcs of those color(s).&nbsp; Otherwise return NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used <a href="regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> optimizing the NFA, so there may be <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> arcs, which<br/></li>
<li></span><span class="Comment"> * we should ignore; the possibility of an <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> is why the result state could<br/></li>
<li></span><span class="Comment"> * be different from s1.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It's worth troubling to handle multiple parallel <a href="regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a> arcs here because a<br/></li>
<li></span><span class="Comment"> * <a href="regcomp.c.html#L1671" title="regex/regcomp.c:1671">bracket</a> construct such as [abc] might yield either one or several parallel<br/></li>
<li></span><span class="Comment"> * <a href="regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a> arcs depending on earlier atoms in the expression.&nbsp; We'd rather that<br/></li>
<li></span><span class="Comment"> * that implementation detail not create user-visible performance differences.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">struct</span> state *<br/></li>
<li><a id="L1524">&#x200c;</a><span class="linkable">single_color_transition</span>(<span class="Type">struct</span> state *s1, <span class="Type">struct</span> state *s2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ignore leading <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> arc, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (s1-&gt;nouts == <span class="Constant">1</span> &amp;&amp; s1-&gt;outs-&gt;type == <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s1 = s1-&gt;outs-&gt;to;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Likewise for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> trailing <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> arc */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (s2-&gt;nins == <span class="Constant">1</span> &amp;&amp; s2-&gt;ins-&gt;type == <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s2 = s2-&gt;ins-&gt;from;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Perhaps we could have a single-state loop in between, if so reject */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (s1 == s2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* s1 must have at least one outarc... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (s1-&gt;outs == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... and they must all be <a href="regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a> arcs to s2 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (a = s1-&gt;outs; a != <span class="Constant">NULL</span>; a = a-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;type != <a href="regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a> || a-&gt;to != s2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, return s1 as the possessor of the relevant outarcs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> s1;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1554" title="regex/regc_nfa.c:1554">specialcolors</a> - fill in special colors for an NFA<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1554">&#x200c;</a></span><span class="linkable">specialcolors</span>(<span class="Type">struct</span> nfa *nfa)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* false colors for BOS, BOL, <a href="regcomp.c.html#L329" title="regex/regcomp.c:329">EOS</a>, EOL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nfa-&gt;parent == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nfa-&gt;bos[<span class="Constant">0</span>] = <a href="regc_color.c.html#L312" title="regex/regc_color.c:312">pseudocolor</a>(nfa-&gt;cm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nfa-&gt;bos[<span class="Constant">1</span>] = <a href="regc_color.c.html#L312" title="regex/regc_color.c:312">pseudocolor</a>(nfa-&gt;cm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nfa-&gt;eos[<span class="Constant">0</span>] = <a href="regc_color.c.html#L312" title="regex/regc_color.c:312">pseudocolor</a>(nfa-&gt;cm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nfa-&gt;eos[<span class="Constant">1</span>] = <a href="regc_color.c.html#L312" title="regex/regc_color.c:312">pseudocolor</a>(nfa-&gt;cm);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(nfa-&gt;parent-&gt;bos[<span class="Constant">0</span>] != COLORLESS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nfa-&gt;bos[<span class="Constant">0</span>] = nfa-&gt;parent-&gt;bos[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(nfa-&gt;parent-&gt;bos[<span class="Constant">1</span>] != COLORLESS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nfa-&gt;bos[<span class="Constant">1</span>] = nfa-&gt;parent-&gt;bos[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(nfa-&gt;parent-&gt;eos[<span class="Constant">0</span>] != COLORLESS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nfa-&gt;eos[<span class="Constant">0</span>] = nfa-&gt;parent-&gt;eos[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(nfa-&gt;parent-&gt;eos[<span class="Constant">1</span>] != COLORLESS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nfa-&gt;eos[<span class="Constant">1</span>] = nfa-&gt;parent-&gt;eos[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1593" title="regex/regc_nfa.c:1593">optimize</a> - <a href="#L1593" title="regex/regc_nfa.c:1593">optimize</a> an NFA<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> goal of this function is not so much &quot;optimization&quot; (though it<br/></li>
<li></span><span class="Comment"> * does try to get rid of useless NFA states) as reducing the NFA to a form<br/></li>
<li></span><span class="Comment"> * the regex executor can handle.&nbsp; The executor, and indeed the cNFA format<br/></li>
<li></span><span class="Comment"> * that is its input, can only handle <a href="regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a> and <a href="regcomp.c.html#L340" title="regex/regcomp.c:340">LACON</a> arcs.&nbsp; The output of<br/></li>
<li></span><span class="Comment"> * the regex parser also includes <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> (do-nothing) arcs, as well as<br/></li>
<li></span><span class="Comment"> * ^, $, <a href="regcomp.c.html#L341" title="regex/regcomp.c:341">AHEAD</a>, and <a href="regcomp.c.html#L342" title="regex/regcomp.c:342">BEHIND</a> constraint arcs, which we must get rid of here.<br/></li>
<li></span><span class="Comment"> * We first get rid of <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> arcs and then deal with the constraint arcs.<br/></li>
<li></span><span class="Comment"> * The hardest part of either job is to get rid of circular loops of the<br/></li>
<li></span><span class="Comment"> * target arc type.&nbsp; We would have to do that in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, though, as such a<br/></li>
<li></span><span class="Comment"> * loop would otherwise allow the executor to cycle through the loop endlessly<br/></li>
<li></span><span class="Comment"> * without making <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> progress in the input string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* re_info bits */<br/></li>
<li><a id="L1593">&#x200c;</a></span><span class="linkable">optimize</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">FILE</span> *f)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for debug output; NULL <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> */<br/></li>
<li></span>{<br/></li>
<li><span class="PreProc">#ifdef REG_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; verbose = (f != <span class="Constant">NULL</span>) ? <span class="Constant">1</span> : <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (verbose)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">initial <a href="#L2929" title="regex/regc_nfa.c:2929">cleanup</a>:</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2929" title="regex/regc_nfa.c:2929">cleanup</a>(nfa);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* may simplify situation */<br/></li>
<li></span><span class="PreProc">#ifdef REG_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (verbose)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3611" title="regex/regc_nfa.c:3611">dumpnfa</a>(nfa, f);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (verbose)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">empties:</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2069" title="regex/regc_nfa.c:2069">fixempties</a>(nfa, f);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* get rid of <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> arcs */<br/></li>
<li></span><span class="PreProc">#ifdef REG_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (verbose)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">constraints:</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2363" title="regex/regc_nfa.c:2363">fixconstraintloops</a>(nfa, f); <span class="Comment">/* get rid of constraint loops */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1633" title="regex/regc_nfa.c:1633">pullback</a>(nfa, f);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L1713" title="regex/regc_nfa.c:1713">pull</a> back constraints backward */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1804" title="regex/regc_nfa.c:1804">pushfwd</a>(nfa, f);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L1884" title="regex/regc_nfa.c:1884">push</a> fwd constraints forward */<br/></li>
<li></span><span class="PreProc">#ifdef REG_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (verbose)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">final <a href="#L2929" title="regex/regc_nfa.c:2929">cleanup</a>:</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2929" title="regex/regc_nfa.c:2929">cleanup</a>(nfa);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* final tidying */<br/></li>
<li></span><span class="PreProc">#ifdef REG_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (verbose)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3611" title="regex/regc_nfa.c:3611">dumpnfa</a>(nfa, f);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3016" title="regex/regc_nfa.c:3016">analyze</a>(nfa);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and analysis */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1633" title="regex/regc_nfa.c:1633">pullback</a> - <a href="#L1713" title="regex/regc_nfa.c:1713">pull</a> back constraints backward to eliminate them<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1633">&#x200c;</a></span><span class="linkable">pullback</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">FILE</span> *f)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for debug output; NULL <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *s;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *nexts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *nexta;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *intermediates;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; progress;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="regexec.c.html#L419" title="regex/regexec.c:419">find</a> and <a href="#L1713" title="regex/regc_nfa.c:1713">pull</a> until there are no more */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; progress = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (s = nfa-&gt;states; s != <span class="Constant">NULL</span> &amp;&amp; !<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>(); s = nexts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nexts = s-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intermediates = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (a = s-&gt;outs; a != <span class="Constant">NULL</span> &amp;&amp; !<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>(); a = nexta)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nexta = a-&gt;outchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;type == <span class="Constant">'^'</span> || a-&gt;type == <a href="regcomp.c.html#L342" title="regex/regcomp.c:342">BEHIND</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1713" title="regex/regc_nfa.c:1713">pull</a>(nfa, a, &amp;intermediates))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; progress = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* clear tmp fields of intermediate states created here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (intermediates != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *ns = intermediates-&gt;tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intermediates-&gt;tmp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intermediates = ns;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if s is <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> useless, get rid of it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((s-&gt;nins == <span class="Constant">0</span> || s-&gt;nouts == <span class="Constant">0</span>) &amp;&amp; !s-&gt;flag)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L226" title="regex/regc_nfa.c:226">dropstate</a>(nfa, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (progress &amp;&amp; f != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3611" title="regex/regc_nfa.c:3611">dumpnfa</a>(nfa, f);<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (progress &amp;&amp; !<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>());<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Any ^ constraints we were able to <a href="#L1713" title="regex/regc_nfa.c:1713">pull</a> to the start state can <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replaced by <a href="regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a> arcs referencing the BOS or BOL colors.&nbsp; There should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be no other ^ or <a href="regcomp.c.html#L342" title="regex/regcomp.c:342">BEHIND</a> arcs left in the NFA, though we do not check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that here (<a href="#L3479" title="regex/regc_nfa.c:3479">compact</a>() will fail if so).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (a = nfa-&gt;pre-&gt;outs; a != <span class="Constant">NULL</span>; a = nexta)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nexta = a-&gt;outchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;type == <span class="Constant">'^'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(a-&gt;co == <span class="Constant">0</span> || a-&gt;co == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L281" title="regex/regc_nfa.c:281">newarc</a>(nfa, <a href="regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a>, nfa-&gt;bos[a-&gt;co], a-&gt;from, a-&gt;to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1713" title="regex/regc_nfa.c:1713">pull</a> - <a href="#L1713" title="regex/regc_nfa.c:1713">pull</a> a back constraint backward past its source state<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns 1 if successful (which it always is unless the source is the<br/></li>
<li></span><span class="Comment"> * start state or we have an <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> error), 0 if nothing happened.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A significant property of this function is that it deletes no pre-existing<br/></li>
<li></span><span class="Comment"> * states, and no outarcs of the constraint's from state other than the given<br/></li>
<li></span><span class="Comment"> * constraint arc.&nbsp; This makes the loops in <a href="#L1633" title="regex/regc_nfa.c:1633">pullback</a>() safe, at the cost that<br/></li>
<li></span><span class="Comment"> * we may leave useless states behind.&nbsp; Therefore, we leave it to <a href="#L1633" title="regex/regc_nfa.c:1633">pullback</a>()<br/></li>
<li></span><span class="Comment"> * to delete such states.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the from state has multiple back-constraint outarcs, and/or multiple<br/></li>
<li></span><span class="Comment"> * compatible constraint inarcs, we only need to create one new intermediate<br/></li>
<li></span><span class="Comment"> * state per combination of predecessor and successor states.&nbsp; *intermediates<br/></li>
<li></span><span class="Comment"> * points to a list of such intermediate states for this from state (chained<br/></li>
<li></span><span class="Comment"> * through their tmp fields).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1713">&#x200c;</a></span><span class="linkable">pull</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp;&nbsp; <span class="Type">struct</span> arc *con,<br/></li>
<li>&nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state **intermediates)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *from = con-&gt;from;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *to = con-&gt;to;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *nexta;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(from != to);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* should have gotten rid of this earlier */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (from-&gt;flag)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can't <a href="#L1713" title="regex/regc_nfa.c:1713">pull</a> back beyond start */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (from-&gt;nins == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* unreachable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, con);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, clone from state if necessary to avoid other outarcs.&nbsp; This may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * seem wasteful, but it simplifies the logic, and we'll get rid of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clone state again at the bottom.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (from-&gt;nouts &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s = <a href="#L137" title="regex/regc_nfa.c:137">newstate</a>(nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L882" title="regex/regc_nfa.c:882">copyins</a>(nfa, from, s);&nbsp; &nbsp; <span class="Comment">/* duplicate inarcs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L608" title="regex/regc_nfa.c:608">cparc</a>(nfa, con, s, to); <span class="Comment">/* move constraint arc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, con);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; from = s;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; con = from-&gt;outs;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; assert(from-&gt;nouts == <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* propagate the constraint into the from state's inarcs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (a = from-&gt;ins; a != <span class="Constant">NULL</span> &amp;&amp; !<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>(); a = nexta)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nexta = a-&gt;inchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L1980" title="regex/regc_nfa.c:1980">combine</a>(nfa, con, a))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="regcomp.c.html#L199" title="regex/regcomp.c:199">INCOMPATIBLE</a>:&nbsp; &nbsp; <span class="Comment">/* destroy the arc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="regcomp.c.html#L200" title="regex/regcomp.c:200">SATISFIED</a>:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no action needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="regcomp.c.html#L201" title="regex/regcomp.c:201">COMPATIBLE</a>:&nbsp; &nbsp; <span class="Comment">/* swap the two arcs, more or less */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* need an intermediate state, but might have one already */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (s = *intermediates; s != <span class="Constant">NULL</span>; s = s-&gt;tmp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(s-&gt;nins &gt; <span class="Constant">0</span> &amp;&amp; s-&gt;nouts &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;ins-&gt;from == a-&gt;from &amp;&amp; s-&gt;outs-&gt;to == to)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = <a href="#L137" title="regex/regc_nfa.c:137">newstate</a>(nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;tmp = *intermediates;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *intermediates = s;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L608" title="regex/regc_nfa.c:608">cparc</a>(nfa, con, a-&gt;from, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L608" title="regex/regc_nfa.c:608">cparc</a>(nfa, a, s, to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="regcomp.c.html#L202" title="regex/regcomp.c:202">REPLACEARC</a>:&nbsp; &nbsp; <span class="Comment">/* replace arc's color */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L281" title="regex/regc_nfa.c:281">newarc</a>(nfa, a-&gt;type, con-&gt;co, a-&gt;from, to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(NOTREACHED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* remaining inarcs, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, incorporate the constraint */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L778" title="regex/regc_nfa.c:778">moveins</a>(nfa, from, to);<br/></li>
<li>&nbsp; &nbsp; <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, con);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* from state is <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> useless, but we leave it to <a href="#L1633" title="regex/regc_nfa.c:1633">pullback</a>() to clean up */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1804" title="regex/regc_nfa.c:1804">pushfwd</a> - <a href="#L1884" title="regex/regc_nfa.c:1884">push</a> forward constraints forward to eliminate them<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1804">&#x200c;</a></span><span class="linkable">pushfwd</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">FILE</span> *f)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for debug output; NULL <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *s;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *nexts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *nexta;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *intermediates;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; progress;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="regexec.c.html#L419" title="regex/regexec.c:419">find</a> and <a href="#L1884" title="regex/regc_nfa.c:1884">push</a> until there are no more */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; progress = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (s = nfa-&gt;states; s != <span class="Constant">NULL</span> &amp;&amp; !<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>(); s = nexts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nexts = s-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intermediates = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (a = s-&gt;ins; a != <span class="Constant">NULL</span> &amp;&amp; !<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>(); a = nexta)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nexta = a-&gt;inchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;type == <span class="Constant">'$'</span> || a-&gt;type == <a href="regcomp.c.html#L341" title="regex/regcomp.c:341">AHEAD</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1884" title="regex/regc_nfa.c:1884">push</a>(nfa, a, &amp;intermediates))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; progress = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* clear tmp fields of intermediate states created here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (intermediates != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *ns = intermediates-&gt;tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intermediates-&gt;tmp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intermediates = ns;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if s is <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> useless, get rid of it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((s-&gt;nins == <span class="Constant">0</span> || s-&gt;nouts == <span class="Constant">0</span>) &amp;&amp; !s-&gt;flag)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L226" title="regex/regc_nfa.c:226">dropstate</a>(nfa, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (progress &amp;&amp; f != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3611" title="regex/regc_nfa.c:3611">dumpnfa</a>(nfa, f);<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (progress &amp;&amp; !<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>());<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Any $ constraints we were able to <a href="#L1884" title="regex/regc_nfa.c:1884">push</a> to the post state can <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replaced by <a href="regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a> arcs referencing the <a href="regcomp.c.html#L329" title="regex/regcomp.c:329">EOS</a> or EOL colors.&nbsp; There should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be no other $ or <a href="regcomp.c.html#L341" title="regex/regcomp.c:341">AHEAD</a> arcs left in the NFA, though we do not check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that here (<a href="#L3479" title="regex/regc_nfa.c:3479">compact</a>() will fail if so).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (a = nfa-&gt;post-&gt;ins; a != <span class="Constant">NULL</span>; a = nexta)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nexta = a-&gt;inchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;type == <span class="Constant">'$'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(a-&gt;co == <span class="Constant">0</span> || a-&gt;co == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L281" title="regex/regc_nfa.c:281">newarc</a>(nfa, <a href="regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a>, nfa-&gt;eos[a-&gt;co], a-&gt;from, a-&gt;to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1884" title="regex/regc_nfa.c:1884">push</a> - <a href="#L1884" title="regex/regc_nfa.c:1884">push</a> a forward constraint forward past its destination state<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns 1 if successful (which it always is unless the destination is the<br/></li>
<li></span><span class="Comment"> * post state or we have an <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> error), 0 if nothing happened.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A significant property of this function is that it deletes no pre-existing<br/></li>
<li></span><span class="Comment"> * states, and no inarcs of the constraint's to state other than the given<br/></li>
<li></span><span class="Comment"> * constraint arc.&nbsp; This makes the loops in <a href="#L1804" title="regex/regc_nfa.c:1804">pushfwd</a>() safe, at the cost that<br/></li>
<li></span><span class="Comment"> * we may leave useless states behind.&nbsp; Therefore, we leave it to <a href="#L1804" title="regex/regc_nfa.c:1804">pushfwd</a>()<br/></li>
<li></span><span class="Comment"> * to delete such states.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the to state has multiple forward-constraint inarcs, and/or multiple<br/></li>
<li></span><span class="Comment"> * compatible constraint outarcs, we only need to create one new intermediate<br/></li>
<li></span><span class="Comment"> * state per combination of predecessor and successor states.&nbsp; *intermediates<br/></li>
<li></span><span class="Comment"> * points to a list of such intermediate states for this to state (chained<br/></li>
<li></span><span class="Comment"> * through their tmp fields).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1884">&#x200c;</a></span><span class="linkable">push</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp;&nbsp; <span class="Type">struct</span> arc *con,<br/></li>
<li>&nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state **intermediates)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *from = con-&gt;from;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *to = con-&gt;to;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *nexta;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(to != from);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* should have gotten rid of this earlier */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (to-&gt;flag)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can't <a href="#L1884" title="regex/regc_nfa.c:1884">push</a> forward beyond end */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (to-&gt;nouts == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dead end */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, con);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, clone to state if necessary to avoid other inarcs.&nbsp; This may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * seem wasteful, but it simplifies the logic, and we'll get rid of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clone state again at the bottom.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (to-&gt;nins &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s = <a href="#L137" title="regex/regc_nfa.c:137">newstate</a>(nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1167" title="regex/regc_nfa.c:1167">copyouts</a>(nfa, to, s);&nbsp; &nbsp; <span class="Comment">/* duplicate outarcs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L608" title="regex/regc_nfa.c:608">cparc</a>(nfa, con, from, s);&nbsp; &nbsp; <span class="Comment">/* move constraint arc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, con);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; to = s;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; con = to-&gt;ins;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; assert(to-&gt;nins == <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* propagate the constraint into the to state's outarcs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (a = to-&gt;outs; a != <span class="Constant">NULL</span> &amp;&amp; !<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>(); a = nexta)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nexta = a-&gt;outchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L1980" title="regex/regc_nfa.c:1980">combine</a>(nfa, con, a))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="regcomp.c.html#L199" title="regex/regcomp.c:199">INCOMPATIBLE</a>:&nbsp; &nbsp; <span class="Comment">/* destroy the arc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="regcomp.c.html#L200" title="regex/regcomp.c:200">SATISFIED</a>:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no action needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="regcomp.c.html#L201" title="regex/regcomp.c:201">COMPATIBLE</a>:&nbsp; &nbsp; <span class="Comment">/* swap the two arcs, more or less */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* need an intermediate state, but might have one already */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (s = *intermediates; s != <span class="Constant">NULL</span>; s = s-&gt;tmp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(s-&gt;nins &gt; <span class="Constant">0</span> &amp;&amp; s-&gt;nouts &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;ins-&gt;from == from &amp;&amp; s-&gt;outs-&gt;to == a-&gt;to)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = <a href="#L137" title="regex/regc_nfa.c:137">newstate</a>(nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;tmp = *intermediates;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *intermediates = s;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L608" title="regex/regc_nfa.c:608">cparc</a>(nfa, con, s, a-&gt;to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L608" title="regex/regc_nfa.c:608">cparc</a>(nfa, a, from, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="regcomp.c.html#L202" title="regex/regcomp.c:202">REPLACEARC</a>:&nbsp; &nbsp; <span class="Comment">/* replace arc's color */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L281" title="regex/regc_nfa.c:281">newarc</a>(nfa, a-&gt;type, con-&gt;co, from, a-&gt;to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(NOTREACHED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* remaining outarcs, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, incorporate the constraint */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1066" title="regex/regc_nfa.c:1066">moveouts</a>(nfa, to, from);<br/></li>
<li>&nbsp; &nbsp; <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, con);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* to state is <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> useless, but we leave it to <a href="#L1804" title="regex/regc_nfa.c:1804">pushfwd</a>() to clean up */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1980" title="regex/regc_nfa.c:1980">combine</a> - constraint lands on an arc, what happens?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * #def <a href="regcomp.c.html#L199" title="regex/regcomp.c:199">INCOMPATIBLE</a>&nbsp; &nbsp; 1&nbsp; &nbsp; // destroys arc<br/></li>
<li></span><span class="Comment"> * #def <a href="regcomp.c.html#L200" title="regex/regcomp.c:200">SATISFIED</a>&nbsp; &nbsp; &nbsp; &nbsp; 2&nbsp; &nbsp; // constraint satisfied<br/></li>
<li></span><span class="Comment"> * #def <a href="regcomp.c.html#L201" title="regex/regcomp.c:201">COMPATIBLE</a>&nbsp; &nbsp; &nbsp; &nbsp; 3&nbsp; &nbsp; // compatible but not satisfied yet<br/></li>
<li></span><span class="Comment"> * #def <a href="regcomp.c.html#L202" title="regex/regcomp.c:202">REPLACEARC</a>&nbsp; &nbsp; &nbsp; &nbsp; 4&nbsp; &nbsp; // replace arc's color with constraint color<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1980">&#x200c;</a></span><span class="linkable">combine</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *con,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *a)<br/></li>
<li>{<br/></li>
<li><a id="L1984">&#x200c;</a><span class="PreProc">#define&nbsp; <span class="linkable">CA</span>(ct,at)&nbsp; &nbsp;&nbsp; (((ct)&lt;&lt;</span><span class="Constant">CHAR_BIT</span><span class="PreProc">) | (at))<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L1984" title="regex/regc_nfa.c:1984">CA</a>(con-&gt;type, a-&gt;type))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1984" title="regex/regc_nfa.c:1984">CA</a>(<span class="Constant">'^'</span>, <a href="regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a>):&nbsp; &nbsp; <span class="Comment">/* newlines are handled separately */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1984" title="regex/regc_nfa.c:1984">CA</a>(<span class="Constant">'$'</span>, <a href="regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a>):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="regcomp.c.html#L199" title="regex/regcomp.c:199">INCOMPATIBLE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1984" title="regex/regc_nfa.c:1984">CA</a>(<a href="regcomp.c.html#L341" title="regex/regcomp.c:341">AHEAD</a>, <a href="regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a>):&nbsp; &nbsp; <span class="Comment">/* color constraints meet colors */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1984" title="regex/regc_nfa.c:1984">CA</a>(<a href="regcomp.c.html#L342" title="regex/regcomp.c:342">BEHIND</a>, <a href="regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a>):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (con-&gt;co == a-&gt;co)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="regcomp.c.html#L200" title="regex/regcomp.c:200">SATISFIED</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (con-&gt;co == RAINBOW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* con is satisfied unless arc's color is a <a href="regc_color.c.html#L312" title="regex/regc_color.c:312">pseudocolor</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(nfa-&gt;cm-&gt;cd[a-&gt;co].flags &amp; PSEUDO))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="regcomp.c.html#L200" title="regex/regcomp.c:200">SATISFIED</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (a-&gt;co == RAINBOW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* con is incompatible if it's for a <a href="regc_color.c.html#L312" title="regex/regc_color.c:312">pseudocolor</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* (this is hypothetical; we make no such constraints today) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nfa-&gt;cm-&gt;cd[con-&gt;co].flags &amp; PSEUDO)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="regcomp.c.html#L199" title="regex/regcomp.c:199">INCOMPATIBLE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* otherwise, constraint constrains arc to be only its color */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="regcomp.c.html#L202" title="regex/regcomp.c:202">REPLACEARC</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="regcomp.c.html#L199" title="regex/regcomp.c:199">INCOMPATIBLE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1984" title="regex/regc_nfa.c:1984">CA</a>(<span class="Constant">'^'</span>, <span class="Constant">'^'</span>):&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* collision, similar constraints */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1984" title="regex/regc_nfa.c:1984">CA</a>(<span class="Constant">'$'</span>, <span class="Constant">'$'</span>):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (con-&gt;co == a-&gt;co)&nbsp; &nbsp; <span class="Comment">/* true duplication */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="regcomp.c.html#L200" title="regex/regcomp.c:200">SATISFIED</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="regcomp.c.html#L199" title="regex/regcomp.c:199">INCOMPATIBLE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1984" title="regex/regc_nfa.c:1984">CA</a>(<a href="regcomp.c.html#L341" title="regex/regcomp.c:341">AHEAD</a>, <a href="regcomp.c.html#L341" title="regex/regcomp.c:341">AHEAD</a>):&nbsp; &nbsp; <span class="Comment">/* collision, similar constraints */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1984" title="regex/regc_nfa.c:1984">CA</a>(<a href="regcomp.c.html#L342" title="regex/regcomp.c:342">BEHIND</a>, <a href="regcomp.c.html#L342" title="regex/regcomp.c:342">BEHIND</a>):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (con-&gt;co == a-&gt;co)&nbsp; &nbsp; <span class="Comment">/* true duplication */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="regcomp.c.html#L200" title="regex/regcomp.c:200">SATISFIED</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (con-&gt;co == RAINBOW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* con is satisfied unless arc's color is a <a href="regc_color.c.html#L312" title="regex/regc_color.c:312">pseudocolor</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(nfa-&gt;cm-&gt;cd[a-&gt;co].flags &amp; PSEUDO))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="regcomp.c.html#L200" title="regex/regcomp.c:200">SATISFIED</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (a-&gt;co == RAINBOW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* con is incompatible if it's for a <a href="regc_color.c.html#L312" title="regex/regc_color.c:312">pseudocolor</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* (this is hypothetical; we make no such constraints today) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nfa-&gt;cm-&gt;cd[con-&gt;co].flags &amp; PSEUDO)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="regcomp.c.html#L199" title="regex/regcomp.c:199">INCOMPATIBLE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* otherwise, constraint constrains arc to be only its color */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="regcomp.c.html#L202" title="regex/regcomp.c:202">REPLACEARC</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="regcomp.c.html#L199" title="regex/regcomp.c:199">INCOMPATIBLE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1984" title="regex/regc_nfa.c:1984">CA</a>(<span class="Constant">'^'</span>, <a href="regcomp.c.html#L342" title="regex/regcomp.c:342">BEHIND</a>):&nbsp; &nbsp; <span class="Comment">/* collision, dissimilar constraints */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1984" title="regex/regc_nfa.c:1984">CA</a>(<a href="regcomp.c.html#L342" title="regex/regcomp.c:342">BEHIND</a>, <span class="Constant">'^'</span>):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1984" title="regex/regc_nfa.c:1984">CA</a>(<span class="Constant">'$'</span>, <a href="regcomp.c.html#L341" title="regex/regcomp.c:341">AHEAD</a>):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1984" title="regex/regc_nfa.c:1984">CA</a>(<a href="regcomp.c.html#L341" title="regex/regcomp.c:341">AHEAD</a>, <span class="Constant">'$'</span>):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="regcomp.c.html#L199" title="regex/regcomp.c:199">INCOMPATIBLE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1984" title="regex/regc_nfa.c:1984">CA</a>(<span class="Constant">'^'</span>, <span class="Constant">'$'</span>):&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* constraints passing each other */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1984" title="regex/regc_nfa.c:1984">CA</a>(<span class="Constant">'^'</span>, <a href="regcomp.c.html#L341" title="regex/regcomp.c:341">AHEAD</a>):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1984" title="regex/regc_nfa.c:1984">CA</a>(<a href="regcomp.c.html#L342" title="regex/regcomp.c:342">BEHIND</a>, <span class="Constant">'$'</span>):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1984" title="regex/regc_nfa.c:1984">CA</a>(<a href="regcomp.c.html#L342" title="regex/regcomp.c:342">BEHIND</a>, <a href="regcomp.c.html#L341" title="regex/regcomp.c:341">AHEAD</a>):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1984" title="regex/regc_nfa.c:1984">CA</a>(<span class="Constant">'$'</span>, <span class="Constant">'^'</span>):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1984" title="regex/regc_nfa.c:1984">CA</a>(<span class="Constant">'$'</span>, <a href="regcomp.c.html#L342" title="regex/regcomp.c:342">BEHIND</a>):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1984" title="regex/regc_nfa.c:1984">CA</a>(<a href="regcomp.c.html#L341" title="regex/regcomp.c:341">AHEAD</a>, <span class="Constant">'^'</span>):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1984" title="regex/regc_nfa.c:1984">CA</a>(<a href="regcomp.c.html#L341" title="regex/regcomp.c:341">AHEAD</a>, <a href="regcomp.c.html#L342" title="regex/regcomp.c:342">BEHIND</a>):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1984" title="regex/regc_nfa.c:1984">CA</a>(<span class="Constant">'^'</span>, <a href="regcomp.c.html#L340" title="regex/regcomp.c:340">LACON</a>):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1984" title="regex/regc_nfa.c:1984">CA</a>(<a href="regcomp.c.html#L342" title="regex/regcomp.c:342">BEHIND</a>, <a href="regcomp.c.html#L340" title="regex/regcomp.c:340">LACON</a>):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1984" title="regex/regc_nfa.c:1984">CA</a>(<span class="Constant">'$'</span>, <a href="regcomp.c.html#L340" title="regex/regcomp.c:340">LACON</a>):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1984" title="regex/regc_nfa.c:1984">CA</a>(<a href="regcomp.c.html#L341" title="regex/regcomp.c:341">AHEAD</a>, <a href="regcomp.c.html#L340" title="regex/regcomp.c:340">LACON</a>):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="regcomp.c.html#L201" title="regex/regcomp.c:201">COMPATIBLE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; assert(NOTREACHED);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="regcomp.c.html#L199" title="regex/regcomp.c:199">INCOMPATIBLE</a>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for benefit of blind compilers */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2069" title="regex/regc_nfa.c:2069">fixempties</a> - get rid of <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> arcs<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2069">&#x200c;</a></span><span class="linkable">fixempties</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">FILE</span> *f)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for debug output; NULL <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *s;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *s2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *nexts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *nexta;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totalinarcs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc **inarcsorig;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc **arcarray;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arccount;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevnins;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nskip;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, get rid of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> states whose sole out-arc is an <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a>, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they're basically just aliases for their successor.&nbsp; The parsing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * algorithm creates enough of these that it's worth special-casing this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (s = nfa-&gt;states; s != <span class="Constant">NULL</span> &amp;&amp; !<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>(); s = nexts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nexts = s-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;flag || s-&gt;nouts != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a = s-&gt;outs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(a != <span class="Constant">NULL</span> &amp;&amp; a-&gt;outchain == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;type != <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s != a-&gt;to)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L778" title="regex/regc_nfa.c:778">moveins</a>(nfa, s, a-&gt;to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L226" title="regex/regc_nfa.c:226">dropstate</a>(nfa, s);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Similarly, get rid of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> state with a single <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> in-arc, by folding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it into its predecessor.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (s = nfa-&gt;states; s != <span class="Constant">NULL</span> &amp;&amp; !<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>(); s = nexts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nexts = s-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* while we're at it, ensure tmp fields are clear for <a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> step */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; assert(s-&gt;tmp == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;flag || s-&gt;nins != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a = s-&gt;ins;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(a != <span class="Constant">NULL</span> &amp;&amp; a-&gt;inchain == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;type != <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s != a-&gt;from)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1066" title="regex/regc_nfa.c:1066">moveouts</a>(nfa, s, a-&gt;from);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L226" title="regex/regc_nfa.c:226">dropstate</a>(nfa, s);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For each remaining NFA state, <a href="regexec.c.html#L419" title="regex/regexec.c:419">find</a> all other states from which it is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reachable by a chain of one or more <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> arcs.&nbsp; Then generate new arcs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that eliminate the need for each such chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We could replace a chain of <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> arcs that leads from a &quot;from&quot; state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to a &quot;to&quot; state either by pushing non-<a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> arcs forward (linking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * directly from &quot;from&quot;'s predecessors to &quot;to&quot;) or by pulling them back<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (linking directly from &quot;from&quot; to &quot;to&quot;'s successors).&nbsp; We choose to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * always do the former; this choice is somewhat arbitrary, but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * approach below requires that we uniformly do one or the other.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Suppose we have a chain of N successive <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> arcs (where N can easily<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * approach the size of the NFA).&nbsp; All of the intermediate states must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have additional inarcs and outarcs, else they'd have been removed by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the steps above.&nbsp; Assuming their inarcs are mostly not empties, we will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * add O(N^2) arcs to the NFA, since a non-<a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> inarc leading to <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * state in the chain must be duplicated to lead to all its successor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * states as well.&nbsp; So there is no hope of doing less than O(N^2) work;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * however, we should endeavor to keep the big-O cost from being even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worse than that, which it can easily become without care.&nbsp; In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * particular, suppose we were to copy all S1's inarcs forward to S2, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then also to S3, and then later we consider pushing S2's inarcs forward<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to S3.&nbsp; If we include the arcs already copied from S1 in that, we'd be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doing O(N^3) work.&nbsp; (The duplicate-arc elimination built into <a href="#L281" title="regex/regc_nfa.c:281">newarc</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and its cohorts would get rid of the extra arcs, but not without cost.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can avoid this cost by treating only arcs that existed at the start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of this phase as candidates to be pushed forward.&nbsp; To identify those,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we remember the first inarc each state had to start with.&nbsp; We rely on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the fact that <a href="#L281" title="regex/regc_nfa.c:281">newarc</a>() and friends put new arcs on the front of their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to-states' inchains, and that this phase never deletes arcs, so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the original arcs must be the last arcs in their to-states' inchains.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * So the process here is that, for each state in the NFA, we gather up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all non-<a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> inarcs of states that can reach the target state via<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> arcs.&nbsp; We then sort, de-duplicate, and <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> these arcs into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * target state's inchain.&nbsp; (We can safely use sort-<a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> for this as long<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as we update each state's original-arcs pointer after we add arcs to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it; the sort step of <a href="#L971" title="regex/regc_nfa.c:971">mergeins</a> probably changed the order of the old<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * arcs.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Another refinement worth making is that, because we only add non-<a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * arcs during this phase, and all added arcs have the same from-state as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the non-<a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> arc they were cloned from, we know ahead of time that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * states having only <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> outarcs will be useless for lack of outarcs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after we drop the <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> arcs.&nbsp; (They cannot gain non-<a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> outarcs if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they had <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> to start with.)&nbsp; So we need not bother to update the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inchains of such states at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remember the states' first original inarcs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* ... and while at it, count how many old inarcs there are altogether */<br/></li>
<li></span>&nbsp; &nbsp; inarcsorig = (<span class="Type">struct</span> arc **) MALLOC(nfa-&gt;nstates * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> arc *));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (inarcsorig == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L40" title="regex/regc_nfa.c:40">NERR</a>(REG_ESPACE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; totalinarcs = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (s = nfa-&gt;states; s != <span class="Constant">NULL</span>; s = s-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inarcsorig[s-&gt;no] = s-&gt;ins;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; totalinarcs += s-&gt;nins;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a workspace for accumulating the inarcs to be added to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current target state.&nbsp; totalinarcs is probably a considerable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overestimate of the space needed, but the NFA is unlikely to be large<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enough at this point to make it worth being smarter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; arcarray = (<span class="Type">struct</span> arc **) MALLOC(totalinarcs * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> arc *));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arcarray == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L40" title="regex/regc_nfa.c:40">NERR</a>(REG_ESPACE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FREE(inarcsorig);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And iterate over the target states */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (s = nfa-&gt;states; s != <span class="Constant">NULL</span> &amp;&amp; !<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>(); s = s-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore target states without non-<a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> outarcs, per note above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!s-&gt;flag &amp;&amp; !<a href="#L575" title="regex/regc_nfa.c:575">hasnonemptyout</a>(s))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find predecessor states and accumulate their original inarcs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; arccount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (s2 = <a href="#L2296" title="regex/regc_nfa.c:2296">emptyreachable</a>(nfa, s, s, inarcsorig); s2 != s; s2 = nexts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add s2's original inarcs to arcarray[], but ignore empties */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (a = inarcsorig[s2-&gt;no]; a != <span class="Constant">NULL</span>; a = a-&gt;inchain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;type != <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arcarray[arccount++] = a;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset the tmp fields as we walk back */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nexts = s2-&gt;tmp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s2-&gt;tmp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s-&gt;tmp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(arccount &lt;= totalinarcs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remember how many original inarcs this state has */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; prevnins = s-&gt;nins;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add non-duplicate inarcs to target state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L971" title="regex/regc_nfa.c:971">mergeins</a>(nfa, s, arcarray, arccount);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now we must update the state's inarcsorig pointer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nskip = s-&gt;nins - prevnins;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a = s-&gt;ins;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (nskip-- &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = a-&gt;inchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inarcsorig[s-&gt;no] = a;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; FREE(arcarray);<br/></li>
<li>&nbsp; &nbsp; FREE(inarcsorig);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now remove all the <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> arcs, since we don't need them anymore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (s = nfa-&gt;states; s != <span class="Constant">NULL</span>; s = s-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (a = s-&gt;outs; a != <span class="Constant">NULL</span>; a = nexta)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nexta = a-&gt;outchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;type == <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And remove <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> states that have become useless.&nbsp; (This <a href="#L2929" title="regex/regc_nfa.c:2929">cleanup</a> is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * very thorough, and would be even less so if we tried to <a href="#L1980" title="regex/regc_nfa.c:1980">combine</a> it with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the previous step; but <a href="#L2929" title="regex/regc_nfa.c:2929">cleanup</a>() will take care of anything we <a href="rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (s = nfa-&gt;states; s != <span class="Constant">NULL</span>; s = nexts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nexts = s-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((s-&gt;nins == <span class="Constant">0</span> || s-&gt;nouts == <span class="Constant">0</span>) &amp;&amp; !s-&gt;flag)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L226" title="regex/regc_nfa.c:226">dropstate</a>(nfa, s);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (f != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3611" title="regex/regc_nfa.c:3611">dumpnfa</a>(nfa, f);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2296" title="regex/regc_nfa.c:2296">emptyreachable</a> - recursively <a href="regexec.c.html#L419" title="regex/regexec.c:419">find</a> all states that can reach s by <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> arcs<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The return value is the last such state found.&nbsp; Its tmp field links back<br/></li>
<li></span><span class="Comment"> * to the <a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-to-last such state, and so on back to s, so that all these<br/></li>
<li></span><span class="Comment"> * states can be located without searching the whole NFA.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since this is only used in <a href="#L2069" title="regex/regc_nfa.c:2069">fixempties</a>(), we pass in the inarcsorig[] array<br/></li>
<li></span><span class="Comment"> * maintained by that function.&nbsp; This lets us <a href="regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> over all new inarcs, which<br/></li>
<li></span><span class="Comment"> * are certainly not <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> arcs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The maximum recursion depth here is <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the length of the <a href="rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a><br/></li>
<li></span><span class="Comment"> * loop-free chain of <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> arcs, which is surely no more than the size of<br/></li>
<li></span><span class="Comment"> * the NFA ... but that could still be enough to cause trouble.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">struct</span> state *<br/></li>
<li><a id="L2296">&#x200c;</a><span class="linkable">emptyreachable</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *s,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *lastfound,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> arc **inarcsorig)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Since this is recursive, it could be driven to stack overflow */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (STACK_TOO_DEEP(nfa-&gt;v-&gt;re))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L40" title="regex/regc_nfa.c:40">NERR</a>(REG_ETOOBIG);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> lastfound;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s-&gt;tmp = lastfound;<br/></li>
<li>&nbsp; &nbsp; lastfound = s;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (a = inarcsorig[s-&gt;no]; a != <span class="Constant">NULL</span>; a = a-&gt;inchain)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;type == <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> &amp;&amp; a-&gt;from-&gt;tmp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastfound = <a href="#L2296" title="regex/regc_nfa.c:2296">emptyreachable</a>(nfa, a-&gt;from, lastfound, inarcsorig);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> lastfound;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2324" title="regex/regc_nfa.c:2324">isconstraintarc</a> - detect whether an arc is of a constraint type<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int<br/></li>
<li><a id="L2324">&#x200c;</a></span><span class="linkable">isconstraintarc</span>(<span class="Type">struct</span> arc *a)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (a-&gt;type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'^'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'$'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="regcomp.c.html#L342" title="regex/regcomp.c:342">BEHIND</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="regcomp.c.html#L341" title="regex/regcomp.c:341">AHEAD</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="regcomp.c.html#L340" title="regex/regcomp.c:340">LACON</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2342" title="regex/regc_nfa.c:2342">hasconstraintout</a> - does state have a constraint out arc?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2342">&#x200c;</a></span><span class="linkable">hasconstraintout</span>(<span class="Type">struct</span> state *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (a = s-&gt;outs; a != <span class="Constant">NULL</span>; a = a-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2324" title="regex/regc_nfa.c:2324">isconstraintarc</a>(a))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2363" title="regex/regc_nfa.c:2363">fixconstraintloops</a> - get rid of loops containing only constraint arcs<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A loop of states that contains only constraint arcs is useless, since<br/></li>
<li></span><span class="Comment"> * passing around the loop represents no forward progress.&nbsp; Moreover, it<br/></li>
<li></span><span class="Comment"> * would cause infinite looping in <a href="#L1633" title="regex/regc_nfa.c:1633">pullback</a>/<a href="#L1804" title="regex/regc_nfa.c:1804">pushfwd</a>, so we need to get rid<br/></li>
<li></span><span class="Comment"> * of such loops <a href="regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> doing that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2363">&#x200c;</a></span><span class="linkable">fixconstraintloops</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">FILE</span> *f)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for debug output; NULL <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *s;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *nexts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *nexta;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasconstraints;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In the trivial case of a state that loops to itself, we can just drop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the constraint arc altogether.&nbsp; This is worth special-casing because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * such loops are far more common than loops containing multiple states.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * While we're at it, note whether <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> constraint arcs survive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hasconstraints = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (s = nfa-&gt;states; s != <span class="Constant">NULL</span> &amp;&amp; !<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>(); s = nexts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nexts = s-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* while we're at it, ensure tmp fields are clear for <a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> step */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; assert(s-&gt;tmp == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (a = s-&gt;outs; a != <span class="Constant">NULL</span> &amp;&amp; !<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>(); a = nexta)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nexta = a-&gt;outchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2324" title="regex/regc_nfa.c:2324">isconstraintarc</a>(a))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;to == s)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasconstraints = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we removed all the outarcs, the state is useless. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;nouts == <span class="Constant">0</span> &amp;&amp; !s-&gt;flag)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L226" title="regex/regc_nfa.c:226">dropstate</a>(nfa, s);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do if no remaining constraint arcs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>() || !hasconstraints)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Starting from each remaining NFA state, search outwards for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constraint loop.&nbsp; If we <a href="regexec.c.html#L419" title="regex/regexec.c:419">find</a> a loop, break the loop, then start the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * search over.&nbsp; (We could possibly retain some state from the first scan,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but it would complicate things greatly, and multi-state constraint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * loops are rare enough that it's not worth optimizing the case.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Statement">restart</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (s = nfa-&gt;states; s != <span class="Constant">NULL</span> &amp;&amp; !<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>(); s = s-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2462" title="regex/regc_nfa.c:2462">findconstraintloop</a>(nfa, s))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> restart;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now remove <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> states that have become useless.&nbsp; (This <a href="#L2929" title="regex/regc_nfa.c:2929">cleanup</a> is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * very thorough, and would be even less so if we tried to <a href="#L1980" title="regex/regc_nfa.c:1980">combine</a> it with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the previous step; but <a href="#L2929" title="regex/regc_nfa.c:2929">cleanup</a>() will take care of anything we <a href="rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Because <a href="#L2462" title="regex/regc_nfa.c:2462">findconstraintloop</a> intentionally doesn't reset all tmp fields,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we have to clear them after it's done.&nbsp; This is a convenient place to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do that, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (s = nfa-&gt;states; s != <span class="Constant">NULL</span>; s = nexts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nexts = s-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s-&gt;tmp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((s-&gt;nins == <span class="Constant">0</span> || s-&gt;nouts == <span class="Constant">0</span>) &amp;&amp; !s-&gt;flag)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L226" title="regex/regc_nfa.c:226">dropstate</a>(nfa, s);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (f != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3611" title="regex/regc_nfa.c:3611">dumpnfa</a>(nfa, f);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2462" title="regex/regc_nfa.c:2462">findconstraintloop</a> - recursively <a href="regexec.c.html#L419" title="regex/regexec.c:419">find</a> a loop of constraint arcs<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If we <a href="regexec.c.html#L419" title="regex/regexec.c:419">find</a> a loop, break it by calling <a href="#L2551" title="regex/regc_nfa.c:2551">breakconstraintloop</a>(), then<br/></li>
<li></span><span class="Comment"> * return 1; otherwise return 0.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * State tmp fields are guaranteed all NULL on a success return, because<br/></li>
<li></span><span class="Comment"> * <a href="#L2551" title="regex/regc_nfa.c:2551">breakconstraintloop</a> does that.&nbsp; After a failure return, <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> state that<br/></li>
<li></span><span class="Comment"> * is known not to be part of a loop is marked with s-&gt;tmp == s; this allows<br/></li>
<li></span><span class="Comment"> * us not to have to re-prove that fact on later calls.&nbsp; (This convention is<br/></li>
<li></span><span class="Comment"> * workable because we already eliminated single-state loops.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the found loop doesn't necessarily include the first state we<br/></li>
<li></span><span class="Comment"> * are called on.&nbsp; Any loop reachable from that state will do.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The maximum recursion depth here is one more than the length of the <a href="rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a><br/></li>
<li></span><span class="Comment"> * loop-free chain of constraint arcs, which is surely no more than the size<br/></li>
<li></span><span class="Comment"> * of the NFA ... but that could still be enough to cause trouble.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2462">&#x200c;</a></span><span class="linkable">findconstraintloop</span>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> state *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Since this is recursive, it could be driven to stack overflow */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (STACK_TOO_DEEP(nfa-&gt;v-&gt;re))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L40" title="regex/regc_nfa.c:40">NERR</a>(REG_ETOOBIG);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* to exit as quickly as possible */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;tmp != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Already proven uninteresting? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;tmp == s)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found a loop involving s */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2551" title="regex/regc_nfa.c:2551">breakconstraintloop</a>(nfa, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The tmp fields have been cleaned up by <a href="#L2551" title="regex/regc_nfa.c:2551">breakconstraintloop</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (a = s-&gt;outs; a != <span class="Constant">NULL</span>; a = a-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2324" title="regex/regc_nfa.c:2324">isconstraintarc</a>(a))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *sto = a-&gt;to;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(sto != s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;tmp = sto;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2462" title="regex/regc_nfa.c:2462">findconstraintloop</a>(nfa, sto))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we get here, no constraint loop exists leading out from s.&nbsp; Mark it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with s-&gt;tmp == s so we need not rediscover that fact again later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; s-&gt;tmp = s;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2551" title="regex/regc_nfa.c:2551">breakconstraintloop</a> - break a loop of constraint arcs<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * sinitial is <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one member state of the loop.&nbsp; Each loop member's tmp<br/></li>
<li></span><span class="Comment"> * field links to its successor within the loop.&nbsp; (Note that this function<br/></li>
<li></span><span class="Comment"> * will reset all the tmp fields to NULL.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We can break the loop by, for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one state S1 in the loop, cloning its<br/></li>
<li></span><span class="Comment"> * loop successor state S2 (and possibly following states), and then moving<br/></li>
<li></span><span class="Comment"> * all S1-&gt;S2 constraint arcs to point to the cloned S2.&nbsp; The cloned S2 should<br/></li>
<li></span><span class="Comment"> * copy <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-constraint outarcs of S2.&nbsp; Constraint outarcs should be<br/></li>
<li></span><span class="Comment"> * dropped if they point back to S1, else they need to be copied as arcs to<br/></li>
<li></span><span class="Comment"> * similarly cloned states S3, S4, etc.&nbsp; In general, each cloned state copies<br/></li>
<li></span><span class="Comment"> * non-constraint outarcs, drops constraint outarcs that would lead to itself<br/></li>
<li></span><span class="Comment"> * or <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> earlier cloned state, and sends other constraint outarcs to newly<br/></li>
<li></span><span class="Comment"> * cloned states.&nbsp; No cloned state will have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> inarcs that aren't constraint<br/></li>
<li></span><span class="Comment"> * arcs or do not lead from S1 or earlier-cloned states.&nbsp; It's okay to drop<br/></li>
<li></span><span class="Comment"> * constraint back-arcs since they would not take us to <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> state we've not<br/></li>
<li></span><span class="Comment"> * already been in; therefore, no new constraint loop is created.&nbsp; In this way<br/></li>
<li></span><span class="Comment"> * we generate a modified NFA that can still represent every useful state<br/></li>
<li></span><span class="Comment"> * sequence, but not sequences that represent state loops with no consumption<br/></li>
<li></span><span class="Comment"> * of input data.&nbsp; Note that the set of cloned states will certainly include<br/></li>
<li></span><span class="Comment"> * all of the loop member states other than S1, and it may also include<br/></li>
<li></span><span class="Comment"> * non-loop states that are reachable from S2 via constraint arcs.&nbsp; This is<br/></li>
<li></span><span class="Comment"> * important because there is no guarantee that <a href="#L2462" title="regex/regc_nfa.c:2462">findconstraintloop</a> found a<br/></li>
<li></span><span class="Comment"> * maximal loop (and searching for one would be NP-hard, so don't try).<br/></li>
<li></span><span class="Comment"> * Frequently the &quot;non-loop states&quot; are actually part of a larger loop that<br/></li>
<li></span><span class="Comment"> * we didn't notice, and indeed there may be several overlapping loops.<br/></li>
<li></span><span class="Comment"> * This technique ensures convergence in such cases, while considering only<br/></li>
<li></span><span class="Comment"> * the originally-found loop does not.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If there is only one S1-&gt;S2 constraint arc, then that constraint is<br/></li>
<li></span><span class="Comment"> * certainly satisfied when we enter <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the clone states.&nbsp; This means that<br/></li>
<li></span><span class="Comment"> * in the common case where many of the constraint arcs are identically<br/></li>
<li></span><span class="Comment"> * labeled, we can <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> together clone states linked by a similarly-labeled<br/></li>
<li></span><span class="Comment"> * constraint: if we can get to the first one we can certainly get to the<br/></li>
<li></span><span class="Comment"> * second, so there's no need to distinguish.&nbsp; This greatly reduces the number<br/></li>
<li></span><span class="Comment"> * of new states needed, so we preferentially break the given loop at a state<br/></li>
<li></span><span class="Comment"> * pair where this is true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Furthermore, it's fairly common to <a href="regexec.c.html#L419" title="regex/regexec.c:419">find</a> that a cloned successor state has<br/></li>
<li></span><span class="Comment"> * no outarcs, especially if we're a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> aggressive about removing unnecessary<br/></li>
<li></span><span class="Comment"> * outarcs.&nbsp; If that happens, then there is simply not <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> interesting state<br/></li>
<li></span><span class="Comment"> * that can be reached through the predecessor's loop arcs, which means we can<br/></li>
<li></span><span class="Comment"> * break the loop just by removing those loop arcs, with no new states added.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2551">&#x200c;</a></span><span class="linkable">breakconstraintloop</span>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> state *sinitial)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *s;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *shead;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *stail;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *sclone;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *nexts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *refarc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *nexta;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start by identifying which loop step we want to break at.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Preferentially this is one with only one constraint arc.&nbsp; (</span><span class="Todo">XXX</span><span class="Comment"> are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other secondary heuristics we want to use here?)&nbsp; Set refarc<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to point to the selected lone constraint arc, if there is one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; refarc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; s = sinitial;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nexts = s-&gt;tmp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(nexts != s);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* should not see <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one-<a href="regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> loops */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (refarc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; narcs = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (a = s-&gt;outs; a != <span class="Constant">NULL</span>; a = a-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;to == nexts &amp;&amp; <a href="#L2324" title="regex/regc_nfa.c:2324">isconstraintarc</a>(a))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; refarc = a;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; narcs++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(narcs &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (narcs &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; refarc = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* multiple constraint arcs here, no good */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s = nexts;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (s != sinitial);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (refarc)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* break at the refarc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; shead = refarc-&gt;from;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stail = refarc-&gt;to;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(stail == shead-&gt;tmp);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for lack of a better idea, break after sinitial */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; shead = sinitial;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stail = sinitial-&gt;tmp;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset the tmp fields so that we can use them for local storage in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L2697" title="regex/regc_nfa.c:2697">clonesuccessorstates</a>.&nbsp; (<a href="#L2462" title="regex/regc_nfa.c:2462">findconstraintloop</a> won't mind, since it's just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * going to abandon its search anyway.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (s = nfa-&gt;states; s != <span class="Constant">NULL</span>; s = s-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s-&gt;tmp = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Recursively build clone state(s) as needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sclone = <a href="#L137" title="regex/regc_nfa.c:137">newstate</a>(nfa);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sclone == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2697" title="regex/regc_nfa.c:2697">clonesuccessorstates</a>(nfa, stail, sclone, shead, refarc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, nfa-&gt;nstates);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's possible that sclone has no outarcs at all, in which case it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * useless.&nbsp; (We don't try extremely hard to get rid of useless states<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here, but this is an easy and fairly common case.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sclone-&gt;nouts == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L242" title="regex/regc_nfa.c:242">freestate</a>(nfa, sclone);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sclone = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Move shead's constraint-loop arcs to point to sclone, or just drop them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we discovered we don't need sclone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (a = shead-&gt;outs; a != <span class="Constant">NULL</span>; a = nexta)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nexta = a-&gt;outchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;to == stail &amp;&amp; <a href="#L2324" title="regex/regc_nfa.c:2324">isconstraintarc</a>(a))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sclone)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L608" title="regex/regc_nfa.c:608">cparc</a>(nfa, a, shead, sclone);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2697" title="regex/regc_nfa.c:2697">clonesuccessorstates</a> - create a tree of constraint-arc successor states<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ssource is the state to be cloned, and sclone is the state to copy its<br/></li>
<li></span><span class="Comment"> * outarcs into.&nbsp; sclone's inarcs, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, should already be set up.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * spredecessor is the original predecessor state that we are trying to build<br/></li>
<li></span><span class="Comment"> * successors for (it may not be the immediate predecessor of ssource).<br/></li>
<li></span><span class="Comment"> * refarc, if not NULL, is the original constraint arc that is known to have<br/></li>
<li></span><span class="Comment"> * been traversed out of spredecessor to reach the successor(s).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For each cloned successor state, we transiently create a &quot;donemap&quot; that is<br/></li>
<li></span><span class="Comment"> * a boolean array showing which source states we've already visited for this<br/></li>
<li></span><span class="Comment"> * clone state.&nbsp; This prevents infinite recursion as well as useless <a href="regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a><br/></li>
<li></span><span class="Comment"> * visits to the same state subtree (which can add up fast, since typical NFAs<br/></li>
<li></span><span class="Comment"> * have multiple redundant arc pathways).&nbsp; Each donemap is a char array<br/></li>
<li></span><span class="Comment"> * indexed by state number.&nbsp; The donemaps are all of the same size &quot;nstates&quot;,<br/></li>
<li></span><span class="Comment"> * which is nfa-&gt;nstates as of the start of the recursion.&nbsp; This is enough to<br/></li>
<li></span><span class="Comment"> * have entries for all pre-existing states, but *not* entries for clone<br/></li>
<li></span><span class="Comment"> * states created during the recursion.&nbsp; That's okay since we have no need to<br/></li>
<li></span><span class="Comment"> * mark those.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * curdonemap is NULL when recursing to a new sclone state, or sclone's<br/></li>
<li></span><span class="Comment"> * donemap when we are recursing without having created a new state (which we<br/></li>
<li></span><span class="Comment"> * do when we decide we can <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> a successor state into the current clone<br/></li>
<li></span><span class="Comment"> * state).&nbsp; outerdonemap is NULL at the top level and otherwise the parent<br/></li>
<li></span><span class="Comment"> * clone state's donemap.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The successor states we create and fill here form a strict tree structure,<br/></li>
<li></span><span class="Comment"> * with each state having exactly one predecessor, except that the toplevel<br/></li>
<li></span><span class="Comment"> * state has no inarcs as yet (<a href="#L2551" title="regex/regc_nfa.c:2551">breakconstraintloop</a> will add its inarcs from<br/></li>
<li></span><span class="Comment"> * spredecessor after we're done).&nbsp; Thus, we can examine sclone's inarcs back<br/></li>
<li></span><span class="Comment"> * to the root, plus refarc if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, to identify the set of constraints already<br/></li>
<li></span><span class="Comment"> * known valid at the current point.&nbsp; This allows us to avoid generating extra<br/></li>
<li></span><span class="Comment"> * successor states.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2697">&#x200c;</a></span><span class="linkable">clonesuccessorstates</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *ssource,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *sclone,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *spredecessor,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> arc *refarc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *curdonemap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *outerdonemap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nstates)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *donemap;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Since this is recursive, it could be driven to stack overflow */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (STACK_TOO_DEEP(nfa-&gt;v-&gt;re))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L40" title="regex/regc_nfa.c:40">NERR</a>(REG_ETOOBIG);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If this state hasn't already got a donemap, create one */<br/></li>
<li></span>&nbsp; &nbsp; donemap = curdonemap;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (donemap == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; donemap = (<span class="Type">char</span> *) MALLOC(nstates * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (donemap == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L40" title="regex/regc_nfa.c:40">NERR</a>(REG_ESPACE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (outerdonemap != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Not at outermost recursion level, so copy the outer level's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * donemap; this ensures that we see states in process of being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * visited at outer levels, or already merged into predecessor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * states, as ones we shouldn't traverse back to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(donemap, outerdonemap, nstates * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* At outermost level, only spredecessor is off-limits */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memset(donemap, <span class="Constant">0</span>, nstates * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(spredecessor-&gt;no &lt; nstates);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; donemap[spredecessor-&gt;no] = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark ssource as visited in the donemap */<br/></li>
<li></span>&nbsp; &nbsp; assert(ssource-&gt;no &lt; nstates);<br/></li>
<li>&nbsp; &nbsp; assert(donemap[ssource-&gt;no] == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; donemap[ssource-&gt;no] = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We proceed by first cloning all of ssource's outarcs, creating new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clone states as needed but not doing more with them than that.&nbsp; Then in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a second pass, recurse to process the child clone states.&nbsp; This allows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * us to have only one child clone state per reachable source state, even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when there are multiple outarcs leading to the same state.&nbsp; Also, when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we do visit a child state, its set of inarcs is known exactly, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * makes it safe to apply the constraint-is-already-checked optimization.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, this ensures that we've merged all the states we can into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current clone <a href="regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we recurse to <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> children, thus possibly saving<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them from making extra images of those states.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * While this function runs, child clone states of the current state are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * marked by setting their tmp fields to point to the original state they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * were cloned from.&nbsp; This makes it possible to detect multiple outarcs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leading to the same state, and also makes it easy to distinguish clone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * states from original states (which will have tmp == NULL).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (a = ssource-&gt;outs; a != <span class="Constant">NULL</span> &amp;&amp; !<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>(); a = a-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *sto = a-&gt;to;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We do not consider cloning successor states that have no constraint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * outarcs; just link to them as-is.&nbsp; They cannot be part of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraint loop so there is no need to make copies.&nbsp; In particular,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this rule keeps us from trying to clone the post state, which would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be a bad idea.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2324" title="regex/regc_nfa.c:2324">isconstraintarc</a>(a) &amp;&amp; <a href="#L2342" title="regex/regc_nfa.c:2342">hasconstraintout</a>(sto))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *prevclone;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; canmerge;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *<a href="../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Back-link constraint arcs must not be followed.&nbsp; Nor is there a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to revisit states previously merged into this clone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(sto-&gt;no &lt; nstates);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (donemap[sto-&gt;no] != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check whether we already have a child clone state for this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * source state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevclone = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<a href="../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> = sclone-&gt;outs; <a href="../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> != <span class="Constant">NULL</span>; <a href="../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> = <a href="../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>-&gt;to-&gt;tmp == sto)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevclone = <a href="../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>-&gt;to;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this arc is labeled the same as refarc, or the same as <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * arc we must have traversed to get to sclone, then no additional<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraints need to be met to get to sto, so we should just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> its outarcs into sclone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (refarc &amp;&amp; a-&gt;type == refarc-&gt;type &amp;&amp; a-&gt;co == refarc-&gt;co)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; canmerge = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; canmerge = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (s = sclone; s-&gt;ins; s = s-&gt;ins-&gt;from)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;nins == <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a-&gt;type == s-&gt;ins-&gt;type &amp;&amp; a-&gt;co == s-&gt;ins-&gt;co)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; canmerge = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (canmerge)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> into sclone.&nbsp; If we previously made a child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clone state, drop it; there's no need to visit it.&nbsp; (This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can happen if ssource has multiple pathways to sto, and we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only just <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> found one that is provably a no-op.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prevclone)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L226" title="regex/regc_nfa.c:226">dropstate</a>(nfa, prevclone);&nbsp; &nbsp; <span class="Comment">/* kills our outarc, too */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse to <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> sto's outarcs into sclone */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2697" title="regex/regc_nfa.c:2697">clonesuccessorstates</a>(nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sto,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sclone,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; spredecessor,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; refarc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; donemap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outerdonemap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nstates);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* sto should <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> be marked as previously visited */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>() || donemap[sto-&gt;no] == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (prevclone)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We already have a clone state for this successor, so just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * make another arc to it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L608" title="regex/regc_nfa.c:608">cparc</a>(nfa, a, sclone, prevclone);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need to create a new successor clone state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *stoclone;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stoclone = <a href="#L137" title="regex/regc_nfa.c:137">newstate</a>(nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stoclone == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark it as to what it's a clone of */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stoclone-&gt;tmp = sto;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and add the outarc leading to it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L608" title="regex/regc_nfa.c:608">cparc</a>(nfa, a, sclone, stoclone);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Non-constraint outarcs just get copied to sclone, as do outarcs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leading to states with no constraint outarc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L608" title="regex/regc_nfa.c:608">cparc</a>(nfa, a, sclone, sto);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are at outer level for this clone state, recurse to all its child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clone states, clearing their tmp fields as we go.&nbsp; (If we're not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * outermost for sclone, leave this to be done by the outer call level.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that if we have multiple outarcs leading to the same clone state,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it will only be recursed-to once.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (curdonemap == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (a = sclone-&gt;outs; a != <span class="Constant">NULL</span> &amp;&amp; !<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>(); a = a-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *stoclone = a-&gt;to;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *sto = stoclone-&gt;tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sto != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stoclone-&gt;tmp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2697" title="regex/regc_nfa.c:2697">clonesuccessorstates</a>(nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sto,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stoclone,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; spredecessor,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; refarc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; donemap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nstates);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't forget to free sclone's donemap when done with it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; FREE(donemap);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2929" title="regex/regc_nfa.c:2929">cleanup</a> - clean up NFA after optimizations<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2929">&#x200c;</a></span><span class="linkable">cleanup</span>(<span class="Type">struct</span> nfa *nfa)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *s;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *nexts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* clear out unreachable or dead-end states */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* use pre to mark reachable, then post to mark can-reach-post */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2964" title="regex/regc_nfa.c:2964">markreachable</a>(nfa, nfa-&gt;pre, (<span class="Type">struct</span> state *) <span class="Constant">NULL</span>, nfa-&gt;pre);<br/></li>
<li>&nbsp; &nbsp; <a href="#L2990" title="regex/regc_nfa.c:2990">markcanreach</a>(nfa, nfa-&gt;post, nfa-&gt;pre, nfa-&gt;post);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (s = nfa-&gt;states; s != <span class="Constant">NULL</span> &amp;&amp; !<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>(); s = nexts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nexts = s-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;tmp != nfa-&gt;post &amp;&amp; !s-&gt;flag)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L226" title="regex/regc_nfa.c:226">dropstate</a>(nfa, s);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; assert(<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>() || nfa-&gt;post-&gt;nins == <span class="Constant">0</span> || nfa-&gt;post-&gt;tmp == nfa-&gt;post);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1487" title="regex/regc_nfa.c:1487">cleartraverse</a>(nfa, nfa-&gt;pre);<br/></li>
<li>&nbsp; &nbsp; assert(<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>() || nfa-&gt;post-&gt;nins == <span class="Constant">0</span> || nfa-&gt;post-&gt;tmp == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the nins==0 (final unreachable) case will be caught later */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* renumber surviving states */<br/></li>
<li></span>&nbsp; &nbsp; n = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (s = nfa-&gt;states; s != <span class="Constant">NULL</span>; s = s-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s-&gt;no = n++;<br/></li>
<li>&nbsp; &nbsp; nfa-&gt;nstates = n;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2964" title="regex/regc_nfa.c:2964">markreachable</a> - recursive marking of reachable states<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2964">&#x200c;</a></span><span class="linkable">markreachable</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *s,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *okay,&nbsp; &nbsp; <span class="Comment">/* consider only states with this mark */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *mark)&nbsp; &nbsp; <span class="Comment">/* the value to mark with */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Since this is recursive, it could be driven to stack overflow */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (STACK_TOO_DEEP(nfa-&gt;v-&gt;re))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L40" title="regex/regc_nfa.c:40">NERR</a>(REG_ETOOBIG);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;tmp != okay)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;tmp = mark;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (a = s-&gt;outs; a != <span class="Constant">NULL</span>; a = a-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2964" title="regex/regc_nfa.c:2964">markreachable</a>(nfa, a-&gt;to, okay, mark);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2990" title="regex/regc_nfa.c:2990">markcanreach</a> - recursive marking of states which can reach here<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2990">&#x200c;</a></span><span class="linkable">markcanreach</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *s,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *okay,&nbsp; &nbsp; <span class="Comment">/* consider only states with this mark */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *mark)&nbsp; &nbsp; <span class="Comment">/* the value to mark with */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Since this is recursive, it could be driven to stack overflow */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (STACK_TOO_DEEP(nfa-&gt;v-&gt;re))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L40" title="regex/regc_nfa.c:40">NERR</a>(REG_ETOOBIG);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;tmp != okay)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;tmp = mark;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (a = s-&gt;ins; a != <span class="Constant">NULL</span>; a = a-&gt;inchain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2990" title="regex/regc_nfa.c:2990">markcanreach</a>(nfa, a-&gt;from, okay, mark);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3016" title="regex/regc_nfa.c:3016">analyze</a> - ascertain potentially-useful facts about an optimized NFA<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* re_info bits to be ORed in */<br/></li>
<li><a id="L3016">&#x200c;</a></span><span class="linkable">analyze</span>(<span class="Type">struct</span> nfa *nfa)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *aa;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Detect whether NFA can't match anything */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nfa-&gt;pre-&gt;outs == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_UIMPOSSIBLE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Detect whether NFA matches all strings (possibly with length bounds) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3062" title="regex/regc_nfa.c:3062">checkmatchall</a>(nfa);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Detect whether NFA can possibly match a zero-length string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (a = nfa-&gt;pre-&gt;outs; a != <span class="Constant">NULL</span>; a = a-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (aa = a-&gt;to-&gt;outs; aa != <span class="Constant">NULL</span>; aa = aa-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aa-&gt;to == nfa-&gt;post)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_UEMPTYMATCH;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3062" title="regex/regc_nfa.c:3062">checkmatchall</a> - does the NFA represent no more than a string length test?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If so, set nfa-&gt;minmatchall and nfa-&gt;maxmatchall correctly (they are -1<br/></li>
<li></span><span class="Comment"> * to begin with) and set the MATCHALL <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> in nfa-&gt;flags.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To succeed, we require all arcs to be <a href="regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a> RAINBOW arcs, except for those<br/></li>
<li></span><span class="Comment"> * for pseudocolors (i.e., BOS/BOL/<a href="regcomp.c.html#L329" title="regex/regcomp.c:329">EOS</a>/EOL).&nbsp; We must be able to reach the<br/></li>
<li></span><span class="Comment"> * post state via RAINBOW arcs, and if there are <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> loops in the graph, they<br/></li>
<li></span><span class="Comment"> * must be loop-to-self arcs, ensuring that each loop iteration consumes<br/></li>
<li></span><span class="Comment"> * exactly one character.&nbsp; (Longer loops are problematic because they create<br/></li>
<li></span><span class="Comment"> * non-consecutive possible match lengths; we have no good way to represent<br/></li>
<li></span><span class="Comment"> * that situation for lengths beyond the DUPINF limit.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Pseudocolor arcs complicate things a little.&nbsp; We know that they can only<br/></li>
<li></span><span class="Comment"> * appear as pre-state outarcs (for BOS/BOL) or post-state inarcs (for<br/></li>
<li></span><span class="Comment"> * <a href="regcomp.c.html#L329" title="regex/regcomp.c:329">EOS</a>/EOL).&nbsp; There, they must exactly replicate the parallel RAINBOW arcs,<br/></li>
<li></span><span class="Comment"> * e.g. if the pre state has one RAINBOW outarc to state 2, it must have BOS<br/></li>
<li></span><span class="Comment"> * and BOL outarcs to state 2, and no others.&nbsp; Missing or extra <a href="regc_color.c.html#L312" title="regex/regc_color.c:312">pseudocolor</a><br/></li>
<li></span><span class="Comment"> * arcs can occur, meaning that the NFA involves some constraint on the<br/></li>
<li></span><span class="Comment"> * adjacent characters, which makes it not a matchall NFA.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3062">&#x200c;</a></span><span class="linkable">checkmatchall</span>(<span class="Type">struct</span> nfa *nfa)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; **haspaths;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *s;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are too many states, don't bother trying to detect matchall.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This limit serves to bound the time and memory we could consume below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that even if the graph is all-RAINBOW, if there are significantly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more than DUPINF states then it's likely that there are paths of length<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more than DUPINF, which would force us to fail anyhow.&nbsp; In practice,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plausible ways of writing a matchall regex with maximum finite path<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * length K tend not to have very many more than K states.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nfa-&gt;nstates &gt; DUPINF * <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, scan all the states to verify that only RAINBOW arcs appear,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plus <a href="regc_color.c.html#L312" title="regex/regc_color.c:312">pseudocolor</a> arcs adjacent to the pre and post states.&nbsp; This lets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * us quickly eliminate most cases that aren't matchall NFAs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (s = nfa-&gt;states; s != <span class="Constant">NULL</span>; s = s-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (a = s-&gt;outs; a != <span class="Constant">NULL</span>; a = a-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;type != <a href="regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> LACONs make it non-matchall */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;co != RAINBOW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nfa-&gt;cm-&gt;cd[a-&gt;co].flags &amp; PSEUDO)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pseudocolor arc: verify it's in a valid place (this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * seems quite unlikely to fail, but let's be sure).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s == nfa-&gt;pre &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (a-&gt;co == nfa-&gt;bos[<span class="Constant">0</span>] || a-&gt;co == nfa-&gt;bos[<span class="Constant">1</span>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* okay BOS/BOL arc */</span> ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (a-&gt;to == nfa-&gt;post &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (a-&gt;co == nfa-&gt;eos[<span class="Constant">0</span>] || a-&gt;co == nfa-&gt;eos[<span class="Constant">1</span>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* okay <a href="regcomp.c.html#L329" title="regex/regcomp.c:329">EOS</a>/EOL arc */</span> ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>; <span class="Comment">/* unexpected <a href="regc_color.c.html#L312" title="regex/regc_color.c:312">pseudocolor</a> arc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We'll check these arcs some more below. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other color makes it non-matchall */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Also, assert that the tmp fields are available for use. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; assert(s-&gt;tmp == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The <a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> cheapest check we can make is to verify that the BOS/BOL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * outarcs of the pre state reach the same states as its RAINBOW outarcs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If they don't, the NFA expresses some constraints on the character<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the matched string, making it non-matchall.&nbsp; Likewise, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="regcomp.c.html#L329" title="regex/regcomp.c:329">EOS</a>/EOL inarcs of the post state must match its RAINBOW inarcs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3380" title="regex/regc_nfa.c:3380">check_out_colors_match</a>(nfa-&gt;pre, RAINBOW, nfa-&gt;bos[<span class="Constant">0</span>]) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L3380" title="regex/regc_nfa.c:3380">check_out_colors_match</a>(nfa-&gt;pre, RAINBOW, nfa-&gt;bos[<span class="Constant">1</span>]) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L3434" title="regex/regc_nfa.c:3434">check_in_colors_match</a>(nfa-&gt;post, RAINBOW, nfa-&gt;eos[<span class="Constant">0</span>]) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L3434" title="regex/regc_nfa.c:3434">check_in_colors_match</a>(nfa-&gt;post, RAINBOW, nfa-&gt;eos[<span class="Constant">1</span>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize an array of path-length arrays, in which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L3242" title="regex/regc_nfa.c:3242">checkmatchall_recurse</a> will return per-state results.&nbsp; This lets us<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memo-ize the recursive search and avoid exponential time consumption.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; haspaths = (<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> **) MALLOC(nfa-&gt;nstates * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (haspaths == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fail quietly */<br/></li>
<li></span>&nbsp; &nbsp; memset(haspaths, <span class="Constant">0</span>, nfa-&gt;nstates * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Recursively search the graph for all-RAINBOW paths to the &quot;post&quot; state,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * starting at the &quot;pre&quot; state, and computing the lengths of the paths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Given the preceding checks, there should be at least one such path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However we could get back a false result anyway, in case there are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multi-state loops, paths exceeding DUPINF+1 length, or non-algorithmic<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * failures such as ENOMEM.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3242" title="regex/regc_nfa.c:3242">checkmatchall_recurse</a>(nfa, nfa-&gt;pre, haspaths))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The useful result is the path length array for the pre state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *haspath = haspaths[nfa-&gt;pre-&gt;no];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minmatch,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxmatch,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; morematch;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(haspath != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * haspath[] <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> represents the set of possible path lengths; but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * want to reduce that to a min and max value, because it doesn't seem<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * worth complicating regexec.c to deal with nonconsecutive possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * match lengths.&nbsp; Find min and max of first run of lengths, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * verify there are no nonconsecutive lengths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (minmatch = <span class="Constant">0</span>; minmatch &lt;= DUPINF + <span class="Constant">1</span>; minmatch++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (haspath[minmatch])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(minmatch &lt;= DUPINF + <span class="Constant">1</span>); <span class="Comment">/* else <a href="#L3242" title="regex/regc_nfa.c:3242">checkmatchall_recurse</a> lied */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (maxmatch = minmatch; maxmatch &lt; DUPINF + <span class="Constant">1</span>; maxmatch++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!haspath[maxmatch + <span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (morematch = maxmatch + <span class="Constant">1</span>; morematch &lt;= DUPINF + <span class="Constant">1</span>; morematch++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (haspath[morematch])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; haspath = <span class="Constant">NULL</span>; <span class="Comment">/* fail, there are nonconsecutive lengths */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (haspath != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Success, so record the info.&nbsp; Here we have a fine point: the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * path length from the pre state includes the pre-to-initial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transition, so it's one more than the actually matched string<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * length.&nbsp; (We avoided counting the final-to-post transition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * within <a href="#L3242" title="regex/regc_nfa.c:3242">checkmatchall_recurse</a>, but not this one.)&nbsp; This is why<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L3242" title="regex/regc_nfa.c:3242">checkmatchall_recurse</a> allows one more level of path length than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might seem necessary.&nbsp; This decrement also takes care of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * converting <a href="#L3242" title="regex/regc_nfa.c:3242">checkmatchall_recurse</a>'s definition of &quot;infinity&quot; as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;DUPINF+1&quot; to our normal representation as &quot;DUPINF&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(minmatch &gt; <span class="Constant">0</span>);&nbsp; &nbsp; <span class="Comment">/* else pre and post states were adjacent */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nfa-&gt;minmatchall = minmatch - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nfa-&gt;maxmatchall = maxmatch - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nfa-&gt;flags |= MATCHALL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean up */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nfa-&gt;nstates; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (haspaths[i] != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FREE(haspaths[i]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; FREE(haspaths);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3242" title="regex/regc_nfa.c:3242">checkmatchall_recurse</a> - recursive search for <a href="#L3062" title="regex/regc_nfa.c:3062">checkmatchall</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * s is the state to be examined in this recursion level.<br/></li>
<li></span><span class="Comment"> * haspaths[] is an array of per-state exit path length arrays.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We return true if the search was performed successfully, false if<br/></li>
<li></span><span class="Comment"> * we had to fail because of multi-state loops or other <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> reasons.<br/></li>
<li></span><span class="Comment"> * (Because &quot;dead&quot; states that can't reach the post state have been<br/></li>
<li></span><span class="Comment"> * eliminated, and we already verified that only RAINBOW and matching<br/></li>
<li></span><span class="Comment"> * <a href="regc_color.c.html#L312" title="regex/regc_color.c:312">pseudocolor</a> arcs exist, every state should have RAINBOW path(s) to<br/></li>
<li></span><span class="Comment"> * the post state.&nbsp; Hence we take a false result from recursive calls<br/></li>
<li></span><span class="Comment"> * as meaning that we'd better fail altogether, not just that that<br/></li>
<li></span><span class="Comment"> * particular state can't reach the post state.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On success, we store a malloc'd result array in haspaths[s-&gt;no],<br/></li>
<li></span><span class="Comment"> * showing the possible path lengths from s to the post state.<br/></li>
<li></span><span class="Comment"> * Each state's haspath[] array is of length DUPINF+2.&nbsp; The entries from<br/></li>
<li></span><span class="Comment"> * k = 0 to DUPINF are true if there is an all-RAINBOW path of length k<br/></li>
<li></span><span class="Comment"> * from this state to the string end.&nbsp; haspath[DUPINF+1] is true if all<br/></li>
<li></span><span class="Comment"> * path lengths &gt;= DUPINF+1 are possible.&nbsp; (Situations that cannot be<br/></li>
<li></span><span class="Comment"> * represented under these rules cause failure.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L3062" title="regex/regc_nfa.c:3062">checkmatchall</a> is responsible for eventually freeing the haspath[] arrays.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3242">&#x200c;</a></span><span class="linkable">checkmatchall_recurse</span>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> state *s, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> **haspaths)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; foundloop = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *haspath;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since this is recursive, it could be driven to stack overflow.&nbsp; But we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need not treat that as a hard failure; just deem the NFA non-matchall.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (STACK_TOO_DEEP(nfa-&gt;v-&gt;re))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* In case the search takes a long time, check for cancel */<br/></li>
<li></span>&nbsp; &nbsp; INTERRUPT(nfa-&gt;v-&gt;re);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create a haspath array for this state */<br/></li>
<li></span>&nbsp; &nbsp; haspath = (<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) MALLOC((DUPINF + <span class="Constant">2</span>) * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (haspath == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* again, treat as non-matchall */<br/></li>
<li></span>&nbsp; &nbsp; memset(haspath, <span class="Constant">0</span>, (DUPINF + <span class="Constant">2</span>) * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark this state as being visited */<br/></li>
<li></span>&nbsp; &nbsp; assert(s-&gt;tmp == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; s-&gt;tmp = s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (a = s-&gt;outs; a != <span class="Constant">NULL</span>; a = a-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;co != RAINBOW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore <a href="regc_color.c.html#L312" title="regex/regc_color.c:312">pseudocolor</a> arcs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;to == nfa-&gt;post)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We found an all-RAINBOW path to the post state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Mark this state as being zero steps away from the string end<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (the transition to the post state isn't counted).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; haspath[<span class="Constant">0</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (a-&gt;to == s)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We found a cycle of length 1, which we'll deal with below. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foundloop = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (a-&gt;to-&gt;tmp != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It's busy, so we found a cycle of length &gt; 1, so fail. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Consider paths forward through this to-state. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nexthaspath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If to-state was not already visited, recurse */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (haspaths[a-&gt;to-&gt;no] == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L3242" title="regex/regc_nfa.c:3242">checkmatchall_recurse</a>(nfa, a-&gt;to, haspaths);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fail if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> recursive path fails */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!result)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The previous visit must have found path(s) to the end */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(a-&gt;to-&gt;tmp == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nexthaspath = haspaths[a-&gt;to-&gt;no];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(nexthaspath != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now, for every path of length i from a-&gt;to to the string end,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there is a path of length i + 1 from s to the string end.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nexthaspath[DUPINF] != nexthaspath[DUPINF + <span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a-&gt;to has a path of length exactly DUPINF, but not longer;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or it has paths of all lengths &gt; DUPINF but not one of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exactly that length.&nbsp; In either case, we cannot represent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the possible path lengths from s correctly, so fail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Merge knowledge of these path lengths into what we have */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; DUPINF; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; haspath[i + <span class="Constant">1</span>] |= nexthaspath[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Infinity + 1 is still infinity */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; haspath[DUPINF + <span class="Constant">1</span>] |= nexthaspath[DUPINF + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result &amp;&amp; foundloop)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there is a length-1 loop at this state, then <a href="regexec.c.html#L419" title="regex/regexec.c:419">find</a> the <a href="rege_dfa.c.html#L204" title="regex/rege_dfa.c:204">shortest</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * known path length to the end.&nbsp; The loop means that every larger<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * path length is possible, too.&nbsp; (It doesn't matter whether <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the longer lengths were already known possible.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt;= DUPINF; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (haspath[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i++; i &lt;= DUPINF + <span class="Constant">1</span>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; haspath[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report out the completed path length map */<br/></li>
<li></span>&nbsp; &nbsp; assert(s-&gt;no &lt; nfa-&gt;nstates);<br/></li>
<li>&nbsp; &nbsp; assert(haspaths[s-&gt;no] == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; haspaths[s-&gt;no] = haspath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark state no longer busy */<br/></li>
<li></span>&nbsp; &nbsp; s-&gt;tmp = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3380" title="regex/regc_nfa.c:3380">check_out_colors_match</a> - subroutine for <a href="#L3062" title="regex/regc_nfa.c:3062">checkmatchall</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check whether the set of states reachable from s by arcs of color co1<br/></li>
<li></span><span class="Comment"> * is equivalent to the set reachable by arcs of color co2.<br/></li>
<li></span><span class="Comment"> * <a href="#L3062" title="regex/regc_nfa.c:3062">checkmatchall</a> already verified that all of the NFA's arcs are <a href="regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a>,<br/></li>
<li></span><span class="Comment"> * so we need not examine arc types here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3380">&#x200c;</a></span><span class="linkable">check_out_colors_match</span>(<span class="Type">struct</span> state *s, color co1, color co2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To do this in linear time, we assume that the NFA contains no duplicate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * arcs.&nbsp; Run through the out-arcs, marking states reachable by arcs of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * color co1.&nbsp; Run through again, un-marking states reachable by arcs of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * color co2; if we see a not-marked state, we know this co2 arc is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unmatched.&nbsp; Then run through again, checking for still-marked states,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case leaving all the tmp fields reset to NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (a = s-&gt;outs; a != <span class="Constant">NULL</span>; a = a-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;co == co1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(a-&gt;to-&gt;tmp == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a-&gt;to-&gt;tmp = a-&gt;to;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (a = s-&gt;outs; a != <span class="Constant">NULL</span>; a = a-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;co == co2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;to-&gt;tmp != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a-&gt;to-&gt;tmp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>; <span class="Comment">/* unmatched co2 arc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (a = s-&gt;outs; a != <span class="Constant">NULL</span>; a = a-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;co == co1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;to-&gt;tmp != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>; <span class="Comment">/* unmatched co1 arc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a-&gt;to-&gt;tmp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3434" title="regex/regc_nfa.c:3434">check_in_colors_match</a> - subroutine for <a href="#L3062" title="regex/regc_nfa.c:3062">checkmatchall</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check whether the set of states that can reach s by arcs of color co1<br/></li>
<li></span><span class="Comment"> * is equivalent to the set that can reach s by arcs of color co2.<br/></li>
<li></span><span class="Comment"> * <a href="#L3062" title="regex/regc_nfa.c:3062">checkmatchall</a> already verified that all of the NFA's arcs are <a href="regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a>,<br/></li>
<li></span><span class="Comment"> * so we need not examine arc types here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3434">&#x200c;</a></span><span class="linkable">check_in_colors_match</span>(<span class="Type">struct</span> state *s, color co1, color co2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Identical algorithm to <a href="#L3380" title="regex/regc_nfa.c:3380">check_out_colors_match</a>, except examine the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from-states of s' inarcs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (a = s-&gt;ins; a != <span class="Constant">NULL</span>; a = a-&gt;inchain)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;co == co1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(a-&gt;from-&gt;tmp == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a-&gt;from-&gt;tmp = a-&gt;from;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (a = s-&gt;ins; a != <span class="Constant">NULL</span>; a = a-&gt;inchain)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;co == co2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;from-&gt;tmp != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a-&gt;from-&gt;tmp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>; <span class="Comment">/* unmatched co2 arc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (a = s-&gt;ins; a != <span class="Constant">NULL</span>; a = a-&gt;inchain)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;co == co1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;from-&gt;tmp != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>; <span class="Comment">/* unmatched co1 arc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a-&gt;from-&gt;tmp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3479" title="regex/regc_nfa.c:3479">compact</a> - construct the <a href="#L3479" title="regex/regc_nfa.c:3479">compact</a> representation of an NFA<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3479">&#x200c;</a></span><span class="linkable">compact</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> cnfa *cnfa)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *s;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; nstates;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; narcs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> carc *ca;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> carc *first;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(!<a href="#L39" title="regex/regc_nfa.c:39">NISERR</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nstates = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; narcs = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (s = nfa-&gt;states; s != <span class="Constant">NULL</span>; s = s-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nstates++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; narcs += s-&gt;nouts + <span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* need one extra for endmarker */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cnfa-&gt;stflags = (<span class="Type">char</span> *) MALLOC(nstates * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span>));<br/></li>
<li>&nbsp; &nbsp; cnfa-&gt;states = (<span class="Type">struct</span> carc **) MALLOC(nstates * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> carc *));<br/></li>
<li>&nbsp; &nbsp; cnfa-&gt;arcs = (<span class="Type">struct</span> carc *) MALLOC(narcs * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> carc));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cnfa-&gt;stflags == <span class="Constant">NULL</span> || cnfa-&gt;states == <span class="Constant">NULL</span> || cnfa-&gt;arcs == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cnfa-&gt;stflags != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FREE(cnfa-&gt;stflags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cnfa-&gt;states != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FREE(cnfa-&gt;states);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cnfa-&gt;arcs != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FREE(cnfa-&gt;arcs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L40" title="regex/regc_nfa.c:40">NERR</a>(REG_ESPACE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; cnfa-&gt;nstates = nstates;<br/></li>
<li>&nbsp; &nbsp; cnfa-&gt;pre = nfa-&gt;pre-&gt;no;<br/></li>
<li>&nbsp; &nbsp; cnfa-&gt;post = nfa-&gt;post-&gt;no;<br/></li>
<li>&nbsp; &nbsp; cnfa-&gt;bos[<span class="Constant">0</span>] = nfa-&gt;bos[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; cnfa-&gt;bos[<span class="Constant">1</span>] = nfa-&gt;bos[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; cnfa-&gt;eos[<span class="Constant">0</span>] = nfa-&gt;eos[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; cnfa-&gt;eos[<span class="Constant">1</span>] = nfa-&gt;eos[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; cnfa-&gt;ncolors = <a href="regc_color.c.html#L172" title="regex/regc_color.c:172">maxcolor</a>(nfa-&gt;cm) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; cnfa-&gt;flags = nfa-&gt;flags;<br/></li>
<li>&nbsp; &nbsp; cnfa-&gt;minmatchall = nfa-&gt;minmatchall;<br/></li>
<li>&nbsp; &nbsp; cnfa-&gt;maxmatchall = nfa-&gt;maxmatchall;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ca = cnfa-&gt;arcs;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (s = nfa-&gt;states; s != <span class="Constant">NULL</span>; s = s-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert((<span class="Type">size_t</span>) s-&gt;no &lt; nstates);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cnfa-&gt;stflags[s-&gt;no] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cnfa-&gt;states[s-&gt;no] = ca;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; first = ca;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (a = s-&gt;outs; a != <span class="Constant">NULL</span>; a = a-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (a-&gt;type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ca-&gt;co = a-&gt;co;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ca-&gt;to = a-&gt;to-&gt;no;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ca++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="regcomp.c.html#L340" title="regex/regcomp.c:340">LACON</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(s-&gt;no != cnfa-&gt;pre);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(a-&gt;co &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ca-&gt;co = (color) (cnfa-&gt;ncolors + a-&gt;co);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ca-&gt;to = a-&gt;to-&gt;no;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ca++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnfa-&gt;flags |= HASLACONS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L40" title="regex/regc_nfa.c:40">NERR</a>(REG_ASSERT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3570" title="regex/regc_nfa.c:3570">carcsort</a>(first, ca - first);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ca-&gt;co = COLORLESS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ca-&gt;to = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ca++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; assert(ca == &amp;cnfa-&gt;arcs[narcs]);<br/></li>
<li>&nbsp; &nbsp; assert(cnfa-&gt;nstates != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* mark no-progress states */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (a = nfa-&gt;pre-&gt;outs; a != <span class="Constant">NULL</span>; a = a-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cnfa-&gt;stflags[a-&gt;to-&gt;no] = CNFA_NOPROGRESS;<br/></li>
<li>&nbsp; &nbsp; cnfa-&gt;stflags[nfa-&gt;pre-&gt;no] = CNFA_NOPROGRESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3570" title="regex/regc_nfa.c:3570">carcsort</a> - sort compacted-NFA arcs by color<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3570">&#x200c;</a></span><span class="linkable">carcsort</span>(<span class="Type">struct</span> carc *first, <span class="Type">size_t</span> n)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (n &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qsort(first, n, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> carc), <a href="#L3577" title="regex/regc_nfa.c:3577">carc_cmp</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L3577">&#x200c;</a></span><span class="linkable">carc_cmp</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">struct</span> carc *aa = (<span class="Type">const</span> <span class="Type">struct</span> carc *) a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">struct</span> carc *bb = (<span class="Type">const</span> <span class="Type">struct</span> carc *) b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aa-&gt;co &lt; bb-&gt;co)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aa-&gt;co &gt; bb-&gt;co)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> +<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aa-&gt;to &lt; bb-&gt;to)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aa-&gt;to &gt; bb-&gt;to)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> +<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This is unreached, since there should be no duplicate arcs <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>: */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3598" title="regex/regc_nfa.c:3598">freecnfa</a> - free a compacted NFA<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3598">&#x200c;</a></span><span class="linkable">freecnfa</span>(<span class="Type">struct</span> cnfa *cnfa)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; assert(!NULLCNFA(*cnfa));&nbsp; &nbsp; <span class="Comment">/* not empty already */<br/></li>
<li></span>&nbsp; &nbsp; FREE(cnfa-&gt;stflags);<br/></li>
<li>&nbsp; &nbsp; FREE(cnfa-&gt;states);<br/></li>
<li>&nbsp; &nbsp; FREE(cnfa-&gt;arcs);<br/></li>
<li>&nbsp; &nbsp; ZAPCNFA(*cnfa);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3611" title="regex/regc_nfa.c:3611">dumpnfa</a> - <a href="regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> an NFA in human-readable form<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3611">&#x200c;</a></span><span class="linkable">dumpnfa</span>(<span class="Type">struct</span> nfa *nfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">FILE</span> *f)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef REG_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> state *s;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nstates = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; narcs = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;pre </span><span class="Special">%d</span><span class="Constant">, post </span><span class="Special">%d</span><span class="Constant">&quot;</span>, nfa-&gt;pre-&gt;no, nfa-&gt;post-&gt;no);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nfa-&gt;bos[<span class="Constant">0</span>] != COLORLESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;, bos [</span><span class="Special">%ld</span><span class="Constant">]&quot;</span>, (<span class="Type">long</span>) nfa-&gt;bos[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nfa-&gt;bos[<span class="Constant">1</span>] != COLORLESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;, bol [</span><span class="Special">%ld</span><span class="Constant">]&quot;</span>, (<span class="Type">long</span>) nfa-&gt;bos[<span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nfa-&gt;eos[<span class="Constant">0</span>] != COLORLESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;, eos [</span><span class="Special">%ld</span><span class="Constant">]&quot;</span>, (<span class="Type">long</span>) nfa-&gt;eos[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nfa-&gt;eos[<span class="Constant">1</span>] != COLORLESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;, eol [</span><span class="Special">%ld</span><span class="Constant">]&quot;</span>, (<span class="Type">long</span>) nfa-&gt;eos[<span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nfa-&gt;flags &amp; HASLACONS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;, haslacons&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nfa-&gt;flags &amp; MATCHALL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;, minmatchall </span><span class="Special">%d</span><span class="Constant">&quot;</span>, nfa-&gt;minmatchall);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nfa-&gt;maxmatchall == DUPINF)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;, maxmatchall inf&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;, maxmatchall </span><span class="Special">%d</span><span class="Constant">&quot;</span>, nfa-&gt;maxmatchall);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (s = nfa-&gt;states; s != <span class="Constant">NULL</span>; s = s-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3658" title="regex/regc_nfa.c:3658">dumpstate</a>(s, f);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nstates++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; narcs += s-&gt;nouts;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;total of </span><span class="Special">%d</span><span class="Constant"> states, </span><span class="Special">%d</span><span class="Constant"> arcs</span><span class="Special">\n</span><span class="Constant">&quot;</span>, nstates, narcs);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nfa-&gt;parent == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_color.c.html#L1111" title="regex/regc_color.c:1111">dumpcolors</a>(nfa-&gt;cm, f);<br/></li>
<li>&nbsp; &nbsp; fflush(f);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef REG_DEBUG&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* subordinates of <a href="#L3611" title="regex/regc_nfa.c:3611">dumpnfa</a> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3658" title="regex/regc_nfa.c:3658">dumpstate</a> - <a href="regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> an NFA state in human-readable form<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3658">&#x200c;</a></span><span class="linkable">dumpstate</span>(<span class="Type">struct</span> state *s,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">FILE</span> *f)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">%d%s%c</span><span class="Constant">&quot;</span>, s-&gt;no, (s-&gt;tmp != <span class="Constant">NULL</span>) ? <span class="Constant">&quot;T&quot;</span> : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (s-&gt;flag) ? s-&gt;flag : <span class="Constant">'.'</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;prev != <span class="Constant">NULL</span> &amp;&amp; s-&gt;prev-&gt;<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> != s)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">\t</span><span class="Constant">state chain bad</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;nouts == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">\t</span><span class="Constant">no out arcs</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3684" title="regex/regc_nfa.c:3684">dumparcs</a>(s, f);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (a = s-&gt;ins; a != <span class="Constant">NULL</span>; a = a-&gt;inchain)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;to != s)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">\t</span><span class="Constant">link from </span><span class="Special">%d</span><span class="Constant"> to </span><span class="Special">%d</span><span class="Constant"> on </span><span class="Special">%d</span><span class="Constant">'s in-chain</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a-&gt;from-&gt;no, a-&gt;to-&gt;no, s-&gt;no);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; fflush(f);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3684" title="regex/regc_nfa.c:3684">dumparcs</a> - <a href="regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> out-arcs in human-readable form<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3684">&#x200c;</a></span><span class="linkable">dumparcs</span>(<span class="Type">struct</span> state *s,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">FILE</span> *f)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* printing oldest arcs first is usually clearer */<br/></li>
<li></span>&nbsp; &nbsp; a = s-&gt;outs;<br/></li>
<li>&nbsp; &nbsp; assert(a != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (a-&gt;outchain != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a = a-&gt;outchain;<br/></li>
<li>&nbsp; &nbsp; pos = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3716" title="regex/regc_nfa.c:3716">dumparc</a>(a, s, f);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pos == <span class="Constant">5</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a = a-&gt;outchainRev;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (a != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pos != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3716" title="regex/regc_nfa.c:3716">dumparc</a> - <a href="regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> one outarc in readable form, including prefixing tab<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3716">&#x200c;</a></span><span class="linkable">dumparc</span>(<span class="Type">struct</span> arc *a,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *s,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">FILE</span> *f)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *aa;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">\t</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (a-&gt;type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;co == RAINBOW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;[*]&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;[</span><span class="Special">%ld</span><span class="Constant">]&quot;</span>, (<span class="Type">long</span>) a-&gt;co);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="regcomp.c.html#L341" title="regex/regcomp.c:341">AHEAD</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;co == RAINBOW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;&gt;*&gt;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;&gt;</span><span class="Special">%ld</span><span class="Constant">&gt;&quot;</span>, (<span class="Type">long</span>) a-&gt;co);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="regcomp.c.html#L342" title="regex/regcomp.c:342">BEHIND</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;co == RAINBOW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;&lt;*&lt;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;&lt;</span><span class="Special">%ld</span><span class="Constant">&lt;&quot;</span>, (<span class="Type">long</span>) a-&gt;co);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="regcomp.c.html#L340" title="regex/regcomp.c:340">LACON</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;:</span><span class="Special">%ld</span><span class="Constant">:&quot;</span>, (<span class="Type">long</span>) a-&gt;co);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'^'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'$'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">%c%d</span><span class="Constant">&quot;</span>, a-&gt;type, (<span class="Type">int</span>) a-&gt;co);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;0x</span><span class="Special">%x</span><span class="Constant">/0</span><span class="Special">%lo</span><span class="Constant">&quot;</span>, a-&gt;type, (<span class="Type">long</span>) a-&gt;co);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;from != s)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;?</span><span class="Special">%d</span><span class="Constant">?&quot;</span>, a-&gt;from-&gt;no);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (aa = a-&gt;from-&gt;outs; aa != <span class="Constant">NULL</span>; aa = aa-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aa == a)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a> BREAK OUT */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (aa == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;?!?&quot;</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* missing from out-chain */<br/></li>
<li></span>&nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;-&gt;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;to == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;NULL&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, a-&gt;to-&gt;no);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (aa = a-&gt;to-&gt;ins; aa != <span class="Constant">NULL</span>; aa = aa-&gt;inchain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aa == a)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a> BREAK OUT */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (aa == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;?!?&quot;</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* missing from in-chain */<br/></li>
<li></span>}<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* REG_DEBUG */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3783" title="regex/regc_nfa.c:3783">dumpcnfa</a> - <a href="regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> a compacted NFA in human-readable form<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef REG_DEBUG<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3783">&#x200c;</a></span><span class="linkable">dumpcnfa</span>(<span class="Type">struct</span> cnfa *cnfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">FILE</span> *f)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; st;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;pre </span><span class="Special">%d</span><span class="Constant">, post </span><span class="Special">%d</span><span class="Constant">&quot;</span>, cnfa-&gt;pre, cnfa-&gt;post);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cnfa-&gt;bos[<span class="Constant">0</span>] != COLORLESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;, bos [</span><span class="Special">%ld</span><span class="Constant">]&quot;</span>, (<span class="Type">long</span>) cnfa-&gt;bos[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cnfa-&gt;bos[<span class="Constant">1</span>] != COLORLESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;, bol [</span><span class="Special">%ld</span><span class="Constant">]&quot;</span>, (<span class="Type">long</span>) cnfa-&gt;bos[<span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cnfa-&gt;eos[<span class="Constant">0</span>] != COLORLESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;, eos [</span><span class="Special">%ld</span><span class="Constant">]&quot;</span>, (<span class="Type">long</span>) cnfa-&gt;eos[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cnfa-&gt;eos[<span class="Constant">1</span>] != COLORLESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;, eol [</span><span class="Special">%ld</span><span class="Constant">]&quot;</span>, (<span class="Type">long</span>) cnfa-&gt;eos[<span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cnfa-&gt;flags &amp; HASLACONS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;, haslacons&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cnfa-&gt;flags &amp; MATCHALL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;, minmatchall </span><span class="Special">%d</span><span class="Constant">&quot;</span>, cnfa-&gt;minmatchall);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cnfa-&gt;maxmatchall == DUPINF)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;, maxmatchall inf&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;, maxmatchall </span><span class="Special">%d</span><span class="Constant">&quot;</span>, cnfa-&gt;maxmatchall);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (st = <span class="Constant">0</span>; st &lt; cnfa-&gt;nstates; st++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3820" title="regex/regc_nfa.c:3820">dumpcstate</a>(st, cnfa, f);<br/></li>
<li>&nbsp; &nbsp; fflush(f);<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef REG_DEBUG&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* subordinates of <a href="#L3783" title="regex/regc_nfa.c:3783">dumpcnfa</a> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3820" title="regex/regc_nfa.c:3820">dumpcstate</a> - <a href="regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> a compacted-NFA state in human-readable form<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3820">&#x200c;</a></span><span class="linkable">dumpcstate</span>(<span class="Type">int</span> st,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> cnfa *cnfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">FILE</span> *f)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> carc *ca;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">%d%s</span><span class="Constant">&quot;</span>, st, (cnfa-&gt;stflags[st] &amp; CNFA_NOPROGRESS) ? <span class="Constant">&quot;:&quot;</span> : <span class="Constant">&quot;.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; pos = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (ca = cnfa-&gt;states[st]; ca-&gt;co != COLORLESS; ca++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ca-&gt;co == RAINBOW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">\t</span><span class="Constant">[*]-&gt;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, ca-&gt;to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ca-&gt;co &lt; cnfa-&gt;ncolors)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">\t</span><span class="Constant">[</span><span class="Special">%ld</span><span class="Constant">]-&gt;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">long</span>) ca-&gt;co, ca-&gt;to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">\t</span><span class="Constant">:</span><span class="Special">%ld</span><span class="Constant">:-&gt;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">long</span>) (ca-&gt;co - cnfa-&gt;ncolors), ca-&gt;to);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pos == <span class="Constant">5</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ca == cnfa-&gt;states[st] || pos != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; fflush(f);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* REG_DEBUG */<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
