<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>regex/regexec.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>regex/regexec.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L39">arcp</a></li>
<li><a href="#L63">dfa</a></li>
<li><a href="#L92">smalldfa</a></li>
<li><a href="#L45">sset</a></li>
<li><a href="#L106">vars</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1076">caltdissect</a></li>
<li><a href="#L994">cbrdissect</a></li>
<li><a href="#L829">ccondissect</a></li>
<li><a href="#L756">cdissect</a></li>
<li><a href="#L509">cfind</a></li>
<li><a href="#L549">cfindloop</a></li>
<li><a href="#L1117">citerdissect</a></li>
<li><a href="#L910">crevcondissect</a></li>
<li><a href="#L1321">creviterdissect</a></li>
<li><a href="#L419">find</a></li>
<li><a href="#L400">getladfa</a></li>
<li><a href="#L372">getsubdfa</a></li>
<li><a href="#L185">pg_regexec</a></li>
<li><a href="#L702">subset</a></li>
<li><a href="#L663">zapallsubs</a></li>
<li><a href="#L679">zaptreesubs</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L101">DOMALLOC</a></li>
<li><a href="#L129">ERR</a></li>
<li><a href="#L91">FEWCOLORS</a></li>
<li><a href="#L90">FEWSTATES</a></li>
<li><a href="#L49">HASH</a></li>
<li><a href="#L50">HIT</a></li>
<li><a href="#L127">ISERR</a></li>
<li><a href="#L204">LOCALDFAS</a></li>
<li><a href="#L201">LOCALMAT</a></li>
<li><a href="#L55">LOCKED</a></li>
<li><a href="#L132">LOFF</a></li>
<li><a href="#L130">NOERR</a></li>
<li><a href="#L56">NOPROGRESS</a></li>
<li><a href="#L131">OFF</a></li>
<li><a href="#L54">POSTSTATE</a></li>
<li><a href="#L53">STARTER</a></li>
<li><a href="#L128">VERR</a></li>
<li><a href="#L126">VISERR</a></li>
<li><a href="#L87">WORK</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * re_*exec and friends - match REs<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 1998, 1999 Henry Spencer.&nbsp; All rights reserved.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Development of this software was funded, in part, by Cray Research Inc.,<br/></li>
<li></span><span class="Comment"> * UUNET Communications Services Inc., Sun Microsystems Inc., and Scriptics<br/></li>
<li></span><span class="Comment"> * Corporation, <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of whom are responsible for the results.&nbsp; The author<br/></li>
<li></span><span class="Comment"> * thanks all of them.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Redistribution and use in source and binary forms -- with or without<br/></li>
<li></span><span class="Comment"> * modification -- are permitted for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> purpose, provided that<br/></li>
<li></span><span class="Comment"> * redistributions in source form retain this entire copyright notice and<br/></li>
<li></span><span class="Comment"> * indicate the origin and nature of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> modifications.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * I'd appreciate being given credit for this package in the documentation<br/></li>
<li></span><span class="Comment"> * of software which uses it, but that is not a requirement.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,<br/></li>
<li></span><span class="Comment"> * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY<br/></li>
<li></span><span class="Comment"> * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.&nbsp; IN NO EVENT SHALL<br/></li>
<li></span><span class="Comment"> * HENRY SPENCER BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,<br/></li>
<li></span><span class="Comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,<br/></li>
<li></span><span class="Comment"> * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;<br/></li>
<li></span><span class="Comment"> * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,<br/></li>
<li></span><span class="Comment"> * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR<br/></li>
<li></span><span class="Comment"> * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF<br/></li>
<li></span><span class="Comment"> * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * src/backend/regex/regexec.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;regex/regguts.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* lazy-DFA representation */<br/></li>
<li><a id="L39">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">arcp</span><br/></li>
<li>{&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* &quot;pointer&quot; to an outarc */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L45" title="regex/regexec.c:45">sset</a> *ss;<br/></li>
<li>&nbsp; &nbsp; color&nbsp; &nbsp; &nbsp; &nbsp; co;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L45">&#x200c;</a><span class="Type">struct</span> <span class="linkable">sset</span><br/></li>
<li>{&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* state set */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">unsigned</span>&nbsp;&nbsp; *states;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pointer to bitvector */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">unsigned</span>&nbsp; &nbsp; <a href="rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> of bitvector */<br/></li>
<li><a id="L49">&#x200c;</a></span><span class="PreProc">#define&nbsp; <span class="linkable">HASH</span>(bv, nw)&nbsp; &nbsp;&nbsp; (((nw) == </span><span class="Constant">1</span><span class="PreProc">) ? *(bv) : <a href="rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>(bv, nw))<br/></li>
<li><a id="L50">&#x200c;</a></span><span class="PreProc">#define&nbsp; <span class="linkable">HIT</span>(h,bv,ss,nw) ((ss)-&gt;<a href="rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> == (h) &amp;&amp; ((nw) == </span><span class="Constant">1</span><span class="PreProc"> || \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; memcmp(VS(bv), VS((ss)-&gt;states), (nw)*</span><span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(</span><span class="Type">unsigned</span><span class="PreProc">)) == </span><span class="Constant">0</span><span class="PreProc">))<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li><a id="L53">&#x200c;</a><span class="PreProc">#define&nbsp; <span class="linkable">STARTER</span>&nbsp; &nbsp;&nbsp; 0</span><span class="Constant">1</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* the initial state set */<br/></li>
<li><a id="L54">&#x200c;</a></span><span class="PreProc">#define&nbsp; <span class="linkable">POSTSTATE</span>&nbsp; &nbsp;&nbsp; 0</span><span class="Constant">2</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* includes the goal state */<br/></li>
<li><a id="L55">&#x200c;</a></span><span class="PreProc">#define&nbsp; <span class="linkable">LOCKED</span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 0</span><span class="Constant">4</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* locked in cache */<br/></li>
<li><a id="L56">&#x200c;</a></span><span class="PreProc">#define&nbsp; <span class="linkable">NOPROGRESS</span>&nbsp; 0</span><span class="Constant">10</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* zero-progress state set */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L39" title="regex/regexec.c:39">arcp</a> ins;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* chain of inarcs pointing here */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lastseen;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* last entered on arrival here */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L45" title="regex/regexec.c:45">sset</a> **outs;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* outarc vector indexed by color */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L39" title="regex/regexec.c:39">arcp</a> *inchain;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* chain-pointer vector for outarcs */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><a id="L63">&#x200c;</a><span class="Type">struct</span> <span class="linkable">dfa</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nssets;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* size of cache */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nssused;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* how many entries occupied yet */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nstates;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of states */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncolors;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* length of outarc and inchain vectors */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wordsper;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* length of state-set bitvectors */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L45" title="regex/regexec.c:45">sset</a> *ssets;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* state-set cache */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">unsigned</span>&nbsp;&nbsp; *statesarea;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* bitvector storage */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">unsigned</span>&nbsp;&nbsp; *work;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pointer to work area within statesarea */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L45" title="regex/regexec.c:45">sset</a> **outsarea;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* outarc-vector storage */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L39" title="regex/regexec.c:39">arcp</a> *incarea;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* inchain storage */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> cnfa *cnfa;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> colormap *cm;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lastpost;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* location of last cache-flushed success */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lastnopr;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* location of last cache-flushed <a href="#L56" title="regex/regexec.c:56">NOPROGRESS</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L45" title="regex/regexec.c:45">sset</a> *search;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* replacement-search-pointer memory */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backno;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if DFA for a backref, subno it refers to */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">short</span>&nbsp; &nbsp; &nbsp; &nbsp; backmin;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* min repetitions for backref */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">short</span>&nbsp; &nbsp; &nbsp; &nbsp; backmax;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* max repetitions for backref */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ismalloced;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* should this struct <a href="#L63" title="regex/regexec.c:63">dfa</a> be freed? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; arraysmalloced; <span class="Comment">/* should its subsidiary arrays be freed? */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><a id="L87">&#x200c;</a><span class="PreProc">#define <span class="linkable">WORK</span>&nbsp; &nbsp; </span><span class="Constant">1</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* number of work bitvectors needed */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* setup for non-malloc allocation for small cases */<br/></li>
<li><a id="L90">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FEWSTATES</span>&nbsp; &nbsp; </span><span class="Constant">20</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* must be less than UBITS */<br/></li>
<li><a id="L91">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FEWCOLORS</span>&nbsp; &nbsp; </span><span class="Constant">15<br/></li>
<li><a id="L92">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">smalldfa</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a>&nbsp; &nbsp; <a href="#L63" title="regex/regexec.c:63">dfa</a>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must be first */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L45" title="regex/regexec.c:45">sset</a> ssets[<a href="#L90" title="regex/regexec.c:90">FEWSTATES</a> * <span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span>&nbsp; &nbsp; statesarea[<a href="#L90" title="regex/regexec.c:90">FEWSTATES</a> * <span class="Constant">2</span> + <a href="#L87" title="regex/regexec.c:87">WORK</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L45" title="regex/regexec.c:45">sset</a> *outsarea[<a href="#L90" title="regex/regexec.c:90">FEWSTATES</a> * <span class="Constant">2</span> * <a href="#L91" title="regex/regexec.c:91">FEWCOLORS</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L39" title="regex/regexec.c:39">arcp</a> incarea[<a href="#L90" title="regex/regexec.c:90">FEWSTATES</a> * <span class="Constant">2</span> * <a href="#L91" title="regex/regexec.c:91">FEWCOLORS</a>];<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L101">&#x200c;</a><span class="PreProc">#define <span class="linkable">DOMALLOC</span>&nbsp; &nbsp; ((</span><span class="Type">struct</span><span class="PreProc"> <a href="#L92" title="regex/regexec.c:92">smalldfa</a> *)</span><span class="Constant">NULL</span><span class="PreProc">)&nbsp; &nbsp; </span><span class="Comment">/* force malloc */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> variables, bundled for easy passing around */<br/></li>
<li><a id="L106">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">vars</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; regex_t&nbsp; &nbsp; *re;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> guts *g;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eflags;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copies of arguments */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; nmatch;<br/></li>
<li>&nbsp; &nbsp; regmatch_t *pmatch;<br/></li>
<li>&nbsp; &nbsp; rm_detail_t *details;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *start;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* start of string */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *search_start;&nbsp; &nbsp; <span class="Comment">/* search start of string */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *stop;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just past end of string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; err;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* error code if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> (0 <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> **subdfas;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* per-tree-<a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> DFAs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> **ladfas;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* per-<a href="rege_dfa.c.html#L916" title="regex/rege_dfa.c:916">lacon</a>-<a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> DFAs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L45" title="regex/regexec.c:45">sset</a> **lblastcss;&nbsp; &nbsp; <span class="Comment">/* per-<a href="rege_dfa.c.html#L916" title="regex/rege_dfa.c:916">lacon</a>-<a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> lookbehind restart data */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; **lblastcp;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* per-<a href="rege_dfa.c.html#L916" title="regex/rege_dfa.c:916">lacon</a>-<a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> lookbehind restart data */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L92" title="regex/regexec.c:92">smalldfa</a> dfa1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L92" title="regex/regexec.c:92">smalldfa</a> dfa2;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L126">&#x200c;</a><span class="PreProc">#define <span class="linkable">VISERR</span>(vv)&nbsp; &nbsp; ((vv)-&gt;err != </span><span class="Constant">0</span><span class="PreProc">)&nbsp; &nbsp; </span><span class="Comment">/* have we seen an error yet? */<br/></li>
<li><a id="L127">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ISERR</span>() <a href="#L126" title="regex/regexec.c:126">VISERR</a>(v)<br/></li>
<li><a id="L128">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">VERR</span>(vv,e)&nbsp; &nbsp; ((vv)-&gt;err = ((vv)-&gt;err ? (vv)-&gt;err : (e)))<br/></li>
<li><a id="L129">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ERR</span>(e)&nbsp; &nbsp; <a href="#L128" title="regex/regexec.c:128">VERR</a>(v, e)&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* record an error */<br/></li>
<li><a id="L130">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NOERR</span>() {</span><span class="Statement">if</span><span class="PreProc"> (<a href="#L127" title="regex/regexec.c:127">ISERR</a>()) </span><span class="Statement">return</span><span class="PreProc"> v-&gt;err;}&nbsp; &nbsp; </span><span class="Comment">/* if error seen, return it */<br/></li>
<li><a id="L131">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">OFF</span>(p)&nbsp; &nbsp; ((p) - v-&gt;start)<br/></li>
<li><a id="L132">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LOFF</span>(p) ((</span><span class="Type">long</span><span class="PreProc">)<a href="#L131" title="regex/regexec.c:131">OFF</a>(p))<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * forward declarations<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Comment">/* === regexec.c === */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *<a href="#L372" title="regex/regexec.c:372">getsubdfa</a>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> *t);<br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *<a href="#L400" title="regex/regexec.c:400">getladfa</a>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">int</span> n);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L419" title="regex/regexec.c:419">find</a>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> cnfa *cnfa, <span class="Type">struct</span> colormap *cm);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L509" title="regex/regexec.c:509">cfind</a>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> cnfa *cnfa, <span class="Type">struct</span> colormap *cm);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L549" title="regex/regexec.c:549">cfindloop</a>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> cnfa *cnfa, <span class="Type">struct</span> colormap *cm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *d, <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *s, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> **coldp);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L663" title="regex/regexec.c:663">zapallsubs</a>(regmatch_t *p, <span class="Type">size_t</span> n);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L679" title="regex/regexec.c:679">zaptreesubs</a>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> *t);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L702" title="regex/regexec.c:702">subset</a>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> *sub, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *begin, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *end);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L756" title="regex/regexec.c:756">cdissect</a>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> *t, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *begin, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *end);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L829" title="regex/regexec.c:829">ccondissect</a>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> *t, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *begin, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *end);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L910" title="regex/regexec.c:910">crevcondissect</a>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> *t, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *begin, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *end);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L994" title="regex/regexec.c:994">cbrdissect</a>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> *t, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *begin, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *end);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1076" title="regex/regexec.c:1076">caltdissect</a>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> *t, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *begin, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *end);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1117" title="regex/regexec.c:1117">citerdissect</a>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> *t, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *begin, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *end);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1321" title="regex/regexec.c:1321">creviterdissect</a>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> *t, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *begin, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *end);<br/></li>
<li><br/></li>
<li><span class="Comment">/* === rege_dfa.c === */<br/></li>
<li></span><span class="Type">static</span> <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *<a href="rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *d,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *start, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *stop, <span class="Type">int</span> *hitstopp);<br/></li>
<li><span class="Type">static</span> <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *<a href="rege_dfa.c.html#L204" title="regex/rege_dfa.c:204">shortest</a>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *d, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *start, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *min,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *max, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> **coldp, <span class="Type">int</span> *hitstopp);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="rege_dfa.c.html#L371" title="regex/rege_dfa.c:371">matchuntil</a>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *d, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *probe,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> <a href="#L45" title="regex/regexec.c:45">sset</a> **lastcss, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> **lastcp);<br/></li>
<li><span class="Type">static</span> <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *<a href="rege_dfa.c.html#L506" title="regex/rege_dfa.c:506">dfa_backref</a>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *d, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *start,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *min, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *max, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="rege_dfa.c.html#L204" title="regex/rege_dfa.c:204">shortest</a>);<br/></li>
<li><span class="Type">static</span> <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *<a href="rege_dfa.c.html#L585" title="regex/rege_dfa.c:585">lastcold</a>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *d);<br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *<a href="rege_dfa.c.html#L607" title="regex/rege_dfa.c:607">newdfa</a>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> cnfa *cnfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> colormap *cm, <span class="Type">struct</span> <a href="#L92" title="regex/regexec.c:92">smalldfa</a> *sml);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="rege_dfa.c.html#L691" title="regex/rege_dfa.c:691">freedfa</a>(<span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *d);<br/></li>
<li><span class="Type">static</span> <span class="Type">unsigned</span> <a href="rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>(<span class="Type">unsigned</span> *uv, <span class="Type">int</span> n);<br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> <a href="#L45" title="regex/regexec.c:45">sset</a> *<a href="rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *d, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *start);<br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> <a href="#L45" title="regex/regexec.c:45">sset</a> *<a href="rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *d, <span class="Type">struct</span> <a href="#L45" title="regex/regexec.c:45">sset</a> *css,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; color co, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *cp, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *start);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="rege_dfa.c.html#L916" title="regex/rege_dfa.c:916">lacon</a>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> cnfa *pcnfa, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *cp, color co);<br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> <a href="#L45" title="regex/regexec.c:45">sset</a> *<a href="rege_dfa.c.html#L973" title="regex/rege_dfa.c:973">getvacant</a>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *d, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *cp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *start);<br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> <a href="#L45" title="regex/regexec.c:45">sset</a> *<a href="rege_dfa.c.html#L1044" title="regex/rege_dfa.c:1044">pickss</a>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *d, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *cp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *start);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L185" title="regex/regexec.c:185">pg_regexec</a> - match regular expression<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L185">&#x200c;</a></span><span class="linkable">pg_regexec</span>(regex_t *re,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">size_t</span> len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">size_t</span> search_start,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rm_detail_t *details,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">size_t</span> nmatch,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; regmatch_t pmatch[],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> var;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v = &amp;var;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; st;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backref;<br/></li>
<li><br/></li>
<li><a id="L201">&#x200c;</a><span class="PreProc">#define&nbsp; <span class="linkable">LOCALMAT</span>&nbsp; &nbsp;&nbsp; </span><span class="Constant">20<br/></li>
<li></span>&nbsp; &nbsp; regmatch_t&nbsp; &nbsp; mat[<a href="#L201" title="regex/regexec.c:201">LOCALMAT</a>];<br/></li>
<li><br/></li>
<li><a id="L204">&#x200c;</a><span class="PreProc">#define&nbsp; <span class="linkable">LOCALDFAS</span>&nbsp; &nbsp;&nbsp; </span><span class="Constant">40<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *subdfas[<a href="#L204" title="regex/regexec.c:204">LOCALDFAS</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sanity checks */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (re == <span class="Constant">NULL</span> || string == <span class="Constant">NULL</span> || re-&gt;re_magic != REMAGIC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_INVARG;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (re-&gt;re_csize != <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_MIXED;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (search_start &gt; len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_NOMATCH;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize locale-dependent support */<br/></li>
<li></span>&nbsp; &nbsp; <a href="regc_pg_locale.c.html#L234" title="regex/regc_pg_locale.c:234">pg_set_regex_collation</a>(re-&gt;re_collation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* setup */<br/></li>
<li></span>&nbsp; &nbsp; v-&gt;re = re;<br/></li>
<li>&nbsp; &nbsp; v-&gt;g = (<span class="Type">struct</span> guts *) re-&gt;re_guts;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((v-&gt;g-&gt;cflags &amp; REG_EXPECT) &amp;&amp; details == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_INVARG;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;g-&gt;info &amp; REG_UIMPOSSIBLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_NOMATCH;<br/></li>
<li>&nbsp; &nbsp; backref = (v-&gt;g-&gt;info &amp; REG_UBACKREF) ? <span class="Constant">1</span> : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; v-&gt;eflags = flags;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (backref &amp;&amp; nmatch &lt;= v-&gt;g-&gt;nsub)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* need larger work area */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;nmatch = v-&gt;g-&gt;nsub + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;nmatch &lt;= <a href="#L201" title="regex/regexec.c:201">LOCALMAT</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;pmatch = mat;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;pmatch = (regmatch_t *) MALLOC(v-&gt;nmatch * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(regmatch_t));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;pmatch == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_ESPACE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L663" title="regex/regexec.c:663">zapallsubs</a>(v-&gt;pmatch, v-&gt;nmatch);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we can store results directly in caller's array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;pmatch = pmatch;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ensure <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> extra entries in caller's array are filled with -1 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nmatch &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L663" title="regex/regexec.c:663">zapallsubs</a>(pmatch, nmatch);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* then forget about extra entries, to avoid useless work in <a href="#L419" title="regex/regexec.c:419">find</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nmatch &gt; v-&gt;g-&gt;nsub + <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmatch = v-&gt;g-&gt;nsub + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;nmatch = nmatch;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; v-&gt;details = details;<br/></li>
<li>&nbsp; &nbsp; v-&gt;start = (<a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *) string;<br/></li>
<li>&nbsp; &nbsp; v-&gt;search_start = (<a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *) string + search_start;<br/></li>
<li>&nbsp; &nbsp; v-&gt;stop = (<a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *) string + len;<br/></li>
<li>&nbsp; &nbsp; v-&gt;err = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; v-&gt;subdfas = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; v-&gt;ladfas = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; v-&gt;lblastcss = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; v-&gt;lblastcp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* below this point, &quot;goto <a href="regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>&quot; will behave sanely */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; assert(v-&gt;g-&gt;ntree &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; n = (<span class="Type">size_t</span>) v-&gt;g-&gt;ntree;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (n &lt;= <a href="#L204" title="regex/regexec.c:204">LOCALDFAS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;subdfas = subdfas;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;subdfas = (<span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> **) MALLOC(n * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;subdfas == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; st = REG_ESPACE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> <a href="regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; n; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;subdfas[i] = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(v-&gt;g-&gt;nlacons &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; n = (<span class="Type">size_t</span>) v-&gt;g-&gt;nlacons;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (n &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;ladfas = (<span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> **) MALLOC(n * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;ladfas == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; st = REG_ESPACE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> <a href="regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; n; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;ladfas[i] = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;lblastcss = (<span class="Type">struct</span> <a href="#L45" title="regex/regexec.c:45">sset</a> **) MALLOC(n * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> <a href="#L45" title="regex/regexec.c:45">sset</a> *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;lblastcp = (<a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> **) MALLOC(n * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;lblastcss == <span class="Constant">NULL</span> || v-&gt;lblastcp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; st = REG_ESPACE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> <a href="regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; n; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;lblastcss[i] = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;lblastcp[i] = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do it */<br/></li>
<li></span>&nbsp; &nbsp; assert(v-&gt;g-&gt;tree != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (backref)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; st = <a href="#L509" title="regex/regexec.c:509">cfind</a>(v, &amp;v-&gt;g-&gt;tree-&gt;cnfa, &amp;v-&gt;g-&gt;cmap);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; st = <a href="#L419" title="regex/regexec.c:419">find</a>(v, &amp;v-&gt;g-&gt;tree-&gt;cnfa, &amp;v-&gt;g-&gt;cmap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* on success, ensure caller's match vector is filled correctly */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (st == REG_OKAY &amp;&amp; nmatch &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;pmatch != pmatch)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy portion of match vector over from (larger) work area */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(nmatch &lt;= v-&gt;nmatch);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(VS(pmatch), VS(v-&gt;pmatch), nmatch * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(regmatch_t));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;g-&gt;cflags &amp; REG_NOSUB)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't expose possibly-partial sub-match results to caller */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L663" title="regex/regexec.c:663">zapallsubs</a>(pmatch, nmatch);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* clean up */<br/></li>
<li></span><span class="Statement"><a href="regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a></span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;pmatch != pmatch &amp;&amp; v-&gt;pmatch != mat)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FREE(v-&gt;pmatch);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;subdfas != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n = (<span class="Type">size_t</span>) v-&gt;g-&gt;ntree;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; n; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;subdfas[i] != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rege_dfa.c.html#L691" title="regex/rege_dfa.c:691">freedfa</a>(v-&gt;subdfas[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;subdfas != subdfas)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FREE(v-&gt;subdfas);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;ladfas != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n = (<span class="Type">size_t</span>) v-&gt;g-&gt;nlacons;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; n; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;ladfas[i] != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rege_dfa.c.html#L691" title="regex/rege_dfa.c:691">freedfa</a>(v-&gt;ladfas[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FREE(v-&gt;ladfas);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;lblastcss != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FREE(v-&gt;lblastcss);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;lblastcp != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FREE(v-&gt;lblastcp);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef REG_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;eflags &amp; (REG_FTRACE | REG_MTRACE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fflush(<span class="Constant">stdout</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> st;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L372" title="regex/regexec.c:372">getsubdfa</a> - create or re-fetch the DFA for a tree <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> node<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We only need to create the DFA once per overall regex execution.<br/></li>
<li></span><span class="Comment"> * The DFA will be freed by the <a href="regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> step in <a href="#L185" title="regex/regexec.c:185">pg_regexec</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *<br/></li>
<li><a id="L372">&#x200c;</a><span class="linkable">getsubdfa</span>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> *t)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *d = v-&gt;subdfas[t-&gt;id];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (d == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; d = <a href="rege_dfa.c.html#L607" title="regex/rege_dfa.c:607">newdfa</a>(v, &amp;t-&gt;cnfa, &amp;v-&gt;g-&gt;cmap, <a href="#L101" title="regex/regexec.c:101">DOMALLOC</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (d == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* set up additional info if this is a backref node */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (t-&gt;op == <span class="Constant">'b'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d-&gt;backno = t-&gt;backno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d-&gt;backmin = t-&gt;min;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d-&gt;backmax = t-&gt;max;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;subdfas[t-&gt;id] = d;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> d;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L400" title="regex/regexec.c:400">getladfa</a> - create or re-fetch the DFA for a <a href="regcomp.c.html#L340" title="regex/regcomp.c:340">LACON</a> <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> node<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Same as above, but for LACONs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *<br/></li>
<li><a id="L400">&#x200c;</a><span class="linkable">getladfa</span>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> n)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; assert(n &gt; <span class="Constant">0</span> &amp;&amp; n &lt; v-&gt;g-&gt;nlacons &amp;&amp; v-&gt;g-&gt;lacons != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;ladfas[n] == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> *sub = &amp;v-&gt;g-&gt;lacons[n];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;ladfas[n] = <a href="rege_dfa.c.html#L607" title="regex/rege_dfa.c:607">newdfa</a>(v, &amp;sub-&gt;cnfa, &amp;v-&gt;g-&gt;cmap, <a href="#L101" title="regex/regexec.c:101">DOMALLOC</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* a <a href="regcomp.c.html#L340" title="regex/regcomp.c:340">LACON</a> can't contain a backref, so nothing else to do */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> v-&gt;ladfas[n];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L419" title="regex/regexec.c:419">find</a> - <a href="#L419" title="regex/regexec.c:419">find</a> a match for the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> NFA (no-complications case)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L419">&#x200c;</a></span><span class="linkable">find</span>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp;&nbsp; <span class="Type">struct</span> cnfa *cnfa,<br/></li>
<li>&nbsp; &nbsp;&nbsp; <span class="Type">struct</span> colormap *cm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *s;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *d;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *begin;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *end = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *cold;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *open;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* open and close of <a href="regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of possible starts */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *close;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hitend;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shorter = (v-&gt;g-&gt;tree-&gt;flags &amp; SHORTER) ? <span class="Constant">1</span> : <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* first, a shot with the search RE */<br/></li>
<li></span>&nbsp; &nbsp; s = <a href="rege_dfa.c.html#L607" title="regex/rege_dfa.c:607">newdfa</a>(v, &amp;v-&gt;g-&gt;search, cm, &amp;v-&gt;dfa1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> v-&gt;err;<br/></li>
<li>&nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">search at </span><span class="Special">%ld\n</span><span class="Constant">&quot;</span>, <a href="#L132" title="regex/regexec.c:132">LOFF</a>(v-&gt;start)));<br/></li>
<li>&nbsp; &nbsp; cold = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; close = <a href="rege_dfa.c.html#L204" title="regex/rege_dfa.c:204">shortest</a>(v, s, v-&gt;search_start, v-&gt;search_start, v-&gt;stop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;cold, (<span class="Type">int</span> *) <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="rege_dfa.c.html#L691" title="regex/rege_dfa.c:691">freedfa</a>(s);<br/></li>
<li>&nbsp; &nbsp; <a href="#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;g-&gt;cflags &amp; REG_EXPECT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(v-&gt;details != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cold != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;details-&gt;rm_extend.rm_so = <a href="#L131" title="regex/regexec.c:131">OFF</a>(cold);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;details-&gt;rm_extend.rm_so = <a href="#L131" title="regex/regexec.c:131">OFF</a>(v-&gt;stop);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;details-&gt;rm_extend.rm_eo = <a href="#L131" title="regex/regexec.c:131">OFF</a>(v-&gt;stop); <span class="Comment">/* unknown */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (close == <span class="Constant">NULL</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not found */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_NOMATCH;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;nmatch == <span class="Constant">0</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* found, don't need exact location */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_OKAY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L419" title="regex/regexec.c:419">find</a> starting point and match */<br/></li>
<li></span>&nbsp; &nbsp; assert(cold != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; open = cold;<br/></li>
<li>&nbsp; &nbsp; cold = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;between </span><span class="Special">%ld</span><span class="Constant"> and </span><span class="Special">%ld\n</span><span class="Constant">&quot;</span>, <a href="#L132" title="regex/regexec.c:132">LOFF</a>(open), <a href="#L132" title="regex/regexec.c:132">LOFF</a>(close)));<br/></li>
<li>&nbsp; &nbsp; d = <a href="rege_dfa.c.html#L607" title="regex/rege_dfa.c:607">newdfa</a>(v, cnfa, cm, &amp;v-&gt;dfa1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (d == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> v-&gt;err;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (begin = open; begin &lt;= close; begin++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant"><a href="#L419" title="regex/regexec.c:419">find</a> trying at </span><span class="Special">%ld\n</span><span class="Constant">&quot;</span>, <a href="#L132" title="regex/regexec.c:132">LOFF</a>(begin)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shorter)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end = <a href="rege_dfa.c.html#L204" title="regex/rege_dfa.c:204">shortest</a>(v, d, begin, begin, v-&gt;stop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> **) <span class="Constant">NULL</span>, &amp;hitend);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end = <a href="rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a>(v, d, begin, v-&gt;stop, &amp;hitend);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L127" title="regex/regexec.c:127">ISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rege_dfa.c.html#L691" title="regex/rege_dfa.c:691">freedfa</a>(d);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> v-&gt;err;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hitend &amp;&amp; cold == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cold = begin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (end != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a> BREAK OUT */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; assert(end != <span class="Constant">NULL</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* search RE succeeded so loop should */<br/></li>
<li></span>&nbsp; &nbsp; <a href="rege_dfa.c.html#L691" title="regex/rege_dfa.c:691">freedfa</a>(d);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and pin down details */<br/></li>
<li></span>&nbsp; &nbsp; assert(v-&gt;nmatch &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; v-&gt;pmatch[<span class="Constant">0</span>].rm_so = <a href="#L131" title="regex/regexec.c:131">OFF</a>(begin);<br/></li>
<li>&nbsp; &nbsp; v-&gt;pmatch[<span class="Constant">0</span>].rm_eo = <a href="#L131" title="regex/regexec.c:131">OFF</a>(end);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;g-&gt;cflags &amp; REG_EXPECT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cold != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;details-&gt;rm_extend.rm_so = <a href="#L131" title="regex/regexec.c:131">OFF</a>(cold);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;details-&gt;rm_extend.rm_so = <a href="#L131" title="regex/regexec.c:131">OFF</a>(v-&gt;stop);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;details-&gt;rm_extend.rm_eo = <a href="#L131" title="regex/regexec.c:131">OFF</a>(v-&gt;stop); <span class="Comment">/* unknown */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;nmatch == <span class="Constant">1</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no need for submatches */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_OKAY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L419" title="regex/regexec.c:419">find</a> submatches */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L756" title="regex/regexec.c:756">cdissect</a>(v, v-&gt;g-&gt;tree, begin, end);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L509" title="regex/regexec.c:509">cfind</a> - <a href="#L419" title="regex/regexec.c:419">find</a> a match for the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> NFA (with complications)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L509">&#x200c;</a></span><span class="linkable">cfind</span>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">struct</span> cnfa *cnfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">struct</span> colormap *cm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *s;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *d;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *cold;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s = <a href="rege_dfa.c.html#L607" title="regex/rege_dfa.c:607">newdfa</a>(v, &amp;v-&gt;g-&gt;search, cm, &amp;v-&gt;dfa1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> v-&gt;err;<br/></li>
<li>&nbsp; &nbsp; d = <a href="rege_dfa.c.html#L607" title="regex/rege_dfa.c:607">newdfa</a>(v, cnfa, cm, &amp;v-&gt;dfa2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (d == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="rege_dfa.c.html#L691" title="regex/rege_dfa.c:691">freedfa</a>(s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> v-&gt;err;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = <a href="#L549" title="regex/regexec.c:549">cfindloop</a>(v, cnfa, cm, d, s, &amp;cold);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="rege_dfa.c.html#L691" title="regex/rege_dfa.c:691">freedfa</a>(d);<br/></li>
<li>&nbsp; &nbsp; <a href="rege_dfa.c.html#L691" title="regex/rege_dfa.c:691">freedfa</a>(s);<br/></li>
<li>&nbsp; &nbsp; <a href="#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;g-&gt;cflags &amp; REG_EXPECT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(v-&gt;details != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cold != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;details-&gt;rm_extend.rm_so = <a href="#L131" title="regex/regexec.c:131">OFF</a>(cold);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;details-&gt;rm_extend.rm_so = <a href="#L131" title="regex/regexec.c:131">OFF</a>(v-&gt;stop);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;details-&gt;rm_extend.rm_eo = <a href="#L131" title="regex/regexec.c:131">OFF</a>(v-&gt;stop); <span class="Comment">/* unknown */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L549" title="regex/regexec.c:549">cfindloop</a> - the heart of <a href="#L509" title="regex/regexec.c:509">cfind</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L549">&#x200c;</a></span><span class="linkable">cfindloop</span>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> cnfa *cnfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> colormap *cm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *d,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *s,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> **coldp)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* where to put coldstart pointer */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *begin;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *end;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *cold;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *open;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* open and close of <a href="regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of possible starts */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *close;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *estart;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *estop;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; er;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shorter = v-&gt;g-&gt;tree-&gt;flags &amp; SHORTER;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hitend;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(d != <span class="Constant">NULL</span> &amp;&amp; s != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; cold = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; close = v-&gt;search_start;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Search with the search RE for match <a href="regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> at/beyond &quot;close&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">csearch at </span><span class="Special">%ld\n</span><span class="Constant">&quot;</span>, <a href="#L132" title="regex/regexec.c:132">LOFF</a>(close)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; close = <a href="rege_dfa.c.html#L204" title="regex/rege_dfa.c:204">shortest</a>(v, s, close, close, v-&gt;stop, &amp;cold, (<span class="Type">int</span> *) <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L127" title="regex/regexec.c:127">ISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *coldp = cold;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> v-&gt;err;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (close == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no more possible match anywhere */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; assert(cold != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; open = cold;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cold = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Search for matches starting between &quot;open&quot; and &quot;close&quot; inclusive */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;cbetween </span><span class="Special">%ld</span><span class="Constant"> and </span><span class="Special">%ld\n</span><span class="Constant">&quot;</span>, <a href="#L132" title="regex/regexec.c:132">LOFF</a>(open), <a href="#L132" title="regex/regexec.c:132">LOFF</a>(close)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (begin = open; begin &lt;= close; begin++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant"><a href="#L509" title="regex/regexec.c:509">cfind</a> trying at </span><span class="Special">%ld\n</span><span class="Constant">&quot;</span>, <a href="#L132" title="regex/regexec.c:132">LOFF</a>(begin)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; estart = begin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; estop = v-&gt;stop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Here we use the top node's detailed RE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shorter)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end = <a href="rege_dfa.c.html#L204" title="regex/rege_dfa.c:204">shortest</a>(v, d, begin, estart,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; estop, (<a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> **) <span class="Constant">NULL</span>, &amp;hitend);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end = <a href="rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a>(v, d, begin, estop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;hitend);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L127" title="regex/regexec.c:127">ISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *coldp = cold;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> v-&gt;err;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hitend &amp;&amp; cold == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cold = begin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (end == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no match with this begin point, try <a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;tentative end </span><span class="Special">%ld\n</span><span class="Constant">&quot;</span>, <a href="#L132" title="regex/regexec.c:132">LOFF</a>(end)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Dissect the potential match to see if it really matches */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; er = <a href="#L756" title="regex/regexec.c:756">cdissect</a>(v, v-&gt;g-&gt;tree, begin, end);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (er == REG_OKAY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;nmatch &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;pmatch[<span class="Constant">0</span>].rm_so = <a href="#L131" title="regex/regexec.c:131">OFF</a>(begin);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;pmatch[<span class="Constant">0</span>].rm_eo = <a href="#L131" title="regex/regexec.c:131">OFF</a>(end);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *coldp = cold;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_OKAY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (er != REG_NOMATCH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="regex/regexec.c:129">ERR</a>(er);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *coldp = cold;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> er;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try <a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> longer/shorter match with same begin point */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shorter)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (end == estop)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; <span class="Comment">/* no more, so try <a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> begin point */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; estart = end + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (end == begin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; <span class="Comment">/* no more, so try <a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> begin point */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; estop = end - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end loop over endpoint positions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end loop over beginning positions */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we get here, there is no possible match starting at or <a href="regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;close&quot;, so consider matches beyond that.&nbsp; We'll do a fresh search<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with the search RE to <a href="#L419" title="regex/regexec.c:419">find</a> a new promising match <a href="regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; close++;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (close &lt; v-&gt;stop);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *coldp = cold;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> REG_NOMATCH;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L663" title="regex/regexec.c:663">zapallsubs</a> - <a href="rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> all subexpression matches to &quot;no match&quot;<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that p[0], the overall-match location, is not touched.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L663">&#x200c;</a></span><span class="linkable">zapallsubs</span>(regmatch_t *p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">size_t</span> n)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = n - <span class="Constant">1</span>; i &gt; <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p[i].rm_so = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p[i].rm_eo = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L679" title="regex/regexec.c:679">zaptreesubs</a> - <a href="rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> subexpressions within subtree to &quot;no match&quot;<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L679">&#x200c;</a></span><span class="linkable">zaptreesubs</span>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> *t)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = t-&gt;capno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> *t2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (n &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((<span class="Type">size_t</span>) n &lt; v-&gt;nmatch)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;pmatch[n].rm_so = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;pmatch[n].rm_eo = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (t2 = t-&gt;child; t2 != <span class="Constant">NULL</span>; t2 = t2-&gt;sibling)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L679" title="regex/regexec.c:679">zaptreesubs</a>(v, t2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L702" title="regex/regexec.c:702">subset</a> - set subexpression match data for a successful <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L702">&#x200c;</a></span><span class="linkable">subset</span>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> *sub,<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *begin,<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *end)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = sub-&gt;capno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(n &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((<span class="Type">size_t</span>) n &gt;= v-&gt;nmatch)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: setting </span><span class="Special">%d</span><span class="Constant"> = </span><span class="Special">%ld</span><span class="Constant">-</span><span class="Special">%ld\n</span><span class="Constant">&quot;</span>, sub-&gt;id, n, <a href="#L132" title="regex/regexec.c:132">LOFF</a>(begin), <a href="#L132" title="regex/regexec.c:132">LOFF</a>(end)));<br/></li>
<li>&nbsp; &nbsp; v-&gt;pmatch[n].rm_so = <a href="#L131" title="regex/regexec.c:131">OFF</a>(begin);<br/></li>
<li>&nbsp; &nbsp; v-&gt;pmatch[n].rm_eo = <a href="#L131" title="regex/regexec.c:131">OFF</a>(end);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L756" title="regex/regexec.c:756">cdissect</a> - check backrefs and determine subexpression matches<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L756" title="regex/regexec.c:756">cdissect</a> recursively processes a <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> tree to check matching of backrefs<br/></li>
<li></span><span class="Comment"> * and/or identify submatch boundaries for capture nodes.&nbsp; The proposed match<br/></li>
<li></span><span class="Comment"> * runs from &quot;begin&quot; to &quot;end&quot; (not including &quot;end&quot;), and we are basically<br/></li>
<li></span><span class="Comment"> * &quot;dissecting&quot; it to see where the submatches are.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Before calling <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> level of <a href="#L756" title="regex/regexec.c:756">cdissect</a>, the caller must have run the node's<br/></li>
<li></span><span class="Comment"> * DFA and found that the proposed substring satisfies the DFA.&nbsp; (We make<br/></li>
<li></span><span class="Comment"> * the caller do that because in concatenation and iteration nodes, it's<br/></li>
<li></span><span class="Comment"> * much faster to check all the substrings against the child DFAs <a href="regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we<br/></li>
<li></span><span class="Comment"> * recurse.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A side-effect of a successful match is to save match locations for<br/></li>
<li></span><span class="Comment"> * capturing subexpressions in v-&gt;pmatch[].&nbsp; This is a little <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> tricky,<br/></li>
<li></span><span class="Comment"> * so we make the following rules:<br/></li>
<li></span><span class="Comment"> * 1. Before initial entry to <a href="#L756" title="regex/regexec.c:756">cdissect</a>, all match data must have been<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; cleared (this is seen to by <a href="#L663" title="regex/regexec.c:663">zapallsubs</a>).<br/></li>
<li></span><span class="Comment"> * 2. Before <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> recursive entry to <a href="#L756" title="regex/regexec.c:756">cdissect</a>, the match data for that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; subexpression tree must be guaranteed clear (see <a href="#L679" title="regex/regexec.c:679">zaptreesubs</a>).<br/></li>
<li></span><span class="Comment"> * 3. When returning REG_OKAY, each level of <a href="#L756" title="regex/regexec.c:756">cdissect</a> will have saved<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> relevant match locations.<br/></li>
<li></span><span class="Comment"> * 4. When returning REG_NOMATCH, each level of <a href="#L756" title="regex/regexec.c:756">cdissect</a> will guarantee<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; that its subexpression match locations are again clear.<br/></li>
<li></span><span class="Comment"> * 5. No guarantees are made for error cases (i.e., other result codes).<br/></li>
<li></span><span class="Comment"> * 6. When a level of <a href="#L756" title="regex/regexec.c:756">cdissect</a> abandons a successful sub-match, it will<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; clear that subtree's match locations with <a href="#L679" title="regex/regexec.c:679">zaptreesubs</a> <a href="regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> trying<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> new DFA match or <a href="#L756" title="regex/regexec.c:756">cdissect</a> call for that subtree or <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subtree<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; to its right (that is, <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subtree that could have a backref into the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; abandoned match).<br/></li>
<li></span><span class="Comment"> * This may seem overly complicated, but it's difficult to simplify it<br/></li>
<li></span><span class="Comment"> * because of the provision that match locations must be reset <a href="regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fresh DFA match (a rule that is needed to make <a href="rege_dfa.c.html#L506" title="regex/rege_dfa.c:506">dfa_backref</a> safe).<br/></li>
<li></span><span class="Comment"> * That means it won't work to just reset relevant match locations at the<br/></li>
<li></span><span class="Comment"> * start of each <a href="#L756" title="regex/regexec.c:756">cdissect</a> level.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* regexec return code */<br/></li>
<li><a id="L756">&#x200c;</a></span><span class="linkable">cdissect</span>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> *t,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *begin,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* beginning of relevant substring */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *end)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of same */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; er;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(t != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: <a href="#L756" title="regex/regexec.c:756">cdissect</a> </span><span class="Special">%c</span><span class="Constant"> </span><span class="Special">%ld</span><span class="Constant">-</span><span class="Special">%ld\n</span><span class="Constant">&quot;</span>, t-&gt;id, t-&gt;op, <a href="#L132" title="regex/regexec.c:132">LOFF</a>(begin), <a href="#L132" title="regex/regexec.c:132">LOFF</a>(end)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* handy place to check for operation cancel */<br/></li>
<li></span>&nbsp; &nbsp; INTERRUPT(v-&gt;re);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... and stack overrun */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (STACK_TOO_DEEP(v-&gt;re))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_ETOOBIG;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (t-&gt;op)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'='</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* terminal node */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(t-&gt;child == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; er = REG_OKAY;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no action, parent did the work */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'b'</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* back reference */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(t-&gt;child == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; er = <a href="#L994" title="regex/regexec.c:994">cbrdissect</a>(v, t, begin, end);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'.'</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* concatenation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(t-&gt;child != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (t-&gt;child-&gt;flags &amp; SHORTER)&nbsp; &nbsp; <span class="Comment">/* reverse scan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; er = <a href="#L910" title="regex/regexec.c:910">crevcondissect</a>(v, t, begin, end);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; er = <a href="#L829" title="regex/regexec.c:829">ccondissect</a>(v, t, begin, end);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'|'</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* alternation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(t-&gt;child != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; er = <a href="#L1076" title="regex/regexec.c:1076">caltdissect</a>(v, t, begin, end);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'*'</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* iteration */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(t-&gt;child != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (t-&gt;child-&gt;flags &amp; SHORTER)&nbsp; &nbsp; <span class="Comment">/* reverse scan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; er = <a href="#L1321" title="regex/regexec.c:1321">creviterdissect</a>(v, t, begin, end);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; er = <a href="#L1117" title="regex/regexec.c:1117">citerdissect</a>(v, t, begin, end);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'('</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no-op capture node */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(t-&gt;child != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; er = <a href="#L756" title="regex/regexec.c:756">cdissect</a>(v, t-&gt;child, begin, end);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; er = REG_ASSERT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We should never have a match failure unless backrefs lurk below;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otherwise, either caller failed to check the DFA, or there's some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inconsistency between the DFA and the node's innards.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; assert(er != REG_NOMATCH || (t-&gt;flags &amp; BACKR));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this node is marked as capturing, save successful match's location.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (t-&gt;capno &gt; <span class="Constant">0</span> &amp;&amp; er == REG_OKAY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L702" title="regex/regexec.c:702">subset</a>(v, t, begin, end);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> er;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L829" title="regex/regexec.c:829">ccondissect</a> - dissect match for concatenation node<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* regexec return code */<br/></li>
<li><a id="L829">&#x200c;</a></span><span class="linkable">ccondissect</span>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> *t,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *begin,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* beginning of relevant substring */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *end)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of same */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> *left = t-&gt;child;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> *right = left-&gt;sibling;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *d;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *d2;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *mid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; er;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(t-&gt;op == <span class="Constant">'.'</span>);<br/></li>
<li>&nbsp; &nbsp; assert(left != <span class="Constant">NULL</span> &amp;&amp; left-&gt;cnfa.nstates &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; assert(right != <span class="Constant">NULL</span> &amp;&amp; right-&gt;cnfa.nstates &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; assert(right-&gt;sibling == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; assert(!(left-&gt;flags &amp; SHORTER));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; d = <a href="#L372" title="regex/regexec.c:372">getsubdfa</a>(v, left);<br/></li>
<li>&nbsp; &nbsp; <a href="#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; d2 = <a href="#L372" title="regex/regexec.c:372">getsubdfa</a>(v, right);<br/></li>
<li>&nbsp; &nbsp; <a href="#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: <a href="#L829" title="regex/regexec.c:829">ccondissect</a> </span><span class="Special">%ld</span><span class="Constant">-</span><span class="Special">%ld\n</span><span class="Constant">&quot;</span>, t-&gt;id, <a href="#L132" title="regex/regexec.c:132">LOFF</a>(begin), <a href="#L132" title="regex/regexec.c:132">LOFF</a>(end)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pick a tentative midpoint */<br/></li>
<li></span>&nbsp; &nbsp; mid = <a href="rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a>(v, d, begin, end, (<span class="Type">int</span> *) <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mid == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_NOMATCH;<br/></li>
<li>&nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: tentative midpoint </span><span class="Special">%ld\n</span><span class="Constant">&quot;</span>, t-&gt;id, <a href="#L132" title="regex/regexec.c:132">LOFF</a>(mid)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* iterate until satisfaction or failure */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* try this midpoint on for size */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a>(v, d2, mid, end, (<span class="Type">int</span> *) <span class="Constant">NULL</span>) == end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; er = <a href="#L756" title="regex/regexec.c:756">cdissect</a>(v, left, begin, mid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (er == REG_OKAY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; er = <a href="#L756" title="regex/regexec.c:756">cdissect</a>(v, right, mid, end);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (er == REG_OKAY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* satisfaction */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: successful</span><span class="Special">\n</span><span class="Constant">&quot;</span>, t-&gt;id));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_OKAY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset left's matches (right should have done so itself) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L679" title="regex/regexec.c:679">zaptreesubs</a>(v, left);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (er != REG_NOMATCH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> er;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* that midpoint didn't work, <a href="#L419" title="regex/regexec.c:419">find</a> a new one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mid == begin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* all possibilities exhausted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: no midpoint</span><span class="Special">\n</span><span class="Constant">&quot;</span>, t-&gt;id));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_NOMATCH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mid = <a href="rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a>(v, d, begin, mid - <span class="Constant">1</span>, (<span class="Type">int</span> *) <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mid == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* failed to <a href="#L419" title="regex/regexec.c:419">find</a> a new one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: failed midpoint</span><span class="Special">\n</span><span class="Constant">&quot;</span>, t-&gt;id));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_NOMATCH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: new midpoint </span><span class="Special">%ld\n</span><span class="Constant">&quot;</span>, t-&gt;id, <a href="#L132" title="regex/regexec.c:132">LOFF</a>(mid)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* can't get here */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> REG_ASSERT;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L910" title="regex/regexec.c:910">crevcondissect</a> - dissect match for concatenation node, <a href="rege_dfa.c.html#L204" title="regex/rege_dfa.c:204">shortest</a>-first<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* regexec return code */<br/></li>
<li><a id="L910">&#x200c;</a></span><span class="linkable">crevcondissect</span>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> *t,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *begin,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* beginning of relevant substring */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *end)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of same */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> *left = t-&gt;child;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> *right = left-&gt;sibling;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *d;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *d2;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *mid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; er;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(t-&gt;op == <span class="Constant">'.'</span>);<br/></li>
<li>&nbsp; &nbsp; assert(left != <span class="Constant">NULL</span> &amp;&amp; left-&gt;cnfa.nstates &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; assert(right != <span class="Constant">NULL</span> &amp;&amp; right-&gt;cnfa.nstates &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; assert(right-&gt;sibling == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; assert(left-&gt;flags &amp; SHORTER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; d = <a href="#L372" title="regex/regexec.c:372">getsubdfa</a>(v, left);<br/></li>
<li>&nbsp; &nbsp; <a href="#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; d2 = <a href="#L372" title="regex/regexec.c:372">getsubdfa</a>(v, right);<br/></li>
<li>&nbsp; &nbsp; <a href="#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: <a href="#L910" title="regex/regexec.c:910">crevcondissect</a> </span><span class="Special">%ld</span><span class="Constant">-</span><span class="Special">%ld\n</span><span class="Constant">&quot;</span>, t-&gt;id, <a href="#L132" title="regex/regexec.c:132">LOFF</a>(begin), <a href="#L132" title="regex/regexec.c:132">LOFF</a>(end)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pick a tentative midpoint */<br/></li>
<li></span>&nbsp; &nbsp; mid = <a href="rege_dfa.c.html#L204" title="regex/rege_dfa.c:204">shortest</a>(v, d, begin, begin, end, (<a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> **) <span class="Constant">NULL</span>, (<span class="Type">int</span> *) <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mid == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_NOMATCH;<br/></li>
<li>&nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: tentative midpoint </span><span class="Special">%ld\n</span><span class="Constant">&quot;</span>, t-&gt;id, <a href="#L132" title="regex/regexec.c:132">LOFF</a>(mid)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* iterate until satisfaction or failure */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* try this midpoint on for size */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a>(v, d2, mid, end, (<span class="Type">int</span> *) <span class="Constant">NULL</span>) == end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; er = <a href="#L756" title="regex/regexec.c:756">cdissect</a>(v, left, begin, mid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (er == REG_OKAY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; er = <a href="#L756" title="regex/regexec.c:756">cdissect</a>(v, right, mid, end);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (er == REG_OKAY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* satisfaction */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: successful</span><span class="Special">\n</span><span class="Constant">&quot;</span>, t-&gt;id));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_OKAY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset left's matches (right should have done so itself) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L679" title="regex/regexec.c:679">zaptreesubs</a>(v, left);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (er != REG_NOMATCH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> er;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* that midpoint didn't work, <a href="#L419" title="regex/regexec.c:419">find</a> a new one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mid == end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* all possibilities exhausted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: no midpoint</span><span class="Special">\n</span><span class="Constant">&quot;</span>, t-&gt;id));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_NOMATCH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mid = <a href="rege_dfa.c.html#L204" title="regex/rege_dfa.c:204">shortest</a>(v, d, begin, mid + <span class="Constant">1</span>, end, (<a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> **) <span class="Constant">NULL</span>, (<span class="Type">int</span> *) <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mid == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* failed to <a href="#L419" title="regex/regexec.c:419">find</a> a new one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: failed midpoint</span><span class="Special">\n</span><span class="Constant">&quot;</span>, t-&gt;id));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_NOMATCH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: new midpoint </span><span class="Special">%ld\n</span><span class="Constant">&quot;</span>, t-&gt;id, <a href="#L132" title="regex/regexec.c:132">LOFF</a>(mid)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* can't get here */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> REG_ASSERT;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L994" title="regex/regexec.c:994">cbrdissect</a> - dissect match for backref node<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The backref match might already have been verified by <a href="rege_dfa.c.html#L506" title="regex/rege_dfa.c:506">dfa_backref</a>(),<br/></li>
<li></span><span class="Comment"> * but we don't know that for sure so must check it here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* regexec return code */<br/></li>
<li><a id="L994">&#x200c;</a></span><span class="linkable">cbrdissect</span>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> *t,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *begin,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* beginning of relevant substring */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *end)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of same */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = t-&gt;backno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; numreps;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; tlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; brlen;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *brstring;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min = t-&gt;min;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max = t-&gt;max;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(t != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; assert(t-&gt;op == <span class="Constant">'b'</span>);<br/></li>
<li>&nbsp; &nbsp; assert(n &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; assert((<span class="Type">size_t</span>) n &lt; v-&gt;nmatch);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: <a href="#L994" title="regex/regexec.c:994">cbrdissect</a> </span><span class="Special">%d</span><span class="Constant">{</span><span class="Special">%d</span><span class="Constant">-</span><span class="Special">%d</span><span class="Constant">} </span><span class="Special">%ld</span><span class="Constant">-</span><span class="Special">%ld\n</span><span class="Constant">&quot;</span>, t-&gt;id, n, min, max,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L132" title="regex/regexec.c:132">LOFF</a>(begin), <a href="#L132" title="regex/regexec.c:132">LOFF</a>(end)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* get the backreferenced string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;pmatch[n].rm_so == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_NOMATCH;<br/></li>
<li>&nbsp; &nbsp; brstring = v-&gt;start + v-&gt;pmatch[n].rm_so;<br/></li>
<li>&nbsp; &nbsp; brlen = v-&gt;pmatch[n].rm_eo - v-&gt;pmatch[n].rm_so;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* special cases for zero-length strings */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (brlen == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matches only if target is zero length, but <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * repetitions can be considered to be present<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (begin == end &amp;&amp; min &lt;= max)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: backref matched trivially</span><span class="Special">\n</span><span class="Constant">&quot;</span>, t-&gt;id));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_OKAY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_NOMATCH;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (begin == end)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* matches only if zero repetitions are okay */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (min == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: backref matched trivially</span><span class="Special">\n</span><span class="Constant">&quot;</span>, t-&gt;id));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_OKAY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_NOMATCH;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check target length to see if it could possibly be an allowed number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * repetitions of brstring<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; assert(end &gt; begin);<br/></li>
<li>&nbsp; &nbsp; tlen = end - begin;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tlen % brlen != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_NOMATCH;<br/></li>
<li>&nbsp; &nbsp; numreps = tlen / brlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numreps &lt; min || (numreps &gt; max &amp;&amp; max != DUPINF))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_NOMATCH;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* okay, <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the actual string contents */<br/></li>
<li></span>&nbsp; &nbsp; p = begin;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (numreps-- &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((*v-&gt;g-&gt;<a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>) (brstring, p, brlen) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_NOMATCH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p += brlen;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: backref matched</span><span class="Special">\n</span><span class="Constant">&quot;</span>, t-&gt;id));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> REG_OKAY;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1076" title="regex/regexec.c:1076">caltdissect</a> - dissect match for alternation node<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* regexec return code */<br/></li>
<li><a id="L1076">&#x200c;</a></span><span class="linkable">caltdissect</span>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> *t,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *begin,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* beginning of relevant substring */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *end)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of same */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *d;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; er;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(t-&gt;op == <span class="Constant">'|'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; t = t-&gt;child;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* there should be at least 2 alternatives */<br/></li>
<li></span>&nbsp; &nbsp; assert(t != <span class="Constant">NULL</span> &amp;&amp; t-&gt;sibling != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (t != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(t-&gt;cnfa.nstates &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: <a href="#L1076" title="regex/regexec.c:1076">caltdissect</a> </span><span class="Special">%ld</span><span class="Constant">-</span><span class="Special">%ld\n</span><span class="Constant">&quot;</span>, t-&gt;id, <a href="#L132" title="regex/regexec.c:132">LOFF</a>(begin), <a href="#L132" title="regex/regexec.c:132">LOFF</a>(end)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; d = <a href="#L372" title="regex/regexec.c:372">getsubdfa</a>(v, t);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a>(v, d, begin, end, (<span class="Type">int</span> *) <span class="Constant">NULL</span>) == end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: <a href="#L1076" title="regex/regexec.c:1076">caltdissect</a> matched</span><span class="Special">\n</span><span class="Constant">&quot;</span>, t-&gt;id));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; er = <a href="#L756" title="regex/regexec.c:756">cdissect</a>(v, t, begin, end);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (er != REG_NOMATCH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> er;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; t = t-&gt;sibling;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> REG_NOMATCH;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1117" title="regex/regexec.c:1117">citerdissect</a> - dissect match for iteration node<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* regexec return code */<br/></li>
<li><a id="L1117">&#x200c;</a></span><span class="linkable">citerdissect</span>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> *t,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *begin,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* beginning of relevant substring */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *end)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of same */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *d;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; **endpts;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *limit;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_matches;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; max_matches;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nverified;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; er;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(t-&gt;op == <span class="Constant">'*'</span>);<br/></li>
<li>&nbsp; &nbsp; assert(t-&gt;child != <span class="Constant">NULL</span> &amp;&amp; t-&gt;child-&gt;cnfa.nstates &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; assert(!(t-&gt;child-&gt;flags &amp; SHORTER));<br/></li>
<li>&nbsp; &nbsp; assert(begin &lt;= end);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: <a href="#L1117" title="regex/regexec.c:1117">citerdissect</a> </span><span class="Special">%ld</span><span class="Constant">-</span><span class="Special">%ld\n</span><span class="Constant">&quot;</span>, t-&gt;id, <a href="#L132" title="regex/regexec.c:132">LOFF</a>(begin), <a href="#L132" title="regex/regexec.c:132">LOFF</a>(end)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For the moment, assume the minimum number of matches is 1.&nbsp; If zero<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * matches are allowed, and the target string is empty, we are allowed to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * match regardless of the contents of the iter node --- but we would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prefer to match once, so that capturing parens get set.&nbsp; (An example of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the concern here is a pattern like &quot;()*\1&quot;, which historically this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * code has allowed to succeed.)&nbsp; Therefore, we deal with the zero-matches<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case at the bottom, after failing to <a href="#L419" title="regex/regexec.c:419">find</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other way to match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; min_matches = t-&gt;min;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (min_matches &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; min_matches = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need workspace to track the endpoints of each sub-match.&nbsp; Normally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we consider only nonzero-length sub-matches, so there can be at most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end-begin of them.&nbsp; However, if min is larger than that, we will also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consider zero-length sub-matches in order to <a href="#L419" title="regex/regexec.c:419">find</a> enough matches.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For convenience, endpts[0] contains the &quot;begin&quot; pointer and we store<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sub-match endpoints in endpts[1..max_matches].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; max_matches = end - begin;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (max_matches &gt; t-&gt;max &amp;&amp; t-&gt;max != DUPINF)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; max_matches = t-&gt;max;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (max_matches &lt; min_matches)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; max_matches = min_matches;<br/></li>
<li>&nbsp; &nbsp; endpts = (<a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> **) MALLOC((max_matches + <span class="Constant">1</span>) * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (endpts == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_ESPACE;<br/></li>
<li>&nbsp; &nbsp; endpts[<span class="Constant">0</span>] = begin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; d = <a href="#L372" title="regex/regexec.c:372">getsubdfa</a>(v, t-&gt;child);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L127" title="regex/regexec.c:127">ISERR</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FREE(endpts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> v-&gt;err;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Our strategy is to first <a href="#L419" title="regex/regexec.c:419">find</a> a set of sub-match endpoints that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * valid according to the child node's DFA, and then recursively dissect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * each sub-match to confirm validity.&nbsp; If <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> validity check fails,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backtrack that sub-match and try again.&nbsp; And, when we <a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> try for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * validity check, we need not recheck <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> successfully verified<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sub-matches that we didn't move the endpoints of.&nbsp; nverified remembers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * how many sub-matches are currently known okay.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> to consider first sub-match */<br/></li>
<li></span>&nbsp; &nbsp; nverified = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; k = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; limit = end;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* iterate until satisfaction or failure */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (k &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* try to <a href="#L419" title="regex/regexec.c:419">find</a> an endpoint for the k'th sub-match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; endpts[k] = <a href="rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a>(v, d, endpts[k - <span class="Constant">1</span>], limit, (<span class="Type">int</span> *) <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L127" title="regex/regexec.c:127">ISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FREE(endpts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> v-&gt;err;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (endpts[k] == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no match possible, so see if we can shorten previous one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> backtrack;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: working endpoint </span><span class="Special">%d</span><span class="Constant">: </span><span class="Special">%ld\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t-&gt;id, k, <a href="#L132" title="regex/regexec.c:132">LOFF</a>(endpts[k])));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* k'th sub-match can no longer be considered verified */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nverified &gt;= k)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nverified = k - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (endpts[k] != end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* haven't reached end yet, try another iteration if allowed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (k &gt;= max_matches)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must try to shorten some previous match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> backtrack;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reject zero-length match unless necessary to achieve min */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (endpts[k] == endpts[k - <span class="Constant">1</span>] &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (k &gt;= min_matches || min_matches - k &lt; end - endpts[k]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> backtrack;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; limit = end;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We've identified a way to divide the string into k sub-matches that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * works so far as the child DFA can tell.&nbsp; If k is an allowed number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of matches, start the slow part: recurse to verify each sub-match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We always have k &lt;= max_matches, needn't check that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (k &lt; min_matches)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> backtrack;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: verifying </span><span class="Special">%d</span><span class="Constant">..</span><span class="Special">%d\n</span><span class="Constant">&quot;</span>, t-&gt;id, nverified + <span class="Constant">1</span>, k));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = nverified + <span class="Constant">1</span>; i &lt;= k; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* zap <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> match data from a non-last iteration */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L679" title="regex/regexec.c:679">zaptreesubs</a>(v, t-&gt;child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; er = <a href="#L756" title="regex/regexec.c:756">cdissect</a>(v, t-&gt;child, endpts[i - <span class="Constant">1</span>], endpts[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (er == REG_OKAY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nverified = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (er == REG_NOMATCH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* oops, something failed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FREE(endpts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> er;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt; k)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* satisfaction */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: successful</span><span class="Special">\n</span><span class="Constant">&quot;</span>, t-&gt;id));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FREE(endpts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_OKAY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* i'th match failed to verify, so backtrack it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; k = i;<br/></li>
<li><br/></li>
<li><span class="Statement">backtrack</span><span class="cUserCont">:<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Must consider shorter versions of the k'th sub-match.&nbsp; However,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll only ask for a zero-length match if necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (k &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *prev_end = endpts[k - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (endpts[k] &gt; prev_end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; limit = endpts[k] - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (limit &gt; prev_end ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (k &lt; min_matches &amp;&amp; min_matches - k &gt;= end - prev_end))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* break out of backtrack loop, continue the outer one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can't shorten k'th sub-match <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more, consider previous one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* all possibilities exhausted */<br/></li>
<li></span>&nbsp; &nbsp; FREE(endpts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now consider the possibility that we can match to a zero-length string<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by using zero repetitions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (t-&gt;min == <span class="Constant">0</span> &amp;&amp; begin == end)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: allowing zero matches</span><span class="Special">\n</span><span class="Constant">&quot;</span>, t-&gt;id));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_OKAY;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: failed</span><span class="Special">\n</span><span class="Constant">&quot;</span>, t-&gt;id));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> REG_NOMATCH;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1321" title="regex/regexec.c:1321">creviterdissect</a> - dissect match for iteration node, <a href="rege_dfa.c.html#L204" title="regex/rege_dfa.c:204">shortest</a>-first<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* regexec return code */<br/></li>
<li><a id="L1321">&#x200c;</a></span><span class="linkable">creviterdissect</span>(<span class="Type">struct</span> <a href="#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="regcomp.c.html#L2093" title="regex/regcomp.c:2093">subre</a> *t,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *begin,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* beginning of relevant substring */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *end)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of same */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L63" title="regex/regexec.c:63">dfa</a> *d;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; **endpts;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *limit;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_matches;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; max_matches;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nverified;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; er;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(t-&gt;op == <span class="Constant">'*'</span>);<br/></li>
<li>&nbsp; &nbsp; assert(t-&gt;child != <span class="Constant">NULL</span> &amp;&amp; t-&gt;child-&gt;cnfa.nstates &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; assert(t-&gt;child-&gt;flags &amp; SHORTER);<br/></li>
<li>&nbsp; &nbsp; assert(begin &lt;= end);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: <a href="#L1321" title="regex/regexec.c:1321">creviterdissect</a> </span><span class="Special">%ld</span><span class="Constant">-</span><span class="Special">%ld\n</span><span class="Constant">&quot;</span>, t-&gt;id, <a href="#L132" title="regex/regexec.c:132">LOFF</a>(begin), <a href="#L132" title="regex/regexec.c:132">LOFF</a>(end)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If zero matches are allowed, and target string is empty, just declare<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * victory.&nbsp; OTOH, if target string isn't empty, zero matches can't work<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so we pretend the min is 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; min_matches = t-&gt;min;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (min_matches &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (begin == end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: allowing zero matches</span><span class="Special">\n</span><span class="Constant">&quot;</span>, t-&gt;id));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_OKAY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; min_matches = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need workspace to track the endpoints of each sub-match.&nbsp; Normally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we consider only nonzero-length sub-matches, so there can be at most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end-begin of them.&nbsp; However, if min is larger than that, we will also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consider zero-length sub-matches in order to <a href="#L419" title="regex/regexec.c:419">find</a> enough matches.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For convenience, endpts[0] contains the &quot;begin&quot; pointer and we store<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sub-match endpoints in endpts[1..max_matches].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; max_matches = end - begin;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (max_matches &gt; t-&gt;max &amp;&amp; t-&gt;max != DUPINF)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; max_matches = t-&gt;max;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (max_matches &lt; min_matches)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; max_matches = min_matches;<br/></li>
<li>&nbsp; &nbsp; endpts = (<a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> **) MALLOC((max_matches + <span class="Constant">1</span>) * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (endpts == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_ESPACE;<br/></li>
<li>&nbsp; &nbsp; endpts[<span class="Constant">0</span>] = begin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; d = <a href="#L372" title="regex/regexec.c:372">getsubdfa</a>(v, t-&gt;child);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L127" title="regex/regexec.c:127">ISERR</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FREE(endpts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> v-&gt;err;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Our strategy is to first <a href="#L419" title="regex/regexec.c:419">find</a> a set of sub-match endpoints that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * valid according to the child node's DFA, and then recursively dissect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * each sub-match to confirm validity.&nbsp; If <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> validity check fails,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backtrack that sub-match and try again.&nbsp; And, when we <a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> try for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * validity check, we need not recheck <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> successfully verified<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sub-matches that we didn't move the endpoints of.&nbsp; nverified remembers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * how many sub-matches are currently known okay.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> to consider first sub-match */<br/></li>
<li></span>&nbsp; &nbsp; nverified = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; k = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; limit = begin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* iterate until satisfaction or failure */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (k &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* disallow zero-length match unless necessary to achieve min */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (limit == endpts[k - <span class="Constant">1</span>] &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; limit != end &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (k &gt;= min_matches || min_matches - k &lt; end - limit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; limit++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if this is the last allowed sub-match, it must reach to the end */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (k &gt;= max_matches)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; limit = end;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* try to <a href="#L419" title="regex/regexec.c:419">find</a> an endpoint for the k'th sub-match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; endpts[k] = <a href="rege_dfa.c.html#L204" title="regex/rege_dfa.c:204">shortest</a>(v, d, endpts[k - <span class="Constant">1</span>], limit, end,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> **) <span class="Constant">NULL</span>, (<span class="Type">int</span> *) <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L127" title="regex/regexec.c:127">ISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FREE(endpts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> v-&gt;err;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (endpts[k] == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no match possible, so see if we can lengthen previous one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> backtrack;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: working endpoint </span><span class="Special">%d</span><span class="Constant">: </span><span class="Special">%ld\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t-&gt;id, k, <a href="#L132" title="regex/regexec.c:132">LOFF</a>(endpts[k])));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* k'th sub-match can no longer be considered verified */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nverified &gt;= k)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nverified = k - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (endpts[k] != end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* haven't reached end yet, try another iteration if allowed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (k &gt;= max_matches)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must try to lengthen some previous match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> backtrack;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; limit = endpts[k - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We've identified a way to divide the string into k sub-matches that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * works so far as the child DFA can tell.&nbsp; If k is an allowed number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of matches, start the slow part: recurse to verify each sub-match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We always have k &lt;= max_matches, needn't check that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (k &lt; min_matches)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> backtrack;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: verifying </span><span class="Special">%d</span><span class="Constant">..</span><span class="Special">%d\n</span><span class="Constant">&quot;</span>, t-&gt;id, nverified + <span class="Constant">1</span>, k));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = nverified + <span class="Constant">1</span>; i &lt;= k; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* zap <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> match data from a non-last iteration */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L679" title="regex/regexec.c:679">zaptreesubs</a>(v, t-&gt;child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; er = <a href="#L756" title="regex/regexec.c:756">cdissect</a>(v, t-&gt;child, endpts[i - <span class="Constant">1</span>], endpts[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (er == REG_OKAY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nverified = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (er == REG_NOMATCH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* oops, something failed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FREE(endpts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> er;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt; k)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* satisfaction */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: successful</span><span class="Special">\n</span><span class="Constant">&quot;</span>, t-&gt;id));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FREE(endpts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_OKAY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* i'th match failed to verify, so backtrack it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; k = i;<br/></li>
<li><br/></li>
<li><span class="Statement">backtrack</span><span class="cUserCont">:<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Must consider longer versions of the k'th sub-match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (k &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (endpts[k] &lt; end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; limit = endpts[k] + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* break out of backtrack loop, continue the outer one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can't lengthen k'th sub-match <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more, consider previous one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* all possibilities exhausted */<br/></li>
<li></span>&nbsp; &nbsp; MDEBUG((<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: failed</span><span class="Special">\n</span><span class="Constant">&quot;</span>, t-&gt;id));<br/></li>
<li>&nbsp; &nbsp; FREE(endpts);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> REG_NOMATCH;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;rege_dfa.c&quot;<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
