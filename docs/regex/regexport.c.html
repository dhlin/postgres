<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>regex/regexport.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>regex/regexport.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L191">pg_reg_colorisbegin</a></li>
<li><a href="#L208">pg_reg_colorisend</a></li>
<li><a href="#L266">pg_reg_getcharacters</a></li>
<li><a href="#L64">pg_reg_getfinalstate</a></li>
<li><a href="#L50">pg_reg_getinitialstate</a></li>
<li><a href="#L230">pg_reg_getnumcharacters</a></li>
<li><a href="#L174">pg_reg_getnumcolors</a></li>
<li><a href="#L134">pg_reg_getnumoutarcs</a></li>
<li><a href="#L36">pg_reg_getnumstates</a></li>
<li><a href="#L155">pg_reg_getoutarcs</a></li>
<li><a href="#L93">traverse_lacons</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * regexport.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Functions for exporting info about a regex's NFA<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In this implementation, the NFA defines a necessary but not sufficient<br/></li>
<li></span><span class="Comment"> * condition for a string to match the regex: that is, there can be strings<br/></li>
<li></span><span class="Comment"> * that match the NFA but don't match the full regex, but not vice versa.<br/></li>
<li></span><span class="Comment"> * Thus, for example, it is okay for the <a href="regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> below to treat lookaround<br/></li>
<li></span><span class="Comment"> * constraints as no-ops, since they merely constrain the string some more.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Notice that these <a href="regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> return info into caller-provided arrays<br/></li>
<li></span><span class="Comment"> * rather than doing their own malloc's.&nbsp; This simplifies the APIs by<br/></li>
<li></span><span class="Comment"> * eliminating a class of error conditions, and in the case of colors<br/></li>
<li></span><span class="Comment"> * allows the caller to decide how big is too big to bother with.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 2013-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1998, 1999 Henry Spencer<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/regex/regexport.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;regex/regguts.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;regex/regexport.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get total number of NFA states.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L36">&#x200c;</a></span><span class="linkable">pg_reg_getnumstates</span>(<span class="Type">const</span> regex_t *regex)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> cnfa *cnfa;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(regex != <span class="Constant">NULL</span> &amp;&amp; regex-&gt;re_magic == REMAGIC);<br/></li>
<li>&nbsp; &nbsp; cnfa = &amp;((<span class="Type">struct</span> guts *) regex-&gt;re_guts)-&gt;search;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cnfa-&gt;nstates;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get initial state of NFA.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L50">&#x200c;</a></span><span class="linkable">pg_reg_getinitialstate</span>(<span class="Type">const</span> regex_t *regex)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> cnfa *cnfa;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(regex != <span class="Constant">NULL</span> &amp;&amp; regex-&gt;re_magic == REMAGIC);<br/></li>
<li>&nbsp; &nbsp; cnfa = &amp;((<span class="Type">struct</span> guts *) regex-&gt;re_guts)-&gt;search;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cnfa-&gt;pre;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get final state of NFA.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L64">&#x200c;</a></span><span class="linkable">pg_reg_getfinalstate</span>(<span class="Type">const</span> regex_t *regex)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> cnfa *cnfa;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(regex != <span class="Constant">NULL</span> &amp;&amp; regex-&gt;re_magic == REMAGIC);<br/></li>
<li>&nbsp; &nbsp; cnfa = &amp;((<span class="Type">struct</span> guts *) regex-&gt;re_guts)-&gt;search;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cnfa-&gt;post;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L134" title="regex/regexport.c:134">pg_reg_getnumoutarcs</a>() and <a href="#L155" title="regex/regexport.c:155">pg_reg_getoutarcs</a>() mask the existence of <a href="regcomp.c.html#L340" title="regex/regcomp.c:340">LACON</a><br/></li>
<li></span><span class="Comment"> * arcs from the caller, treating <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="regcomp.c.html#L340" title="regex/regcomp.c:340">LACON</a> as being automatically satisfied.<br/></li>
<li></span><span class="Comment"> * Since the output representation does not support arcs that consume no<br/></li>
<li></span><span class="Comment"> * character when traversed, we have to recursively traverse <a href="regcomp.c.html#L340" title="regex/regcomp.c:340">LACON</a> arcs here,<br/></li>
<li></span><span class="Comment"> * and report whatever normal arcs are reachable by traversing <a href="regcomp.c.html#L340" title="regex/regcomp.c:340">LACON</a> arcs.<br/></li>
<li></span><span class="Comment"> * Note that this wouldn't work if it were possible to reach the final state<br/></li>
<li></span><span class="Comment"> * via <a href="regcomp.c.html#L340" title="regex/regcomp.c:340">LACON</a> traversal, but the regex library never builds NFAs that have<br/></li>
<li></span><span class="Comment"> * <a href="regcomp.c.html#L340" title="regex/regcomp.c:340">LACON</a> arcs leading directly to the final state.&nbsp; (This is because the<br/></li>
<li></span><span class="Comment"> * regex executor is designed to consume one character beyond the nominal<br/></li>
<li></span><span class="Comment"> * match end --- possibly an <a href="regcomp.c.html#L329" title="regex/regcomp.c:329">EOS</a> indicator --- so there is always a set of<br/></li>
<li></span><span class="Comment"> * ordinary arcs leading to the final state.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L93" title="regex/regexport.c:93">traverse_lacons</a> is a recursive subroutine used by both exported <a href="regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> * to count and then emit the reachable regular arcs.&nbsp; *arcs_count is<br/></li>
<li></span><span class="Comment"> * incremented by the number of reachable arcs, and as many as will fit in<br/></li>
<li></span><span class="Comment"> * arcs_len (possibly 0) are emitted into arcs[].<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L93">&#x200c;</a></span><span class="linkable">traverse_lacons</span>(<span class="Type">struct</span> cnfa *cnfa, <span class="Type">int</span> st,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *arcs_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; regex_arc_t *arcs, <span class="Type">int</span> arcs_len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> carc *ca;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since this function recurses, it could theoretically be driven to stack<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overflow.&nbsp; In practice, this is mostly useful to backstop against a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * failure of the regex compiler to remove a loop of <a href="regcomp.c.html#L340" title="regex/regcomp.c:340">LACON</a> arcs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (ca = cnfa-&gt;states[st]; ca-&gt;co != COLORLESS; ca++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ca-&gt;co &lt; cnfa-&gt;ncolors)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ordinary arc, so count and possibly emit it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndx = (*arcs_count)++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ndx &lt; arcs_len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arcs[ndx].co = ca-&gt;co;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arcs[ndx].to = ca-&gt;to;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="regcomp.c.html#L340" title="regex/regcomp.c:340">LACON</a> arc --- assume it's satisfied and recurse... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... but first, assert it doesn't lead directly to post state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ca-&gt;to != cnfa-&gt;post);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L93" title="regex/regexport.c:93">traverse_lacons</a>(cnfa, ca-&gt;to, arcs_count, arcs, arcs_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get number of outgoing NFA arcs of state number &quot;st&quot;.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L134">&#x200c;</a></span><span class="linkable">pg_reg_getnumoutarcs</span>(<span class="Type">const</span> regex_t *regex, <span class="Type">int</span> st)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> cnfa *cnfa;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arcs_count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(regex != <span class="Constant">NULL</span> &amp;&amp; regex-&gt;re_magic == REMAGIC);<br/></li>
<li>&nbsp; &nbsp; cnfa = &amp;((<span class="Type">struct</span> guts *) regex-&gt;re_guts)-&gt;search;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (st &lt; <span class="Constant">0</span> || st &gt;= cnfa-&gt;nstates)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; arcs_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L93" title="regex/regexport.c:93">traverse_lacons</a>(cnfa, st, &amp;arcs_count, <span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> arcs_count;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write array of outgoing NFA arcs of state number &quot;st&quot; into arcs[],<br/></li>
<li></span><span class="Comment"> * whose length arcs_len must be at least as long as indicated by<br/></li>
<li></span><span class="Comment"> * <a href="#L134" title="regex/regexport.c:134">pg_reg_getnumoutarcs</a>(), else not all arcs will be returned.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L155">&#x200c;</a></span><span class="linkable">pg_reg_getoutarcs</span>(<span class="Type">const</span> regex_t *regex, <span class="Type">int</span> st,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; regex_arc_t *arcs, <span class="Type">int</span> arcs_len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> cnfa *cnfa;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arcs_count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(regex != <span class="Constant">NULL</span> &amp;&amp; regex-&gt;re_magic == REMAGIC);<br/></li>
<li>&nbsp; &nbsp; cnfa = &amp;((<span class="Type">struct</span> guts *) regex-&gt;re_guts)-&gt;search;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (st &lt; <span class="Constant">0</span> || st &gt;= cnfa-&gt;nstates || arcs_len &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; arcs_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L93" title="regex/regexport.c:93">traverse_lacons</a>(cnfa, st, &amp;arcs_count, arcs, arcs_len);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get total number of colors.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L174">&#x200c;</a></span><span class="linkable">pg_reg_getnumcolors</span>(<span class="Type">const</span> regex_t *regex)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> colormap *cm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(regex != <span class="Constant">NULL</span> &amp;&amp; regex-&gt;re_magic == REMAGIC);<br/></li>
<li>&nbsp; &nbsp; cm = &amp;((<span class="Type">struct</span> guts *) regex-&gt;re_guts)-&gt;cmap;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cm-&gt;max + <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check if color is beginning of line/string.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (We might at some point need to offer more refined handling of pseudocolors,<br/></li>
<li></span><span class="Comment"> * but this will do for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L191">&#x200c;</a></span><span class="linkable">pg_reg_colorisbegin</span>(<span class="Type">const</span> regex_t *regex, <span class="Type">int</span> co)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> cnfa *cnfa;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(regex != <span class="Constant">NULL</span> &amp;&amp; regex-&gt;re_magic == REMAGIC);<br/></li>
<li>&nbsp; &nbsp; cnfa = &amp;((<span class="Type">struct</span> guts *) regex-&gt;re_guts)-&gt;search;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (co == cnfa-&gt;bos[<span class="Constant">0</span>] || co == cnfa-&gt;bos[<span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check if color is end of line/string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L208">&#x200c;</a></span><span class="linkable">pg_reg_colorisend</span>(<span class="Type">const</span> regex_t *regex, <span class="Type">int</span> co)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> cnfa *cnfa;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(regex != <span class="Constant">NULL</span> &amp;&amp; regex-&gt;re_magic == REMAGIC);<br/></li>
<li>&nbsp; &nbsp; cnfa = &amp;((<span class="Type">struct</span> guts *) regex-&gt;re_guts)-&gt;search;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (co == cnfa-&gt;eos[<span class="Constant">0</span>] || co == cnfa-&gt;eos[<span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get number of member chrs of color number &quot;co&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we return -1 if the color number is invalid, or if it is a special<br/></li>
<li></span><span class="Comment"> * color (WHITE, RAINBOW, or a <a href="regc_color.c.html#L312" title="regex/regc_color.c:312">pseudocolor</a>), or if the number of members is<br/></li>
<li></span><span class="Comment"> * uncertain.<br/></li>
<li></span><span class="Comment"> * Callers should not try to extract the members if -1 is returned.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L230">&#x200c;</a></span><span class="linkable">pg_reg_getnumcharacters</span>(<span class="Type">const</span> regex_t *regex, <span class="Type">int</span> co)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> colormap *cm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(regex != <span class="Constant">NULL</span> &amp;&amp; regex-&gt;re_magic == REMAGIC);<br/></li>
<li>&nbsp; &nbsp; cm = &amp;((<span class="Type">struct</span> guts *) regex-&gt;re_guts)-&gt;cmap;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (co &lt;= <span class="Constant">0</span> || co &gt; cm-&gt;max)&nbsp; &nbsp; <span class="Comment">/* &lt;= 0 rejects WHITE and RAINBOW */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cm-&gt;cd[co].flags &amp; PSEUDO)&nbsp; &nbsp; <span class="Comment">/* also pseudocolors (BOS etc) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the color appears anywhere in the high colormap, treat its number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * members as uncertain.&nbsp; In principle we could determine all the specific<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * chrs corresponding to each such entry, but it would be expensive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (particularly if character class tests are required) and it doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * seem worth it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cm-&gt;cd[co].nuchrs != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, return the known number of member chrs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> cm-&gt;cd[co].nschrs;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write array of member chrs of color number &quot;co&quot; into chars[],<br/></li>
<li></span><span class="Comment"> * whose length chars_len must be at least as long as indicated by<br/></li>
<li></span><span class="Comment"> * <a href="#L230" title="regex/regexport.c:230">pg_reg_getnumcharacters</a>(), else not all chars will be returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Fetching the members of WHITE, RAINBOW, or a <a href="regc_color.c.html#L312" title="regex/regc_color.c:312">pseudocolor</a> is not supported.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caution: this is a relatively expensive operation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L266">&#x200c;</a></span><span class="linkable">pg_reg_getcharacters</span>(<span class="Type">const</span> regex_t *regex, <span class="Type">int</span> co,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_wchar *chars, <span class="Type">int</span> chars_len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> colormap *cm;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(regex != <span class="Constant">NULL</span> &amp;&amp; regex-&gt;re_magic == REMAGIC);<br/></li>
<li>&nbsp; &nbsp; cm = &amp;((<span class="Type">struct</span> guts *) regex-&gt;re_guts)-&gt;cmap;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (co &lt;= <span class="Constant">0</span> || co &gt; cm-&gt;max || chars_len &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cm-&gt;cd[co].flags &amp; PSEUDO)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need only examine the low character map; there should not be <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * matching entries in the high map.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (c = CHR_MIN; c &lt;= MAX_SIMPLE_CHR; c++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cm-&gt;locolormap[c - CHR_MIN] == co)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *chars++ = c;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (--chars_len == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
