<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>regex/regcomp.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>regex/regcomp.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L356">functions</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L280">vars</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1671">bracket</a></li>
<li><a href="#L1761">brackpart</a></li>
<li><a href="#L1727">cbracket</a></li>
<li><a href="#L1492">charclass</a></li>
<li><a href="#L1516">charclasscomplement</a></li>
<li><a href="#L2310">cleanst</a></li>
<li><a href="#L2491">dump</a></li>
<li><a href="#L2554">dumpst</a></li>
<li><a href="#L2427">freelacons</a></li>
<li><a href="#L2185">freesrnode</a></li>
<li><a href="#L2150">freesubre</a></li>
<li><a href="#L2169">freesubreandsiblings</a></li>
<li><a href="#L590">freev</a></li>
<li><a href="#L619">makesearch</a></li>
<li><a href="#L2295">markst</a></li>
<li><a href="#L553">moresubs</a></li>
<li><a href="#L2388">newlacon</a></li>
<li><a href="#L2349">nfanode</a></li>
<li><a href="#L2329">nfatree</a></li>
<li><a href="#L1456">nonword</a></li>
<li><a href="#L2262">numst</a></li>
<li><a href="#L1909">onechr</a></li>
<li><a href="#L1935">optimizebracket</a></li>
<li><a href="#L715">parse</a></li>
<li><a href="#L783">parsebranch</a></li>
<li><a href="#L836">parseqatom</a></li>
<li><a href="#L370">pg_regcomp</a></li>
<li><a href="#L2027">processlacon</a></li>
<li><a href="#L2216">removecaptures</a></li>
<li><a href="#L1584">repeat</a></li>
<li><a href="#L2444">rfree</a></li>
<li><a href="#L2480">rstacktoodeep</a></li>
<li><a href="#L1553">scannum</a></li>
<li><a href="#L1884">scanplain</a></li>
<li><a href="#L2569">stdump</a></li>
<li><a href="#L2627">stid</a></li>
<li><a href="#L2093">subre</a></li>
<li><a href="#L1474">word</a></li>
<li><a href="#L1991">wordchrs</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L341">AHEAD</a></li>
<li><a href="#L846">ARCV</a></li>
<li><a href="#L332">BACKREF</a></li>
<li><a href="#L342">BEHIND</a></li>
<li><a href="#L335">CCLASS</a></li>
<li><a href="#L338">CCLASSC</a></li>
<li><a href="#L337">CCLASSS</a></li>
<li><a href="#L388">CNOERR</a></li>
<li><a href="#L333">COLLEL</a></li>
<li><a href="#L350">COLORED</a></li>
<li><a href="#L201">COMPATIBLE</a></li>
<li><a href="#L331">DIGIT</a></li>
<li><a href="#L314">EAT</a></li>
<li><a href="#L334">ECLASS</a></li>
<li><a href="#L328">EMPTY</a></li>
<li><a href="#L325">EMPTYARC</a></li>
<li><a href="#L336">END</a></li>
<li><a href="#L329">EOS</a></li>
<li><a href="#L319">ERR</a></li>
<li><a href="#L199">INCOMPATIBLE</a></li>
<li><a href="#L1591">INF</a></li>
<li><a href="#L323">INSIST</a></li>
<li><a href="#L316">ISERR</a></li>
<li><a href="#L340">LACON</a></li>
<li><a href="#L312">NEXT</a></li>
<li><a href="#L320">NOERR</a></li>
<li><a href="#L321">NOERRN</a></li>
<li><a href="#L322">NOERRZ</a></li>
<li><a href="#L324">NOTE</a></li>
<li><a href="#L344">NWBDRY</a></li>
<li><a href="#L1592">PAIR</a></li>
<li><a href="#L330">PLAIN</a></li>
<li><a href="#L339">RANGE</a></li>
<li><a href="#L1593">REDUCE</a></li>
<li><a href="#L202">REPLACEARC</a></li>
<li><a href="#L200">SATISFIED</a></li>
<li><a href="#L345">SBEGIN</a></li>
<li><a href="#L313">SEE</a></li>
<li><a href="#L346">SEND</a></li>
<li><a href="#L1590">SOME</a></li>
<li><a href="#L317">VERR</a></li>
<li><a href="#L315">VISERR</a></li>
<li><a href="#L343">WBDRY</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * re_*comp and friends - compile REs<br/></li>
<li></span><span class="Comment"> * This file #includes several others (see the bottom).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 1998, 1999 Henry Spencer.&nbsp; All rights reserved.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Development of this software was funded, in part, by Cray Research Inc.,<br/></li>
<li></span><span class="Comment"> * UUNET Communications Services Inc., Sun Microsystems Inc., and Scriptics<br/></li>
<li></span><span class="Comment"> * Corporation, <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of whom are responsible for the results.&nbsp; The author<br/></li>
<li></span><span class="Comment"> * thanks all of them.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Redistribution and use in source and binary forms -- with or without<br/></li>
<li></span><span class="Comment"> * modification -- are permitted for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> purpose, provided that<br/></li>
<li></span><span class="Comment"> * redistributions in source form retain this entire copyright notice and<br/></li>
<li></span><span class="Comment"> * indicate the origin and nature of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> modifications.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * I'd appreciate being given credit for this package in the documentation<br/></li>
<li></span><span class="Comment"> * of software which uses it, but that is not a requirement.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,<br/></li>
<li></span><span class="Comment"> * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY<br/></li>
<li></span><span class="Comment"> * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.&nbsp; IN NO EVENT SHALL<br/></li>
<li></span><span class="Comment"> * HENRY SPENCER BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,<br/></li>
<li></span><span class="Comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,<br/></li>
<li></span><span class="Comment"> * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;<br/></li>
<li></span><span class="Comment"> * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,<br/></li>
<li></span><span class="Comment"> * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR<br/></li>
<li></span><span class="Comment"> * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF<br/></li>
<li></span><span class="Comment"> * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * src/backend/regex/regcomp.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;regex/regguts.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * forward declarations, up here so forward datatypes etc. are defined early<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Comment">/* === regcomp.c === */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L553" title="regex/regcomp.c:553">moresubs</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">int</span> wanted);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L590" title="regex/regcomp.c:590">freev</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">int</span> err);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L619" title="regex/regcomp.c:619">makesearch</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> nfa *nfa);<br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *<a href="#L715" title="regex/regcomp.c:715">parse</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">int</span> stopper, <span class="Type">int</span> type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *init, <span class="Type">struct</span> state *final);<br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *<a href="#L783" title="regex/regcomp.c:783">parsebranch</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">int</span> stopper, <span class="Type">int</span> type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *left, <span class="Type">struct</span> state *right,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> partial);<br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *<a href="#L836" title="regex/regcomp.c:836">parseqatom</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">int</span> stopper, <span class="Type">int</span> type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *lp, <span class="Type">struct</span> state *rp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *top);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1456" title="regex/regcomp.c:1456">nonword</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">int</span> dir, <span class="Type">struct</span> state *lp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *rp);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1474" title="regex/regcomp.c:1474">word</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">int</span> dir, <span class="Type">struct</span> state *lp, <span class="Type">struct</span> state *rp);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1492" title="regex/regcomp.c:1492">charclass</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">enum</span> char_classes cls, <span class="Type">struct</span> state *lp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *rp);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1516" title="regex/regcomp.c:1516">charclasscomplement</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">enum</span> char_classes cls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *lp, <span class="Type">struct</span> state *rp);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1553" title="regex/regcomp.c:1553">scannum</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1584" title="regex/regcomp.c:1584">repeat</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> state *lp, <span class="Type">struct</span> state *rp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> m, <span class="Type">int</span> n);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1671" title="regex/regcomp.c:1671">bracket</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> state *lp, <span class="Type">struct</span> state *rp);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1727" title="regex/regcomp.c:1727">cbracket</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> state *lp, <span class="Type">struct</span> state *rp);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1761" title="regex/regcomp.c:1761">brackpart</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> state *lp, <span class="Type">struct</span> state *rp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *have_cclassc);<br/></li>
<li><span class="Type">static</span> <span class="Type">const</span> <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *<a href="#L1884" title="regex/regcomp.c:1884">scanplain</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1909" title="regex/regcomp.c:1909">onechr</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> c, <span class="Type">struct</span> state *lp, <span class="Type">struct</span> state *rp);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1935" title="regex/regcomp.c:1935">optimizebracket</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> state *lp, <span class="Type">struct</span> state *rp);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1991" title="regex/regcomp.c:1991">wordchrs</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2027" title="regex/regcomp.c:2027">processlacon</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> state *begin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *end, <span class="Type">int</span> latype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *lp, <span class="Type">struct</span> state *rp);<br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *<a href="#L2093" title="regex/regcomp.c:2093">subre</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">int</span> op, <span class="Type">int</span> flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *begin, <span class="Type">struct</span> state *end);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2150" title="regex/regcomp.c:2150">freesubre</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *sr);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2169" title="regex/regcomp.c:2169">freesubreandsiblings</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *sr);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2185" title="regex/regcomp.c:2185">freesrnode</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *sr);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2216" title="regex/regcomp.c:2216">removecaptures</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *t);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2262" title="regex/regcomp.c:2262">numst</a>(<span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *t, <span class="Type">int</span> start);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2295" title="regex/regcomp.c:2295">markst</a>(<span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *t);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2310" title="regex/regcomp.c:2310">cleanst</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v);<br/></li>
<li><span class="Type">static</span> <span class="Type">long</span> <a href="#L2329" title="regex/regcomp.c:2329">nfatree</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *t, <span class="Type">FILE</span> *f);<br/></li>
<li><span class="Type">static</span> <span class="Type">long</span> <a href="#L2349" title="regex/regcomp.c:2349">nfanode</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *t,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> converttosearch, <span class="Type">FILE</span> *f);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2388" title="regex/regcomp.c:2388">newlacon</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> state *begin, <span class="Type">struct</span> state *end,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> latype);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2427" title="regex/regcomp.c:2427">freelacons</a>(<span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *subs, <span class="Type">int</span> n);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2444" title="regex/regcomp.c:2444">rfree</a>(regex_t *re);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2480" title="regex/regcomp.c:2480">rstacktoodeep</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef REG_DEBUG<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L2491" title="regex/regcomp.c:2491">dump</a>(regex_t *re, <span class="Type">FILE</span> *f);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2554" title="regex/regcomp.c:2554">dumpst</a>(<span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *t, <span class="Type">FILE</span> *f, <span class="Type">int</span> nfapresent);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2569" title="regex/regcomp.c:2569">stdump</a>(<span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *t, <span class="Type">FILE</span> *f, <span class="Type">int</span> nfapresent);<br/></li>
<li><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<a href="#L2627" title="regex/regcomp.c:2627">stid</a>(<span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *t, <span class="Type">char</span> *buf, <span class="Type">size_t</span> bufsize);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="Comment">/* === regc_lex.c === */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="regc_lex.c.html#L70" title="regex/regc_lex.c:70">lexstart</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_lex.c.html#L99" title="regex/regc_lex.c:99">prefixes</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_lex.c.html#L601" title="regex/regc_lex.c:601">lexescape</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v);<br/></li>
<li><span class="Type">static</span> <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; <a href="regc_lex.c.html#L780" title="regex/regc_lex.c:780">lexdigits</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">int</span> base, <span class="Type">int</span> minlen, <span class="Type">int</span> maxlen);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_lex.c.html#L861" title="regex/regc_lex.c:861">brenext</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> c);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v);<br/></li>
<li><span class="Type">static</span> <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; <a href="regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; <a href="regc_lex.c.html#L1022" title="regex/regc_lex.c:1022">chrnamed</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">const</span> <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *startp, <span class="Type">const</span> <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *endp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> lastresort);<br/></li>
<li><br/></li>
<li><span class="Comment">/* === regc_color.c === */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="regc_color.c.html#L49" title="regex/regc_color.c:49">initcm</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> colormap *cm);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_color.c.html#L103" title="regex/regc_color.c:103">freecm</a>(<span class="Type">struct</span> colormap *cm);<br/></li>
<li><span class="Type">static</span> color <a href="regc_color.c.html#L172" title="regex/regc_color.c:172">maxcolor</a>(<span class="Type">struct</span> colormap *cm);<br/></li>
<li><span class="Type">static</span> color <a href="regc_color.c.html#L185" title="regex/regc_color.c:185">newcolor</a>(<span class="Type">struct</span> colormap *cm);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_color.c.html#L257" title="regex/regc_color.c:257">freecolor</a>(<span class="Type">struct</span> colormap *cm, color co);<br/></li>
<li><span class="Type">static</span> color <a href="regc_color.c.html#L312" title="regex/regc_color.c:312">pseudocolor</a>(<span class="Type">struct</span> colormap *cm);<br/></li>
<li><span class="Type">static</span> color <a href="regc_color.c.html#L336" title="regex/regc_color.c:336">subcolor</a>(<span class="Type">struct</span> colormap *cm, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> c);<br/></li>
<li><span class="Type">static</span> color <a href="regc_color.c.html#L366" title="regex/regc_color.c:366">subcolorhi</a>(<span class="Type">struct</span> colormap *cm, color *pco);<br/></li>
<li><span class="Type">static</span> color <a href="regc_color.c.html#L389" title="regex/regc_color.c:389">newsub</a>(<span class="Type">struct</span> colormap *cm, color co);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_color.c.html#L420" title="regex/regc_color.c:420">newhicolorrow</a>(<span class="Type">struct</span> colormap *cm, <span class="Type">int</span> oldrow);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_color.c.html#L469" title="regex/regc_color.c:469">newhicolorcols</a>(<span class="Type">struct</span> colormap *cm);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_color.c.html#L522" title="regex/regc_color.c:522">subcolorcvec</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> cvec *cv, <span class="Type">struct</span> state *lp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *rp);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_color.c.html#L624" title="regex/regc_color.c:624">subcoloronechr</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> ch, <span class="Type">struct</span> state *lp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *rp, color *lastsubcolor);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_color.c.html#L747" title="regex/regc_color.c:747">subcoloronerange</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> from, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> to,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *lp, <span class="Type">struct</span> state *rp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; color *lastsubcolor);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_color.c.html#L885" title="regex/regc_color.c:885">subcoloronerow</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">int</span> rownum, <span class="Type">struct</span> state *lp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *rp, color *lastsubcolor);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_color.c.html#L916" title="regex/regc_color.c:916">okcolors</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> colormap *cm);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_color.c.html#L984" title="regex/regc_color.c:984">colorchain</a>(<span class="Type">struct</span> colormap *cm, <span class="Type">struct</span> arc *a);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_color.c.html#L1001" title="regex/regc_color.c:1001">uncolorchain</a>(<span class="Type">struct</span> colormap *cm, <span class="Type">struct</span> arc *a);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_color.c.html#L1031" title="regex/regc_color.c:1031">rainbow</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> colormap *cm, <span class="Type">int</span> type, color but,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *from, <span class="Type">struct</span> state *to);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_color.c.html#L1064" title="regex/regc_color.c:1064">colorcomplement</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> colormap *cm, <span class="Type">int</span> type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *of, <span class="Type">struct</span> state *from,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *to);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef REG_DEBUG<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="regc_color.c.html#L1111" title="regex/regc_color.c:1111">dumpcolors</a>(<span class="Type">struct</span> colormap *cm, <span class="Type">FILE</span> *f);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_color.c.html#L1175" title="regex/regc_color.c:1175">dumpchr</a>(<a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> c, <span class="Type">FILE</span> *f);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="Comment">/* === regc_nfa.c === */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">struct</span> nfa *<a href="regc_nfa.c.html#L47" title="regex/regc_nfa.c:47">newnfa</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">struct</span> colormap *cm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> nfa *parent);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L107" title="regex/regc_nfa.c:107">freenfa</a>(<span class="Type">struct</span> nfa *nfa);<br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> state *<a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(<span class="Type">struct</span> nfa *nfa);<br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> state *<a href="regc_nfa.c.html#L212" title="regex/regc_nfa.c:212">newfstate</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">int</span> flag);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L226" title="regex/regc_nfa.c:226">dropstate</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> state *s);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L242" title="regex/regc_nfa.c:242">freestate</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> state *s);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L281" title="regex/regc_nfa.c:281">newarc</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">int</span> t, color co,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *from, <span class="Type">struct</span> state *to);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L323" title="regex/regc_nfa.c:323">createarc</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">int</span> t, color co,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *from, <span class="Type">struct</span> state *to);<br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> arc *<a href="regc_nfa.c.html#L368" title="regex/regc_nfa.c:368">allocarc</a>(<span class="Type">struct</span> nfa *nfa);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L418" title="regex/regc_nfa.c:418">freearc</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> arc *victim);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L489" title="regex/regc_nfa.c:489">changearcsource</a>(<span class="Type">struct</span> arc *a, <span class="Type">struct</span> state *newfrom);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L533" title="regex/regc_nfa.c:533">changearctarget</a>(<span class="Type">struct</span> arc *a, <span class="Type">struct</span> state *newto);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_nfa.c.html#L575" title="regex/regc_nfa.c:575">hasnonemptyout</a>(<span class="Type">struct</span> state *s);<br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> arc *<a href="regc_nfa.c.html#L592" title="regex/regc_nfa.c:592">findarc</a>(<span class="Type">struct</span> state *s, <span class="Type">int</span> type, color co);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L608" title="regex/regc_nfa.c:608">cparc</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> arc *oa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *from, <span class="Type">struct</span> state *to);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L620" title="regex/regc_nfa.c:620">sortins</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> state *s);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_nfa.c.html#L662" title="regex/regc_nfa.c:662">sortins_cmp</a>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L687" title="regex/regc_nfa.c:687">sortouts</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> state *s);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_nfa.c.html#L729" title="regex/regc_nfa.c:729">sortouts_cmp</a>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L778" title="regex/regc_nfa.c:778">moveins</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> state *oldState,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *newState);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L882" title="regex/regc_nfa.c:882">copyins</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> state *oldState,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *newState);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L971" title="regex/regc_nfa.c:971">mergeins</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> state *s,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> arc **arcarray, <span class="Type">int</span> arccount);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L1066" title="regex/regc_nfa.c:1066">moveouts</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> state *oldState,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *newState);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L1167" title="regex/regc_nfa.c:1167">copyouts</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> state *oldState,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *newState);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L1256" title="regex/regc_nfa.c:1256">cloneouts</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> state *old, <span class="Type">struct</span> state *from,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *to, <span class="Type">int</span> type);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L1281" title="regex/regc_nfa.c:1281">delsub</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> state *lp, <span class="Type">struct</span> state *rp);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L1304" title="regex/regc_nfa.c:1304">deltraverse</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> state *leftend,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *s);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L1355" title="regex/regc_nfa.c:1355">dupnfa</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> state *start, <span class="Type">struct</span> state *stop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *from, <span class="Type">struct</span> state *to);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L1379" title="regex/regc_nfa.c:1379">duptraverse</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> state *s, <span class="Type">struct</span> state *stmp);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L1419" title="regex/regc_nfa.c:1419">removeconstraints</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> state *start, <span class="Type">struct</span> state *stop);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L1438" title="regex/regc_nfa.c:1438">removetraverse</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> state *s);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L1487" title="regex/regc_nfa.c:1487">cleartraverse</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> state *s);<br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> state *<a href="regc_nfa.c.html#L1524" title="regex/regc_nfa.c:1524">single_color_transition</a>(<span class="Type">struct</span> state *s1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *s2);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L1554" title="regex/regc_nfa.c:1554">specialcolors</a>(<span class="Type">struct</span> nfa *nfa);<br/></li>
<li><span class="Type">static</span> <span class="Type">long</span> <a href="regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">FILE</span> *f);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L1633" title="regex/regc_nfa.c:1633">pullback</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">FILE</span> *f);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> arc *con,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state **intermediates);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L1804" title="regex/regc_nfa.c:1804">pushfwd</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">FILE</span> *f);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> arc *con,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state **intermediates);<br/></li>
<li><br/></li>
<li><a id="L199">&#x200c;</a><span class="PreProc">#define <span class="linkable">INCOMPATIBLE</span>&nbsp; &nbsp; </span><span class="Constant">1</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* destroys arc */<br/></li>
<li><a id="L200">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SATISFIED</span>&nbsp; &nbsp; </span><span class="Constant">2</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* constraint satisfied */<br/></li>
<li><a id="L201">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">COMPATIBLE</span>&nbsp; &nbsp; </span><span class="Constant">3</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* compatible but not satisfied yet */<br/></li>
<li><a id="L202">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">REPLACEARC</span>&nbsp; &nbsp; </span><span class="Constant">4</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* replace arc's color with constraint color */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> arc *con, <span class="Type">struct</span> arc *a);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L2069" title="regex/regc_nfa.c:2069">fixempties</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">FILE</span> *f);<br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> state *<a href="regc_nfa.c.html#L2296" title="regex/regc_nfa.c:2296">emptyreachable</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> state *s,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *lastfound,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> arc **inarcsorig);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_nfa.c.html#L2324" title="regex/regc_nfa.c:2324">isconstraintarc</a>(<span class="Type">struct</span> arc *a);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_nfa.c.html#L2342" title="regex/regc_nfa.c:2342">hasconstraintout</a>(<span class="Type">struct</span> state *s);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L2363" title="regex/regc_nfa.c:2363">fixconstraintloops</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">FILE</span> *f);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_nfa.c.html#L2462" title="regex/regc_nfa.c:2462">findconstraintloop</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> state *s);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L2551" title="regex/regc_nfa.c:2551">breakconstraintloop</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> state *sinitial);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L2697" title="regex/regc_nfa.c:2697">clonesuccessorstates</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> state *ssource,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *sclone,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *spredecessor,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> arc *refarc, <span class="Type">char</span> *curdonemap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *outerdonemap, <span class="Type">int</span> nstates);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>(<span class="Type">struct</span> nfa *nfa);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L2964" title="regex/regc_nfa.c:2964">markreachable</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> state *s,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *okay, <span class="Type">struct</span> state *mark);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L2990" title="regex/regc_nfa.c:2990">markcanreach</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> state *s, <span class="Type">struct</span> state *okay,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *mark);<br/></li>
<li><span class="Type">static</span> <span class="Type">long</span> <a href="regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>(<span class="Type">struct</span> nfa *nfa);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L3062" title="regex/regc_nfa.c:3062">checkmatchall</a>(<span class="Type">struct</span> nfa *nfa);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="regc_nfa.c.html#L3242" title="regex/regc_nfa.c:3242">checkmatchall_recurse</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> state *s,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> **haspaths);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="regc_nfa.c.html#L3380" title="regex/regc_nfa.c:3380">check_out_colors_match</a>(<span class="Type">struct</span> state *s, color co1, color co2);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="regc_nfa.c.html#L3434" title="regex/regc_nfa.c:3434">check_in_colors_match</a>(<span class="Type">struct</span> state *s, color co1, color co2);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L3479" title="regex/regc_nfa.c:3479">compact</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">struct</span> cnfa *cnfa);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L3570" title="regex/regc_nfa.c:3570">carcsort</a>(<span class="Type">struct</span> carc *first, <span class="Type">size_t</span> n);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_nfa.c.html#L3577" title="regex/regc_nfa.c:3577">carc_cmp</a>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L3598" title="regex/regc_nfa.c:3598">freecnfa</a>(<span class="Type">struct</span> cnfa *cnfa);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L3611" title="regex/regc_nfa.c:3611">dumpnfa</a>(<span class="Type">struct</span> nfa *nfa, <span class="Type">FILE</span> *f);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef REG_DEBUG<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L3658" title="regex/regc_nfa.c:3658">dumpstate</a>(<span class="Type">struct</span> state *s, <span class="Type">FILE</span> *f);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L3684" title="regex/regc_nfa.c:3684">dumparcs</a>(<span class="Type">struct</span> state *s, <span class="Type">FILE</span> *f);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L3716" title="regex/regc_nfa.c:3716">dumparc</a>(<span class="Type">struct</span> arc *a, <span class="Type">struct</span> state *s, <span class="Type">FILE</span> *f);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L3783" title="regex/regc_nfa.c:3783">dumpcnfa</a>(<span class="Type">struct</span> cnfa *cnfa, <span class="Type">FILE</span> *f);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_nfa.c.html#L3820" title="regex/regc_nfa.c:3820">dumpcstate</a>(<span class="Type">int</span> st, <span class="Type">struct</span> cnfa *cnfa, <span class="Type">FILE</span> *f);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="Comment">/* === regc_cvec.c === */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">struct</span> cvec *<a href="regc_cvec.c.html#L45" title="regex/regc_cvec.c:45">newcvec</a>(<span class="Type">int</span> nchrs, <span class="Type">int</span> nranges);<br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> cvec *<a href="regc_cvec.c.html#L66" title="regex/regc_cvec.c:66">clearcvec</a>(<span class="Type">struct</span> cvec *cv);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_cvec.c.html#L79" title="regex/regc_cvec.c:79">addchr</a>(<span class="Type">struct</span> cvec *cv, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> c);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_cvec.c.html#L90" title="regex/regc_cvec.c:90">addrange</a>(<span class="Type">struct</span> cvec *cv, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> from, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> to);<br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> cvec *<a href="regc_cvec.c.html#L112" title="regex/regc_cvec.c:112">getcvec</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">int</span> nchrs, <span class="Type">int</span> nranges);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="regc_cvec.c.html#L135" title="regex/regc_cvec.c:135">freecvec</a>(<span class="Type">struct</span> cvec *cv);<br/></li>
<li><br/></li>
<li><span class="Comment">/* === regc_pg_locale.c === */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_pg_locale.c.html#L294" title="regex/regc_pg_locale.c:294">pg_wc_isdigit</a>(pg_wchar c);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_pg_locale.c.html#L328" title="regex/regc_pg_locale.c:328">pg_wc_isalpha</a>(pg_wchar c);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_pg_locale.c.html#L362" title="regex/regc_pg_locale.c:362">pg_wc_isalnum</a>(pg_wchar c);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_pg_locale.c.html#L396" title="regex/regc_pg_locale.c:396">pg_wc_isword</a>(pg_wchar c);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_pg_locale.c.html#L405" title="regex/regc_pg_locale.c:405">pg_wc_isupper</a>(pg_wchar c);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_pg_locale.c.html#L439" title="regex/regc_pg_locale.c:439">pg_wc_islower</a>(pg_wchar c);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_pg_locale.c.html#L473" title="regex/regc_pg_locale.c:473">pg_wc_isgraph</a>(pg_wchar c);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_pg_locale.c.html#L507" title="regex/regc_pg_locale.c:507">pg_wc_isprint</a>(pg_wchar c);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_pg_locale.c.html#L541" title="regex/regc_pg_locale.c:541">pg_wc_ispunct</a>(pg_wchar c);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_pg_locale.c.html#L575" title="regex/regc_pg_locale.c:575">pg_wc_isspace</a>(pg_wchar c);<br/></li>
<li><span class="Type">static</span> pg_wchar <a href="regc_pg_locale.c.html#L609" title="regex/regc_pg_locale.c:609">pg_wc_toupper</a>(pg_wchar c);<br/></li>
<li><span class="Type">static</span> pg_wchar <a href="regc_pg_locale.c.html#L651" title="regex/regc_pg_locale.c:651">pg_wc_tolower</a>(pg_wchar c);<br/></li>
<li><br/></li>
<li><span class="Comment">/* === regc_locale.c === */<br/></li>
<li></span><span class="Type">static</span> <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; <a href="regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">const</span> <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *startp, <span class="Type">const</span> <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *endp);<br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> cvec *<a href="regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> a, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> b, <span class="Type">int</span> cases);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>(<a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> x, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> y);<br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> cvec *<a href="regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> c, <span class="Type">int</span> cases);<br/></li>
<li><span class="Type">static</span> <span class="Type">enum</span> char_classes <a href="regc_locale.c.html#L536" title="regex/regc_locale.c:536">lookupcclass</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">const</span> <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *startp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *endp);<br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> cvec *<a href="regc_locale.c.html#L569" title="regex/regc_locale.c:569">cclasscvec</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <span class="Type">enum</span> char_classes cclasscode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> cases);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_locale.c.html#L671" title="regex/regc_locale.c:671">cclass_column_index</a>(<span class="Type">struct</span> colormap *cm, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> c);<br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> cvec *<a href="regc_locale.c.html#L717" title="regex/regc_locale.c:717">allcases</a>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v, <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> c);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>(<span class="Type">const</span> <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *x, <span class="Type">const</span> <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *y, <span class="Type">size_t</span> len);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="regc_locale.c.html#L758" title="regex/regc_locale.c:758">casecmp</a>(<span class="Type">const</span> <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *x, <span class="Type">const</span> <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *y, <span class="Type">size_t</span> len);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> variables, bundled for easy passing around */<br/></li>
<li><a id="L280">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">vars</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; regex_t&nbsp; &nbsp; *re;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; *<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* scan pointer into string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">const</span> <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; *stop;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; err;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* error code (0 if <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cflags;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy of compile flags */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lasttype;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* type of previous token */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nexttype;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* type of <a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> token */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextvalue;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* value (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) of <a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> token */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lexcon;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* lexical context type (see regc_lex.c) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nsubexp;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* subexpression count */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> **subs;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* subRE pointer vector */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; nsubs;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* length of vector */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *sub10[<span class="Constant">10</span>];&nbsp; &nbsp; <span class="Comment">/* initial vector, enough for most */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> nfa *nfa;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the NFA */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> colormap *cm;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* character color map */<br/></li>
<li></span>&nbsp; &nbsp; color&nbsp; &nbsp; &nbsp; &nbsp; nlcolor;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* color of <a href="regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> state *<a href="#L1991" title="regex/regcomp.c:1991">wordchrs</a>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* state in nfa holding <a href="#L1474" title="regex/regcomp.c:1474">word</a>-char outarcs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *tree;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* subexpression tree */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *treechain;&nbsp; &nbsp; <span class="Comment">/* all tree nodes allocated */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *treefree;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> free tree nodes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntree;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of tree nodes, plus one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> cvec *cv;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* interface cvec */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> cvec *cv2;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* utility cvec */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *lacons;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* lookaround-constraint vector */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nlacons;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* size of lacons[]; note that only slots<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * numbered 1 .. nlacons-1 are used */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; spaceused;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* approx. space used for compilation */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* parsing macros; most know that `v' is the struct <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> pointer */<br/></li>
<li><a id="L312">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NEXT</span>()&nbsp; &nbsp; (<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>(v))&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* advance by one token */<br/></li>
<li><a id="L313">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SEE</span>(t)&nbsp; &nbsp; (v-&gt;nexttype == (t))&nbsp; &nbsp; </span><span class="Comment">/* is <a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> token this? */<br/></li>
<li><a id="L314">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EAT</span>(t)&nbsp; &nbsp; (<a href="#L313" title="regex/regcomp.c:313">SEE</a>(t) &amp;&amp; <a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>(v)) </span><span class="Comment">/* if <a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> is this, swallow it */<br/></li>
<li><a id="L315">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">VISERR</span>(vv)&nbsp; &nbsp; ((vv)-&gt;err != </span><span class="Constant">0</span><span class="PreProc">)&nbsp; &nbsp; </span><span class="Comment">/* have we seen an error yet? */<br/></li>
<li><a id="L316">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ISERR</span>() <a href="regexec.c.html#L126" title="regex/regexec.c:126">VISERR</a>(v)<br/></li>
<li><a id="L317">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">VERR</span>(vv,e)&nbsp; &nbsp; ((vv)-&gt;nexttype = <a href="#L329" title="regex/regcomp.c:329">EOS</a>, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (vv)-&gt;err = ((vv)-&gt;err ? (vv)-&gt;err : (e)))<br/></li>
<li><a id="L319">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ERR</span>(e)&nbsp; &nbsp; <a href="regexec.c.html#L128" title="regex/regexec.c:128">VERR</a>(v, e)&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* record an error */<br/></li>
<li><a id="L320">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NOERR</span>() {</span><span class="Statement">if</span><span class="PreProc"> (<a href="regexec.c.html#L127" title="regex/regexec.c:127">ISERR</a>()) </span><span class="Statement">return</span><span class="PreProc">;}&nbsp; &nbsp; </span><span class="Comment">/* if error seen, return */<br/></li>
<li><a id="L321">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NOERRN</span>()&nbsp; &nbsp; {</span><span class="Statement">if</span><span class="PreProc"> (<a href="regexec.c.html#L127" title="regex/regexec.c:127">ISERR</a>()) </span><span class="Statement">return</span><span class="PreProc"> </span><span class="Constant">NULL</span><span class="PreProc">;} </span><span class="Comment">/* <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a> with retval */<br/></li>
<li><a id="L322">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NOERRZ</span>()&nbsp; &nbsp; {</span><span class="Statement">if</span><span class="PreProc"> (<a href="regexec.c.html#L127" title="regex/regexec.c:127">ISERR</a>()) </span><span class="Statement">return</span><span class="PreProc"> </span><span class="Constant">0</span><span class="PreProc">;}&nbsp; &nbsp; </span><span class="Comment">/* <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a> with retval */<br/></li>
<li><a id="L323">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">INSIST</span>(c, e) </span><span class="Statement">do</span><span class="PreProc"> { </span><span class="Statement">if</span><span class="PreProc"> (!(c)) <a href="regexec.c.html#L129" title="regex/regexec.c:129">ERR</a>(e); } </span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">) </span><span class="Comment">/* error if c false */<br/></li>
<li><a id="L324">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NOTE</span>(b) (v-&gt;re-&gt;re_info |= (b)) </span><span class="Comment">/* note visible condition */<br/></li>
<li><a id="L325">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EMPTYARC</span>(x, y)&nbsp; &nbsp; <a href="regc_nfa.c.html#L281" title="regex/regc_nfa.c:281">newarc</a>(v-&gt;nfa, <a href="#L328" title="regex/regcomp.c:328">EMPTY</a>, </span><span class="Constant">0</span><span class="PreProc">, x, y)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* token type codes, some also used as NFA arc types */<br/></li>
<li><a id="L328">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EMPTY</span>&nbsp; &nbsp; </span><span class="Constant">'n'</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* no token present */<br/></li>
<li><a id="L329">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EOS</span> </span><span class="Constant">'e'</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* end of string */<br/></li>
<li><a id="L330">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PLAIN</span>&nbsp; &nbsp; </span><span class="Constant">'p'</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* ordinary character */<br/></li>
<li><a id="L331">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DIGIT</span>&nbsp; &nbsp; </span><span class="Constant">'d'</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* digit (in bound) */<br/></li>
<li><a id="L332">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BACKREF</span> </span><span class="Constant">'b'</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* back reference */<br/></li>
<li><a id="L333">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">COLLEL</span>&nbsp; &nbsp; </span><span class="Constant">'I'</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* start of [. */<br/></li>
<li><a id="L334">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ECLASS</span>&nbsp; &nbsp; </span><span class="Constant">'E'</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* start of [= */<br/></li>
<li><a id="L335">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CCLASS</span>&nbsp; &nbsp; </span><span class="Constant">'C'</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* start of [: */<br/></li>
<li><a id="L336">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">END</span> </span><span class="Constant">'X'</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* end of [. [= [: */<br/></li>
<li><a id="L337">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CCLASSS</span>&nbsp; &nbsp; </span><span class="Constant">'s'</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* char class shorthand escape */<br/></li>
<li><a id="L338">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CCLASSC</span>&nbsp; &nbsp; </span><span class="Constant">'c'</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* complement char class shorthand escape */<br/></li>
<li><a id="L339">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RANGE</span>&nbsp; &nbsp; </span><span class="Constant">'R'</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* - within [] which might be <a href="regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> delim. */<br/></li>
<li><a id="L340">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LACON</span>&nbsp; &nbsp; </span><span class="Constant">'L'</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* lookaround constraint subRE */<br/></li>
<li><a id="L341">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">AHEAD</span>&nbsp; &nbsp; </span><span class="Constant">'a'</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* color-lookahead arc */<br/></li>
<li><a id="L342">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BEHIND</span>&nbsp; &nbsp; </span><span class="Constant">'r'</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* color-lookbehind arc */<br/></li>
<li><a id="L343">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WBDRY</span>&nbsp; &nbsp; </span><span class="Constant">'w'</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* <a href="#L1474" title="regex/regcomp.c:1474">word</a> boundary constraint */<br/></li>
<li><a id="L344">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NWBDRY</span>&nbsp; &nbsp; </span><span class="Constant">'W'</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* non-<a href="#L1474" title="regex/regcomp.c:1474">word</a>-boundary constraint */<br/></li>
<li><a id="L345">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SBEGIN</span>&nbsp; &nbsp; </span><span class="Constant">'A'</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* beginning of string (even if not BOL) */<br/></li>
<li><a id="L346">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SEND</span>&nbsp; &nbsp; </span><span class="Constant">'Z'</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* end of string (even if not EOL) */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* is an arc colored, and hence should belong to a color chain? */<br/></li>
<li></span><span class="Comment">/* the test on &quot;co&quot; eliminates RAINBOW arcs, which we don't bother to chain */<br/></li>
<li><a id="L350">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">COLORED</span>(a) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((a)-&gt;co &gt;= </span><span class="Constant">0</span><span class="PreProc"> &amp;&amp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; ((a)-&gt;type == <a href="#L330" title="regex/regcomp.c:330">PLAIN</a> || (a)-&gt;type == <a href="#L341" title="regex/regcomp.c:341">AHEAD</a> || (a)-&gt;type == <a href="#L342" title="regex/regcomp.c:342">BEHIND</a>))<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* static function list */<br/></li>
<li><a id="L356">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">struct</span> fns <span class="linkable">functions</span> = {<br/></li>
<li>&nbsp; &nbsp; <a href="#L2444" title="regex/regcomp.c:2444">rfree</a>,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* regfree insides */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2480" title="regex/regcomp.c:2480">rstacktoodeep</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check for stack getting dangerously deep */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L370" title="regex/regcomp.c:370">pg_regcomp</a> - compile regular expression<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: on failure, no resources remain allocated, so <a href="regfree.c.html#L49" title="regex/regfree.c:49">pg_regfree</a>()<br/></li>
<li></span><span class="Comment"> * need not be applied to re.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L370">&#x200c;</a></span><span class="linkable">pg_regcomp</span>(regex_t *re,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">size_t</span> len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid collation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> var;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v = &amp;var;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> guts *g;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef REG_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">FILE</span>&nbsp; &nbsp; &nbsp;&nbsp; *debug = (flags &amp; REG_PROGRESS) ? <span class="Constant">stdout</span> : (<span class="Type">FILE</span> *) <span class="Constant">NULL</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">FILE</span>&nbsp; &nbsp; &nbsp;&nbsp; *debug = (<span class="Type">FILE</span> *) <span class="Constant">NULL</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L388">&#x200c;</a><span class="PreProc">#define&nbsp; <span class="linkable">CNOERR</span>()&nbsp; &nbsp;&nbsp; { </span><span class="Statement">if</span><span class="PreProc"> (<a href="regexec.c.html#L127" title="regex/regexec.c:127">ISERR</a>()) </span><span class="Statement">return</span><span class="PreProc"> <a href="#L590" title="regex/regcomp.c:590">freev</a>(v, v-&gt;err); }<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sanity checks */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (re == <span class="Constant">NULL</span> || string == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_INVARG;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; REG_QUOTE) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (flags &amp; (REG_ADVANCED | REG_EXPANDED | REG_NEWLINE)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_INVARG;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(flags &amp; REG_EXTENDED) &amp;&amp; (flags &amp; REG_ADVF))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_INVARG;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize locale-dependent support */<br/></li>
<li></span>&nbsp; &nbsp; <a href="regc_pg_locale.c.html#L234" title="regex/regc_pg_locale.c:234">pg_set_regex_collation</a>(collation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* initial setup (after which <a href="#L590" title="regex/regcomp.c:590">freev</a>() is callable) */<br/></li>
<li></span>&nbsp; &nbsp; v-&gt;re = re;<br/></li>
<li>&nbsp; &nbsp; v-&gt;<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = string;<br/></li>
<li>&nbsp; &nbsp; v-&gt;stop = v-&gt;<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> + len;<br/></li>
<li>&nbsp; &nbsp; v-&gt;err = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; v-&gt;cflags = flags;<br/></li>
<li>&nbsp; &nbsp; v-&gt;nsubexp = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; v-&gt;subs = v-&gt;sub10;<br/></li>
<li>&nbsp; &nbsp; v-&gt;nsubs = <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; v-&gt;nsubs; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;subs[j] = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; v-&gt;nfa = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; v-&gt;cm = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; v-&gt;nlcolor = COLORLESS;<br/></li>
<li>&nbsp; &nbsp; v-&gt;<a href="#L1991" title="regex/regcomp.c:1991">wordchrs</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; v-&gt;tree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; v-&gt;treechain = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; v-&gt;treefree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; v-&gt;cv = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; v-&gt;cv2 = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; v-&gt;lacons = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; v-&gt;nlacons = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; v-&gt;spaceused = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; re-&gt;re_magic = REMAGIC;<br/></li>
<li>&nbsp; &nbsp; re-&gt;re_info = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* bits get set during <a href="#L715" title="regex/regcomp.c:715">parse</a> */<br/></li>
<li></span>&nbsp; &nbsp; re-&gt;re_csize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>);<br/></li>
<li>&nbsp; &nbsp; re-&gt;re_collation = collation;<br/></li>
<li>&nbsp; &nbsp; re-&gt;re_guts = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; re-&gt;re_fns = VS(&amp;<a href="#L356" title="regex/regcomp.c:356">functions</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* more complex setup, malloced things */<br/></li>
<li></span>&nbsp; &nbsp; re-&gt;re_guts = VS(MALLOC(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> guts)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (re-&gt;re_guts == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L590" title="regex/regcomp.c:590">freev</a>(v, REG_ESPACE);<br/></li>
<li>&nbsp; &nbsp; g = (<span class="Type">struct</span> guts *) re-&gt;re_guts;<br/></li>
<li>&nbsp; &nbsp; g-&gt;tree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="regc_color.c.html#L49" title="regex/regc_color.c:49">initcm</a>(v, &amp;g-&gt;cmap);<br/></li>
<li>&nbsp; &nbsp; v-&gt;cm = &amp;g-&gt;cmap;<br/></li>
<li>&nbsp; &nbsp; g-&gt;lacons = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; g-&gt;nlacons = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ZAPCNFA(g-&gt;search);<br/></li>
<li>&nbsp; &nbsp; v-&gt;nfa = <a href="regc_nfa.c.html#L47" title="regex/regc_nfa.c:47">newnfa</a>(v, v-&gt;cm, (<span class="Type">struct</span> nfa *) <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L388" title="regex/regcomp.c:388">CNOERR</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set up a reasonably-sized transient cvec for <a href="regc_cvec.c.html#L112" title="regex/regc_cvec.c:112">getcvec</a> usage */<br/></li>
<li></span>&nbsp; &nbsp; v-&gt;cv = <a href="regc_cvec.c.html#L45" title="regex/regc_cvec.c:45">newcvec</a>(<span class="Constant">100</span>, <span class="Constant">20</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;cv == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L590" title="regex/regcomp.c:590">freev</a>(v, REG_ESPACE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* parsing */<br/></li>
<li></span>&nbsp; &nbsp; <a href="regc_lex.c.html#L70" title="regex/regc_lex.c:70">lexstart</a>(v);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* also handles <a href="regc_lex.c.html#L99" title="regex/regc_lex.c:99">prefixes</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((v-&gt;cflags &amp; REG_NLSTOP) || (v-&gt;cflags &amp; REG_NLANCH))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* assign <a href="regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a> a unique color */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;nlcolor = <a href="regc_color.c.html#L336" title="regex/regc_color.c:336">subcolor</a>(v-&gt;cm, <a href="regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_color.c.html#L916" title="regex/regc_color.c:916">okcolors</a>(v-&gt;nfa, v-&gt;cm);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="#L388" title="regex/regcomp.c:388">CNOERR</a>();<br/></li>
<li>&nbsp; &nbsp; v-&gt;tree = <a href="#L715" title="regex/regcomp.c:715">parse</a>(v, <a href="#L329" title="regex/regcomp.c:329">EOS</a>, <a href="#L330" title="regex/regcomp.c:330">PLAIN</a>, v-&gt;nfa-&gt;init, v-&gt;nfa-&gt;final);<br/></li>
<li>&nbsp; &nbsp; assert(<a href="#L313" title="regex/regcomp.c:313">SEE</a>(<a href="#L329" title="regex/regcomp.c:329">EOS</a>));&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* even if error; <a href="regexec.c.html#L127" title="regex/regexec.c:127">ISERR</a>() =&gt; <a href="#L313" title="regex/regcomp.c:313">SEE</a>(<a href="#L329" title="regex/regcomp.c:329">EOS</a>) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L388" title="regex/regcomp.c:388">CNOERR</a>();<br/></li>
<li>&nbsp; &nbsp; assert(v-&gt;tree != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* finish setup of nfa and its <a href="#L2093" title="regex/regcomp.c:2093">subre</a> tree */<br/></li>
<li></span>&nbsp; &nbsp; <a href="regc_nfa.c.html#L1554" title="regex/regc_nfa.c:1554">specialcolors</a>(v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; <a href="#L388" title="regex/regcomp.c:388">CNOERR</a>();<br/></li>
<li><span class="PreProc">#ifdef REG_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (debug != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(debug, <span class="Constant">&quot;</span><span class="Special">\n\n\n</span><span class="Constant">========= RAW ==========</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L3611" title="regex/regc_nfa.c:3611">dumpnfa</a>(v-&gt;nfa, debug);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2554" title="regex/regcomp.c:2554">dumpst</a>(v-&gt;tree, debug, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;cflags &amp; REG_NOSUB)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2216" title="regex/regcomp.c:2216">removecaptures</a>(v, v-&gt;tree);<br/></li>
<li>&nbsp; &nbsp; v-&gt;ntree = <a href="#L2262" title="regex/regcomp.c:2262">numst</a>(v-&gt;tree, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L2295" title="regex/regcomp.c:2295">markst</a>(v-&gt;tree);<br/></li>
<li>&nbsp; &nbsp; <a href="#L2310" title="regex/regcomp.c:2310">cleanst</a>(v);<br/></li>
<li><span class="PreProc">#ifdef REG_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (debug != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(debug, <span class="Constant">&quot;</span><span class="Special">\n\n\n</span><span class="Constant">========= TREE FIXED ==========</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2554" title="regex/regcomp.c:2554">dumpst</a>(v-&gt;tree, debug, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build compacted NFAs for tree and lacons */<br/></li>
<li></span>&nbsp; &nbsp; re-&gt;re_info |= <a href="#L2329" title="regex/regcomp.c:2329">nfatree</a>(v, v-&gt;tree, debug);<br/></li>
<li>&nbsp; &nbsp; <a href="#L388" title="regex/regcomp.c:388">CNOERR</a>();<br/></li>
<li>&nbsp; &nbsp; assert(v-&gt;nlacons == <span class="Constant">0</span> || v-&gt;lacons != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; v-&gt;nlacons; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *lasub = &amp;v-&gt;lacons[i];<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef REG_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (debug != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(debug, <span class="Constant">&quot;</span><span class="Special">\n\n\n</span><span class="Constant">========= LA</span><span class="Special">%d</span><span class="Constant"> ==========</span><span class="Special">\n</span><span class="Constant">&quot;</span>, i);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prepend .* to pattern if it's a lookbehind <a href="#L340" title="regex/regcomp.c:340">LACON</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2349" title="regex/regcomp.c:2349">nfanode</a>(v, lasub, !LATYPE_IS_AHEAD(lasub-&gt;latype), debug);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="#L388" title="regex/regcomp.c:388">CNOERR</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;tree-&gt;flags &amp; SHORTER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L324" title="regex/regcomp.c:324">NOTE</a>(REG_USHORTEST);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build compacted NFAs for tree, lacons, fast search */<br/></li>
<li></span><span class="PreProc">#ifdef REG_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (debug != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(debug, <span class="Constant">&quot;</span><span class="Special">\n\n\n</span><span class="Constant">========= SEARCH ==========</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* can sacrifice <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> NFA <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, so use it as work area */<br/></li>
<li></span>&nbsp; &nbsp; (DISCARD) <a href="regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a>(v-&gt;nfa, debug);<br/></li>
<li>&nbsp; &nbsp; <a href="#L388" title="regex/regcomp.c:388">CNOERR</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L619" title="regex/regcomp.c:619">makesearch</a>(v, v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; <a href="#L388" title="regex/regcomp.c:388">CNOERR</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="regc_nfa.c.html#L3479" title="regex/regc_nfa.c:3479">compact</a>(v-&gt;nfa, &amp;g-&gt;search);<br/></li>
<li>&nbsp; &nbsp; <a href="#L388" title="regex/regcomp.c:388">CNOERR</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* looks okay, package it up */<br/></li>
<li></span>&nbsp; &nbsp; re-&gt;re_nsub = v-&gt;nsubexp;<br/></li>
<li>&nbsp; &nbsp; v-&gt;re = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L590" title="regex/regcomp.c:590">freev</a> no longer frees re */<br/></li>
<li></span>&nbsp; &nbsp; g-&gt;magic = GUTSMAGIC;<br/></li>
<li>&nbsp; &nbsp; g-&gt;cflags = v-&gt;cflags;<br/></li>
<li>&nbsp; &nbsp; g-&gt;info = re-&gt;re_info;<br/></li>
<li>&nbsp; &nbsp; g-&gt;nsub = re-&gt;re_nsub;<br/></li>
<li>&nbsp; &nbsp; g-&gt;tree = v-&gt;tree;<br/></li>
<li>&nbsp; &nbsp; v-&gt;tree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; g-&gt;ntree = v-&gt;ntree;<br/></li>
<li>&nbsp; &nbsp; g-&gt;<a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> = (v-&gt;cflags &amp; REG_ICASE) ? <a href="regc_locale.c.html#L758" title="regex/regc_locale.c:758">casecmp</a> : <a href="regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li>&nbsp; &nbsp; g-&gt;lacons = v-&gt;lacons;<br/></li>
<li>&nbsp; &nbsp; v-&gt;lacons = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; g-&gt;nlacons = v-&gt;nlacons;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef REG_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; REG_DUMP)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2491" title="regex/regcomp.c:2491">dump</a>(re, <span class="Constant">stdout</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fflush(<span class="Constant">stdout</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; assert(v-&gt;err == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L590" title="regex/regcomp.c:590">freev</a>(v, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L553" title="regex/regcomp.c:553">moresubs</a> - enlarge subRE vector<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L553">&#x200c;</a></span><span class="linkable">moresubs</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> wanted)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* want enough room for this one */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> **p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(wanted &gt; <span class="Constant">0</span> &amp;&amp; (<span class="Type">size_t</span>) wanted &gt;= v-&gt;nsubs);<br/></li>
<li>&nbsp; &nbsp; n = (<span class="Type">size_t</span>) wanted * <span class="Constant">3</span> / <span class="Constant">2</span> + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;subs == v-&gt;sub10)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p = (<span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> **) MALLOC(n * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (p != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(VS(p), VS(v-&gt;subs),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; v-&gt;nsubs * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; p = (<span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> **) REALLOC(v-&gt;subs, n * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (p == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L129" title="regex/regexec.c:129">ERR</a>(REG_ESPACE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; v-&gt;subs = p;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (p = &amp;v-&gt;subs[v-&gt;nsubs]; v-&gt;nsubs &lt; n; p++, v-&gt;nsubs++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *p = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; assert(v-&gt;nsubs == n);<br/></li>
<li>&nbsp; &nbsp; assert((<span class="Type">size_t</span>) wanted &lt; v-&gt;nsubs);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L590" title="regex/regcomp.c:590">freev</a> - free <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> struct's substructures where necessary<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Optionally does error-number setting, and always returns error code<br/></li>
<li></span><span class="Comment"> * (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>), to make error-handling code terser.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L590">&#x200c;</a></span><span class="linkable">freev</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">int</span> err)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;re != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2444" title="regex/regcomp.c:2444">rfree</a>(v-&gt;re);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;subs != v-&gt;sub10)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FREE(v-&gt;subs);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;nfa != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L107" title="regex/regc_nfa.c:107">freenfa</a>(v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;tree != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2150" title="regex/regcomp.c:2150">freesubre</a>(v, v-&gt;tree);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;treechain != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2310" title="regex/regcomp.c:2310">cleanst</a>(v);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;cv != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_cvec.c.html#L135" title="regex/regc_cvec.c:135">freecvec</a>(v-&gt;cv);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;cv2 != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_cvec.c.html#L135" title="regex/regc_cvec.c:135">freecvec</a>(v-&gt;cv2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;lacons != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2427" title="regex/regcomp.c:2427">freelacons</a>(v-&gt;lacons, v-&gt;nlacons);<br/></li>
<li>&nbsp; &nbsp; <a href="regexec.c.html#L129" title="regex/regexec.c:129">ERR</a>(err);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nop if err==0 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> v-&gt;err;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L619" title="regex/regcomp.c:619">makesearch</a> - turn an NFA into a search NFA (implicit prepend of .*?)<br/></li>
<li></span><span class="Comment"> * NFA must have been <a href="regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a>()d already.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L619">&#x200c;</a></span><span class="linkable">makesearch</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> nfa *nfa)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *b;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *pre = nfa-&gt;pre;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *s;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *s2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *slist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no loops are needed if it's anchored */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (a = pre-&gt;outs; a != <span class="Constant">NULL</span>; a = a-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(a-&gt;type == <a href="#L330" title="regex/regcomp.c:330">PLAIN</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;co != nfa-&gt;bos[<span class="Constant">0</span>] &amp;&amp; a-&gt;co != nfa-&gt;bos[<span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* add implicit .* in front */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_color.c.html#L1031" title="regex/regc_color.c:1031">rainbow</a>(nfa, v-&gt;cm, <a href="#L330" title="regex/regcomp.c:330">PLAIN</a>, COLORLESS, pre, pre);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and ^* and \A* too -- not always necessary, but harmless */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L281" title="regex/regc_nfa.c:281">newarc</a>(nfa, <a href="#L330" title="regex/regcomp.c:330">PLAIN</a>, nfa-&gt;bos[<span class="Constant">0</span>], pre, pre);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L281" title="regex/regc_nfa.c:281">newarc</a>(nfa, <a href="#L330" title="regex/regcomp.c:330">PLAIN</a>, nfa-&gt;bos[<span class="Constant">1</span>], pre, pre);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The pattern is still MATCHALL if it was <a href="regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>, but the max match<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * length is <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> infinity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nfa-&gt;flags &amp; MATCHALL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nfa-&gt;maxmatchall = DUPINF;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now here's the subtle part.&nbsp; Because many REs have no lookback<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constraints, often knowing when you were in the pre state tells you<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * little; it's the <a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> state(s) that are informative.&nbsp; But some of them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * may have other inarcs, i.e. it may be possible to make actual progress<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and then return to one of them.&nbsp; We must de-<a href="regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> such cases,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * splitting each such state into progress and no-progress states.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* first, make a list of the states reachable from pre and elsewhere */<br/></li>
<li></span>&nbsp; &nbsp; slist = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (a = pre-&gt;outs; a != <span class="Constant">NULL</span>; a = a-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s = a-&gt;to;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (b = s-&gt;ins; b != <span class="Constant">NULL</span>; b = b-&gt;inchain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (b-&gt;from != pre)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We want to mark states as being in the list already by having non<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NULL tmp fields, but we can't just store the old slist value in tmp<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because that doesn't work for the first such state.&nbsp; Instead, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first list entry gets its own address in tmp.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (b != <span class="Constant">NULL</span> &amp;&amp; s-&gt;tmp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;tmp = (slist != <span class="Constant">NULL</span>) ? slist : s;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slist = s;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do the splits */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (s = slist; s != <span class="Constant">NULL</span>; s = s2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s2 = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L1167" title="regex/regc_nfa.c:1167">copyouts</a>(nfa, s, s2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (a = s-&gt;ins; a != <span class="Constant">NULL</span>; a = b)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b = a-&gt;inchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;from != pre)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L608" title="regex/regc_nfa.c:608">cparc</a>(nfa, a, a-&gt;from, s2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L418" title="regex/regc_nfa.c:418">freearc</a>(nfa, a);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s2 = (s-&gt;tmp != s) ? s-&gt;tmp : <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s-&gt;tmp = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* clean up while we're at it */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L715" title="regex/regcomp.c:715">parse</a> - <a href="#L715" title="regex/regcomp.c:715">parse</a> an RE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is actually just the top level, which parses a bunch of branches<br/></li>
<li></span><span class="Comment"> * tied together with '|'.&nbsp; If there's more than one, they appear in the<br/></li>
<li></span><span class="Comment"> * tree as the children of a '|' <a href="#L2093" title="regex/regcomp.c:2093">subre</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *<br/></li>
<li><a id="L715">&#x200c;</a><span class="linkable">parse</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">int</span> stopper,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L329" title="regex/regcomp.c:329">EOS</a> or ')' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Type">int</span> type,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L340" title="regex/regcomp.c:340">LACON</a> (lookaround subRE) or <a href="#L330" title="regex/regcomp.c:330">PLAIN</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *init,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* initial state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *final)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* final state */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *branches;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* top level */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *lastbranch;&nbsp; &nbsp; <span class="Comment">/* latest branch */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; assert(stopper == <span class="Constant">')'</span> || stopper == <a href="#L329" title="regex/regcomp.c:329">EOS</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; branches = <a href="#L2093" title="regex/regcomp.c:2093">subre</a>(v, <span class="Constant">'|'</span>, LONGER, init, final);<br/></li>
<li>&nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; lastbranch = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* a branch */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *branch;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *left;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* scaffolding for branch */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *right;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; left = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; right = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L325" title="regex/regcomp.c:325">EMPTYARC</a>(init, left);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L325" title="regex/regcomp.c:325">EMPTYARC</a>(right, final);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; branch = <a href="#L783" title="regex/regcomp.c:783">parsebranch</a>(v, stopper, type, left, right, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lastbranch)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastbranch-&gt;sibling = branch;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; branches-&gt;child = branch;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; branches-&gt;flags |= UP(branches-&gt;flags | branch-&gt;flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lastbranch = branch;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (<a href="#L314" title="regex/regcomp.c:314">EAT</a>(<span class="Constant">'|'</span>));<br/></li>
<li>&nbsp; &nbsp; assert(<a href="#L313" title="regex/regcomp.c:313">SEE</a>(stopper) || <a href="#L313" title="regex/regcomp.c:313">SEE</a>(<a href="#L329" title="regex/regcomp.c:329">EOS</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L313" title="regex/regcomp.c:313">SEE</a>(stopper))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(stopper == <span class="Constant">')'</span> &amp;&amp; <a href="#L313" title="regex/regcomp.c:313">SEE</a>(<a href="#L329" title="regex/regcomp.c:329">EOS</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L129" title="regex/regexec.c:129">ERR</a>(REG_EPAREN);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> out simple cases */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lastbranch == branches-&gt;child)<br/></li>
<li>&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* only one branch */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; assert(lastbranch-&gt;sibling == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2185" title="regex/regcomp.c:2185">freesrnode</a>(v, branches);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; branches = lastbranch;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!MESSY(branches-&gt;flags))<br/></li>
<li>&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no interesting innards */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2169" title="regex/regcomp.c:2169">freesubreandsiblings</a>(v, branches-&gt;child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; branches-&gt;child = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; branches-&gt;op = <span class="Constant">'='</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> branches;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L783" title="regex/regcomp.c:783">parsebranch</a> - <a href="#L715" title="regex/regcomp.c:715">parse</a> one branch of an RE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This mostly manages concatenation, working closely with <a href="#L836" title="regex/regcomp.c:836">parseqatom</a>().<br/></li>
<li></span><span class="Comment"> * Concatenated things are bundled up as much as possible, with separate<br/></li>
<li></span><span class="Comment"> * '.' nodes introduced only when necessary due to substructure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *<br/></li>
<li><a id="L783">&#x200c;</a><span class="linkable">parsebranch</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> stopper,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L329" title="regex/regcomp.c:329">EOS</a> or ')' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> type,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L340" title="regex/regcomp.c:340">LACON</a> (lookaround subRE) or <a href="#L330" title="regex/regcomp.c:330">PLAIN</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *left, <span class="Comment">/* leftmost state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *right,&nbsp; &nbsp; <span class="Comment">/* rightmost state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> partial)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* is this only part of a branch? */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *lp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* left end of current construct */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seencontent;&nbsp; &nbsp; <span class="Comment">/* is there anything in this branch yet? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *t;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lp = left;<br/></li>
<li>&nbsp; &nbsp; seencontent = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; t = <a href="#L2093" title="regex/regcomp.c:2093">subre</a>(v, <span class="Constant">'='</span>, <span class="Constant">0</span>, left, right);&nbsp; &nbsp; <span class="Comment">/* op '=' is tentative */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (!<a href="#L313" title="regex/regcomp.c:313">SEE</a>(<span class="Constant">'|'</span>) &amp;&amp; !<a href="#L313" title="regex/regcomp.c:313">SEE</a>(stopper) &amp;&amp; !<a href="#L313" title="regex/regcomp.c:313">SEE</a>(<a href="#L329" title="regex/regcomp.c:329">EOS</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (seencontent)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* implicit concat operator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lp = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L778" title="regex/regc_nfa.c:778">moveins</a>(v-&gt;nfa, right, lp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seencontent = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NB, recursion in <a href="#L836" title="regex/regcomp.c:836">parseqatom</a>() may swallow rest of branch */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; t = <a href="#L836" title="regex/regcomp.c:836">parseqatom</a>(v, stopper, type, lp, right, t);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!seencontent)<br/></li>
<li>&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* empty branch */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!partial)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L324" title="regex/regcomp.c:324">NOTE</a>(REG_UUNSPEC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(lp == left);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L325" title="regex/regcomp.c:325">EMPTYARC</a>(left, right);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> t;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L836" title="regex/regcomp.c:836">parseqatom</a> - <a href="#L715" title="regex/regcomp.c:715">parse</a> one quantified atom or constraint of an RE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The bookkeeping near the end cooperates very closely with <a href="#L783" title="regex/regcomp.c:783">parsebranch</a>();<br/></li>
<li></span><span class="Comment"> * in particular, it contains a recursion that can involve parsing the rest<br/></li>
<li></span><span class="Comment"> * of the branch, making this function's name somewhat inaccurate.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Usually, the return value is just &quot;top&quot;, but in some cases where we<br/></li>
<li></span><span class="Comment"> * have parsed the rest of the branch, we may deem &quot;top&quot; redundant and<br/></li>
<li></span><span class="Comment"> * free it, returning some child <a href="#L2093" title="regex/regcomp.c:2093">subre</a> instead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *<br/></li>
<li><a id="L836">&#x200c;</a><span class="linkable">parseqatom</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> stopper,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L329" title="regex/regcomp.c:329">EOS</a> or ')' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> type,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L340" title="regex/regcomp.c:340">LACON</a> (lookaround subRE) or <a href="#L330" title="regex/regcomp.c:330">PLAIN</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *lp,&nbsp; &nbsp; <span class="Comment">/* left state to hang it on */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *rp,&nbsp; &nbsp; <span class="Comment">/* right state to hang it on */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *top)&nbsp; &nbsp; <span class="Comment">/* subtree top */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *s;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* temporaries for new states */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> state *s2;<br/></li>
<li><br/></li>
<li><a id="L846">&#x200c;</a><span class="PreProc">#define&nbsp; <span class="linkable">ARCV</span>(t, val)&nbsp; &nbsp;&nbsp; <a href="regc_nfa.c.html#L281" title="regex/regc_nfa.c:281">newarc</a>(v-&gt;nfa, t, val, lp, rp)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; m,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *atom;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* atom's subtree */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *t;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cap;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* capturing parens? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; latype;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* lookaround constraint type */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subno;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* capturing-parens or backref number */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atomtype;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qprefer;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* quantifier short/long preference */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> **atomp;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* where the pointer to atom is */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* initial bookkeeping */<br/></li>
<li></span>&nbsp; &nbsp; atom = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; assert(lp-&gt;nouts == <span class="Constant">0</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must string new code */<br/></li>
<li></span>&nbsp; &nbsp; assert(rp-&gt;nins == <span class="Constant">0</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* between lp and rp */<br/></li>
<li></span>&nbsp; &nbsp; subno = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just to shut lint up */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* an atom or constraint... */<br/></li>
<li></span>&nbsp; &nbsp; atomtype = v-&gt;nexttype;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (atomtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* first, constraints, which end by returning */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'^'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L846" title="regex/regcomp.c:846">ARCV</a>(<span class="Constant">'^'</span>, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;cflags &amp; REG_NLANCH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L846" title="regex/regcomp.c:846">ARCV</a>(<a href="#L342" title="regex/regcomp.c:342">BEHIND</a>, v-&gt;nlcolor);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> top;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'$'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L846" title="regex/regcomp.c:846">ARCV</a>(<span class="Constant">'$'</span>, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;cflags &amp; REG_NLANCH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L846" title="regex/regcomp.c:846">ARCV</a>(<a href="#L341" title="regex/regcomp.c:341">AHEAD</a>, v-&gt;nlcolor);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> top;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L345" title="regex/regcomp.c:345">SBEGIN</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L846" title="regex/regcomp.c:846">ARCV</a>(<span class="Constant">'^'</span>, <span class="Constant">1</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* BOL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L846" title="regex/regcomp.c:846">ARCV</a>(<span class="Constant">'^'</span>, <span class="Constant">0</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* or BOS */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> top;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L346" title="regex/regcomp.c:346">SEND</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L846" title="regex/regcomp.c:846">ARCV</a>(<span class="Constant">'$'</span>, <span class="Constant">1</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* EOL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L846" title="regex/regcomp.c:846">ARCV</a>(<span class="Constant">'$'</span>, <span class="Constant">0</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* or <a href="#L329" title="regex/regcomp.c:329">EOS</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> top;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'&lt;'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1991" title="regex/regcomp.c:1991">wordchrs</a>(v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1456" title="regex/regcomp.c:1456">nonword</a>(v, <a href="#L342" title="regex/regcomp.c:342">BEHIND</a>, lp, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1474" title="regex/regcomp.c:1474">word</a>(v, <a href="#L341" title="regex/regcomp.c:341">AHEAD</a>, s, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> top;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'&gt;'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1991" title="regex/regcomp.c:1991">wordchrs</a>(v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1474" title="regex/regcomp.c:1474">word</a>(v, <a href="#L342" title="regex/regcomp.c:342">BEHIND</a>, lp, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1456" title="regex/regcomp.c:1456">nonword</a>(v, <a href="#L341" title="regex/regcomp.c:341">AHEAD</a>, s, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> top;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L343" title="regex/regcomp.c:343">WBDRY</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1991" title="regex/regcomp.c:1991">wordchrs</a>(v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1456" title="regex/regcomp.c:1456">nonword</a>(v, <a href="#L342" title="regex/regcomp.c:342">BEHIND</a>, lp, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1474" title="regex/regcomp.c:1474">word</a>(v, <a href="#L341" title="regex/regcomp.c:341">AHEAD</a>, s, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1474" title="regex/regcomp.c:1474">word</a>(v, <a href="#L342" title="regex/regcomp.c:342">BEHIND</a>, lp, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1456" title="regex/regcomp.c:1456">nonword</a>(v, <a href="#L341" title="regex/regcomp.c:341">AHEAD</a>, s, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> top;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L344" title="regex/regcomp.c:344">NWBDRY</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1991" title="regex/regcomp.c:1991">wordchrs</a>(v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1474" title="regex/regcomp.c:1474">word</a>(v, <a href="#L342" title="regex/regcomp.c:342">BEHIND</a>, lp, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1474" title="regex/regcomp.c:1474">word</a>(v, <a href="#L341" title="regex/regcomp.c:341">AHEAD</a>, s, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1456" title="regex/regcomp.c:1456">nonword</a>(v, <a href="#L342" title="regex/regcomp.c:342">BEHIND</a>, lp, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1456" title="regex/regcomp.c:1456">nonword</a>(v, <a href="#L341" title="regex/regcomp.c:341">AHEAD</a>, s, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> top;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L340" title="regex/regcomp.c:340">LACON</a>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* lookaround constraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; latype = v-&gt;nextvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s2 = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t = <a href="#L715" title="regex/regcomp.c:715">parse</a>(v, <span class="Constant">')'</span>, <a href="#L340" title="regex/regcomp.c:340">LACON</a>, s, s2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2150" title="regex/regcomp.c:2150">freesubre</a>(v, t);&nbsp; &nbsp; <span class="Comment">/* <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> structure irrelevant */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(<a href="#L313" title="regex/regcomp.c:313">SEE</a>(<span class="Constant">')'</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2027" title="regex/regcomp.c:2027">processlacon</a>(v, s, s2, latype, lp, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> top;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* then errors, to get them out of the way */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'*'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'+'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'?'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'{'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L129" title="regex/regexec.c:129">ERR</a>(REG_BADRPT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> top;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L129" title="regex/regexec.c:129">ERR</a>(REG_ASSERT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> top;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* then plain characters, and minor variants on that theme */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">')'</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* unbalanced paren */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((v-&gt;cflags &amp; REG_ADVANCED) != REG_EXTENDED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L129" title="regex/regexec.c:129">ERR</a>(REG_EPAREN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> top;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* legal in EREs due to specification botch */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L324" title="regex/regcomp.c:324">NOTE</a>(REG_UPBOTCH);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through into case <a href="#L330" title="regex/regcomp.c:330">PLAIN</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALLTHROUGH */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L330" title="regex/regcomp.c:330">PLAIN</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1909" title="regex/regcomp.c:1909">onechr</a>(v, v-&gt;nextvalue, lp, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_color.c.html#L916" title="regex/regc_color.c:916">okcolors</a>(v-&gt;nfa, v-&gt;cm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'['</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;nextvalue == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1671" title="regex/regcomp.c:1671">bracket</a>(v, lp, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1727" title="regex/regcomp.c:1727">cbracket</a>(v, lp, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(<a href="#L313" title="regex/regcomp.c:313">SEE</a>(<span class="Constant">']'</span>) || <a href="regexec.c.html#L127" title="regex/regexec.c:127">ISERR</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L337" title="regex/regcomp.c:337">CCLASSS</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1492" title="regex/regcomp.c:1492">charclass</a>(v, (<span class="Type">enum</span> char_classes) v-&gt;nextvalue, lp, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_color.c.html#L916" title="regex/regc_color.c:916">okcolors</a>(v-&gt;nfa, v-&gt;cm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L338" title="regex/regcomp.c:338">CCLASSC</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1516" title="regex/regcomp.c:1516">charclasscomplement</a>(v, (<span class="Type">enum</span> char_classes) v-&gt;nextvalue, lp, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L1516" title="regex/regcomp.c:1516">charclasscomplement</a>() did <a href="regc_color.c.html#L916" title="regex/regc_color.c:916">okcolors</a>() internally */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'.'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_color.c.html#L1031" title="regex/regc_color.c:1031">rainbow</a>(v-&gt;nfa, v-&gt;cm, <a href="#L330" title="regex/regcomp.c:330">PLAIN</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (v-&gt;cflags &amp; REG_NLSTOP) ? v-&gt;nlcolor : COLORLESS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lp, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and finally the ugly stuff */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'('</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* value flags as capturing or non */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cap = (type == <a href="#L340" title="regex/regcomp.c:340">LACON</a>) ? <span class="Constant">0</span> : v-&gt;nextvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;nsubexp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subno = v-&gt;nsubexp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((<span class="Type">size_t</span>) subno &gt;= v-&gt;nsubs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L553" title="regex/regcomp.c:553">moresubs</a>(v, subno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atomtype = <a href="#L330" title="regex/regcomp.c:330">PLAIN</a>;&nbsp; &nbsp; <span class="Comment">/* something that's not '(' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make separate endpoint states to keep this sub-NFA distinct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from what surrounds it.&nbsp; We need to be sure that when we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * duplicate the sub-NFA for a backref, we get the right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * states/arcs and no others.&nbsp; In particular, letting a backref<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * duplicate the sub-NFA from lp to rp would be quite wrong,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because we may add quantification superstructure around this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * atom below.&nbsp; (Perhaps we could <a href="regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the extra states for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-capturing parens, but it seems not worth the trouble.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s2 = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We may not need these arcs, but keep things connected for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L325" title="regex/regcomp.c:325">EMPTYARC</a>(lp, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L325" title="regex/regcomp.c:325">EMPTYARC</a>(s2, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atom = <a href="#L715" title="regex/regcomp.c:715">parse</a>(v, <span class="Constant">')'</span>, type, s, s2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(<a href="#L313" title="regex/regcomp.c:313">SEE</a>(<span class="Constant">')'</span>) || <a href="regexec.c.html#L127" title="regex/regexec.c:127">ISERR</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (atom-&gt;capno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* normal case: just mark the atom as capturing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atom-&gt;flags |= CAP;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atom-&gt;capno = subno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* generate no-op wrapper node to handle &quot;((x))&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t = <a href="#L2093" title="regex/regcomp.c:2093">subre</a>(v, <span class="Constant">'('</span>, atom-&gt;flags | CAP, s, s2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t-&gt;capno = subno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t-&gt;child = atom;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atom = t;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(v-&gt;subs[subno] == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;subs[subno] = atom;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* postpone everything else pending possible {0} */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L332" title="regex/regcomp.c:332">BACKREF</a>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the Feature From The Black Lagoon */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="regex/regcomp.c:323">INSIST</a>(type != <a href="#L340" title="regex/regcomp.c:340">LACON</a>, REG_ESUBREG);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subno = v-&gt;nextvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(subno &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="regex/regcomp.c:323">INSIST</a>(subno &lt; v-&gt;nsubs, REG_ESUBREG);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="regex/regcomp.c:323">INSIST</a>(v-&gt;subs[subno] != <span class="Constant">NULL</span>, REG_ESUBREG);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atom = <a href="#L2093" title="regex/regcomp.c:2093">subre</a>(v, <span class="Constant">'b'</span>, BACKR, lp, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atom-&gt;backno = subno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;subs[subno]-&gt;flags |= BRUSE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L325" title="regex/regcomp.c:325">EMPTYARC</a>(lp, rp);&nbsp; &nbsp; <span class="Comment">/* temporarily, so there's something */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ...and an atom may be followed by a quantifier */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (v-&gt;nexttype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'*'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; m = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = DUPINF;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qprefer = (v-&gt;nextvalue) ? LONGER : SHORTER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'+'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; m = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = DUPINF;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qprefer = (v-&gt;nextvalue) ? LONGER : SHORTER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'?'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; m = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qprefer = (v-&gt;nextvalue) ? LONGER : SHORTER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'{'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; m = <a href="#L1553" title="regex/regcomp.c:1553">scannum</a>(v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L314" title="regex/regcomp.c:314">EAT</a>(<span class="Constant">','</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L313" title="regex/regcomp.c:313">SEE</a>(<a href="#L331" title="regex/regcomp.c:331">DIGIT</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = <a href="#L1553" title="regex/regcomp.c:1553">scannum</a>(v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = DUPINF;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (m &gt; n)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L129" title="regex/regexec.c:129">ERR</a>(REG_BADBR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> top;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* {m,n} exercises preference, even if it's {m,m} */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qprefer = (v-&gt;nextvalue) ? LONGER : SHORTER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = m;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* {m} passes operand's preference through */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qprefer = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L313" title="regex/regcomp.c:313">SEE</a>(<span class="Constant">'}'</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* catches errors too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L129" title="regex/regexec.c:129">ERR</a>(REG_BADBR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> top;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no quantifier */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; m = n = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qprefer = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* annoying special case:&nbsp; {0} or {0,0} cancels everything */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (m == <span class="Constant">0</span> &amp;&amp; n == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we had capturing subexpression(s) within the atom, we don't want<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to destroy them, because it's legal (if useless) to back-ref them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * later.&nbsp; Hence, just unlink the atom from lp/rp and then ignore it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (atom != <span class="Constant">NULL</span> &amp;&amp; (atom-&gt;flags &amp; CAP))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L1281" title="regex/regc_nfa.c:1281">delsub</a>(v-&gt;nfa, lp, atom-&gt;begin);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L1281" title="regex/regc_nfa.c:1281">delsub</a>(v-&gt;nfa, atom-&gt;end, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise, we can clean up <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> infrastructure we made */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (atom != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2150" title="regex/regcomp.c:2150">freesubre</a>(v, atom);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L1281" title="regex/regc_nfa.c:1281">delsub</a>(v-&gt;nfa, lp, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L325" title="regex/regcomp.c:325">EMPTYARC</a>(lp, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> top;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if not a messy case, avoid hard part */<br/></li>
<li></span>&nbsp; &nbsp; assert(!MESSY(top-&gt;flags));<br/></li>
<li>&nbsp; &nbsp; f = top-&gt;flags | qprefer | ((atom != <span class="Constant">NULL</span>) ? atom-&gt;flags : <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (atomtype != <span class="Constant">'('</span> &amp;&amp; atomtype != <a href="#L332" title="regex/regcomp.c:332">BACKREF</a> &amp;&amp; !MESSY(UP(f)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(m == <span class="Constant">1</span> &amp;&amp; n == <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1584" title="regex/regcomp.c:1584">repeat</a>(v, lp, rp, m, n);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (atom != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2150" title="regex/regcomp.c:2150">freesubre</a>(v, atom);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; top-&gt;flags = f;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> top;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hard part:&nbsp; something messy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * That is, capturing parens, back reference, short/long clash, or an atom<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with substructure containing one of those.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we'll need a <a href="#L2093" title="regex/regcomp.c:2093">subre</a> for the contents even if they're boring */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (atom == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; atom = <a href="#L2093" title="regex/regcomp.c:2093">subre</a>(v, <span class="Constant">'='</span>, <span class="Constant">0</span>, lp, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For what follows, we need the atom to have its own begin/end states<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that are distinct from lp/rp, so that we can wrap iteration structure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * around it.&nbsp; The parenthesized-atom case above already made suitable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * states (and we don't want to modify a capturing <a href="#L2093" title="regex/regcomp.c:2093">subre</a>, since it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already recorded in v-&gt;subs[]).&nbsp; Otherwise, we need more states.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (atom-&gt;begin == lp || atom-&gt;end == rp)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s2 = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L1066" title="regex/regc_nfa.c:1066">moveouts</a>(v-&gt;nfa, lp, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L778" title="regex/regc_nfa.c:778">moveins</a>(v-&gt;nfa, rp, s2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; atom-&gt;begin = s;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; atom-&gt;end = s2;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The atom's OK, but we must temporarily disconnect it from lp/rp */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* (this removes the <a href="#L328" title="regex/regcomp.c:328">EMPTY</a> arcs we made above) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L1281" title="regex/regc_nfa.c:1281">delsub</a>(v-&gt;nfa, lp, atom-&gt;begin);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L1281" title="regex/regc_nfa.c:1281">delsub</a>(v-&gt;nfa, atom-&gt;end, rp);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare a general-purpose state skeleton.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In the no-backrefs case, we want this:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * [lp] ---&gt; [s] ---prefix---&gt; ---atom---&gt; ---rest---&gt; [rp]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * where prefix is some repetitions of atom, and &quot;rest&quot; is the remainder<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the branch.&nbsp; In the general case we need:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * [lp] ---&gt; [s] ---iterator---&gt; [s2] ---rest---&gt; [rp]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * where the iterator wraps around the atom.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We make the s state here for both cases; s2 is made below if needed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; s = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(v-&gt;nfa);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* set up starting state */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L325" title="regex/regcomp.c:325">EMPTYARC</a>(lp, s);<br/></li>
<li>&nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* break remaining subRE into x{...} and what follows */<br/></li>
<li></span>&nbsp; &nbsp; t = <a href="#L2093" title="regex/regcomp.c:2093">subre</a>(v, <span class="Constant">'.'</span>, COMBINE(qprefer, atom-&gt;flags), lp, rp);<br/></li>
<li>&nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; t-&gt;child = atom;<br/></li>
<li>&nbsp; &nbsp; atomp = &amp;t-&gt;child;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Here we should recurse to fill t-&gt;child-&gt;sibling ... but we must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * postpone that to the end.&nbsp; One reason is that t-&gt;child may be replaced<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * below, and we don't want to worry about its sibling link.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Convert top node to a concatenation of the prefix (top-&gt;child, covering<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whatever we parsed previously) and remaining (t).&nbsp; Note that the prefix<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * could be empty, in which case this concatenation node is unnecessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To keep things simple, we operate in a general way for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, and get rid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of unnecessary subres below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; assert(top-&gt;op == <span class="Constant">'='</span> &amp;&amp; top-&gt;child == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; top-&gt;child = <a href="#L2093" title="regex/regcomp.c:2093">subre</a>(v, <span class="Constant">'='</span>, top-&gt;flags, top-&gt;begin, lp);<br/></li>
<li>&nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; top-&gt;op = <span class="Constant">'.'</span>;<br/></li>
<li>&nbsp; &nbsp; top-&gt;child-&gt;sibling = t;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* top-&gt;flags will get updated later */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if it's a backref, <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> is the time to replicate the subNFA */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (atomtype == <a href="#L332" title="regex/regcomp.c:332">BACKREF</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(atom-&gt;begin-&gt;nouts == <span class="Constant">1</span>);&nbsp; &nbsp; <span class="Comment">/* just the <a href="#L328" title="regex/regcomp.c:328">EMPTY</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L1281" title="regex/regc_nfa.c:1281">delsub</a>(v-&gt;nfa, atom-&gt;begin, atom-&gt;end);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(v-&gt;subs[subno] != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * And here's why the recursion got postponed: it must wait until the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * skeleton is filled in, because it may hit a backref that wants to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * copy the filled-in skeleton.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L1355" title="regex/regc_nfa.c:1355">dupnfa</a>(v-&gt;nfa, v-&gt;subs[subno]-&gt;begin, v-&gt;subs[subno]-&gt;end,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; atom-&gt;begin, atom-&gt;end);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The backref node's NFA should not enforce <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> constraints */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L1419" title="regex/regc_nfa.c:1419">removeconstraints</a>(v-&gt;nfa, atom-&gt;begin, atom-&gt;end);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's quantifier time.&nbsp; If the atom is just a backref, we'll let it deal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with quantifiers internally.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (atomtype == <a href="#L332" title="regex/regcomp.c:332">BACKREF</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* special case:&nbsp; backrefs have <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> quantifiers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L325" title="regex/regcomp.c:325">EMPTYARC</a>(s, atom-&gt;begin);&nbsp; &nbsp; <span class="Comment">/* empty prefix */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just stuff everything into atom */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1584" title="regex/regcomp.c:1584">repeat</a>(v, atom-&gt;begin, atom-&gt;end, m, n);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; atom-&gt;min = (<span class="Type">short</span>) m;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; atom-&gt;max = (<span class="Type">short</span>) n;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; atom-&gt;flags |= COMBINE(qprefer, atom-&gt;flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* rest of branch can be strung starting from atom-&gt;end */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; s2 = atom-&gt;end;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (m == <span class="Constant">1</span> &amp;&amp; n == <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (qprefer == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (atom-&gt;flags &amp; (LONGER | SHORTER | MIXED)) == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qprefer == (atom-&gt;flags &amp; (LONGER | SHORTER | MIXED))))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no/vacuous quantifier:&nbsp; done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L325" title="regex/regcomp.c:325">EMPTYARC</a>(s, atom-&gt;begin);&nbsp; &nbsp; <span class="Comment">/* empty prefix */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* rest of branch can be strung starting from atom-&gt;end */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; s2 = atom-&gt;end;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!(atom-&gt;flags &amp; (CAP | BACKR)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there's no captures nor backrefs in the atom being repeated, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't really care where the submatches of the iteration are, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't need an iteration node.&nbsp; Make a plain DFA node instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L325" title="regex/regcomp.c:325">EMPTYARC</a>(s, atom-&gt;begin);&nbsp; &nbsp; <span class="Comment">/* empty prefix */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1584" title="regex/regcomp.c:1584">repeat</a>(v, atom-&gt;begin, atom-&gt;end, m, n);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; f = COMBINE(qprefer, atom-&gt;flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; t = <a href="#L2093" title="regex/regcomp.c:2093">subre</a>(v, <span class="Constant">'='</span>, f, atom-&gt;begin, atom-&gt;end);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2150" title="regex/regcomp.c:2150">freesubre</a>(v, atom);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *atomp = t;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* rest of branch can be strung starting from t-&gt;end */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; s2 = t-&gt;end;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (m &gt; <span class="Constant">0</span> &amp;&amp; !(atom-&gt;flags &amp; BACKR))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there's no backrefs involved, we can turn x{m,n} into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * x{m-1,n-1}x, with capturing parens in only the second x.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * valid because we only care about capturing matches from the final<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * iteration of the quantifier.&nbsp; It's a win because we can implement<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the backref-free left side as a plain DFA node, since we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * really care where its submatches are.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L1355" title="regex/regc_nfa.c:1355">dupnfa</a>(v-&gt;nfa, atom-&gt;begin, atom-&gt;end, s, atom-&gt;begin);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(m &gt;= <span class="Constant">1</span> &amp;&amp; m != DUPINF &amp;&amp; n &gt;= <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1584" title="regex/regcomp.c:1584">repeat</a>(v, s, atom-&gt;begin, m - <span class="Constant">1</span>, (n == DUPINF) ? n : n - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; f = COMBINE(qprefer, atom-&gt;flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; t = <a href="#L2093" title="regex/regcomp.c:2093">subre</a>(v, <span class="Constant">'.'</span>, f, s, atom-&gt;end); <span class="Comment">/* prefix and atom */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; t-&gt;child = <a href="#L2093" title="regex/regcomp.c:2093">subre</a>(v, <span class="Constant">'='</span>, PREF(f), s, atom-&gt;begin);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; t-&gt;child-&gt;sibling = atom;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *atomp = t;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* rest of branch can be strung starting from atom-&gt;end */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; s2 = atom-&gt;end;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* general case: need an iteration node */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; s2 = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L1066" title="regex/regc_nfa.c:1066">moveouts</a>(v-&gt;nfa, atom-&gt;end, s2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L1355" title="regex/regc_nfa.c:1355">dupnfa</a>(v-&gt;nfa, atom-&gt;begin, atom-&gt;end, s, s2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1584" title="regex/regcomp.c:1584">repeat</a>(v, s, s2, m, n);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; f = COMBINE(qprefer, atom-&gt;flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; t = <a href="#L2093" title="regex/regcomp.c:2093">subre</a>(v, <span class="Constant">'*'</span>, f, s, s2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; t-&gt;min = (<span class="Type">short</span>) m;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; t-&gt;max = (<span class="Type">short</span>) n;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; t-&gt;child = atom;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *atomp = t;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* rest of branch is to be strung from iteration's end state */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and finally, look after that postponed recursion */<br/></li>
<li></span>&nbsp; &nbsp; t = top-&gt;child-&gt;sibling;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(<a href="#L313" title="regex/regcomp.c:313">SEE</a>(<span class="Constant">'|'</span>) || <a href="#L313" title="regex/regcomp.c:313">SEE</a>(stopper) || <a href="#L313" title="regex/regcomp.c:313">SEE</a>(<a href="#L329" title="regex/regcomp.c:329">EOS</a>)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L715" title="regex/regcomp.c:715">parse</a> all the rest of the branch, and insert in t-&gt;child-&gt;sibling */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; t-&gt;child-&gt;sibling = <a href="#L783" title="regex/regcomp.c:783">parsebranch</a>(v, stopper, type, s2, rp, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L321" title="regex/regcomp.c:321">NOERRN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(<a href="#L313" title="regex/regcomp.c:313">SEE</a>(<span class="Constant">'|'</span>) || <a href="#L313" title="regex/regcomp.c:313">SEE</a>(stopper) || <a href="#L313" title="regex/regcomp.c:313">SEE</a>(<a href="#L329" title="regex/regcomp.c:329">EOS</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* here's the promised update of the flags */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; t-&gt;flags |= COMBINE(t-&gt;flags, t-&gt;child-&gt;sibling-&gt;flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; top-&gt;flags |= COMBINE(top-&gt;flags, t-&gt;flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* neither t nor top could be directly marked for capture as yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; assert(t-&gt;capno == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(top-&gt;capno == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At this point both top and t are concatenation (op == '.') subres,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and we have top-&gt;child = prefix of branch, top-&gt;child-&gt;sibling = t,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * t-&gt;child = messy atom (with quantification superstructure if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * needed), t-&gt;child-&gt;sibling = rest of branch.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the messy atom was the first thing in the branch, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * top-&gt;child is vacuous and we can get rid of one level of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * concatenation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; assert(top-&gt;child-&gt;op == <span class="Constant">'='</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (top-&gt;child-&gt;begin == top-&gt;child-&gt;end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(!MESSY(top-&gt;child-&gt;flags));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2150" title="regex/regcomp.c:2150">freesubre</a>(v, top-&gt;child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; top-&gt;child = t-&gt;child;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2185" title="regex/regcomp.c:2185">freesrnode</a>(v, t);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, it's possible that t-&gt;child is not messy in itself, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we considered it messy because its greediness conflicts with what<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * preceded it.&nbsp; Then it could be that the combination of t-&gt;child and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the rest of the branch is also not messy, in which case we can get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rid of the child concatenation by merging t-&gt;child and the rest of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the branch into one plain DFA node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (t-&gt;child-&gt;op == <span class="Constant">'='</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; t-&gt;child-&gt;sibling-&gt;op == <span class="Constant">'='</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !MESSY(UP(t-&gt;child-&gt;flags | t-&gt;child-&gt;sibling-&gt;flags)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t-&gt;op = <span class="Constant">'='</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t-&gt;flags = COMBINE(t-&gt;child-&gt;flags, t-&gt;child-&gt;sibling-&gt;flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2169" title="regex/regcomp.c:2169">freesubreandsiblings</a>(v, t-&gt;child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t-&gt;child = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There's nothing left in the branch, so we don't need the second<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * concatenation node 't'.&nbsp; Just link s2 straight to rp.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L325" title="regex/regcomp.c:325">EMPTYARC</a>(s2, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; top-&gt;child-&gt;sibling = t-&gt;child;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; top-&gt;flags |= COMBINE(top-&gt;flags, top-&gt;child-&gt;sibling-&gt;flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2185" title="regex/regcomp.c:2185">freesrnode</a>(v, t);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Again, it could be that top-&gt;child is vacuous (if the messy atom<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * was in fact the only thing in the branch).&nbsp; In that case we need no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * concatenation at all; just replace top with top-&gt;child-&gt;sibling.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; assert(top-&gt;child-&gt;op == <span class="Constant">'='</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (top-&gt;child-&gt;begin == top-&gt;child-&gt;end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(!MESSY(top-&gt;child-&gt;flags));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t = top-&gt;child-&gt;sibling;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; top-&gt;child-&gt;sibling = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2150" title="regex/regcomp.c:2150">freesubre</a>(v, top);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; top = t;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> top;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1456" title="regex/regcomp.c:1456">nonword</a> - generate arcs for non-<a href="#L1474" title="regex/regcomp.c:1474">word</a>-character ahead or behind<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1456">&#x200c;</a></span><span class="linkable">nonword</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> dir,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L341" title="regex/regcomp.c:341">AHEAD</a> or <a href="#L342" title="regex/regcomp.c:342">BEHIND</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *lp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *rp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; anchor = (dir == <a href="#L341" title="regex/regcomp.c:341">AHEAD</a>) ? <span class="Constant">'$'</span> : <span class="Constant">'^'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(dir == <a href="#L341" title="regex/regcomp.c:341">AHEAD</a> || dir == <a href="#L342" title="regex/regcomp.c:342">BEHIND</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="regc_nfa.c.html#L281" title="regex/regc_nfa.c:281">newarc</a>(v-&gt;nfa, anchor, <span class="Constant">1</span>, lp, rp);<br/></li>
<li>&nbsp; &nbsp; <a href="regc_nfa.c.html#L281" title="regex/regc_nfa.c:281">newarc</a>(v-&gt;nfa, anchor, <span class="Constant">0</span>, lp, rp);<br/></li>
<li>&nbsp; &nbsp; <a href="regc_color.c.html#L1064" title="regex/regc_color.c:1064">colorcomplement</a>(v-&gt;nfa, v-&gt;cm, dir, v-&gt;<a href="#L1991" title="regex/regcomp.c:1991">wordchrs</a>, lp, rp);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* (no need for special attention to \n) */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1474" title="regex/regcomp.c:1474">word</a> - generate arcs for <a href="#L1474" title="regex/regcomp.c:1474">word</a> character ahead or behind<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1474">&#x200c;</a></span><span class="linkable">word</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp;&nbsp; <span class="Type">int</span> dir,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L341" title="regex/regcomp.c:341">AHEAD</a> or <a href="#L342" title="regex/regcomp.c:342">BEHIND</a> */<br/></li>
<li></span>&nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *lp,<br/></li>
<li>&nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *rp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; assert(dir == <a href="#L341" title="regex/regcomp.c:341">AHEAD</a> || dir == <a href="#L342" title="regex/regcomp.c:342">BEHIND</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="regc_nfa.c.html#L1256" title="regex/regc_nfa.c:1256">cloneouts</a>(v-&gt;nfa, v-&gt;<a href="#L1991" title="regex/regcomp.c:1991">wordchrs</a>, lp, rp, dir);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* (no need for special attention to \n) */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1492" title="regex/regcomp.c:1492">charclass</a> - generate arcs for a character class<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used for both atoms (\w and sibling escapes) and for elements<br/></li>
<li></span><span class="Comment"> * of <a href="#L1671" title="regex/regcomp.c:1671">bracket</a> expressions.&nbsp; The caller is responsible for calling <a href="regc_color.c.html#L916" title="regex/regc_color.c:916">okcolors</a>()<br/></li>
<li></span><span class="Comment"> * at the end of processing the atom or <a href="#L1671" title="regex/regcomp.c:1671">bracket</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1492">&#x200c;</a></span><span class="linkable">charclass</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">enum</span> char_classes cls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *lp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *rp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> cvec *cv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* obtain possibly-cached cvec for char class */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L324" title="regex/regcomp.c:324">NOTE</a>(REG_ULOCALE);<br/></li>
<li>&nbsp; &nbsp; cv = <a href="regc_locale.c.html#L569" title="regex/regc_locale.c:569">cclasscvec</a>(v, cls, (v-&gt;cflags &amp; REG_ICASE));<br/></li>
<li>&nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build the arcs; this may cause color splitting */<br/></li>
<li></span>&nbsp; &nbsp; <a href="regc_color.c.html#L522" title="regex/regc_color.c:522">subcolorcvec</a>(v, cv, lp, rp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1516" title="regex/regcomp.c:1516">charclasscomplement</a> - generate arcs for a complemented character class<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used for both atoms (\W and sibling escapes) and for elements<br/></li>
<li></span><span class="Comment"> * of <a href="#L1671" title="regex/regcomp.c:1671">bracket</a> expressions.&nbsp; In <a href="#L1671" title="regex/regcomp.c:1671">bracket</a> expressions, it is the caller's<br/></li>
<li></span><span class="Comment"> * responsibility that there not be <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> open subcolors when this is called.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1516">&#x200c;</a></span><span class="linkable">charclasscomplement</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">enum</span> char_classes cls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *lp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *rp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *cstate;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> cvec *cv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make dummy state to hang temporary arcs on */<br/></li>
<li></span>&nbsp; &nbsp; cstate = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* obtain possibly-cached cvec for char class */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L324" title="regex/regcomp.c:324">NOTE</a>(REG_ULOCALE);<br/></li>
<li>&nbsp; &nbsp; cv = <a href="regc_locale.c.html#L569" title="regex/regc_locale.c:569">cclasscvec</a>(v, cls, (v-&gt;cflags &amp; REG_ICASE));<br/></li>
<li>&nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build arcs for char class; this may cause color splitting */<br/></li>
<li></span>&nbsp; &nbsp; <a href="regc_color.c.html#L522" title="regex/regc_color.c:522">subcolorcvec</a>(v, cv, cstate, cstate);<br/></li>
<li>&nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* clean up <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subcolors in the arc set */<br/></li>
<li></span>&nbsp; &nbsp; <a href="regc_color.c.html#L916" title="regex/regc_color.c:916">okcolors</a>(v-&gt;nfa, v-&gt;cm);<br/></li>
<li>&nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> build output arcs for the complement of the char class */<br/></li>
<li></span>&nbsp; &nbsp; <a href="regc_color.c.html#L1064" title="regex/regc_color.c:1064">colorcomplement</a>(v-&gt;nfa, v-&gt;cm, <a href="#L330" title="regex/regcomp.c:330">PLAIN</a>, cstate, lp, rp);<br/></li>
<li>&nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* clean up dummy state */<br/></li>
<li></span>&nbsp; &nbsp; <a href="regc_nfa.c.html#L226" title="regex/regc_nfa.c:226">dropstate</a>(v-&gt;nfa, cstate);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1553" title="regex/regcomp.c:1553">scannum</a> - scan a number<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* value, &lt;= DUPMAX */<br/></li>
<li><a id="L1553">&#x200c;</a></span><span class="linkable">scannum</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L313" title="regex/regcomp.c:313">SEE</a>(<a href="#L331" title="regex/regcomp.c:331">DIGIT</a>) &amp;&amp; n &lt; DUPMAX)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n = n * <span class="Constant">10</span> + v-&gt;nextvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L313" title="regex/regcomp.c:313">SEE</a>(<a href="#L331" title="regex/regcomp.c:331">DIGIT</a>) || n &gt; DUPMAX)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L129" title="regex/regexec.c:129">ERR</a>(REG_BADBR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> n;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1584" title="regex/regcomp.c:1584">repeat</a> - replicate subNFA for quantifiers<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The sub-NFA strung from lp to rp is modified to represent m to n<br/></li>
<li></span><span class="Comment"> * repetitions of its initial contents.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The duplication sequences used here are chosen carefully so that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * pointers starting out pointing into the subexpression end up pointing into<br/></li>
<li></span><span class="Comment"> * the last occurrence.&nbsp; (Note that it may not be strung between the same<br/></li>
<li></span><span class="Comment"> * left and right end states, however!)&nbsp; This used to be important for the<br/></li>
<li></span><span class="Comment"> * subRE tree, although the important bits are <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> handled by the in-line<br/></li>
<li></span><span class="Comment"> * code in <a href="#L715" title="regex/regcomp.c:715">parse</a>(), and when this is called, it doesn't matter <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1584">&#x200c;</a></span><span class="linkable">repeat</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *lp,<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *rp,<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> m,<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> n)<br/></li>
<li>{<br/></li>
<li><a id="L1590">&#x200c;</a><span class="PreProc">#define&nbsp; <span class="linkable">SOME</span>&nbsp; &nbsp;&nbsp; </span><span class="Constant">2<br/></li>
<li><a id="L1591">&#x200c;</a></span><span class="PreProc">#define&nbsp; <span class="linkable">INF</span>&nbsp; &nbsp;&nbsp; </span><span class="Constant">3<br/></li>
<li><a id="L1592">&#x200c;</a></span><span class="PreProc">#define&nbsp; <span class="linkable">PAIR</span>(x, y)&nbsp; ((x)*</span><span class="Constant">4</span><span class="PreProc"> + (y))<br/></li>
<li><a id="L1593">&#x200c;</a></span><span class="PreProc">#define&nbsp; <span class="linkable">REDUCE</span>(x)&nbsp; &nbsp;&nbsp; ( ((x) == DUPINF) ? <a href="#L1591" title="regex/regcomp.c:1591">INF</a> : (((x) &gt; </span><span class="Constant">1</span><span class="PreProc">) ? <a href="#L1590" title="regex/regcomp.c:1590">SOME</a> : (x)) )<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">int</span>&nbsp; &nbsp; rm = <a href="#L1593" title="regex/regcomp.c:1593">REDUCE</a>(m);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">int</span>&nbsp; &nbsp; rn = <a href="#L1593" title="regex/regcomp.c:1593">REDUCE</a>(n);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *s;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *s2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L1592" title="regex/regcomp.c:1592">PAIR</a>(rm, rn))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1592" title="regex/regcomp.c:1592">PAIR</a>(<span class="Constant">0</span>, <span class="Constant">0</span>):&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* empty string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L1281" title="regex/regc_nfa.c:1281">delsub</a>(v-&gt;nfa, lp, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L325" title="regex/regcomp.c:325">EMPTYARC</a>(lp, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1592" title="regex/regcomp.c:1592">PAIR</a>(<span class="Constant">0</span>, <span class="Constant">1</span>):&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do as x| */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L325" title="regex/regcomp.c:325">EMPTYARC</a>(lp, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1592" title="regex/regcomp.c:1592">PAIR</a>(<span class="Constant">0</span>, <a href="#L1590" title="regex/regcomp.c:1590">SOME</a>):&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do as x{1,n}| */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1584" title="regex/regcomp.c:1584">repeat</a>(v, lp, rp, <span class="Constant">1</span>, n);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L325" title="regex/regcomp.c:325">EMPTYARC</a>(lp, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1592" title="regex/regcomp.c:1592">PAIR</a>(<span class="Constant">0</span>, <a href="#L1591" title="regex/regcomp.c:1591">INF</a>):&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* loop x around */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L1066" title="regex/regc_nfa.c:1066">moveouts</a>(v-&gt;nfa, lp, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L778" title="regex/regc_nfa.c:778">moveins</a>(v-&gt;nfa, rp, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L325" title="regex/regcomp.c:325">EMPTYARC</a>(lp, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L325" title="regex/regcomp.c:325">EMPTYARC</a>(s, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1592" title="regex/regcomp.c:1592">PAIR</a>(<span class="Constant">1</span>, <span class="Constant">1</span>):&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no action required */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1592" title="regex/regcomp.c:1592">PAIR</a>(<span class="Constant">1</span>, <a href="#L1590" title="regex/regcomp.c:1590">SOME</a>):&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do as x{0,n-1}x = (x{1,n-1}|)x */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L1066" title="regex/regc_nfa.c:1066">moveouts</a>(v-&gt;nfa, lp, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L1355" title="regex/regc_nfa.c:1355">dupnfa</a>(v-&gt;nfa, s, rp, lp, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1584" title="regex/regcomp.c:1584">repeat</a>(v, lp, s, <span class="Constant">1</span>, n - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L325" title="regex/regcomp.c:325">EMPTYARC</a>(lp, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1592" title="regex/regcomp.c:1592">PAIR</a>(<span class="Constant">1</span>, <a href="#L1591" title="regex/regcomp.c:1591">INF</a>):&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* add loopback arc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s2 = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L1066" title="regex/regc_nfa.c:1066">moveouts</a>(v-&gt;nfa, lp, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L778" title="regex/regc_nfa.c:778">moveins</a>(v-&gt;nfa, rp, s2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L325" title="regex/regcomp.c:325">EMPTYARC</a>(lp, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L325" title="regex/regcomp.c:325">EMPTYARC</a>(s2, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L325" title="regex/regcomp.c:325">EMPTYARC</a>(s2, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1592" title="regex/regcomp.c:1592">PAIR</a>(<a href="#L1590" title="regex/regcomp.c:1590">SOME</a>, <a href="#L1590" title="regex/regcomp.c:1590">SOME</a>):&nbsp; &nbsp; <span class="Comment">/* do as x{m-1,n-1}x */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L1066" title="regex/regc_nfa.c:1066">moveouts</a>(v-&gt;nfa, lp, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L1355" title="regex/regc_nfa.c:1355">dupnfa</a>(v-&gt;nfa, s, rp, lp, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1584" title="regex/regcomp.c:1584">repeat</a>(v, lp, s, m - <span class="Constant">1</span>, n - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1592" title="regex/regcomp.c:1592">PAIR</a>(<a href="#L1590" title="regex/regcomp.c:1590">SOME</a>, <a href="#L1591" title="regex/regcomp.c:1591">INF</a>):&nbsp; &nbsp; <span class="Comment">/* do as x{m-1,}x */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L1066" title="regex/regc_nfa.c:1066">moveouts</a>(v-&gt;nfa, lp, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L1355" title="regex/regc_nfa.c:1355">dupnfa</a>(v-&gt;nfa, s, rp, lp, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1584" title="regex/regcomp.c:1584">repeat</a>(v, lp, s, m - <span class="Constant">1</span>, n);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L129" title="regex/regexec.c:129">ERR</a>(REG_ASSERT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1671" title="regex/regcomp.c:1671">bracket</a> - handle non-complemented <a href="#L1671" title="regex/regcomp.c:1671">bracket</a> expression<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also called from <a href="#L1727" title="regex/regcomp.c:1727">cbracket</a> for complemented <a href="#L1671" title="regex/regcomp.c:1671">bracket</a> expressions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1671">&#x200c;</a></span><span class="linkable">bracket</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *lp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *rp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can't process complemented char classes (e.g. \W) immediately while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scanning the <a href="#L1671" title="regex/regcomp.c:1671">bracket</a> expression, else color bookkeeping gets confused.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Instead, remember whether we saw <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> in have_cclassc[], and process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them at the end.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_cclassc[NUM_CCLASSES];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; any_cclassc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(have_cclassc, <span class="Constant">false</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(have_cclassc));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(<a href="#L313" title="regex/regcomp.c:313">SEE</a>(<span class="Constant">'['</span>));<br/></li>
<li>&nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (!<a href="#L313" title="regex/regcomp.c:313">SEE</a>(<span class="Constant">']'</span>) &amp;&amp; !<a href="#L313" title="regex/regcomp.c:313">SEE</a>(<a href="#L329" title="regex/regcomp.c:329">EOS</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1761" title="regex/regcomp.c:1761">brackpart</a>(v, lp, rp, have_cclassc);<br/></li>
<li>&nbsp; &nbsp; assert(<a href="#L313" title="regex/regcomp.c:313">SEE</a>(<span class="Constant">']'</span>) || <a href="regexec.c.html#L127" title="regex/regexec.c:127">ISERR</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* close up open subcolors from the positive <a href="#L1671" title="regex/regcomp.c:1671">bracket</a> elements */<br/></li>
<li></span>&nbsp; &nbsp; <a href="regc_color.c.html#L916" title="regex/regc_color.c:916">okcolors</a>(v-&gt;nfa, v-&gt;cm);<br/></li>
<li>&nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> handle <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> complemented elements */<br/></li>
<li></span>&nbsp; &nbsp; any_cclassc = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; NUM_CCLASSES; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (have_cclassc[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1516" title="regex/regcomp.c:1516">charclasscomplement</a>(v, (<span class="Type">enum</span> char_classes) i, lp, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; any_cclassc = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we had <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> complemented elements, see if we can <a href="regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> the <a href="#L1671" title="regex/regcomp.c:1671">bracket</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into a <a href="regc_color.c.html#L1031" title="regex/regc_color.c:1031">rainbow</a>.&nbsp; Since a complemented <a href="regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is the only way a WHITE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * arc could get into the result, there's no point in checking otherwise.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (any_cclassc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1935" title="regex/regcomp.c:1935">optimizebracket</a>(v, lp, rp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1727" title="regex/regcomp.c:1727">cbracket</a> - handle complemented <a href="#L1671" title="regex/regcomp.c:1671">bracket</a> expression<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We do it by calling <a href="#L1671" title="regex/regcomp.c:1671">bracket</a>() with dummy endpoints, and then complementing<br/></li>
<li></span><span class="Comment"> * the result.&nbsp; The alternative would be to invoke <a href="regc_color.c.html#L1031" title="regex/regc_color.c:1031">rainbow</a>(), and then delete<br/></li>
<li></span><span class="Comment"> * arcs as the b.e. is seen... but that gets messy, and is really quite<br/></li>
<li></span><span class="Comment"> * infeasible <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that <a href="regc_color.c.html#L1031" title="regex/regc_color.c:1031">rainbow</a>() just puts out one RAINBOW arc.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1727">&#x200c;</a></span><span class="linkable">cbracket</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *lp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *rp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *left = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *right = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(v-&gt;nfa);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L1671" title="regex/regcomp.c:1671">bracket</a>(v, left, right);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* in NLSTOP mode, ensure <a href="regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a> is not part of the result set */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;cflags &amp; REG_NLSTOP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L281" title="regex/regc_nfa.c:281">newarc</a>(v-&gt;nfa, <a href="#L330" title="regex/regcomp.c:330">PLAIN</a>, v-&gt;nlcolor, left, right);<br/></li>
<li>&nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(lp-&gt;nouts == <span class="Constant">0</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* all outarcs will be ours */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Easy part of complementing, and all there is to do since the MCCE code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * was removed.&nbsp; Note that the result of <a href="regc_color.c.html#L1064" title="regex/regc_color.c:1064">colorcomplement</a>() cannot be a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="regc_color.c.html#L1031" title="regex/regc_color.c:1031">rainbow</a>, since we don't allow empty brackets; so there's no point in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calling <a href="#L1935" title="regex/regcomp.c:1935">optimizebracket</a>() again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="regc_color.c.html#L1064" title="regex/regc_color.c:1064">colorcomplement</a>(v-&gt;nfa, v-&gt;cm, <a href="#L330" title="regex/regcomp.c:330">PLAIN</a>, left, lp, rp);<br/></li>
<li>&nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="regc_nfa.c.html#L226" title="regex/regc_nfa.c:226">dropstate</a>(v-&gt;nfa, left);<br/></li>
<li>&nbsp; &nbsp; assert(right-&gt;nins == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="regc_nfa.c.html#L242" title="regex/regc_nfa.c:242">freestate</a>(v-&gt;nfa, right);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1761" title="regex/regcomp.c:1761">brackpart</a> - handle one item (or <a href="regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>) within a <a href="#L1671" title="regex/regcomp.c:1671">bracket</a> expression<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1761">&#x200c;</a></span><span class="linkable">brackpart</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *lp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *rp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *have_cclassc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startc;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> cvec *cv;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">enum</span> char_classes cls;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; *startp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; *endp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L715" title="regex/regcomp.c:715">parse</a> something, get rid of special cases, take shortcuts */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (v-&gt;nexttype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L339" title="regex/regcomp.c:339">RANGE</a>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* a-b-c or other botch */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L129" title="regex/regexec.c:129">ERR</a>(REG_ERANGE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L330" title="regex/regcomp.c:330">PLAIN</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startc = v-&gt;nextvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shortcut for ordinary <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> (not <a href="regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L313" title="regex/regcomp.c:313">SEE</a>(<a href="#L339" title="regex/regcomp.c:339">RANGE</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1909" title="regex/regcomp.c:1909">onechr</a>(v, startc, lp, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L333" title="regex/regcomp.c:333">COLLEL</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startp = v-&gt;<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endp = <a href="#L1884" title="regex/regcomp.c:1884">scanplain</a>(v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="regex/regcomp.c:323">INSIST</a>(startp &lt; endp, REG_ECOLLATE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startc = <a href="regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>(v, startp, endp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L334" title="regex/regcomp.c:334">ECLASS</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startp = v-&gt;<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endp = <a href="#L1884" title="regex/regcomp.c:1884">scanplain</a>(v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="regex/regcomp.c:323">INSIST</a>(startp &lt; endp, REG_ECOLLATE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startc = <a href="regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>(v, startp, endp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cv = <a href="regc_locale.c.html#L500" title="regex/regc_locale.c:500">eclass</a>(v, startc, (v-&gt;cflags &amp; REG_ICASE));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_color.c.html#L522" title="regex/regc_color.c:522">subcolorcvec</a>(v, cv, lp, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L335" title="regex/regcomp.c:335">CCLASS</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startp = v-&gt;<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endp = <a href="#L1884" title="regex/regcomp.c:1884">scanplain</a>(v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="regex/regcomp.c:323">INSIST</a>(startp &lt; endp, REG_ECTYPE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cls = <a href="regc_locale.c.html#L536" title="regex/regc_locale.c:536">lookupcclass</a>(v, startp, endp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1492" title="regex/regcomp.c:1492">charclass</a>(v, cls, lp, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L337" title="regex/regcomp.c:337">CCLASSS</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1492" title="regex/regcomp.c:1492">charclass</a>(v, (<span class="Type">enum</span> char_classes) v-&gt;nextvalue, lp, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L338" title="regex/regcomp.c:338">CCLASSC</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we cannot call <a href="#L1516" title="regex/regcomp.c:1516">charclasscomplement</a>() immediately */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_cclassc[v-&gt;nextvalue] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L129" title="regex/regexec.c:129">ERR</a>(REG_ASSERT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L313" title="regex/regcomp.c:313">SEE</a>(<a href="#L339" title="regex/regcomp.c:339">RANGE</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (v-&gt;nexttype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L330" title="regex/regcomp.c:330">PLAIN</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L339" title="regex/regcomp.c:339">RANGE</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endc = v-&gt;nextvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L333" title="regex/regcomp.c:333">COLLEL</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startp = v-&gt;<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endp = <a href="#L1884" title="regex/regcomp.c:1884">scanplain</a>(v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="regex/regcomp.c:323">INSIST</a>(startp &lt; endp, REG_ECOLLATE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endc = <a href="regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>(v, startp, endp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L129" title="regex/regexec.c:129">ERR</a>(REG_ERANGE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; endc = startc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../access/brin/brin_minmax_multi.c.html#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a> are unportable.&nbsp; Actually, standard C does guarantee that digits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are contiguous, but making that an exception is just too complicated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (startc != endc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L324" title="regex/regcomp.c:324">NOTE</a>(REG_UUNPORT);<br/></li>
<li>&nbsp; &nbsp; cv = <a href="regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>(v, startc, endc, (v-&gt;cflags &amp; REG_ICASE));<br/></li>
<li>&nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="regc_color.c.html#L522" title="regex/regc_color.c:522">subcolorcvec</a>(v, cv, lp, rp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1884" title="regex/regcomp.c:1884">scanplain</a> - scan <a href="#L330" title="regex/regcomp.c:330">PLAIN</a> contents of [. etc.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Certain bits of trickery in regc_lex.c know that this code does not try<br/></li>
<li></span><span class="Comment"> * to look past the final <a href="#L1671" title="regex/regcomp.c:1671">bracket</a> of the [. etc.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just after end of sequence */<br/></li>
<li><a id="L1884">&#x200c;</a></span><span class="linkable">scanplain</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; *endp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(<a href="#L313" title="regex/regcomp.c:313">SEE</a>(<a href="#L333" title="regex/regcomp.c:333">COLLEL</a>) || <a href="#L313" title="regex/regcomp.c:313">SEE</a>(<a href="#L334" title="regex/regcomp.c:334">ECLASS</a>) || <a href="#L313" title="regex/regcomp.c:313">SEE</a>(<a href="#L335" title="regex/regcomp.c:335">CCLASS</a>));<br/></li>
<li>&nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; endp = v-&gt;<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L313" title="regex/regcomp.c:313">SEE</a>(<a href="#L330" title="regex/regcomp.c:330">PLAIN</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; endp = v-&gt;<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(<a href="#L313" title="regex/regcomp.c:313">SEE</a>(<a href="#L336" title="regex/regcomp.c:336">END</a>) || <a href="regexec.c.html#L127" title="regex/regexec.c:127">ISERR</a>());<br/></li>
<li>&nbsp; &nbsp; <a href="#L312" title="regex/regcomp.c:312">NEXT</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> endp;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1909" title="regex/regcomp.c:1909">onechr</a> - fill in arcs for a plain character, and possible case complements<br/></li>
<li></span><span class="Comment"> * This is mostly a shortcut for efficient handling of the common case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1909">&#x200c;</a></span><span class="linkable">onechr</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> c,<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *lp,<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *rp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(v-&gt;cflags &amp; REG_ICASE))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; color&nbsp; &nbsp; &nbsp; &nbsp; lastsubcolor = COLORLESS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_color.c.html#L624" title="regex/regc_color.c:624">subcoloronechr</a>(v, c, lp, rp, &amp;lastsubcolor);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* rats, need general case anyway... */<br/></li>
<li></span>&nbsp; &nbsp; <a href="regc_color.c.html#L522" title="regex/regc_color.c:522">subcolorcvec</a>(v, <a href="regc_locale.c.html#L717" title="regex/regc_locale.c:717">allcases</a>(v, c), lp, rp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1935" title="regex/regcomp.c:1935">optimizebracket</a> - see if <a href="#L1671" title="regex/regcomp.c:1671">bracket</a> expression can be converted to RAINBOW<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Cases such as &quot;[\s\S]&quot; can produce a set of arcs of all colors, which we<br/></li>
<li></span><span class="Comment"> * can replace by a single RAINBOW arc for efficiency.&nbsp; (This might seem<br/></li>
<li></span><span class="Comment"> * like a silly way to write &quot;.&quot;, but it's seemingly a common locution in<br/></li>
<li></span><span class="Comment"> * some other flavors of regex, so take the trouble to support it well.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1935">&#x200c;</a></span><span class="linkable">optimizebracket</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *lp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *rp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> colordesc *cd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> colordesc *end = CDEND(v-&gt;cm);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> arc *a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; israinbow;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan lp's out-arcs and transiently mark the mentioned colors.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expect that all of lp's out-arcs are plain, non-RAINBOW arcs to rp.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Note: there shouldn't be <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pseudocolors yet, but check anyway.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (a = lp-&gt;outs; a != <span class="Constant">NULL</span>; a = a-&gt;outchain)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(a-&gt;type == <a href="#L330" title="regex/regcomp.c:330">PLAIN</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(a-&gt;co &gt;= <span class="Constant">0</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* i.e. not RAINBOW */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; assert(a-&gt;to == rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cd = &amp;v-&gt;cm-&gt;cd[a-&gt;co];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assert(!UNUSEDCOLOR(cd) &amp;&amp; !(cd-&gt;flags &amp; PSEUDO));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cd-&gt;flags |= COLMARK;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan colors, clear transient marks, check for unmarked live colors */<br/></li>
<li></span>&nbsp; &nbsp; israinbow = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (cd = v-&gt;cm-&gt;cd; cd &lt; end; cd++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cd-&gt;flags &amp; COLMARK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cd-&gt;flags &amp;= ~COLMARK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!UNUSEDCOLOR(cd) &amp;&amp; !(cd-&gt;flags &amp; PSEUDO))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; israinbow = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't do anything if not all colors have arcs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!israinbow)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, drop existing arcs and replace with a <a href="regc_color.c.html#L1031" title="regex/regc_color.c:1031">rainbow</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> ((a = lp-&gt;outs) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L418" title="regex/regc_nfa.c:418">freearc</a>(v-&gt;nfa, a);<br/></li>
<li>&nbsp; &nbsp; <a href="regc_nfa.c.html#L281" title="regex/regc_nfa.c:281">newarc</a>(v-&gt;nfa, <a href="#L330" title="regex/regcomp.c:330">PLAIN</a>, RAINBOW, lp, rp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1991" title="regex/regcomp.c:1991">wordchrs</a> - set up <a href="#L1474" title="regex/regcomp.c:1474">word</a>-<a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> list for <a href="#L1474" title="regex/regcomp.c:1474">word</a>-boundary stuff, if needed<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The list is kept as a bunch of circular arcs on an otherwise-unused state.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this must not be called while we have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> open subcolors,<br/></li>
<li></span><span class="Comment"> * else construction of the list would confuse color bookkeeping.<br/></li>
<li></span><span class="Comment"> * Hence, we can't currently apply a similar optimization in<br/></li>
<li></span><span class="Comment"> * <a href="#L1492" title="regex/regcomp.c:1492">charclass</a>[complement](), as those need to be usable within <a href="#L1671" title="regex/regcomp.c:1671">bracket</a><br/></li>
<li></span><span class="Comment"> * expressions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1991">&#x200c;</a></span><span class="linkable">wordchrs</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *cstate;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> cvec *cv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;<a href="#L1991" title="regex/regcomp.c:1991">wordchrs</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* done already */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make dummy state to hang the cache arcs on */<br/></li>
<li></span>&nbsp; &nbsp; cstate = <a href="regc_nfa.c.html#L137" title="regex/regc_nfa.c:137">newstate</a>(v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* obtain possibly-cached cvec for \w characters */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L324" title="regex/regcomp.c:324">NOTE</a>(REG_ULOCALE);<br/></li>
<li>&nbsp; &nbsp; cv = <a href="regc_locale.c.html#L569" title="regex/regc_locale.c:569">cclasscvec</a>(v, CC_WORD, (v-&gt;cflags &amp; REG_ICASE));<br/></li>
<li>&nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build the arcs; this may cause color splitting */<br/></li>
<li></span>&nbsp; &nbsp; <a href="regc_color.c.html#L522" title="regex/regc_color.c:522">subcolorcvec</a>(v, cv, cstate, cstate);<br/></li>
<li>&nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* close new open subcolors to ensure the cache entry is self-contained */<br/></li>
<li></span>&nbsp; &nbsp; <a href="regc_color.c.html#L916" title="regex/regc_color.c:916">okcolors</a>(v-&gt;nfa, v-&gt;cm);<br/></li>
<li>&nbsp; &nbsp; <a href="regexec.c.html#L130" title="regex/regexec.c:130">NOERR</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* success! save the cache pointer */<br/></li>
<li></span>&nbsp; &nbsp; v-&gt;<a href="#L1991" title="regex/regcomp.c:1991">wordchrs</a> = cstate;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2027" title="regex/regcomp.c:2027">processlacon</a> - generate the NFA representation of a <a href="#L340" title="regex/regcomp.c:340">LACON</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the general case this is just <a href="#L2388" title="regex/regcomp.c:2388">newlacon</a>() + <a href="regc_nfa.c.html#L281" title="regex/regc_nfa.c:281">newarc</a>(), but some cases<br/></li>
<li></span><span class="Comment"> * can be optimized.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2027">&#x200c;</a></span><span class="linkable">processlacon</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *begin,&nbsp; &nbsp; <span class="Comment">/* start of parsed <a href="#L340" title="regex/regcomp.c:340">LACON</a> sub-re */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *end, <span class="Comment">/* end of parsed <a href="#L340" title="regex/regcomp.c:340">LACON</a> sub-re */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> latype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *lp,&nbsp; &nbsp; <span class="Comment">/* left state to hang it on */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *rp)&nbsp; &nbsp; <span class="Comment">/* right state to hang it on */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> state *s1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for lookaround RE consisting of a single plain color arc (or set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of arcs); this would typically be a simple <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> or a <a href="#L1671" title="regex/regcomp.c:1671">bracket</a> expression.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; s1 = <a href="regc_nfa.c.html#L1524" title="regex/regc_nfa.c:1524">single_color_transition</a>(begin, end);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (latype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LATYPE_AHEAD_POS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If lookahead RE is just colorset C, convert to <a href="#L341" title="regex/regcomp.c:341">AHEAD</a>(C) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s1 != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L1256" title="regex/regc_nfa.c:1256">cloneouts</a>(v-&gt;nfa, s1, lp, rp, <a href="#L341" title="regex/regcomp.c:341">AHEAD</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LATYPE_AHEAD_NEG:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If lookahead RE is just colorset C, convert to <a href="#L341" title="regex/regcomp.c:341">AHEAD</a>(^C)|$ */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s1 != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_color.c.html#L1064" title="regex/regc_color.c:1064">colorcomplement</a>(v-&gt;nfa, v-&gt;cm, <a href="#L341" title="regex/regcomp.c:341">AHEAD</a>, s1, lp, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L281" title="regex/regc_nfa.c:281">newarc</a>(v-&gt;nfa, <span class="Constant">'$'</span>, <span class="Constant">1</span>, lp, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L281" title="regex/regc_nfa.c:281">newarc</a>(v-&gt;nfa, <span class="Constant">'$'</span>, <span class="Constant">0</span>, lp, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LATYPE_BEHIND_POS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If lookbehind RE is just colorset C, convert to <a href="#L342" title="regex/regcomp.c:342">BEHIND</a>(C) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s1 != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L1256" title="regex/regc_nfa.c:1256">cloneouts</a>(v-&gt;nfa, s1, lp, rp, <a href="#L342" title="regex/regcomp.c:342">BEHIND</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LATYPE_BEHIND_NEG:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If lookbehind RE is just colorset C, convert to <a href="#L342" title="regex/regcomp.c:342">BEHIND</a>(^C)|^ */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s1 != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_color.c.html#L1064" title="regex/regc_color.c:1064">colorcomplement</a>(v-&gt;nfa, v-&gt;cm, <a href="#L342" title="regex/regcomp.c:342">BEHIND</a>, s1, lp, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L281" title="regex/regc_nfa.c:281">newarc</a>(v-&gt;nfa, <span class="Constant">'^'</span>, <span class="Constant">1</span>, lp, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L281" title="regex/regc_nfa.c:281">newarc</a>(v-&gt;nfa, <span class="Constant">'^'</span>, <span class="Constant">0</span>, lp, rp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(NOTREACHED);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* General case: we need a <a href="#L340" title="regex/regcomp.c:340">LACON</a> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> and arc */<br/></li>
<li></span>&nbsp; &nbsp; n = <a href="#L2388" title="regex/regcomp.c:2388">newlacon</a>(v, begin, end, latype);<br/></li>
<li>&nbsp; &nbsp; <a href="regc_nfa.c.html#L281" title="regex/regc_nfa.c:281">newarc</a>(v-&gt;nfa, <a href="#L340" title="regex/regcomp.c:340">LACON</a>, n, lp, rp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2093" title="regex/regcomp.c:2093">subre</a> - allocate a <a href="#L2093" title="regex/regcomp.c:2093">subre</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *<br/></li>
<li><a id="L2093">&#x200c;</a><span class="linkable">subre</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">int</span> op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">int</span> flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *begin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">struct</span> state *end)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *ret = v-&gt;treefree;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Checking for stack overflow here is sufficient to protect <a href="#L715" title="regex/regcomp.c:715">parse</a>() and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its recursive subroutines.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (STACK_TOO_DEEP(v-&gt;re))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L129" title="regex/regexec.c:129">ERR</a>(REG_ETOOBIG);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ret != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;treefree = ret-&gt;child;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ret = (<span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *) MALLOC(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ret == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L129" title="regex/regexec.c:129">ERR</a>(REG_ESPACE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ret-&gt;chain = v-&gt;treechain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;treechain = ret;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(strchr(<span class="Constant">&quot;=b|.*(&quot;</span>, op) != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret-&gt;op = op;<br/></li>
<li>&nbsp; &nbsp; ret-&gt;flags = flags;<br/></li>
<li>&nbsp; &nbsp; ret-&gt;latype = (<span class="Type">char</span>) -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; ret-&gt;id = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* will be assigned later */<br/></li>
<li></span>&nbsp; &nbsp; ret-&gt;capno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ret-&gt;backno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ret-&gt;min = ret-&gt;max = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; ret-&gt;child = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ret-&gt;sibling = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ret-&gt;begin = begin;<br/></li>
<li>&nbsp; &nbsp; ret-&gt;end = end;<br/></li>
<li>&nbsp; &nbsp; ZAPCNFA(ret-&gt;cnfa);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2150" title="regex/regcomp.c:2150">freesubre</a> - free a subRE subtree<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This frees child node(s) of the given subRE too,<br/></li>
<li></span><span class="Comment"> * but not its siblings.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2150">&#x200c;</a></span><span class="linkable">freesubre</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* might be NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *sr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sr-&gt;child != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2169" title="regex/regcomp.c:2169">freesubreandsiblings</a>(v, sr-&gt;child);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2185" title="regex/regcomp.c:2185">freesrnode</a>(v, sr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2169" title="regex/regcomp.c:2169">freesubreandsiblings</a> - free a subRE subtree<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This frees child node(s) of the given subRE too,<br/></li>
<li></span><span class="Comment"> * as well as <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> following siblings.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2169">&#x200c;</a></span><span class="linkable">freesubreandsiblings</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v,&nbsp; &nbsp; <span class="Comment">/* might be NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *sr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (sr != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = sr-&gt;sibling;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2150" title="regex/regcomp.c:2150">freesubre</a>(v, sr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sr = <a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2185" title="regex/regcomp.c:2185">freesrnode</a> - free one node in a subRE subtree<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2185">&#x200c;</a></span><span class="linkable">freesrnode</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* might be NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *sr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!NULLCNFA(sr-&gt;cnfa))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L3598" title="regex/regc_nfa.c:3598">freecnfa</a>(&amp;sr-&gt;cnfa);<br/></li>
<li>&nbsp; &nbsp; sr-&gt;flags = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* in particular, not INUSE */<br/></li>
<li></span>&nbsp; &nbsp; sr-&gt;child = sr-&gt;sibling = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; sr-&gt;begin = sr-&gt;end = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v != <span class="Constant">NULL</span> &amp;&amp; v-&gt;treechain != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we're still parsing, maybe we can reuse the <a href="#L2093" title="regex/regcomp.c:2093">subre</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sr-&gt;child = v-&gt;treefree;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;treefree = sr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; FREE(sr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2216" title="regex/regcomp.c:2216">removecaptures</a> - remove unnecessary capture subREs<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the caller said that it doesn't care about subexpression match data,<br/></li>
<li></span><span class="Comment"> * we may delete the &quot;capture&quot; markers on subREs that are not referenced<br/></li>
<li></span><span class="Comment"> * by <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> backrefs, and then simplify anything that's become non-messy.<br/></li>
<li></span><span class="Comment"> * Call this only if REG_NOSUB flag is set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2216">&#x200c;</a></span><span class="linkable">removecaptures</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *t)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *t2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(t != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this isn't itself a backref target, clear capno and tentatively<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clear CAP flag.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(t-&gt;flags &amp; BRUSE))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; t-&gt;capno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; t-&gt;flags &amp;= ~CAP;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now recurse to children */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (t2 = t-&gt;child; t2 != <span class="Constant">NULL</span>; t2 = t2-&gt;sibling)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2216" title="regex/regcomp.c:2216">removecaptures</a>(v, t2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Propagate child CAP flag back up, if it's still set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (t2-&gt;flags &amp; CAP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t-&gt;flags |= CAP;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If t <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> contains neither captures nor backrefs, there's no longer <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to care where its sub-match boundaries are, so we can reduce it to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a simple DFA node.&nbsp; (Note in particular that MIXED child greediness is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not a hindrance here, so we don't use the MESSY() macro.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((t-&gt;flags &amp; (CAP | BACKR)) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (t-&gt;child)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2169" title="regex/regcomp.c:2169">freesubreandsiblings</a>(v, t-&gt;child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; t-&gt;child = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; t-&gt;op = <span class="Constant">'='</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; t-&gt;flags &amp;= ~MIXED;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2262" title="regex/regcomp.c:2262">numst</a> - number tree nodes (assigning &quot;id&quot; indexes)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> number */<br/></li>
<li><a id="L2262">&#x200c;</a></span><span class="linkable">numst</span>(<span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *t,<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">int</span> start)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* starting point for subtree numbers */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *t2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(t != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i = start;<br/></li>
<li>&nbsp; &nbsp; t-&gt;id = i++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (t2 = t-&gt;child; t2 != <span class="Constant">NULL</span>; t2 = t2-&gt;sibling)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i = <a href="#L2262" title="regex/regcomp.c:2262">numst</a>(t2, i);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> i;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2295" title="regex/regcomp.c:2295">markst</a> - mark tree nodes as INUSE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this is a great deal more subtle than it looks.&nbsp; During initial<br/></li>
<li></span><span class="Comment"> * parsing of a regex, all subres are linked into the treechain list;<br/></li>
<li></span><span class="Comment"> * discarded ones are also linked into the treefree list for possible reuse.<br/></li>
<li></span><span class="Comment"> * After we are done creating all subres required for a regex, we run <a href="#L2295" title="regex/regcomp.c:2295">markst</a>()<br/></li>
<li></span><span class="Comment"> * then <a href="#L2310" title="regex/regcomp.c:2310">cleanst</a>(), which results in discarding all subres not reachable from<br/></li>
<li></span><span class="Comment"> * v-&gt;tree.&nbsp; We then clear v-&gt;treechain, indicating that subres must be found<br/></li>
<li></span><span class="Comment"> * by descending from v-&gt;tree.&nbsp; This changes the behavior of <a href="#L2150" title="regex/regcomp.c:2150">freesubre</a>(): it<br/></li>
<li></span><span class="Comment"> * will henceforth FREE() unwanted subres rather than sticking them into the<br/></li>
<li></span><span class="Comment"> * treefree list.&nbsp; (Doing that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> earlier would result in dangling links in<br/></li>
<li></span><span class="Comment"> * the treechain list.)&nbsp; This all means that <a href="#L590" title="regex/regcomp.c:590">freev</a>() will clean up correctly<br/></li>
<li></span><span class="Comment"> * if invoked <a href="regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> or after <a href="#L2295" title="regex/regcomp.c:2295">markst</a>()+<a href="#L2310" title="regex/regcomp.c:2310">cleanst</a>(); but it would not work if<br/></li>
<li></span><span class="Comment"> * called partway through this state conversion, so we mustn't error out<br/></li>
<li></span><span class="Comment"> * in or between these two <a href="#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2295">&#x200c;</a></span><span class="linkable">markst</span>(<span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *t)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *t2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(t != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; t-&gt;flags |= INUSE;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (t2 = t-&gt;child; t2 != <span class="Constant">NULL</span>; t2 = t2-&gt;sibling)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2295" title="regex/regcomp.c:2295">markst</a>(t2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2310" title="regex/regcomp.c:2310">cleanst</a> - free <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tree nodes not marked INUSE<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2310">&#x200c;</a></span><span class="linkable">cleanst</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *t;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *<a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (t = v-&gt;treechain; t != <span class="Constant">NULL</span>; t = <a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = t-&gt;chain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(t-&gt;flags &amp; INUSE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FREE(t);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; v-&gt;treechain = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; v-&gt;treefree = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just on general principles */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2329" title="regex/regcomp.c:2329">nfatree</a> - turn a subRE subtree into a tree of compacted NFAs<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> results from top node */<br/></li>
<li><a id="L2329">&#x200c;</a></span><span class="linkable">nfatree</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *t,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">FILE</span> *f)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for debug output */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *t2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(t != <span class="Constant">NULL</span> &amp;&amp; t-&gt;begin != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (t2 = t-&gt;child; t2 != <span class="Constant">NULL</span>; t2 = t2-&gt;sibling)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (DISCARD) <a href="#L2329" title="regex/regcomp.c:2329">nfatree</a>(v, t2, f);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2349" title="regex/regcomp.c:2349">nfanode</a>(v, t, <span class="Constant">0</span>, f);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2349" title="regex/regcomp.c:2349">nfanode</a> - do one NFA for <a href="#L2329" title="regex/regcomp.c:2329">nfatree</a> or lacons<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If converttosearch is true, apply <a href="#L619" title="regex/regcomp.c:619">makesearch</a>() to the NFA.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> results */<br/></li>
<li><a id="L2349">&#x200c;</a></span><span class="linkable">nfanode</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *t,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> converttosearch,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">FILE</span> *f)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for debug output */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> nfa *nfa;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; ret = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(t-&gt;begin != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef REG_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (f != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; idbuf[<span class="Constant">50</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">\n\n\n</span><span class="Constant">========= TREE <a href="../utils/adt/tsquery_cleanup.c.html#L22" title="utils/adt/tsquery_cleanup.c:22">NODE</a> </span><span class="Special">%s</span><span class="Constant"> ==========</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2627" title="regex/regcomp.c:2627">stid</a>(t, idbuf, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(idbuf)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; nfa = <a href="regc_nfa.c.html#L47" title="regex/regc_nfa.c:47">newnfa</a>(v, v-&gt;cm, v-&gt;nfa);<br/></li>
<li>&nbsp; &nbsp; <a href="#L322" title="regex/regcomp.c:322">NOERRZ</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="regc_nfa.c.html#L1355" title="regex/regc_nfa.c:1355">dupnfa</a>(nfa, t-&gt;begin, t-&gt;end, nfa-&gt;init, nfa-&gt;final);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="regexec.c.html#L127" title="regex/regexec.c:127">ISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L1554" title="regex/regc_nfa.c:1554">specialcolors</a>(nfa);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="regexec.c.html#L127" title="regex/regexec.c:127">ISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a>(nfa, f);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (converttosearch &amp;&amp; !<a href="regexec.c.html#L127" title="regex/regexec.c:127">ISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L619" title="regex/regcomp.c:619">makesearch</a>(v, nfa);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="regexec.c.html#L127" title="regex/regexec.c:127">ISERR</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L3479" title="regex/regc_nfa.c:3479">compact</a>(nfa, &amp;t-&gt;cnfa);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="regc_nfa.c.html#L107" title="regex/regc_nfa.c:107">freenfa</a>(nfa);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2388" title="regex/regcomp.c:2388">newlacon</a> - allocate a lookaround-constraint subRE<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="rege_dfa.c.html#L916" title="regex/rege_dfa.c:916">lacon</a> number */<br/></li>
<li><a id="L2388">&#x200c;</a></span><span class="linkable">newlacon</span>(<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *begin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> state *end,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> latype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *newlacons;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *sub;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;nlacons == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> 0th */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newlacons = (<span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *) MALLOC(<span class="Constant">2</span> * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n = v-&gt;nlacons;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newlacons = (<span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *) REALLOC(v-&gt;lacons,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (n + <span class="Constant">1</span>) * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newlacons == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regexec.c.html#L129" title="regex/regexec.c:129">ERR</a>(REG_ESPACE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; v-&gt;lacons = newlacons;<br/></li>
<li>&nbsp; &nbsp; v-&gt;nlacons = n + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; sub = &amp;v-&gt;lacons[n];<br/></li>
<li>&nbsp; &nbsp; sub-&gt;begin = begin;<br/></li>
<li>&nbsp; &nbsp; sub-&gt;end = end;<br/></li>
<li>&nbsp; &nbsp; sub-&gt;latype = latype;<br/></li>
<li>&nbsp; &nbsp; ZAPCNFA(sub-&gt;cnfa);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> n;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2427" title="regex/regcomp.c:2427">freelacons</a> - free lookaround-constraint subRE vector<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2427">&#x200c;</a></span><span class="linkable">freelacons</span>(<span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *subs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> n)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *sub;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(n &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (sub = subs + <span class="Constant">1</span>, i = n - <span class="Constant">1</span>; i &gt; <span class="Constant">0</span>; sub++, i--)&nbsp; &nbsp; <span class="Comment">/* no 0th */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!NULLCNFA(sub-&gt;cnfa))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L3598" title="regex/regc_nfa.c:3598">freecnfa</a>(&amp;sub-&gt;cnfa);<br/></li>
<li>&nbsp; &nbsp; FREE(subs);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2444" title="regex/regcomp.c:2444">rfree</a> - free a whole RE (insides of regfree)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2444">&#x200c;</a></span><span class="linkable">rfree</span>(regex_t *re)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> guts *g;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (re == <span class="Constant">NULL</span> || re-&gt;re_magic != REMAGIC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; re-&gt;re_magic = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* invalidate RE */<br/></li>
<li></span>&nbsp; &nbsp; g = (<span class="Type">struct</span> guts *) re-&gt;re_guts;<br/></li>
<li>&nbsp; &nbsp; re-&gt;re_guts = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; re-&gt;re_fns = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (g != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; g-&gt;magic = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_color.c.html#L103" title="regex/regc_color.c:103">freecm</a>(&amp;g-&gt;cmap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (g-&gt;tree != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2150" title="regex/regcomp.c:2150">freesubre</a>((<span class="Type">struct</span> <a href="regexec.c.html#L106" title="regex/regexec.c:106">vars</a> *) <span class="Constant">NULL</span>, g-&gt;tree);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (g-&gt;lacons != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2427" title="regex/regcomp.c:2427">freelacons</a>(g-&gt;lacons, g-&gt;nlacons);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!NULLCNFA(g-&gt;search))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L3598" title="regex/regc_nfa.c:3598">freecnfa</a>(&amp;g-&gt;search);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FREE(g);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2480" title="regex/regcomp.c:2480">rstacktoodeep</a> - check for stack getting dangerously deep<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return nonzero to fail the operation with error code REG_ETOOBIG,<br/></li>
<li></span><span class="Comment"> * zero to keep going<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The current implementation is Postgres-specific.&nbsp; If we ever get around<br/></li>
<li></span><span class="Comment"> * to splitting the regex code out as a standalone library, there will need<br/></li>
<li></span><span class="Comment"> * to be some API to let applications define a callback function for this.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2480">&#x200c;</a></span><span class="linkable">rstacktoodeep</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../tcop/postgres.c.html#L3545" title="tcop/postgres.c:3545">stack_is_too_deep</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef REG_DEBUG<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2491" title="regex/regcomp.c:2491">dump</a> - <a href="#L2491" title="regex/regcomp.c:2491">dump</a> an RE in human-readable form<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2491">&#x200c;</a></span><span class="linkable">dump</span>(regex_t *re,<br/></li>
<li>&nbsp; &nbsp;&nbsp; <span class="Type">FILE</span> *f)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> guts *g;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (re-&gt;re_magic != REMAGIC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;bad magic number (0x</span><span class="Special">%x</span><span class="Constant"> not 0x</span><span class="Special">%x</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>, re-&gt;re_magic,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; REMAGIC);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (re-&gt;re_guts == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;NULL guts!!!</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; g = (<span class="Type">struct</span> guts *) re-&gt;re_guts;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (g-&gt;magic != GUTSMAGIC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;bad guts magic number (0x</span><span class="Special">%x</span><span class="Constant"> not 0x</span><span class="Special">%x</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>, g-&gt;magic,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GUTSMAGIC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">\n\n\n</span><span class="Constant">========= DUMP ==========</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;nsub </span><span class="Special">%d</span><span class="Constant">, info 0</span><span class="Special">%lo</span><span class="Constant">, csize </span><span class="Special">%d</span><span class="Constant">, ntree </span><span class="Special">%d\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) re-&gt;re_nsub, re-&gt;re_info, re-&gt;re_csize, g-&gt;ntree);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="regc_color.c.html#L1111" title="regex/regc_color.c:1111">dumpcolors</a>(&amp;g-&gt;cmap, f);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!NULLCNFA(g-&gt;search))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">search:</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L3783" title="regex/regc_nfa.c:3783">dumpcnfa</a>(&amp;g-&gt;search, f);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; g-&gt;nlacons; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *lasub = &amp;g-&gt;lacons[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *latype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (lasub-&gt;latype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LATYPE_AHEAD_POS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; latype = <span class="Constant">&quot;positive lookahead&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LATYPE_AHEAD_NEG:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; latype = <span class="Constant">&quot;negative lookahead&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LATYPE_BEHIND_POS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; latype = <span class="Constant">&quot;positive lookbehind&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LATYPE_BEHIND_NEG:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; latype = <span class="Constant">&quot;negative lookbehind&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; latype = <span class="Constant">&quot;???&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">la</span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">):</span><span class="Special">\n</span><span class="Constant">&quot;</span>, i, latype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L3783" title="regex/regc_nfa.c:3783">dumpcnfa</a>(&amp;lasub-&gt;cnfa, f);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L2554" title="regex/regcomp.c:2554">dumpst</a>(g-&gt;tree, f, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2554" title="regex/regcomp.c:2554">dumpst</a> - <a href="#L2491" title="regex/regcomp.c:2491">dump</a> a subRE tree<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2554">&#x200c;</a></span><span class="linkable">dumpst</span>(<span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *t,<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">FILE</span> *f,<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nfapresent)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* is the original NFA still around? */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (t == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;null tree</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2569" title="regex/regcomp.c:2569">stdump</a>(t, f, nfapresent);<br/></li>
<li>&nbsp; &nbsp; fflush(f);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2569" title="regex/regcomp.c:2569">stdump</a> - recursive guts of <a href="#L2554" title="regex/regcomp.c:2554">dumpst</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2569">&#x200c;</a></span><span class="linkable">stdump</span>(<span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *t,<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">FILE</span> *f,<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nfapresent)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* is the original NFA still around? */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; idbuf[<span class="Constant">50</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *t2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">. `</span><span class="Special">%c</span><span class="Constant">'&quot;</span>, <a href="#L2627" title="regex/regcomp.c:2627">stid</a>(t, idbuf, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(idbuf)), t-&gt;op);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (t-&gt;flags &amp; LONGER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot; <a href="rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (t-&gt;flags &amp; SHORTER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot; <a href="rege_dfa.c.html#L204" title="regex/rege_dfa.c:204">shortest</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (t-&gt;flags &amp; MIXED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot; hasmixed&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (t-&gt;flags &amp; CAP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot; hascapture&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (t-&gt;flags &amp; BACKR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot; hasbackref&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (t-&gt;flags &amp; BRUSE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot; isreferenced&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(t-&gt;flags &amp; INUSE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot; UNUSED&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (t-&gt;latype != (<span class="Type">char</span>) -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot; latype(</span><span class="Special">%d</span><span class="Constant">)&quot;</span>, t-&gt;latype);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (t-&gt;capno != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot; capture(</span><span class="Special">%d</span><span class="Constant">)&quot;</span>, t-&gt;capno);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (t-&gt;backno != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot; backref(</span><span class="Special">%d</span><span class="Constant">)&quot;</span>, t-&gt;backno);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (t-&gt;min != <span class="Constant">1</span> || t-&gt;max != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot; {</span><span class="Special">%d</span><span class="Constant">,&quot;</span>, t-&gt;min);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (t-&gt;max != DUPINF)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, t-&gt;max);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;}&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nfapresent)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot; </span><span class="Special">%ld</span><span class="Constant">-</span><span class="Special">%ld</span><span class="Constant">&quot;</span>, (<span class="Type">long</span>) t-&gt;begin-&gt;no, (<span class="Type">long</span>) t-&gt;end-&gt;no);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (t-&gt;child != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot; C:</span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="#L2627" title="regex/regcomp.c:2627">stid</a>(t-&gt;child, idbuf, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(idbuf)));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* printing second child isn't necessary, but it is often helpful */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (t-&gt;child != <span class="Constant">NULL</span> &amp;&amp; t-&gt;child-&gt;sibling != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot; C2:</span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="#L2627" title="regex/regcomp.c:2627">stid</a>(t-&gt;child-&gt;sibling, idbuf, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(idbuf)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (t-&gt;sibling != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot; S:</span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="#L2627" title="regex/regcomp.c:2627">stid</a>(t-&gt;sibling, idbuf, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(idbuf)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!NULLCNFA(t-&gt;cnfa))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="regc_nfa.c.html#L3783" title="regex/regc_nfa.c:3783">dumpcnfa</a>(&amp;t-&gt;cnfa, f);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; fprintf(f, <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (t2 = t-&gt;child; t2 != <span class="Constant">NULL</span>; t2 = t2-&gt;sibling)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2569" title="regex/regcomp.c:2569">stdump</a>(t2, f, nfapresent);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2627" title="regex/regcomp.c:2627">stid</a> - identify a subtree node for dumping<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* points to buf or constant string */<br/></li>
<li><a id="L2627">&#x200c;</a></span><span class="linkable">stid</span>(<span class="Type">struct</span> <a href="#L2093" title="regex/regcomp.c:2093">subre</a> *t,<br/></li>
<li>&nbsp; &nbsp;&nbsp; <span class="Type">char</span> *buf,<br/></li>
<li>&nbsp; &nbsp;&nbsp; <span class="Type">size_t</span> bufsize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* big enough for hex int or decimal t-&gt;id? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bufsize &lt; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">void</span> *) * <span class="Constant">2</span> + <span class="Constant">3</span> || bufsize &lt; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(t-&gt;id) * <span class="Constant">3</span> + <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;unable&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (t-&gt;id != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sprintf(buf, <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, t-&gt;id);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sprintf(buf, <span class="Constant">&quot;</span><span class="Special">%p</span><span class="Constant">&quot;</span>, t);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* REG_DEBUG */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;regc_lex.c&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;regc_color.c&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;regc_nfa.c&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;regc_cvec.c&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;regc_pg_locale.c&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;regc_locale.c&quot;<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
