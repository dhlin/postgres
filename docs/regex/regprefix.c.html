<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>regex/regprefix.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>regex/regprefix.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L116">findprefix</a></li>
<li><a href="#L46">pg_regprefix</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * regprefix.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Extract a common prefix, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, from a compiled regex.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 2012-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1998, 1999 Henry Spencer<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/regex/regprefix.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;regex/regguts.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * forward declarations<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L116" title="regex/regprefix.c:116">findprefix</a>(<span class="Type">struct</span> cnfa *cnfa, <span class="Type">struct</span> colormap *cm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *string, <span class="Type">size_t</span> *slength);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L46" title="regex/regprefix.c:46">pg_regprefix</a> - get common prefix for regular expression<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns one of:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; REG_NOMATCH: there is no common prefix of strings matching the regex<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; REG_PREFIX: there is a common prefix of strings matching the regex<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; REG_EXACT: all strings satisfying the regex must match the same string<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; or a REG_XXX error code<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the non-failure cases, *string is set to a <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d string containing<br/></li>
<li></span><span class="Comment"> * the common prefix or exact value, of length *slength (measured in chrs<br/></li>
<li></span><span class="Comment"> * not bytes!).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function does not <a href="regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a> all complex cases (such as lookaround<br/></li>
<li></span><span class="Comment"> * constraints) exactly.&nbsp; Therefore it is possible that some strings matching<br/></li>
<li></span><span class="Comment"> * the reported prefix or exact-match string do not satisfy the regex.&nbsp; But<br/></li>
<li></span><span class="Comment"> * it should never be the case that a string satisfying the regex does not<br/></li>
<li></span><span class="Comment"> * match the reported prefix or exact-match string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L46">&#x200c;</a></span><span class="linkable">pg_regprefix</span>(regex_t *re,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> **string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">size_t</span> *slength)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> guts *g;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> cnfa *cnfa;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; st;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sanity checks */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (string == <span class="Constant">NULL</span> || slength == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_INVARG;<br/></li>
<li>&nbsp; &nbsp; *string = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> for failure cases */<br/></li>
<li></span>&nbsp; &nbsp; *slength = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (re == <span class="Constant">NULL</span> || re-&gt;re_magic != REMAGIC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_INVARG;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (re-&gt;re_csize != <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_MIXED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize locale-dependent support */<br/></li>
<li></span>&nbsp; &nbsp; <a href="regc_pg_locale.c.html#L234" title="regex/regc_pg_locale.c:234">pg_set_regex_collation</a>(re-&gt;re_collation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* setup */<br/></li>
<li></span>&nbsp; &nbsp; g = (<span class="Type">struct</span> guts *) re-&gt;re_guts;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (g-&gt;info &amp; REG_UIMPOSSIBLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_NOMATCH;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This implementation considers only the search NFA for the topmost regex<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tree node.&nbsp; Therefore, constraints such as backrefs are not fully<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * applied, which is allowed per the function's API spec.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; assert(g-&gt;tree != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; cnfa = &amp;g-&gt;tree-&gt;cnfa;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* matchall NFAs never have a fixed prefix */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cnfa-&gt;flags &amp; MATCHALL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_NOMATCH;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since a correct NFA should never contain <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> exit-free loops, it should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not be possible for our traversal to return to a previously visited NFA<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * state.&nbsp; Hence we need at most nstates chrs in the output string.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *string = (<a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *) MALLOC(cnfa-&gt;nstates * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*string == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_ESPACE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do it */<br/></li>
<li></span>&nbsp; &nbsp; st = <a href="#L116" title="regex/regprefix.c:116">findprefix</a>(cnfa, &amp;g-&gt;cmap, *string, slength);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; assert(*slength &lt;= cnfa-&gt;nstates);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* clean up */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (st != REG_PREFIX &amp;&amp; st != REG_EXACT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FREE(*string);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *string = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *slength = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> st;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L116" title="regex/regprefix.c:116">findprefix</a> - extract common prefix from cNFA<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Results are returned into the preallocated <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> array string[], with<br/></li>
<li></span><span class="Comment"> * *slength (which must be preset to zero) incremented for each <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* regprefix return code */<br/></li>
<li><a id="L116">&#x200c;</a></span><span class="linkable">findprefix</span>(<span class="Type">struct</span> cnfa *cnfa,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> colormap *cm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> *string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">size_t</span> *slength)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; st;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextst;<br/></li>
<li>&nbsp; &nbsp; color&nbsp; &nbsp; &nbsp; &nbsp; thiscolor;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> carc *ca;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The &quot;pre&quot; state must have only BOS/BOL outarcs, else pattern isn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anchored left.&nbsp; If we have both BOS and BOL, they must go to the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; st = cnfa-&gt;pre;<br/></li>
<li>&nbsp; &nbsp; nextst = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (ca = cnfa-&gt;states[st]; ca-&gt;co != COLORLESS; ca++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ca-&gt;co == cnfa-&gt;bos[<span class="Constant">0</span>] || ca-&gt;co == cnfa-&gt;bos[<span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nextst == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextst = ca-&gt;to;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (nextst != ca-&gt;to)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_NOMATCH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_NOMATCH;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nextst == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_NOMATCH;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan through successive states, stopping as soon as we <a href="regexec.c.html#L419" title="regex/regexec.c:419">find</a> one with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more than one acceptable transition character (either multiple colors<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on out-arcs, or a color with more than one member <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We could <a href="regexec.c.html#L419" title="regex/regexec.c:419">find</a> a state with multiple out-arcs that are all labeled with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the same singleton color; this comes from patterns like &quot;^ab(cde|cxy)&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In that case we add the <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> &quot;c&quot; to the output string but then exit the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * loop with nextst == -1.&nbsp; This leaves a little <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> on the table: if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pattern is like &quot;^ab(cde|cdy)&quot;, we won't notice that &quot;d&quot; could be added<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the prefix.&nbsp; But chasing multiple parallel state chains doesn't seem<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worth the trouble.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; st = nextst;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nextst = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; thiscolor = COLORLESS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (ca = cnfa-&gt;states[st]; ca-&gt;co != COLORLESS; ca++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can ignore BOS/BOL arcs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ca-&gt;co == cnfa-&gt;bos[<span class="Constant">0</span>] || ca-&gt;co == cnfa-&gt;bos[<span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ... but <a href="regcomp.c.html#L329" title="regex/regcomp.c:329">EOS</a>/EOL arcs terminate the search, as do RAINBOW arcs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and LACONs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ca-&gt;co == cnfa-&gt;eos[<span class="Constant">0</span>] || ca-&gt;co == cnfa-&gt;eos[<span class="Constant">1</span>] ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ca-&gt;co == RAINBOW || ca-&gt;co &gt;= cnfa-&gt;ncolors)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thiscolor = COLORLESS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (thiscolor == COLORLESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First plain outarc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thiscolor = ca-&gt;co;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextst = ca-&gt;to;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (thiscolor == ca-&gt;co)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Another plain outarc for same color */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextst = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* More than one plain outarc color terminates the search */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thiscolor = COLORLESS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Done if we didn't <a href="regexec.c.html#L419" title="regex/regexec.c:419">find</a> exactly one color on plain outarcs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (thiscolor == COLORLESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The color must be a singleton */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cm-&gt;cd[thiscolor].nschrs != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must not have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> high-color-map entries */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cm-&gt;cd[thiscolor].nuchrs != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Identify the color's sole member <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> and add it to the prefix<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * string.&nbsp; In general the colormap data structure doesn't provide a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * way to <a href="regexec.c.html#L419" title="regex/regexec.c:419">find</a> color member chrs, except by trying GETCOLOR() on each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> value, which won't do at all.&nbsp; However, for the cases<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we care about it should be sufficient to test the &quot;firstchr&quot; value,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that is the first <a href="../utils/adt/oracle_compat.c.html#L1006" title="utils/adt/oracle_compat.c:1006">chr</a> ever added to the color.&nbsp; There are cases<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * where this might no longer be a member of the color (so we do need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to test), but <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of them are likely to arise for a character that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is a member of a common prefix.&nbsp; If we do hit such a corner case,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we just fall out without adding anything to the prefix string.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; c = cm-&gt;cd[thiscolor].firstchr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GETCOLOR(cm, c) != thiscolor)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; string[(*slength)++] = c;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance to <a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> state, but only if we have a unique <a href="regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> state */<br/></li>
<li></span>&nbsp; &nbsp; } <span class="Statement">while</span> (nextst != -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we ended at a state that only has <a href="regcomp.c.html#L329" title="regex/regcomp.c:329">EOS</a>/EOL outarcs leading to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;post&quot; state, then we have an exact-match string.&nbsp; Note this is true<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * even if the string is of zero length.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nextst = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (ca = cnfa-&gt;states[st]; ca-&gt;co != COLORLESS; ca++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ca-&gt;co == cnfa-&gt;eos[<span class="Constant">0</span>] || ca-&gt;co == cnfa-&gt;eos[<span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nextst == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextst = ca-&gt;to;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (nextst != ca-&gt;to)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextst = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextst = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nextst == cnfa-&gt;post)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_EXACT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, if we were unable to identify <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> prefix characters, say<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NOMATCH --- the pattern is anchored left, but doesn't specify <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * particular first character.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*slength &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> REG_PREFIX;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> REG_NOMATCH;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
