<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>jit/llvm/llvmjit_deform.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>jit/llvm/llvmjit_deform.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L34">slot_compile_deform</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * llvmjit_deform.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Generate code for deforming a heap tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This gains performance benefits over unJITed deforming from compile-time<br/></li>
<li></span><span class="Comment"> * knowledge of the tuple descriptor. Fixed column widths, NOT NULLness, etc<br/></li>
<li></span><span class="Comment"> * can be taken advantage of.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/jit/llvm/llvmjit_deform.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;llvm-c/Core.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tupdesc_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/tuptable.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;jit/llvmjit.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;jit/llvmjit_emit.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a function that deforms a tuple of type desc up to natts columns.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>LLVMValueRef<br/></li>
<li><a id="L34">&#x200c;</a><span class="linkable">slot_compile_deform</span>(LLVMJitContext *context, TupleDesc desc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> TupleTableSlotOps *ops, <span class="Type">int</span> natts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *funcname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LLVMModuleRef mod;<br/></li>
<li>&nbsp; &nbsp; LLVMContextRef lc;<br/></li>
<li>&nbsp; &nbsp; LLVMBuilderRef b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LLVMTypeRef deform_sig;<br/></li>
<li>&nbsp; &nbsp; LLVMValueRef v_deform_fn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LLVMBasicBlockRef b_entry;<br/></li>
<li>&nbsp; &nbsp; LLVMBasicBlockRef b_adjust_unavail_cols;<br/></li>
<li>&nbsp; &nbsp; LLVMBasicBlockRef b_find_start;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LLVMBasicBlockRef b_out;<br/></li>
<li>&nbsp; &nbsp; LLVMBasicBlockRef b_dead;<br/></li>
<li>&nbsp; &nbsp; LLVMBasicBlockRef *attcheckattnoblocks;<br/></li>
<li>&nbsp; &nbsp; LLVMBasicBlockRef *attstartblocks;<br/></li>
<li>&nbsp; &nbsp; LLVMBasicBlockRef *attisnullblocks;<br/></li>
<li>&nbsp; &nbsp; LLVMBasicBlockRef *attcheckalignblocks;<br/></li>
<li>&nbsp; &nbsp; LLVMBasicBlockRef *attalignblocks;<br/></li>
<li>&nbsp; &nbsp; LLVMBasicBlockRef *attstoreblocks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LLVMValueRef v_offp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LLVMValueRef v_tupdata_base;<br/></li>
<li>&nbsp; &nbsp; LLVMValueRef v_tts_values;<br/></li>
<li>&nbsp; &nbsp; LLVMValueRef v_tts_nulls;<br/></li>
<li>&nbsp; &nbsp; LLVMValueRef v_slotoffp;<br/></li>
<li>&nbsp; &nbsp; LLVMValueRef v_flagsp;<br/></li>
<li>&nbsp; &nbsp; LLVMValueRef v_nvalidp;<br/></li>
<li>&nbsp; &nbsp; LLVMValueRef v_nvalid;<br/></li>
<li>&nbsp; &nbsp; LLVMValueRef v_maxatt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LLVMValueRef v_slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LLVMValueRef v_tupleheaderp;<br/></li>
<li>&nbsp; &nbsp; LLVMValueRef v_tuplep;<br/></li>
<li>&nbsp; &nbsp; LLVMValueRef v_infomask1;<br/></li>
<li>&nbsp; &nbsp; LLVMValueRef v_infomask2;<br/></li>
<li>&nbsp; &nbsp; LLVMValueRef v_bits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LLVMValueRef v_hoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LLVMValueRef v_hasnulls;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* last column (0 indexed) guaranteed to exist */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; guaranteed_column_number = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* current known alignment */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; known_alignment = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if true, known_alignment describes definite offset of column */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; attguaranteedalign = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* virtual tuples never need deforming, so don't generate code */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ops == &amp;<a href="../../executor/execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* decline to JIT for slot types we don't know to handle */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ops != &amp;<a href="../../executor/execTuples.c.html#L85" title="executor/execTuples.c:85">TTSOpsHeapTuple</a> &amp;&amp; ops != &amp;<a href="../../executor/execTuples.c.html#L87" title="executor/execTuples.c:87">TTSOpsBufferHeapTuple</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ops != &amp;<a href="../../executor/execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mod = <a href="llvmjit.c.html#L334" title="jit/llvm/llvmjit.c:334">llvm_mutable_module</a>(context);<br/></li>
<li>&nbsp; &nbsp; lc = LLVMGetModuleContext(mod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; funcname = <a href="llvmjit.c.html#L359" title="jit/llvm/llvmjit.c:359">llvm_expand_funcname</a>(context, <span class="Constant">&quot;deform&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check which columns have to exist, so we don't have to check the row's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * natts unnecessarily.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (attnum = <span class="Constant">0</span>; attnum &lt; desc-&gt;natts; attnum++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(desc, attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the column is declared NOT NULL then it must be present in every<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple, unless there's a &quot;missing&quot; entry that could provide a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-NULL value for it. That in turn guarantees that the NULL bitmap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * - if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> NULLable columns - is at least long enough to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cover columns up to attnum.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Be paranoid and also check !attisdropped, even though the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * combination of attisdropped &amp;&amp; attnotnull combination shouldn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attnotnull &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !att-&gt;atthasmissing &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !att-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; guaranteed_column_number = attnum;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the signature and function */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMTypeRef param_types[<span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; param_types[<span class="Constant">0</span>] = l_ptr(<a href="llvmjit_types.c.html#L66" title="jit/llvm/llvmjit_types.c:66">StructTupleTableSlot</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; deform_sig = LLVMFunctionType(LLVMVoidTypeInContext(lc),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; param_types, lengthof(param_types), <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; v_deform_fn = LLVMAddFunction(mod, funcname, deform_sig);<br/></li>
<li>&nbsp; &nbsp; LLVMSetLinkage(v_deform_fn, LLVMInternalLinkage);<br/></li>
<li>&nbsp; &nbsp; LLVMSetParamAlignment(LLVMGetParam(v_deform_fn, <span class="Constant">0</span>), MAXIMUM_ALIGNOF);<br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit.c.html#L548" title="jit/llvm/llvmjit.c:548">llvm_copy_attributes</a>(<a href="llvmjit_types.c.html#L81" title="jit/llvm/llvmjit_types.c:81">AttributeTemplate</a>, v_deform_fn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; b_entry =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMAppendBasicBlockInContext(lc, v_deform_fn, <span class="Constant">&quot;entry&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; b_adjust_unavail_cols =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMAppendBasicBlockInContext(lc, v_deform_fn, <span class="Constant">&quot;adjust_unavail_cols&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; b_find_start =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMAppendBasicBlockInContext(lc, v_deform_fn, <span class="Constant">&quot;find_startblock&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; b_out =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMAppendBasicBlockInContext(lc, v_deform_fn, <span class="Constant">&quot;outblock&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; b_dead =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMAppendBasicBlockInContext(lc, v_deform_fn, <span class="Constant">&quot;deadblock&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; b = LLVMCreateBuilderInContext(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attcheckattnoblocks = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LLVMBasicBlockRef) * natts);<br/></li>
<li>&nbsp; &nbsp; attstartblocks = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LLVMBasicBlockRef) * natts);<br/></li>
<li>&nbsp; &nbsp; attisnullblocks = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LLVMBasicBlockRef) * natts);<br/></li>
<li>&nbsp; &nbsp; attcheckalignblocks = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LLVMBasicBlockRef) * natts);<br/></li>
<li>&nbsp; &nbsp; attalignblocks = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LLVMBasicBlockRef) * natts);<br/></li>
<li>&nbsp; &nbsp; attstoreblocks = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LLVMBasicBlockRef) * natts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; known_alignment = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LLVMPositionBuilderAtEnd(b, b_entry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* perform allocas first, llvm only converts those to registers */<br/></li>
<li></span>&nbsp; &nbsp; v_offp = LLVMBuildAlloca(b, <a href="llvmjit_types.c.html#L49" title="jit/llvm/llvmjit_types.c:49">TypeSizeT</a>, <span class="Constant">&quot;v_offp&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; v_slot = LLVMGetParam(v_deform_fn, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; v_tts_values =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; l_load_struct_gep(b, <a href="llvmjit_types.c.html#L66" title="jit/llvm/llvmjit_types.c:66">StructTupleTableSlot</a>, v_slot, FIELDNO_TUPLETABLESLOT_VALUES,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;tts_values&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; v_tts_nulls =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; l_load_struct_gep(b, <a href="llvmjit_types.c.html#L66" title="jit/llvm/llvmjit_types.c:66">StructTupleTableSlot</a>, v_slot, FIELDNO_TUPLETABLESLOT_ISNULL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;tts_ISNULL&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; v_flagsp = l_struct_gep(b, <a href="llvmjit_types.c.html#L66" title="jit/llvm/llvmjit_types.c:66">StructTupleTableSlot</a>, v_slot, FIELDNO_TUPLETABLESLOT_FLAGS, <span class="Constant">&quot;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; v_nvalidp = l_struct_gep(b, <a href="llvmjit_types.c.html#L66" title="jit/llvm/llvmjit_types.c:66">StructTupleTableSlot</a>, v_slot, FIELDNO_TUPLETABLESLOT_NVALID, <span class="Constant">&quot;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ops == &amp;<a href="../../executor/execTuples.c.html#L85" title="executor/execTuples.c:85">TTSOpsHeapTuple</a> || ops == &amp;<a href="../../executor/execTuples.c.html#L87" title="executor/execTuples.c:87">TTSOpsBufferHeapTuple</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_heapslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v_heapslot =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildBitCast(b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; v_slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; l_ptr(<a href="llvmjit_types.c.html#L67" title="jit/llvm/llvmjit_types.c:67">StructHeapTupleTableSlot</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;heapslot&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v_slotoffp = l_struct_gep(b, <a href="llvmjit_types.c.html#L67" title="jit/llvm/llvmjit_types.c:67">StructHeapTupleTableSlot</a>, v_heapslot, FIELDNO_HEAPTUPLETABLESLOT_OFF, <span class="Constant">&quot;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v_tupleheaderp =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l_load_struct_gep(b, <a href="llvmjit_types.c.html#L67" title="jit/llvm/llvmjit_types.c:67">StructHeapTupleTableSlot</a>, v_heapslot, FIELDNO_HEAPTUPLETABLESLOT_TUPLE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;tupleheader&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ops == &amp;<a href="../../executor/execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_minimalslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v_minimalslot =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildBitCast(b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; v_slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; l_ptr(<a href="llvmjit_types.c.html#L68" title="jit/llvm/llvmjit_types.c:68">StructMinimalTupleTableSlot</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;minimalslot&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v_slotoffp = l_struct_gep(b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="llvmjit_types.c.html#L68" title="jit/llvm/llvmjit_types.c:68">StructMinimalTupleTableSlot</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_minimalslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FIELDNO_MINIMALTUPLETABLESLOT_OFF, <span class="Constant">&quot;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v_tupleheaderp =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l_load_struct_gep(b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="llvmjit_types.c.html#L68" title="jit/llvm/llvmjit_types.c:68">StructMinimalTupleTableSlot</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_minimalslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FIELDNO_MINIMALTUPLETABLESLOT_TUPLE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;tupleheader&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* should've returned at the start of the function */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pg_unreachable();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; v_tuplep =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; l_load_struct_gep(b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="llvmjit_types.c.html#L63" title="jit/llvm/llvmjit_types.c:63">StructHeapTupleData</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_tupleheaderp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FIELDNO_HEAPTUPLEDATA_DATA,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;tuple&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; v_bits =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildBitCast(b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; l_struct_gep(b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="llvmjit_types.c.html#L64" title="jit/llvm/llvmjit_types.c:64">StructHeapTupleHeaderData</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_tuplep,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FIELDNO_HEAPTUPLEHEADERDATA_BITS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; l_ptr(LLVMInt8TypeInContext(lc)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;t_bits&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; v_infomask1 =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; l_load_struct_gep(b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="llvmjit_types.c.html#L64" title="jit/llvm/llvmjit_types.c:64">StructHeapTupleHeaderData</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_tuplep,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FIELDNO_HEAPTUPLEHEADERDATA_INFOMASK,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;infomask1&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; v_infomask2 =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; l_load_struct_gep(b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="llvmjit_types.c.html#L64" title="jit/llvm/llvmjit_types.c:64">StructHeapTupleHeaderData</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_tuplep, FIELDNO_HEAPTUPLEHEADERDATA_INFOMASK2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;infomask2&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* t_infomask &amp; HEAP_HASNULL */<br/></li>
<li></span>&nbsp; &nbsp; v_hasnulls =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildICmp(b, LLVMIntNE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildAnd(b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; l_int16_const(lc, HEAP_HASNULL),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; v_infomask1, <span class="Constant">&quot;&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l_int16_const(lc, <span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;hasnulls&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* t_infomask2 &amp; HEAP_NATTS_MASK */<br/></li>
<li></span>&nbsp; &nbsp; v_maxatt = LLVMBuildAnd(b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l_int16_const(lc, HEAP_NATTS_MASK),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_infomask2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;maxatt&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Need to zext, as getelementptr otherwise treats hoff as a signed 8bit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * integer, which'd yield a negative offset for t_hoff &gt; 127.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; v_hoff =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildZExt(b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l_load_struct_gep(b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="llvmjit_types.c.html#L64" title="jit/llvm/llvmjit_types.c:64">StructHeapTupleHeaderData</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_tuplep,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FIELDNO_HEAPTUPLEHEADERDATA_HOFF,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMInt32TypeInContext(lc), <span class="Constant">&quot;t_hoff&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; v_tupdata_base = l_gep(b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LLVMInt8TypeInContext(lc),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LLVMBuildBitCast(b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_tuplep,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l_ptr(LLVMInt8TypeInContext(lc)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;v_hoff, <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;v_tupdata_base&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Load tuple start offset from slot. Will be reset below in case there's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no existing deformed columns in slot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_off_start;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v_off_start = l_load(b, LLVMInt32TypeInContext(lc), v_slotoffp, <span class="Constant">&quot;v_slot_off&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v_off_start = LLVMBuildZExt(b, v_off_start, <a href="llvmjit_types.c.html#L49" title="jit/llvm/llvmjit_types.c:49">TypeSizeT</a>, <span class="Constant">&quot;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildStore(b, v_off_start, v_offp);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build the basic block for each attribute, need them as jump target */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (attnum = <span class="Constant">0</span>; attnum &lt; natts; attnum++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attcheckattnoblocks[attnum] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l_bb_append_v(v_deform_fn, <span class="Constant">&quot;block.attr.</span><span class="Special">%d</span><span class="Constant">.attcheckattno&quot;</span>, attnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attstartblocks[attnum] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l_bb_append_v(v_deform_fn, <span class="Constant">&quot;block.attr.</span><span class="Special">%d</span><span class="Constant">.start&quot;</span>, attnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attisnullblocks[attnum] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l_bb_append_v(v_deform_fn, <span class="Constant">&quot;block.attr.</span><span class="Special">%d</span><span class="Constant">.attisnull&quot;</span>, attnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attcheckalignblocks[attnum] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l_bb_append_v(v_deform_fn, <span class="Constant">&quot;block.attr.</span><span class="Special">%d</span><span class="Constant">.attcheckalign&quot;</span>, attnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attalignblocks[attnum] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l_bb_append_v(v_deform_fn, <span class="Constant">&quot;block.attr.</span><span class="Special">%d</span><span class="Constant">.align&quot;</span>, attnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attstoreblocks[attnum] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l_bb_append_v(v_deform_fn, <span class="Constant">&quot;block.attr.</span><span class="Special">%d</span><span class="Constant">.store&quot;</span>, attnum);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if it is guaranteed that all the desired attributes are available<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the tuple (but still possibly NULL), by dint of either the last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to-be-deformed column being NOT NULL, or subsequent ones not accessed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here being NOT NULL.&nbsp; If that's not guaranteed the tuple headers natt's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has to be checked, and missing attributes potentially have to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fetched (using <a href="../../executor/execTuples.c.html#L1955" title="executor/execTuples.c:1955">slot_getmissingattrs</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((natts - <span class="Constant">1</span>) &lt;= guaranteed_column_number)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> through unnecessary blocks */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildBr(b, b_adjust_unavail_cols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMPositionBuilderAtEnd(b, b_adjust_unavail_cols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildBr(b, b_find_start);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_params[<span class="Constant">3</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef f;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* branch if not all columns available */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildCondBr(b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildICmp(b, LLVMIntULT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_maxatt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l_int16_const(lc, natts),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b_adjust_unavail_cols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b_find_start);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if not, memset tts_isnull of relevant cols to true */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; LLVMPositionBuilderAtEnd(b, b_adjust_unavail_cols);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v_params[<span class="Constant">0</span>] = v_slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v_params[<span class="Constant">1</span>] = LLVMBuildZExt(b, v_maxatt, LLVMInt32TypeInContext(lc), <span class="Constant">&quot;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v_params[<span class="Constant">2</span>] = l_int32_const(lc, natts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; f = <a href="llvmjit.c.html#L496" title="jit/llvm/llvmjit.c:496">llvm_pg_func</a>(mod, <span class="Constant">&quot;<a href="../../executor/execTuples.c.html#L1955" title="executor/execTuples.c:1955">slot_getmissingattrs</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; l_call(b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="llvmjit_wrap.cpp.html#L40" title="jit/llvm/llvmjit_wrap.cpp:40">LLVMGetFunctionType</a>(f), f,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; v_params, lengthof(v_params), <span class="Constant">&quot;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildBr(b, b_find_start);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LLVMPositionBuilderAtEnd(b, b_find_start);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; v_nvalid = l_load(b, LLVMInt16TypeInContext(lc), v_nvalidp, <span class="Constant">&quot;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build switch to go from nvalid to the right startblock.&nbsp; Callers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * currently don't have the knowledge, but it'd be good for performance to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * avoid this check when it's known that the slot is empty (e.g. in scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nodes).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_switch = LLVMBuildSwitch(b, v_nvalid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b_dead, natts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (attnum = <span class="Constant">0</span>; attnum &lt; natts; attnum++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_attno = l_int16_const(lc, attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMAddCase(v_switch, v_attno, attcheckattnoblocks[attnum]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* jump from entry block to first block */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildBr(b, attcheckattnoblocks[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LLVMPositionBuilderAtEnd(b, b_dead);<br/></li>
<li>&nbsp; &nbsp; LLVMBuildUnreachable(b);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Iterate over each attribute that needs to be deformed, build code to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deform it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (attnum = <span class="Constant">0</span>; attnum &lt; natts; attnum++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(desc, attnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_incby;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; alignto;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef l_attno = l_int16_const(lc, attnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_attdatap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_resultp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* build block checking whether we did all the necessary attributes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; LLVMPositionBuilderAtEnd(b, attcheckattnoblocks[attnum]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is the first attribute, slot-&gt;tts_nvalid was 0. Therefore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * also reset offset to 0, it may be from a previous execution.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attnum == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildStore(b, l_sizet_const(<span class="Constant">0</span>), v_offp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Build check whether column is available (i.e. whether the tuple has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that many columns stored). We can avoid the branch if we know<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there's a subsequent NOT NULL column.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attnum &lt;= guaranteed_column_number)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildBr(b, attstartblocks[attnum]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_islast;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_islast = LLVMBuildICmp(b, LLVMIntUGE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; l_attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; v_maxatt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;heap_natts&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildCondBr(b, v_islast, b_out, attstartblocks[attnum]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMPositionBuilderAtEnd(b, attstartblocks[attnum]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for nulls if necessary. No need to take missing attributes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * into account, because if they're present the heaptuple's natts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would have indicated that a <a href="../../executor/execTuples.c.html#L1955" title="executor/execTuples.c:1955">slot_getmissingattrs</a>() is needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!att-&gt;attnotnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBasicBlockRef b_ifnotnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBasicBlockRef b_ifnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBasicBlockRef b_next;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_attisnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_nullbyteno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_nullbytemask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_nullbyte;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_nullbit;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b_ifnotnull = attcheckalignblocks[attnum];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b_ifnull = attisnullblocks[attnum];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attnum + <span class="Constant">1</span> == natts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b_next = b_out;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b_next = attcheckattnoblocks[attnum + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_nullbyteno = l_int32_const(lc, attnum &gt;&gt; <span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_nullbytemask = l_int8_const(lc, <span class="Constant">1</span> &lt;&lt; ((attnum) &amp; <span class="Constant">0x07</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_nullbyte = l_load_gep1(b, LLVMInt8TypeInContext(lc), v_bits, v_nullbyteno, <span class="Constant">&quot;attnullbyte&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_nullbit = LLVMBuildICmp(b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMIntEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildAnd(b, v_nullbyte, v_nullbytemask, <span class="Constant">&quot;&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l_int8_const(lc, <span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;attisnull&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_attisnull = LLVMBuildAnd(b, v_hasnulls, v_nullbit, <span class="Constant">&quot;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildCondBr(b, v_attisnull, b_ifnull, b_ifnotnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMPositionBuilderAtEnd(b, b_ifnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* store null-byte */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildStore(b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; l_int8_const(lc, <span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; l_gep(b, LLVMInt8TypeInContext(lc), v_tts_nulls, &amp;l_attno, <span class="Constant">1</span>, <span class="Constant">&quot;&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* store zero datum */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildStore(b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; l_sizet_const(<span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; l_gep(b, <a href="llvmjit_types.c.html#L49" title="jit/llvm/llvmjit_types.c:49">TypeSizeT</a>, v_tts_values, &amp;l_attno, <span class="Constant">1</span>, <span class="Constant">&quot;&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildBr(b, b_next);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attguaranteedalign = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildBr(b, attcheckalignblocks[attnum]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMPositionBuilderAtEnd(b, attisnullblocks[attnum]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildBr(b, attcheckalignblocks[attnum]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMPositionBuilderAtEnd(b, attcheckalignblocks[attnum]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* determine required alignment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attalign == TYPALIGN_INT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; alignto = ALIGNOF_INT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (att-&gt;attalign == TYPALIGN_CHAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; alignto = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (att-&gt;attalign == TYPALIGN_DOUBLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; alignto = ALIGNOF_DOUBLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (att-&gt;attalign == TYPALIGN_SHORT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; alignto = ALIGNOF_SHORT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unknown alignment&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; alignto = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Even if alignment is required, we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> doing it if provably<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unnecessary:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * - first column is guaranteed to be aligned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * - columns following a NOT NULL fixed width datum have known<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; alignment, can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> alignment computation if that known alignment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; is compatible with current column.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (alignto &gt; <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (known_alignment &lt; <span class="Constant">0</span> || known_alignment != TYPEALIGN(alignto, known_alignment)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When accessing a varlena field, we have to &quot;peek&quot; to see if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are looking at a pad byte or the first byte of a 1-byte-header<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * datum.&nbsp; A zero byte must be either a pad byte, or the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * byte of a correctly aligned 4-byte length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>; in either case,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we can align safely.&nbsp; A non-zero byte must be either a 1-byte<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>, or the first byte of a correctly aligned 4-byte<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>; in either case, we need not align.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attlen == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_possible_padbyte;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_ispad;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_off;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't know if short varlena or not */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attguaranteedalign = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_off = l_load(b, <a href="llvmjit_types.c.html#L49" title="jit/llvm/llvmjit_types.c:49">TypeSizeT</a>, v_offp, <span class="Constant">&quot;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_possible_padbyte =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l_load_gep1(b, LLVMInt8TypeInContext(lc), v_tupdata_base, v_off, <span class="Constant">&quot;padbyte&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_ispad =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildICmp(b, LLVMIntEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_possible_padbyte, l_int8_const(lc, <span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;ispadbyte&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildCondBr(b, v_ispad,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attalignblocks[attnum],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attstoreblocks[attnum]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildBr(b, attalignblocks[attnum]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMPositionBuilderAtEnd(b, attalignblocks[attnum]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translation of alignment code (cf TYPEALIGN()) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_off_aligned;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_off = l_load(b, <a href="llvmjit_types.c.html#L49" title="jit/llvm/llvmjit_types.c:49">TypeSizeT</a>, v_offp, <span class="Constant">&quot;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ((ALIGNVAL) - 1) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_alignval = l_sizet_const(alignto - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ((uintptr_t) (LEN) + ((ALIGNVAL) - 1)) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_lh = LLVMBuildAdd(b, v_off, v_alignval, <span class="Constant">&quot;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ~((uintptr_t) ((ALIGNVAL) - 1)) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_rh = l_sizet_const(~(alignto - <span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_off_aligned = LLVMBuildAnd(b, v_lh, v_rh, <span class="Constant">&quot;aligned_offset&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildStore(b, v_off_aligned, v_offp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As alignment either was unnecessary or has been performed, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> know the current alignment. This is only safe because this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * value isn't used for varlena and nullable columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (known_alignment &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(known_alignment != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; known_alignment = TYPEALIGN(alignto, known_alignment);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildBr(b, attstoreblocks[attnum]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMPositionBuilderAtEnd(b, attstoreblocks[attnum]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMPositionBuilderAtEnd(b, attcheckalignblocks[attnum]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildBr(b, attalignblocks[attnum]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMPositionBuilderAtEnd(b, attalignblocks[attnum]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildBr(b, attstoreblocks[attnum]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMPositionBuilderAtEnd(b, attstoreblocks[attnum]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Store the current offset if known to be constant. That allows LLVM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to generate better code. Without that LLVM can't figure out that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the offset might be constant due to the jumps for previously<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decoded columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attguaranteedalign)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(known_alignment &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildStore(b, l_sizet_const(known_alignment), v_offp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* compute what following columns are aligned to */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attlen &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can't guarantee <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> alignment after variable length field */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; known_alignment = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attguaranteedalign = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (att-&gt;attnotnull &amp;&amp; attguaranteedalign &amp;&amp; known_alignment &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the offset to the column was previously known, a NOT NULL &amp;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fixed-width column guarantees that alignment is just the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * previous alignment plus column width.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(att-&gt;attlen &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; known_alignment += att-&gt;attlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (att-&gt;attnotnull &amp;&amp; (att-&gt;attlen % alignto) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * After a NOT NULL fixed-width column with a length that is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multiple of its alignment requirement, we know the following<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column is aligned to at least the current column's alignment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(att-&gt;attlen &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; known_alignment = alignto;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(known_alignment &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attguaranteedalign = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; known_alignment = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attguaranteedalign = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* compute address to load data from */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_off = l_load(b, <a href="llvmjit_types.c.html#L49" title="jit/llvm/llvmjit_types.c:49">TypeSizeT</a>, v_offp, <span class="Constant">&quot;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_attdatap =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l_gep(b, LLVMInt8TypeInContext(lc), v_tupdata_base, &amp;v_off, <span class="Constant">1</span>, <span class="Constant">&quot;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* compute address to store value at */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; v_resultp = l_gep(b, <a href="llvmjit_types.c.html#L49" title="jit/llvm/llvmjit_types.c:49">TypeSizeT</a>, v_tts_values, &amp;l_attno, <span class="Constant">1</span>, <span class="Constant">&quot;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* store null-byte (false) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildStore(b, l_int8_const(lc, <span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; l_gep(b, <a href="llvmjit_types.c.html#L50" title="jit/llvm/llvmjit_types.c:50">TypeStorageBool</a>, v_tts_nulls, &amp;l_attno, <span class="Constant">1</span>, <span class="Constant">&quot;&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Store datum. For byval: datums copy the value, extend to Datum's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * width, and store. For byref types: store pointer to data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attbyval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_tmp_loaddata;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMTypeRef vartype = LLVMIntTypeInContext(lc, att-&gt;attlen * <span class="Constant">8</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMTypeRef vartypep = LLVMPointerType(vartype, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_tmp_loaddata =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildPointerCast(b, v_attdatap, vartypep, <span class="Constant">&quot;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_tmp_loaddata = l_load(b, vartype, v_tmp_loaddata, <span class="Constant">&quot;attr_byval&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_tmp_loaddata = LLVMBuildZExt(b, v_tmp_loaddata, <a href="llvmjit_types.c.html#L49" title="jit/llvm/llvmjit_types.c:49">TypeSizeT</a>, <span class="Constant">&quot;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildStore(b, v_tmp_loaddata, v_resultp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_tmp_loaddata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* store pointer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_tmp_loaddata =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildPtrToInt(b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_attdatap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="llvmjit_types.c.html#L49" title="jit/llvm/llvmjit_types.c:49">TypeSizeT</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;attr_ptr&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildStore(b, v_tmp_loaddata, v_resultp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* increment data pointer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attlen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_incby = l_sizet_const(att-&gt;attlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (att-&gt;attlen == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_incby = l_call(b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="llvmjit.c.html#L474" title="jit/llvm/llvmjit.c:474">llvm_pg_var_func_type</a>(<span class="Constant">&quot;<a href="../../access/common/heaptuple.c.html#L1594" title="access/common/heaptuple.c:1594">varsize_any</a>&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="llvmjit.c.html#L496" title="jit/llvm/llvmjit.c:496">llvm_pg_func</a>(mod, <span class="Constant">&quot;<a href="../../access/common/heaptuple.c.html#L1594" title="access/common/heaptuple.c:1594">varsize_any</a>&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;v_attdatap, <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="../../access/common/heaptuple.c.html#L1594" title="access/common/heaptuple.c:1594">varsize_any</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l_callsite_ro(v_incby);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l_callsite_alwaysinline(v_incby);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (att-&gt;attlen == -<span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_incby = l_call(b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="llvmjit.c.html#L474" title="jit/llvm/llvmjit.c:474">llvm_pg_var_func_type</a>(<span class="Constant">&quot;strlen&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="llvmjit.c.html#L496" title="jit/llvm/llvmjit.c:496">llvm_pg_func</a>(mod, <span class="Constant">&quot;strlen&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;v_attdatap, <span class="Constant">1</span>, <span class="Constant">&quot;strlen&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l_callsite_ro(v_incby);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* add 1 for NUL byte */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_incby = LLVMBuildAdd(b, v_incby, l_sizet_const(<span class="Constant">1</span>), <span class="Constant">&quot;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_incby = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* silence compiler */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attguaranteedalign)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(known_alignment &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildStore(b, l_sizet_const(known_alignment), v_offp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_off = l_load(b, <a href="llvmjit_types.c.html#L49" title="jit/llvm/llvmjit_types.c:49">TypeSizeT</a>, v_offp, <span class="Constant">&quot;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_off = LLVMBuildAdd(b, v_off, v_incby, <span class="Constant">&quot;increment_offset&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildStore(b, v_off, v_offp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * jump to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block, unless last possible column, or all desired<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (available) attributes have been fetched.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attnum + <span class="Constant">1</span> == natts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* jump out */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildBr(b, b_out);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildBr(b, attcheckattnoblocks[attnum + <span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build block that returns */<br/></li>
<li></span>&nbsp; &nbsp; LLVMPositionBuilderAtEnd(b, b_out);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_off = l_load(b, <a href="llvmjit_types.c.html#L49" title="jit/llvm/llvmjit_types.c:49">TypeSizeT</a>, v_offp, <span class="Constant">&quot;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildStore(b, l_int16_const(lc, natts), v_nvalidp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v_off = LLVMBuildTrunc(b, v_off, LLVMInt32TypeInContext(lc), <span class="Constant">&quot;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildStore(b, v_off, v_slotoffp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v_flags = l_load(b, LLVMInt16TypeInContext(lc), v_flagsp, <span class="Constant">&quot;tts_flags&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v_flags = LLVMBuildOr(b, v_flags, l_int16_const(lc, TTS_FLAG_SLOW), <span class="Constant">&quot;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildStore(b, v_flags, v_flagsp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMBuildRetVoid(b);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LLVMDisposeBuilder(b);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> v_deform_fn;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
