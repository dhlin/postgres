<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>jit/llvm/llvmjit_inline.cpp - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>jit/llvm/llvmjit_inline.cpp - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L99">inline_cost_decay_factor</a></li>
<li><a href="#L100">inline_initial_cost</a></li>
<li><a href="#L107">module_cache</a></li>
<li><a href="#L109">summary_cache</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L83">FunctionInlineState</a></li>
<li><a href="#L89">FunctionInlineState</a></li>
<li><a href="#L90">FunctionInlineStates</a></li>
<li><a href="#L96">ImportMapTy</a></li>
<li><a href="#L67">InlineSearchPath</a></li>
<li><a href="#L77">InlineWorkList</a></li>
<li><a href="#L72">InlineWorkListItem</a></li>
<li><a href="#L76">InlineWorkListItem</a></li>
<li><a href="#L106">ModuleCache</a></li>
<li><a href="#L108">SummaryCache</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L797">add_module_to_inline_search_path</a></li>
<li><a href="#L850">create_redirection_function</a></li>
<li><a href="#L568">function_inlinable</a></li>
<li><a href="#L511">function_references</a></li>
<li><a href="#L183">llvm_build_inline_plan</a></li>
<li><a href="#L377">llvm_execute_inline_plan</a></li>
<li><a href="#L167">llvm_inline</a></li>
<li><a href="#L156">llvm_inline_reset_caches</a></li>
<li><a href="#L768">llvm_load_summary</a></li>
<li><a href="#L481">load_module</a></li>
<li><a href="#L468">load_module_cached</a></li>
<li><a href="#L829">summaries_for_guid</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L46">Min</a></li>
<li><a href="#L598">hasFnAttr</a></li>
<li><a href="#L145">ilog</a></li>
<li><a href="#L147">ilog</a></li>
<li><a href="#L801">starts_with</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * llvmjit_inline.cpp<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Cross module inlining suitable for postgres' JIT<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The inliner iterates over external <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> referenced from the passed<br/></li>
<li></span><span class="Comment"> * module and attempts to inline those.&nbsp; It does so by utilizing pre-built<br/></li>
<li></span><span class="Comment"> * indexes over both postgres core code and extension modules.&nbsp; When a match<br/></li>
<li></span><span class="Comment"> * for an external function is found - not guaranteed! - the index will then<br/></li>
<li></span><span class="Comment"> * be used to judge their instruction count / inline worthiness. After doing<br/></li>
<li></span><span class="Comment"> * so for all external <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, all the referenced <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> (and<br/></li>
<li></span><span class="Comment"> * prerequisites) will be imported.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2016-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/lib/llvmjit/llvmjit_inline.cpp<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">extern</span> <span class="Constant">&quot;C&quot;<br/></li>
<li></span>{<br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;jit/llvmjit.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">extern</span> <span class="Constant">&quot;C&quot;<br/></li>
<li></span>{<br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/mman.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/types.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;common/string.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;llvm-c/Core.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm-c/BitReader.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Avoid macro clash with LLVM's C++ headers */<br/></li>
<li><a id="L46">&#x200c;</a></span><span class="PreProc">#undef <span class="linkable">Min</span><br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;llvm/ADT/SetVector.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm/ADT/StringSet.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm/ADT/StringMap.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm/Analysis/ModuleSummaryAnalysis.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm/Bitcode/BitcodeReader.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm/IR/Attributes.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm/IR/DebugInfo.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm/IR/IntrinsicInst.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm/IR/IRBuilder.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm/IR/ModuleSummaryIndex.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm/Linker/IRMover.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm/Support/ManagedStatic.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm/Support/MemoryBuffer.h&gt;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Type used to represent modules <a href="#L72" title="jit/llvm/llvmjit_inline.cpp:72">InlineWorkListItem</a>'s subject is searched for<br/></li>
<li></span><span class="Comment"> * in.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L67">&#x200c;</a></span><span class="Type">typedef</span> llvm::SmallVector&lt;llvm::ModuleSummaryIndex *, <span class="Constant">2</span>&gt; <span class="linkable">InlineSearchPath</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Item in queue of to-be-checked symbols and corresponding queue.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L72">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">InlineWorkListItem</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; llvm::StringRef symbolName;<br/></li>
<li>&nbsp; &nbsp; llvm::SmallVector&lt;llvm::ModuleSummaryIndex *, <span class="Constant">2</span>&gt; searchpath;<br/></li>
<li><a id="L76">&#x200c;</a>} <span class="linkable">InlineWorkListItem</span>;<br/></li>
<li><a id="L77">&#x200c;</a><span class="Type">typedef</span> llvm::SmallVector&lt;<a href="#L72" title="jit/llvm/llvmjit_inline.cpp:72">InlineWorkListItem</a>, <span class="Constant">128</span>&gt; <span class="linkable">InlineWorkList</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Information about symbols processed during inlining. Used to prevent<br/></li>
<li></span><span class="Comment"> * repeated searches and provide additional information.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L83">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">FunctionInlineState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span> costLimit;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> processed;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> inlined;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> allowReconsidering;<br/></li>
<li><a id="L89">&#x200c;</a>} <span class="linkable">FunctionInlineState</span>;<br/></li>
<li><a id="L90">&#x200c;</a><span class="Type">typedef</span> llvm::StringMap&lt;<a href="#L83" title="jit/llvm/llvmjit_inline.cpp:83">FunctionInlineState</a>&gt; <span class="linkable">FunctionInlineStates</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Map of modules that should be inlined, with a list of the to-be inlined<br/></li>
<li></span><span class="Comment"> * symbols.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L96">&#x200c;</a></span><span class="Type">typedef</span> llvm::StringMap&lt;llvm::StringSet&lt;&gt; &gt; <span class="linkable">ImportMapTy</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L99">&#x200c;</a><span class="Type">const</span> <span class="Type">float</span> <span class="linkable">inline_cost_decay_factor</span> = <span class="Constant">0.5</span>;<br/></li>
<li><a id="L100">&#x200c;</a><span class="Type">const</span> <span class="Type">int</span> <span class="linkable">inline_initial_cost</span> = <span class="Constant">150</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * These are managed statics so LLVM knows to deallocate them during an<br/></li>
<li></span><span class="Comment"> * LLVMShutdown(), rather than after (which'd cause crashes).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L106">&#x200c;</a></span><span class="Type">typedef</span> llvm::StringMap&lt;std::unique_ptr&lt;llvm::Module&gt; &gt; <span class="linkable">ModuleCache</span>;<br/></li>
<li><a id="L107">&#x200c;</a>llvm::ManagedStatic&lt;<a href="#L106" title="jit/llvm/llvmjit_inline.cpp:106">ModuleCache</a>&gt; <span class="linkable">module_cache</span>;<br/></li>
<li><a id="L108">&#x200c;</a><span class="Type">typedef</span> llvm::StringMap&lt;std::unique_ptr&lt;llvm::ModuleSummaryIndex&gt; &gt; <span class="linkable">SummaryCache</span>;<br/></li>
<li><a id="L109">&#x200c;</a>llvm::ManagedStatic&lt;<a href="#L108" title="jit/llvm/llvmjit_inline.cpp:108">SummaryCache</a>&gt; <span class="linkable">summary_cache</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> std::unique_ptr&lt;<a href="#L96" title="jit/llvm/llvmjit_inline.cpp:96">ImportMapTy</a>&gt; <a href="#L183" title="jit/llvm/llvmjit_inline.cpp:183">llvm_build_inline_plan</a>(LLVMContextRef lc, llvm::Module *mod);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L377" title="jit/llvm/llvmjit_inline.cpp:377">llvm_execute_inline_plan</a>(llvm::Module *mod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L96" title="jit/llvm/llvmjit_inline.cpp:96">ImportMapTy</a> *globalsToInline);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> llvm::Module* <a href="#L468" title="jit/llvm/llvmjit_inline.cpp:468">load_module_cached</a>(LLVMContextRef c, llvm::StringRef modPath);<br/></li>
<li><span class="Type">static</span> std::unique_ptr&lt;llvm::Module&gt; <a href="#L481" title="jit/llvm/llvmjit_inline.cpp:481">load_module</a>(LLVMContextRef c, llvm::StringRef Identifier);<br/></li>
<li><span class="Type">static</span> std::unique_ptr&lt;llvm::ModuleSummaryIndex&gt; <a href="#L768" title="jit/llvm/llvmjit_inline.cpp:768">llvm_load_summary</a>(llvm::StringRef path);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> llvm::Function* <a href="#L850" title="jit/llvm/llvmjit_inline.cpp:850">create_redirection_function</a>(std::unique_ptr&lt;llvm::Module&gt; &amp;importMod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; llvm::Function *F,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; llvm::StringRef Name);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L568" title="jit/llvm/llvmjit_inline.cpp:568">function_inlinable</a>(llvm::Function &amp;F,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> threshold,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L90" title="jit/llvm/llvmjit_inline.cpp:90">FunctionInlineStates</a> &amp;functionState,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L77" title="jit/llvm/llvmjit_inline.cpp:77">InlineWorkList</a> &amp;worklist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L67" title="jit/llvm/llvmjit_inline.cpp:67">InlineSearchPath</a> &amp;searchpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; llvm::SmallPtrSet&lt;<span class="Type">const</span> llvm::Function *, <span class="Constant">8</span>&gt; &amp;visitedFunctions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> &amp;running_instcount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; llvm::StringSet&lt;&gt; &amp;importVars);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L511" title="jit/llvm/llvmjit_inline.cpp:511">function_references</a>(llvm::Function &amp;F,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> &amp;running_instcount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; llvm::SmallPtrSet&lt;llvm::GlobalVariable *, <span class="Constant">8</span>&gt; &amp;referencedVars,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; llvm::SmallPtrSet&lt;llvm::Function *, <span class="Constant">8</span>&gt; &amp;referencedFunctions);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L797" title="jit/llvm/llvmjit_inline.cpp:797">add_module_to_inline_search_path</a>(<a href="#L67" title="jit/llvm/llvmjit_inline.cpp:67">InlineSearchPath</a>&amp; path, llvm::StringRef modpath);<br/></li>
<li><span class="Type">static</span> llvm::SmallVector&lt;llvm::GlobalValueSummary *, <span class="Constant">1</span>&gt;<br/></li>
<li><a href="#L829" title="jit/llvm/llvmjit_inline.cpp:829">summaries_for_guid</a>(<span class="Type">const</span> <a href="#L67" title="jit/llvm/llvmjit_inline.cpp:67">InlineSearchPath</a>&amp; path, llvm::GlobalValue::GUID guid);<br/></li>
<li><br/></li>
<li><span class="Comment">/* verbose debugging for inliner development */<br/></li>
<li></span><span class="Comment">/* #define INLINE_DEBUG */<br/></li>
<li></span><span class="PreProc">#ifdef INLINE_DEBUG<br/></li>
<li><a id="L145">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ilog</span>&nbsp; &nbsp; &nbsp; &nbsp; elog<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li><a id="L147">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ilog</span>(...)&nbsp; &nbsp; (</span><span class="Type">void</span><span class="PreProc">) </span><span class="Constant">0<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reset inlining related state. This needs to be called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the currently<br/></li>
<li></span><span class="Comment"> * used LLVMContextRef is disposed (and a new one create), otherwise we would<br/></li>
<li></span><span class="Comment"> * have dangling references to deleted modules.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L156">&#x200c;</a></span><span class="linkable">llvm_inline_reset_caches</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="jit/llvm/llvmjit_inline.cpp:107">module_cache</a>-&gt;clear();<br/></li>
<li>&nbsp; &nbsp; <a href="#L109" title="jit/llvm/llvmjit_inline.cpp:109">summary_cache</a>-&gt;clear();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform inlining of external function references in M based on a simple<br/></li>
<li></span><span class="Comment"> * cost based analysis.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L167">&#x200c;</a></span><span class="linkable">llvm_inline</span>(LLVMModuleRef M)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LLVMContextRef lc = LLVMGetModuleContext(M);<br/></li>
<li>&nbsp; &nbsp; llvm::Module *mod = llvm::unwrap(M);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; std::unique_ptr&lt;<a href="#L96" title="jit/llvm/llvmjit_inline.cpp:96">ImportMapTy</a>&gt; globalsToInline = <a href="#L183" title="jit/llvm/llvmjit_inline.cpp:183">llvm_build_inline_plan</a>(lc, mod);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!globalsToInline)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L377" title="jit/llvm/llvmjit_inline.cpp:377">llvm_execute_inline_plan</a>(mod, globalsToInline.get());<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Build information necessary for inlining external function references in<br/></li>
<li></span><span class="Comment"> * mod.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> std::unique_ptr&lt;<a href="#L96" title="jit/llvm/llvmjit_inline.cpp:96">ImportMapTy</a>&gt;<br/></li>
<li><a id="L183">&#x200c;</a><span class="linkable">llvm_build_inline_plan</span>(LLVMContextRef lc, llvm::Module *mod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; std::unique_ptr&lt;<a href="#L96" title="jit/llvm/llvmjit_inline.cpp:96">ImportMapTy</a>&gt; globalsToInline(<span class="Statement">new</span> <a href="#L96" title="jit/llvm/llvmjit_inline.cpp:96">ImportMapTy</a>());<br/></li>
<li>&nbsp; &nbsp; <a href="#L90" title="jit/llvm/llvmjit_inline.cpp:90">FunctionInlineStates</a> functionStates;<br/></li>
<li>&nbsp; &nbsp; <a href="#L77" title="jit/llvm/llvmjit_inline.cpp:77">InlineWorkList</a> worklist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L67" title="jit/llvm/llvmjit_inline.cpp:67">InlineSearchPath</a> defaultSearchPath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* attempt to add module to search path */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L797" title="jit/llvm/llvmjit_inline.cpp:797">add_module_to_inline_search_path</a>(defaultSearchPath, <span class="Constant">&quot;$libdir/postgres&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if postgres isn't available, no point continuing */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (defaultSearchPath.empty())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">nullptr</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start inlining with current references to external <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> by putting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them on the inlining worklist. If, during inlining of those, new extern<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> need to be inlined, they'll also be put there, with a <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * priority.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">const</span> llvm::Function &amp;funcDecl : mod-&gt;<a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L72" title="jit/llvm/llvmjit_inline.cpp:72">InlineWorkListItem</a> item = {};<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L83" title="jit/llvm/llvmjit_inline.cpp:83">FunctionInlineState</a> inlineState = {};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* already has a definition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!funcDecl.isDeclaration())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* llvm provides implementation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (funcDecl.isIntrinsic())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; item.symbolName = funcDecl.getName();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; item.searchpath = defaultSearchPath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; worklist.push_back(item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inlineState.costLimit = <a href="#L100" title="jit/llvm/llvmjit_inline.cpp:100">inline_initial_cost</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inlineState.processed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inlineState.inlined = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inlineState.allowReconsidering = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; functionStates[funcDecl.getName()] = inlineState;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Iterate over pending worklist items, look them up in index, check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whether they should be inlined.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (!worklist.empty())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L72" title="jit/llvm/llvmjit_inline.cpp:72">InlineWorkListItem</a> item = worklist.pop_back_val();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; llvm::StringRef symbolName = item.symbolName;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> *cmodname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> *cfuncname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L83" title="jit/llvm/llvmjit_inline.cpp:83">FunctionInlineState</a> &amp;inlineState = functionStates[symbolName];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; llvm::GlobalValue::GUID funcGUID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="llvmjit.c.html#L1144" title="jit/llvm/llvmjit.c:1144">llvm_split_symbol_name</a>(symbolName.data(), &amp;cmodname, &amp;cfuncname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcGUID = llvm::GlobalValue::getGUID(cfuncname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* already processed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (inlineState.processed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cmodname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L797" title="jit/llvm/llvmjit_inline.cpp:797">add_module_to_inline_search_path</a>(item.searchpath, cmodname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Iterate over all known definitions of function, via the index. Then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * look up module(s), check if function actually is defined (there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could be <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> conflicts).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">const</span> <span class="Type">auto</span> &amp;gvs : <a href="#L829" title="jit/llvm/llvmjit_inline.cpp:829">summaries_for_guid</a>(item.searchpath, funcGUID))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> llvm::FunctionSummary *fs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; llvm::StringRef modPath = gvs-&gt;modulePath();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; llvm::Module *defMod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; llvm::Function *funcDef;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fs = llvm::cast&lt;llvm::FunctionSummary&gt;(gvs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (gvs-&gt;notEligibleToImport())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L145" title="jit/llvm/llvmjit_inline.cpp:145">ilog</a>(DEBUG1, <span class="Constant">&quot;ineligibile to import </span><span class="Special">%s</span><span class="Constant"> due to summary&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; symbolName.data());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((<span class="Type">int</span>) fs-&gt;instCount() &gt; inlineState.costLimit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L145" title="jit/llvm/llvmjit_inline.cpp:145">ilog</a>(DEBUG1, <span class="Constant">&quot;ineligibile to import </span><span class="Special">%s</span><span class="Constant"> due to early threshold: </span><span class="Special">%u</span><span class="Constant"> vs </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; symbolName.data(), fs-&gt;instCount(), inlineState.costLimit);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inlineState.allowReconsidering = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defMod = <a href="#L468" title="jit/llvm/llvmjit_inline.cpp:468">load_module_cached</a>(lc, modPath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (defMod-&gt;materializeMetadata())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;failed to materialize metadata&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; funcDef = defMod-&gt;getFunction(cfuncname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This can happen e.g. in case of a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> collision of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function's name.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!funcDef)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (funcDef-&gt;materialize())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;failed to materialize metadata&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!funcDef-&gt;isDeclaration());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(funcDef-&gt;hasExternalLinkage());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; llvm::StringSet&lt;&gt; importVars;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; llvm::SmallPtrSet&lt;<span class="Type">const</span> llvm::Function *, <span class="Constant">8</span>&gt; visitedFunctions;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> running_instcount = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check whether function, and objects it depends on, are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inlinable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L568" title="jit/llvm/llvmjit_inline.cpp:568">function_inlinable</a>(*funcDef,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inlineState.costLimit,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; functionStates,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; worklist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; item.searchpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; visitedFunctions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; running_instcount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; importVars))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check whether function and all its dependencies are too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * big. Dependencies already counted for other <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will get inlined are not counted again. While this make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * things somewhat order dependent, I can't quite see a point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in a different behaviour.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (running_instcount &gt; inlineState.costLimit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L145" title="jit/llvm/llvmjit_inline.cpp:145">ilog</a>(DEBUG1, <span class="Constant">&quot;skipping inlining of </span><span class="Special">%s</span><span class="Constant"> due to late threshold </span><span class="Special">%d</span><span class="Constant"> vs </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; symbolName.data(), running_instcount, inlineState.costLimit);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inlineState.allowReconsidering = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L145" title="jit/llvm/llvmjit_inline.cpp:145">ilog</a>(DEBUG1, <span class="Constant">&quot;inline top function </span><span class="Special">%s</span><span class="Constant"> total_instcount: </span><span class="Special">%d</span><span class="Constant">, partial: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; symbolName.data(), running_instcount, fs-&gt;instCount());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* import referenced function itself */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; importVars.insert(symbolName);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; llvm::StringSet&lt;&gt; &amp;modGlobalsToInline = (*globalsToInline)[modPath];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">auto</span>&amp; importVar : importVars)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modGlobalsToInline.insert(importVar.first());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(modGlobalsToInline.size() &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mark function as inlined */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inlineState.inlined = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Found definition to inline, don't look for further<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * potential definitions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L145" title="jit/llvm/llvmjit_inline.cpp:145">ilog</a>(DEBUG1, <span class="Constant">&quot;had to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> inlining </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; symbolName.data());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It's possible there's another definition that's inlinable. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Signal that we're done with symbol, whether successful (inlined =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * true above) or not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; inlineState.processed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> globalsToInline;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform the actual inlining of external <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> (and their dependencies)<br/></li>
<li></span><span class="Comment"> * into mod.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L377">&#x200c;</a></span><span class="linkable">llvm_execute_inline_plan</span>(llvm::Module *mod, <a href="#L96" title="jit/llvm/llvmjit_inline.cpp:96">ImportMapTy</a> *globalsToInline)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; llvm::IRMover Mover(*mod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">const</span> <span class="Type">auto</span>&amp; toInline : *globalsToInline)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> llvm::StringRef&amp; modPath = toInline.first();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> llvm::StringSet&lt;&gt;&amp; modGlobalsToInline = toInline.second;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; llvm::SetVector&lt;llvm::GlobalValue *&gt; GlobalsToImport;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L107" title="jit/llvm/llvmjit_inline.cpp:107">module_cache</a>-&gt;count(modPath));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; std::unique_ptr&lt;llvm::Module&gt; importMod(std::move((*<a href="#L107" title="jit/llvm/llvmjit_inline.cpp:107">module_cache</a>)[modPath]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="jit/llvm/llvmjit_inline.cpp:107">module_cache</a>-&gt;erase(modPath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (modGlobalsToInline.empty())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">auto</span> &amp;glob: modGlobalsToInline)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; llvm::StringRef SymbolName = glob.first();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> *modname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> *funcname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="llvmjit.c.html#L1144" title="jit/llvm/llvmjit.c:1144">llvm_split_symbol_name</a>(SymbolName.data(), &amp;modname, &amp;funcname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; llvm::GlobalValue *valueToImport = importMod-&gt;getNamedValue(funcname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!valueToImport)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;didn't refind value </span><span class="Special">%s</span><span class="Constant"> to import&quot;</span>, SymbolName.data());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> (global <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> are only inlined if already static),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mark imported variables as being clones from other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>. That a) avoids symbol conflicts b) allows the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * optimizer to perform inlining.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (llvm::isa&lt;llvm::Function&gt;(valueToImport))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; llvm::Function *F = llvm::dyn_cast&lt;llvm::Function&gt;(valueToImport);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">typedef</span> llvm::GlobalValue::LinkageTypes LinkageTypes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Per-function info isn't necessarily stripped yet, as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * module is lazy-loaded when stripped above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; llvm::stripDebugInfo(*F);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the to-be-imported function is one referenced including<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * its module name, create a tiny inline function that just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * forwards the call. One might think a GlobalAlias would do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the trick, but a) IRMover doesn't override a declaration<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with an alias pointing to a definition (instead renaming<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it), b) Aliases can't be AvailableExternally.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (modname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; llvm::Function *AF;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AF = <a href="#L850" title="jit/llvm/llvmjit_inline.cpp:850">create_redirection_function</a>(importMod, F, SymbolName);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GlobalsToImport.insert(AF);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; llvm::stripDebugInfo(*AF);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (valueToImport-&gt;hasExternalLinkage())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valueToImport-&gt;setLinkage(LinkageTypes::AvailableExternallyLinkage);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GlobalsToImport.insert(valueToImport);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L145" title="jit/llvm/llvmjit_inline.cpp:145">ilog</a>(DEBUG1, <span class="Constant">&quot;performing import of </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; modPath.data(), SymbolName.data());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (Mover.move(std::move(importMod), GlobalsToImport.getArrayRef(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [](llvm::GlobalValue &amp;, llvm::IRMover::ValueAdder) {},<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/*IsPerformingImport=*/</span><span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;function import failed with linker error&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return a module identified by modPath, caching it in memory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that such a module may *not* be modified without copying, otherwise<br/></li>
<li></span><span class="Comment"> * the cache state would get corrupted.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> llvm::Module*<br/></li>
<li><a id="L468">&#x200c;</a><span class="linkable">load_module_cached</span>(LLVMContextRef lc, llvm::StringRef modPath)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">auto</span> it = <a href="#L107" title="jit/llvm/llvmjit_inline.cpp:107">module_cache</a>-&gt;<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a>(modPath);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (it == <a href="#L107" title="jit/llvm/llvmjit_inline.cpp:107">module_cache</a>-&gt;end())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; it = <a href="#L107" title="jit/llvm/llvmjit_inline.cpp:107">module_cache</a>-&gt;insert(<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; std::make_pair(modPath, <a href="#L481" title="jit/llvm/llvmjit_inline.cpp:481">load_module</a>(lc, modPath))).first;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> it-&gt;second.get();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> std::unique_ptr&lt;llvm::Module&gt;<br/></li>
<li><a id="L481">&#x200c;</a><span class="linkable">load_module</span>(LLVMContextRef lc, llvm::StringRef Identifier)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LLVMMemoryBufferRef buf;<br/></li>
<li>&nbsp; &nbsp; LLVMModuleRef mod;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span> path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span> *msg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(path, MAXPGPATH,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/bitcode/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="../../utils/init/globals.c.html#L79" title="utils/init/globals.c:79">pkglib_path</a>, Identifier.data());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (LLVMCreateMemoryBufferWithContentsOfFile(path, &amp;buf, &amp;msg))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;failed to open bitcode file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path, msg);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (LLVMGetBitcodeModuleInContext2(lc, buf, &amp;mod))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;failed to <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> bitcode in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Currently there's no use in more detailed debug info for JITed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * code. Until that changes, not much point in wasting memory and cycles<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on processing debuginfo.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; llvm::StripDebugInfo(*llvm::unwrap(mod));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> std::unique_ptr&lt;llvm::Module&gt;(llvm::unwrap(mod));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute list of referenced variables, <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> and the instruction count<br/></li>
<li></span><span class="Comment"> * for a function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L511">&#x200c;</a></span><span class="linkable">function_references</span>(llvm::Function &amp;F,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> &amp;running_instcount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; llvm::SmallPtrSet&lt;llvm::GlobalVariable *, <span class="Constant">8</span>&gt; &amp;referencedVars,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; llvm::SmallPtrSet&lt;llvm::Function *, <span class="Constant">8</span>&gt; &amp;referencedFunctions)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; llvm::SmallPtrSet&lt;<span class="Type">const</span> llvm::User *, <span class="Constant">32</span>&gt; Visited;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (llvm::BasicBlock &amp;BB : F)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (llvm::Instruction &amp;I : BB)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (llvm::isa&lt;llvm::DbgInfoIntrinsic&gt;(I))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; llvm::SmallVector&lt;llvm::User *, <span class="Constant">8</span>&gt; Worklist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Worklist.push_back(&amp;I);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; running_instcount++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (!Worklist.empty()) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; llvm::User *U = Worklist.pop_back_val();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* visited <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!Visited.insert(U).second)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">auto</span> &amp;OI : U-&gt;operands()) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; llvm::User *Operand = llvm::dyn_cast&lt;llvm::User&gt;(OI);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!Operand)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (llvm::isa&lt;llvm::BlockAddress&gt;(Operand))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<span class="Type">auto</span> *GV = llvm::dyn_cast&lt;llvm::GlobalVariable&gt;(Operand)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; referencedVars.insert(GV);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GV-&gt;hasInitializer())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Worklist.push_back(GV-&gt;getInitializer());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<span class="Type">auto</span> *CF = llvm::dyn_cast&lt;llvm::Function&gt;(Operand)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; referencedFunctions.insert(CF);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Worklist.push_back(Operand);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether function F is inlinable and, if so, what globals need to be<br/></li>
<li></span><span class="Comment"> * imported.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * References to external <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> from, potentially recursively, inlined<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are added to the passed in worklist.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L568">&#x200c;</a></span><span class="linkable">function_inlinable</span>(llvm::Function &amp;F,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> threshold,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L90" title="jit/llvm/llvmjit_inline.cpp:90">FunctionInlineStates</a> &amp;functionStates,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L77" title="jit/llvm/llvmjit_inline.cpp:77">InlineWorkList</a> &amp;worklist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L67" title="jit/llvm/llvmjit_inline.cpp:67">InlineSearchPath</a> &amp;searchpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; llvm::SmallPtrSet&lt;<span class="Type">const</span> llvm::Function *, <span class="Constant">8</span>&gt; &amp;visitedFunctions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> &amp;running_instcount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; llvm::StringSet&lt;&gt; &amp;importVars)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span> subThreshold = threshold * <a href="#L99" title="jit/llvm/llvmjit_inline.cpp:99">inline_cost_decay_factor</a>;<br/></li>
<li>&nbsp; &nbsp; llvm::SmallPtrSet&lt;llvm::GlobalVariable *, <span class="Constant">8</span>&gt; referencedVars;<br/></li>
<li>&nbsp; &nbsp; llvm::SmallPtrSet&lt;llvm::Function *, <span class="Constant">8</span>&gt; referencedFunctions;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* can't rely on what may be inlined */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (F.isInterposable())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Can't rely on function being present. Alternatively we could create a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * static version of these <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (F.hasAvailableExternallyLinkage())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L145" title="jit/llvm/llvmjit_inline.cpp:145">ilog</a>(DEBUG1, <span class="Constant">&quot;checking inlinability of </span><span class="Special">%s</span><span class="Constant">&quot;</span>, F.getName().data());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (F.materialize())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;failed to materialize metadata&quot;</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#if LLVM_VERSION_MAJOR &lt; </span><span class="Constant">14<br/></li>
<li><a id="L598">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">hasFnAttr</span> hasFnAttribute<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (F.getAttributes().<a href="#L598" title="jit/llvm/llvmjit_inline.cpp:598">hasFnAttr</a>(llvm::Attribute::NoInline))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L145" title="jit/llvm/llvmjit_inline.cpp:145">ilog</a>(DEBUG1, <span class="Constant">&quot;ineligibile to import </span><span class="Special">%s</span><span class="Constant"> due to noinline&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; F.getName().data());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L511" title="jit/llvm/llvmjit_inline.cpp:511">function_references</a>(F, running_instcount, referencedVars, referencedFunctions);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (llvm::GlobalVariable* rv: referencedVars)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rv-&gt;materialize())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;failed to materialize metadata&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't inline <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that access thread local variables.&nbsp; That<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doesn't work on current LLVM releases (but might in future).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rv-&gt;isThreadLocal())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L145" title="jit/llvm/llvmjit_inline.cpp:145">ilog</a>(DEBUG1, <span class="Constant">&quot;cannot inline </span><span class="Special">%s</span><span class="Constant"> due to thread-local variable </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; F.getName().data(), rv-&gt;getName().data());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Never want to inline externally visible <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>, cheap enough to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reference.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rv-&gt;hasExternalLinkage() || rv-&gt;hasAvailableExternallyLinkage())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If variable is file-local, we need to inline it, to be able to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inline the function itself. Can't do that if the variable can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * modified, because they'd obviously get out of sync.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: Currently not a problem, but there'd be problems with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nontrivial initializers if they were allowed for postgres.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rv-&gt;isConstant())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L145" title="jit/llvm/llvmjit_inline.cpp:145">ilog</a>(DEBUG1, <span class="Constant">&quot;cannot inline </span><span class="Special">%s</span><span class="Constant"> due to uncloneable variable </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; F.getName().data(), rv-&gt;getName().data());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L145" title="jit/llvm/llvmjit_inline.cpp:145">ilog</a>(DEBUG1, <span class="Constant">&quot;memorizing global var </span><span class="Special">%s</span><span class="Constant"> linkage </span><span class="Special">%d</span><span class="Constant"> for inlining&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rv-&gt;getName().data(), (<span class="Type">int</span>)rv-&gt;getLinkage());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; importVars.insert(rv-&gt;getName());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* small cost attributed to each cloned global */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; running_instcount += <span class="Constant">5</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; visitedFunctions.insert(&amp;F);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check referenced <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>. Check whether used static ones are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inlinable, and remember external ones for inlining.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (llvm::Function* referencedFunction: referencedFunctions)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; llvm::StringSet&lt;&gt; recImportVars;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (referencedFunction-&gt;materialize())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;failed to materialize metadata&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (referencedFunction-&gt;isIntrinsic())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if already visited <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>, otherwise remember */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!visitedFunctions.insert(referencedFunction).second)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't inline external <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> directly here, instead we put<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * them on the worklist if appropriate and check them from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L183" title="jit/llvm/llvmjit_inline.cpp:183">llvm_build_inline_plan</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (referencedFunction-&gt;hasExternalLinkage())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; llvm::StringRef funcName = referencedFunction-&gt;getName();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't bother checking for inlining if remaining cost budget is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * very small.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subThreshold &lt; <span class="Constant">5</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">auto</span> it = functionStates.<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a>(funcName);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (it == functionStates.end())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L83" title="jit/llvm/llvmjit_inline.cpp:83">FunctionInlineState</a> inlineState;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inlineState.costLimit = subThreshold;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inlineState.processed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inlineState.inlined = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inlineState.allowReconsidering = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; functionStates[funcName] = inlineState;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worklist.push_back({funcName, searchpath});<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L145" title="jit/llvm/llvmjit_inline.cpp:145">ilog</a>(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;considering extern function </span><span class="Special">%s</span><span class="Constant"> at </span><span class="Special">%d</span><span class="Constant"> for inlining&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; funcName.data(), subThreshold);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!it-&gt;second.inlined &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (!it-&gt;second.processed || it-&gt;second.allowReconsidering) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; it-&gt;second.costLimit &lt; subThreshold)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update inlining threshold if higher. Need to re-queue<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to be processed if already processed with <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * threshold.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (it-&gt;second.processed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L145" title="jit/llvm/llvmjit_inline.cpp:145">ilog</a>(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;reconsidering extern function </span><span class="Special">%s</span><span class="Constant"> at </span><span class="Special">%d</span><span class="Constant"> for inlining, increasing from </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; funcName.data(), subThreshold, it-&gt;second.costLimit);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; it-&gt;second.processed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; it-&gt;second.allowReconsidering = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worklist.push_back({funcName, searchpath});<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; it-&gt;second.costLimit = subThreshold;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can't rely on what may be inlined */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (referencedFunction-&gt;isInterposable())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L568" title="jit/llvm/llvmjit_inline.cpp:568">function_inlinable</a>(*referencedFunction,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subThreshold,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; functionStates,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worklist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; searchpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; visitedFunctions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; running_instcount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recImportVars))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L145" title="jit/llvm/llvmjit_inline.cpp:145">ilog</a>(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;cannot inline </span><span class="Special">%s</span><span class="Constant"> due to required function </span><span class="Special">%s</span><span class="Constant"> not being inlinable&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; F.getName().data(), referencedFunction-&gt;getName().data());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* import referenced function itself */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; importVars.insert(referencedFunction-&gt;getName());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* import referenced function and its dependents */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">auto</span>&amp; recImportVar : recImportVars)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; importVars.insert(recImportVar.first());<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Attempt to load module summary located at path. Return empty pointer when<br/></li>
<li></span><span class="Comment"> * loading fails.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> std::unique_ptr&lt;llvm::ModuleSummaryIndex&gt;<br/></li>
<li><a id="L768">&#x200c;</a><span class="linkable">llvm_load_summary</span>(llvm::StringRef path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; llvm::ErrorOr&lt;std::unique_ptr&lt;llvm::MemoryBuffer&gt; &gt; MBOrErr =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; llvm::MemoryBuffer::getFile(path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (std::error_code EC = MBOrErr.getError())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L145" title="jit/llvm/llvmjit_inline.cpp:145">ilog</a>(DEBUG1, <span class="Constant">&quot;failed to open </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, path.data(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EC.message().c_str());<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; llvm::MemoryBufferRef ref(*MBOrErr.get().get());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; llvm::Expected&lt;std::unique_ptr&lt;llvm::ModuleSummaryIndex&gt; &gt; IndexOrErr =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; llvm::getModuleSummaryIndex(ref);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IndexOrErr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> std::move(IndexOrErr.get());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;failed to load summary </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path.data(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; toString(IndexOrErr.takeError()).c_str());<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">nullptr</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Attempt to add modpath to the search path.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L797">&#x200c;</a></span><span class="linkable">add_module_to_inline_search_path</span>(<a href="#L67" title="jit/llvm/llvmjit_inline.cpp:67">InlineSearchPath</a>&amp; searchpath, llvm::StringRef modpath)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* only extension in libdir are candidates for inlining for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span><span class="PreProc">#if LLVM_VERSION_MAJOR &lt; </span><span class="Constant">16<br/></li>
<li><a id="L801">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">starts_with</span> startswith<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!modpath.<a href="#L801" title="jit/llvm/llvmjit_inline.cpp:801">starts_with</a>(<span class="Constant">&quot;$libdir/&quot;</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if there's no match, attempt to load */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">auto</span> it = <a href="#L109" title="jit/llvm/llvmjit_inline.cpp:109">summary_cache</a>-&gt;<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a>(modpath);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (it == <a href="#L109" title="jit/llvm/llvmjit_inline.cpp:109">summary_cache</a>-&gt;end())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; std::string path(modpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path = path.replace(<span class="Constant">0</span>, strlen(<span class="Constant">&quot;$libdir&quot;</span>), std::string(<a href="../../utils/init/globals.c.html#L79" title="utils/init/globals.c:79">pkglib_path</a>) + <span class="Constant">&quot;/bitcode&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; path += <span class="Constant">&quot;.index.bc&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*<a href="#L109" title="jit/llvm/llvmjit_inline.cpp:109">summary_cache</a>)[modpath] = <a href="#L768" title="jit/llvm/llvmjit_inline.cpp:768">llvm_load_summary</a>(path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; it = <a href="#L109" title="jit/llvm/llvmjit_inline.cpp:109">summary_cache</a>-&gt;<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a>(modpath);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(it != <a href="#L109" title="jit/llvm/llvmjit_inline.cpp:109">summary_cache</a>-&gt;end());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if the entry isn't NULL, it's validly loaded */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (it-&gt;second)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; searchpath.push_back(it-&gt;second.get());<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Search for all references for <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> hashing to guid in the search path,<br/></li>
<li></span><span class="Comment"> * and return them in search path order.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> llvm::SmallVector&lt;llvm::GlobalValueSummary *, <span class="Constant">1</span>&gt;<br/></li>
<li><a id="L829">&#x200c;</a><span class="linkable">summaries_for_guid</span>(<span class="Type">const</span> <a href="#L67" title="jit/llvm/llvmjit_inline.cpp:67">InlineSearchPath</a>&amp; path, llvm::GlobalValue::GUID guid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; llvm::SmallVector&lt;llvm::GlobalValueSummary *, <span class="Constant">1</span>&gt; matches;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">auto</span> index : path)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; llvm::ValueInfo funcVI = index-&gt;getValueInfo(guid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if index doesn't know function, we don't have a body, continue */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (funcVI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">auto</span> &amp;gv : funcVI.getSummaryList())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches.push_back(gv.get());<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> matches;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create inline wrapper with the name Name, redirecting the call to F.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> llvm::Function*<br/></li>
<li><a id="L850">&#x200c;</a><span class="linkable">create_redirection_function</span>(std::unique_ptr&lt;llvm::Module&gt; &amp;importMod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; llvm::Function *F,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; llvm::StringRef Name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">typedef</span> llvm::GlobalValue::LinkageTypes LinkageTypes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; llvm::LLVMContext &amp;Context = F-&gt;getContext();<br/></li>
<li>&nbsp; &nbsp; llvm::IRBuilder&lt;&gt; Builder(Context);<br/></li>
<li>&nbsp; &nbsp; llvm::Function *AF;<br/></li>
<li>&nbsp; &nbsp; llvm::BasicBlock *BB;<br/></li>
<li>&nbsp; &nbsp; llvm::CallInst *fwdcall;<br/></li>
<li><span class="PreProc">#if LLVM_VERSION_MAJOR &lt; </span><span class="Constant">14<br/></li>
<li></span>&nbsp; &nbsp; llvm::Attribute inlineAttribute;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; AF = llvm::Function::Create(F-&gt;getFunctionType(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LinkageTypes::AvailableExternallyLinkage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Name, importMod.get());<br/></li>
<li>&nbsp; &nbsp; BB = llvm::BasicBlock::Create(Context, <span class="Constant">&quot;entry&quot;</span>, AF);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Builder.SetInsertPoint(BB);<br/></li>
<li>&nbsp; &nbsp; fwdcall = Builder.CreateCall(F, &amp;*AF-&gt;arg_begin());<br/></li>
<li><span class="PreProc">#if LLVM_VERSION_MAJOR &lt; </span><span class="Constant">14<br/></li>
<li></span>&nbsp; &nbsp; inlineAttribute = llvm::Attribute::get(Context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; llvm::Attribute::AlwaysInline);<br/></li>
<li>&nbsp; &nbsp; fwdcall-&gt;addAttribute(~<span class="Constant">0U</span>, inlineAttribute);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; fwdcall-&gt;addFnAttr(llvm::Attribute::AlwaysInline);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; Builder.CreateRet(fwdcall);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> AF;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
