<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>jit/llvm/llvmjit.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>jit/llvm/llvmjit.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L86">AttributeTemplate</a></li>
<li><a href="#L88">ExecEvalBoolSubroutineTemplate</a></li>
<li><a href="#L87">ExecEvalSubroutineTemplate</a></li>
<li><a href="#L81">StructAggState</a></li>
<li><a href="#L82">StructAggStatePerGroupData</a></li>
<li><a href="#L83">StructAggStatePerTransData</a></li>
<li><a href="#L78">StructExprContext</a></li>
<li><a href="#L79">StructExprEvalStep</a></li>
<li><a href="#L80">StructExprState</a></li>
<li><a href="#L77">StructFunctionCallInfoData</a></li>
<li><a href="#L69">StructHeapTupleData</a></li>
<li><a href="#L73">StructHeapTupleHeaderData</a></li>
<li><a href="#L74">StructHeapTupleTableSlot</a></li>
<li><a href="#L76">StructMemoryContextData</a></li>
<li><a href="#L70">StructMinimalTupleData</a></li>
<li><a href="#L75">StructMinimalTupleTableSlot</a></li>
<li><a href="#L68">StructNullableDatum</a></li>
<li><a href="#L84">StructPlanState</a></li>
<li><a href="#L71">StructTupleDescData</a></li>
<li><a href="#L72">StructTupleTableSlot</a></li>
<li><a href="#L67">TypePGFunction</a></li>
<li><a href="#L65">TypeParamBool</a></li>
<li><a href="#L64">TypeSizeT</a></li>
<li><a href="#L66">TypeStorageBool</a></li>
<li><a href="#L135">jit_resowner_desc</a></li>
<li><a href="#L102">llvm_context</a></li>
<li><a href="#L93">llvm_generation</a></li>
<li><a href="#L96">llvm_jit_context_in_use_count</a></li>
<li><a href="#L101">llvm_layout</a></li>
<li><a href="#L99">llvm_llvm_context_reuse_count</a></li>
<li><a href="#L108">llvm_opt0_orc</a></li>
<li><a href="#L111">llvm_opt0_orc</a></li>
<li><a href="#L109">llvm_opt3_orc</a></li>
<li><a href="#L112">llvm_opt3_orc</a></li>
<li><a href="#L92">llvm_session_initialized</a></li>
<li><a href="#L105">llvm_targetref</a></li>
<li><a href="#L100">llvm_triple</a></li>
<li><a href="#L107">llvm_ts_context</a></li>
<li><a href="#L90">llvm_types_module</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L51">LLVMJitHandle</a></li>
<li><a href="#L60">LLVMJitHandle</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1373">ResOwnerReleaseJitContext</a></li>
<li><a href="#L151">ResourceOwnerForgetJIT</a></li>
<li><a href="#L146">ResourceOwnerRememberJIT</a></li>
<li><a href="#L163">_PG_jit_provider_init</a></li>
<li><a href="#L732">llvm_compile_module</a></li>
<li><a href="#L548">llvm_copy_attributes</a></li>
<li><a href="#L524">llvm_copy_attributes_at_index</a></li>
<li><a href="#L235">llvm_create_context</a></li>
<li><a href="#L1305">llvm_create_jit_instance</a></li>
<li><a href="#L1274">llvm_create_object_layer</a></li>
<li><a href="#L1090">llvm_create_types</a></li>
<li><a href="#L1357">llvm_error_message</a></li>
<li><a href="#L359">llvm_expand_funcname</a></li>
<li><a href="#L572">llvm_function_reference</a></li>
<li><a href="#L380">llvm_get_function</a></li>
<li><a href="#L1264">llvm_log_jit_error</a></li>
<li><a href="#L334">llvm_mutable_module</a></li>
<li><a href="#L635">llvm_optimize_module</a></li>
<li><a href="#L496">llvm_pg_func</a></li>
<li><a href="#L474">llvm_pg_var_func_type</a></li>
<li><a href="#L454">llvm_pg_var_type</a></li>
<li><a href="#L185">llvm_recreate_llvm_context</a></li>
<li><a href="#L264">llvm_release_context</a></li>
<li><a href="#L1178">llvm_resolve_symbol</a></li>
<li><a href="#L1219">llvm_resolve_symbols</a></li>
<li><a href="#L863">llvm_session_initialize</a></li>
<li><a href="#L1071">llvm_set_target</a></li>
<li><a href="#L992">llvm_shutdown</a></li>
<li><a href="#L1144">llvm_split_symbol_name</a></li>
<li><a href="#L1051">load_return_type</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L48">LLVMJIT_LLVM_CONTEXT_REUSE_MAX</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * llvmjit.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Core part of the LLVM JIT <a href="../jit.c.html#L43" title="jit/jit.c:43">provider</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2016-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/jit/llvm/llvmjit.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;llvm-c/Analysis.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm-c/BitReader.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm-c/BitWriter.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm-c/Core.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm-c/ExecutionEngine.h&gt;<br/></li>
<li></span><span class="PreProc">#if LLVM_VERSION_MAJOR &gt; </span><span class="Constant">16<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm-c/Transforms/PassBuilder.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#if LLVM_VERSION_MAJOR &gt; </span><span class="Constant">11<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm-c/Orc.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm-c/OrcEE.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm-c/LLJIT.h&gt;<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm-c/OrcBindings.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm-c/Support.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm-c/Target.h&gt;<br/></li>
<li></span><span class="PreProc">#if LLVM_VERSION_MAJOR &lt; </span><span class="Constant">17<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm-c/Transforms/IPO.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm-c/Transforms/PassManagerBuilder.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm-c/Transforms/Scalar.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;llvm-c/Transforms/Utils.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;jit/llvmjit.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;jit/llvmjit_emit.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;portability/instr_time.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/resowner.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L48">&#x200c;</a><span class="PreProc">#define <span class="linkable">LLVMJIT_LLVM_CONTEXT_REUSE_MAX</span> </span><span class="Constant">100<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Handle of a module emitted via ORC JIT */<br/></li>
<li><a id="L51">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">LLVMJitHandle</span><br/></li>
<li>{<br/></li>
<li><span class="PreProc">#if LLVM_VERSION_MAJOR &gt; </span><span class="Constant">11<br/></li>
<li></span>&nbsp; &nbsp; LLVMOrcLLJITRef lljit;<br/></li>
<li>&nbsp; &nbsp; LLVMOrcResourceTrackerRef resource_tracker;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; LLVMOrcJITStackRef stack;<br/></li>
<li>&nbsp; &nbsp; LLVMOrcModuleHandle orc_handle;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li><a id="L60">&#x200c;</a></span>} <span class="linkable">LLVMJitHandle</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* types &amp; <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> commonly needed for JITing */<br/></li>
<li><a id="L64">&#x200c;</a></span>LLVMTypeRef <span class="linkable">TypeSizeT</span>;<br/></li>
<li><a id="L65">&#x200c;</a>LLVMTypeRef <span class="linkable">TypeParamBool</span>;<br/></li>
<li><a id="L66">&#x200c;</a>LLVMTypeRef <span class="linkable">TypeStorageBool</span>;<br/></li>
<li><a id="L67">&#x200c;</a>LLVMTypeRef <span class="linkable">TypePGFunction</span>;<br/></li>
<li><a id="L68">&#x200c;</a>LLVMTypeRef <span class="linkable">StructNullableDatum</span>;<br/></li>
<li><a id="L69">&#x200c;</a>LLVMTypeRef <span class="linkable">StructHeapTupleData</span>;<br/></li>
<li><a id="L70">&#x200c;</a>LLVMTypeRef <span class="linkable">StructMinimalTupleData</span>;<br/></li>
<li><a id="L71">&#x200c;</a>LLVMTypeRef <span class="linkable">StructTupleDescData</span>;<br/></li>
<li><a id="L72">&#x200c;</a>LLVMTypeRef <span class="linkable">StructTupleTableSlot</span>;<br/></li>
<li><a id="L73">&#x200c;</a>LLVMTypeRef <span class="linkable">StructHeapTupleHeaderData</span>;<br/></li>
<li><a id="L74">&#x200c;</a>LLVMTypeRef <span class="linkable">StructHeapTupleTableSlot</span>;<br/></li>
<li><a id="L75">&#x200c;</a>LLVMTypeRef <span class="linkable">StructMinimalTupleTableSlot</span>;<br/></li>
<li><a id="L76">&#x200c;</a>LLVMTypeRef <span class="linkable">StructMemoryContextData</span>;<br/></li>
<li><a id="L77">&#x200c;</a>LLVMTypeRef <span class="linkable">StructFunctionCallInfoData</span>;<br/></li>
<li><a id="L78">&#x200c;</a>LLVMTypeRef <span class="linkable">StructExprContext</span>;<br/></li>
<li><a id="L79">&#x200c;</a>LLVMTypeRef <span class="linkable">StructExprEvalStep</span>;<br/></li>
<li><a id="L80">&#x200c;</a>LLVMTypeRef <span class="linkable">StructExprState</span>;<br/></li>
<li><a id="L81">&#x200c;</a>LLVMTypeRef <span class="linkable">StructAggState</span>;<br/></li>
<li><a id="L82">&#x200c;</a>LLVMTypeRef <span class="linkable">StructAggStatePerGroupData</span>;<br/></li>
<li><a id="L83">&#x200c;</a>LLVMTypeRef <span class="linkable">StructAggStatePerTransData</span>;<br/></li>
<li><a id="L84">&#x200c;</a>LLVMTypeRef <span class="linkable">StructPlanState</span>;<br/></li>
<li><br/></li>
<li><a id="L86">&#x200c;</a>LLVMValueRef <span class="linkable">AttributeTemplate</span>;<br/></li>
<li><a id="L87">&#x200c;</a>LLVMValueRef <span class="linkable">ExecEvalSubroutineTemplate</span>;<br/></li>
<li><a id="L88">&#x200c;</a>LLVMValueRef <span class="linkable">ExecEvalBoolSubroutineTemplate</span>;<br/></li>
<li><br/></li>
<li><a id="L90">&#x200c;</a><span class="Type">static</span> LLVMModuleRef <span class="linkable">llvm_types_module</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><a id="L92">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">llvm_session_initialized</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L93">&#x200c;</a><span class="Type">static</span> <span class="Type">size_t</span> <span class="linkable">llvm_generation</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* number of LLVMJitContexts that currently are in use */<br/></li>
<li><a id="L96">&#x200c;</a></span><span class="Type">static</span> <span class="Type">size_t</span> <span class="linkable">llvm_jit_context_in_use_count</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* how many times has the current LLVMContextRef been used */<br/></li>
<li><a id="L99">&#x200c;</a></span><span class="Type">static</span> <span class="Type">size_t</span> <span class="linkable">llvm_llvm_context_reuse_count</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L100">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<span class="linkable">llvm_triple</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L101">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<span class="linkable">llvm_layout</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L102">&#x200c;</a><span class="Type">static</span> LLVMContextRef <span class="linkable">llvm_context</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L105">&#x200c;</a><span class="Type">static</span> LLVMTargetRef <span class="linkable">llvm_targetref</span>;<br/></li>
<li><span class="PreProc">#if LLVM_VERSION_MAJOR &gt; </span><span class="Constant">11<br/></li>
<li><a id="L107">&#x200c;</a></span><span class="Type">static</span> LLVMOrcThreadSafeContextRef <span class="linkable">llvm_ts_context</span>;<br/></li>
<li><a id="L108">&#x200c;</a><span class="Type">static</span> LLVMOrcLLJITRef <span class="linkable">llvm_opt0_orc</span>;<br/></li>
<li><a id="L109">&#x200c;</a><span class="Type">static</span> LLVMOrcLLJITRef <span class="linkable">llvm_opt3_orc</span>;<br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* LLVM_VERSION_MAJOR &gt; 11 */<br/></li>
<li><a id="L111">&#x200c;</a></span><span class="Type">static</span> LLVMOrcJITStackRef <span class="linkable">llvm_opt0_orc</span>;<br/></li>
<li><a id="L112">&#x200c;</a><span class="Type">static</span> LLVMOrcJITStackRef <span class="linkable">llvm_opt3_orc</span>;<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* LLVM_VERSION_MAJOR &gt; 11 */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L264" title="jit/llvm/llvmjit.c:264">llvm_release_context</a>(JitContext *context);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L863" title="jit/llvm/llvmjit.c:863">llvm_session_initialize</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L992" title="jit/llvm/llvmjit.c:992">llvm_shutdown</a>(<span class="Type">int</span> code, Datum arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L732" title="jit/llvm/llvmjit.c:732">llvm_compile_module</a>(LLVMJitContext *context);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L635" title="jit/llvm/llvmjit.c:635">llvm_optimize_module</a>(LLVMJitContext *context, LLVMModuleRef module);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1090" title="jit/llvm/llvmjit.c:1090">llvm_create_types</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1071" title="jit/llvm/llvmjit.c:1071">llvm_set_target</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L185" title="jit/llvm/llvmjit.c:185">llvm_recreate_llvm_context</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">uint64_t</span> <a href="#L1178" title="jit/llvm/llvmjit.c:1178">llvm_resolve_symbol</a>(<span class="Type">const</span> <span class="Type">char</span> *name, <span class="Type">void</span> *ctx);<br/></li>
<li><br/></li>
<li><span class="PreProc">#if LLVM_VERSION_MAJOR &gt; </span><span class="Constant">11<br/></li>
<li></span><span class="Type">static</span> LLVMOrcLLJITRef <a href="#L1305" title="jit/llvm/llvmjit.c:1305">llvm_create_jit_instance</a>(LLVMTargetMachineRef tm);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L1357" title="jit/llvm/llvmjit.c:1357">llvm_error_message</a>(LLVMErrorRef error);<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* LLVM_VERSION_MAJOR &gt; 11 */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* ResourceOwner callbacks to hold JitContexts&nbsp; */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L1373" title="jit/llvm/llvmjit.c:1373">ResOwnerReleaseJitContext</a>(Datum res);<br/></li>
<li><br/></li>
<li><a id="L135">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> ResourceOwnerDesc <span class="linkable">jit_resowner_desc</span> =<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; .name = <span class="Constant">&quot;LLVM JIT context&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; .release_phase = RESOURCE_RELEASE_BEFORE_LOCKS,<br/></li>
<li>&nbsp; &nbsp; .release_priority = RELEASE_PRIO_JIT_CONTEXTS,<br/></li>
<li>&nbsp; &nbsp; .ReleaseResource = <a href="#L1373" title="jit/llvm/llvmjit.c:1373">ResOwnerReleaseJitContext</a>,<br/></li>
<li>&nbsp; &nbsp; .DebugPrint = <span class="Constant">NULL</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the default message is fine */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Convenience wrappers over <a href="../../utils/resowner/resowner.c.html#L514" title="utils/resowner/resowner.c:514">ResourceOwnerRemember</a>/Forget */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L146">&#x200c;</a></span><span class="linkable">ResourceOwnerRememberJIT</span>(ResourceOwner owner, LLVMJitContext *handle)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L514" title="utils/resowner/resowner.c:514">ResourceOwnerRemember</a>(owner, PointerGetDatum(handle), &amp;<a href="#L135" title="jit/llvm/llvmjit.c:135">jit_resowner_desc</a>);<br/></li>
<li>}<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L151">&#x200c;</a></span><span class="linkable">ResourceOwnerForgetJIT</span>(ResourceOwner owner, LLVMJitContext *handle)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L554" title="utils/resowner/resowner.c:554">ResourceOwnerForget</a>(owner, PointerGetDatum(handle), &amp;<a href="#L135" title="jit/llvm/llvmjit.c:135">jit_resowner_desc</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>PG_MODULE_MAGIC;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize LLVM JIT <a href="../jit.c.html#L43" title="jit/jit.c:43">provider</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L163">&#x200c;</a></span><span class="linkable">_PG_jit_provider_init</span>(JitProviderCallbacks *cb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; cb-&gt;reset_after_error = <a href="llvmjit_error.cpp.html#L102" title="jit/llvm/llvmjit_error.cpp:102">llvm_reset_after_error</a>;<br/></li>
<li>&nbsp; &nbsp; cb-&gt;release_context = <a href="#L264" title="jit/llvm/llvmjit.c:264">llvm_release_context</a>;<br/></li>
<li>&nbsp; &nbsp; cb-&gt;compile_expr = <a href="llvmjit_expr.c.html#L78" title="jit/llvm/llvmjit_expr.c:78">llvm_compile_expr</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Every <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> and then create a new LLVMContextRef. Unfortunately, during every<br/></li>
<li></span><span class="Comment"> * round of inlining, types may &quot;leak&quot; (they can still be found/used via the<br/></li>
<li></span><span class="Comment"> * context, but new types will be created the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time in inlining is<br/></li>
<li></span><span class="Comment"> * performed). To prevent that from slowly accumulating problematic amounts of<br/></li>
<li></span><span class="Comment"> * memory, recreate the LLVMContextRef we use. We don't want to do so too<br/></li>
<li></span><span class="Comment"> * often, as that implies some overhead (particularly re-loading the module<br/></li>
<li></span><span class="Comment"> * summaries / modules is fairly expensive). A future </span><span class="Todo">TODO</span><span class="Comment"> would be to make<br/></li>
<li></span><span class="Comment"> * this more finegrained and only drop/recreate the LLVMContextRef when we know<br/></li>
<li></span><span class="Comment"> * there has been inlining. If we can get the size of the context from LLVM<br/></li>
<li></span><span class="Comment"> * then that might be a better way to determine when to drop/recreate rather<br/></li>
<li></span><span class="Comment"> * then the usagecount heuristic currently employed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L185">&#x200c;</a></span><span class="linkable">llvm_recreate_llvm_context</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L102" title="jit/llvm/llvmjit.c:102">llvm_context</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;Trying to recreate a non-existing context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can only safely recreate the LLVM context if no other code is being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * JITed, otherwise we'd release the types in use for that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L96" title="jit/llvm/llvmjit.c:96">llvm_jit_context_in_use_count</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L99" title="jit/llvm/llvmjit.c:99">llvm_llvm_context_reuse_count</a>++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L99" title="jit/llvm/llvmjit.c:99">llvm_llvm_context_reuse_count</a> &lt;= <a href="#L48" title="jit/llvm/llvmjit.c:48">LLVMJIT_LLVM_CONTEXT_REUSE_MAX</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L99" title="jit/llvm/llvmjit.c:99">llvm_llvm_context_reuse_count</a>++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Need to reset the modules that the inlining code caches <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * disposing of the context. LLVM modules exist within a specific LLVM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * context, therefore disposing of the context <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> resetting the cache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would lead to dangling pointers to modules.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="llvmjit_inline.cpp.html#L156" title="jit/llvm/llvmjit_inline.cpp:156">llvm_inline_reset_caches</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LLVMContextDispose(<a href="#L102" title="jit/llvm/llvmjit.c:102">llvm_context</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L102" title="jit/llvm/llvmjit.c:102">llvm_context</a> = LLVMContextCreate();<br/></li>
<li>&nbsp; &nbsp; <a href="#L99" title="jit/llvm/llvmjit.c:99">llvm_llvm_context_reuse_count</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Re-build cached type information, so code generation code can rely on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that information to be present (also prevents the variables to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dangling references).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1090" title="jit/llvm/llvmjit.c:1090">llvm_create_types</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a context for JITing work.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The context, including subsidiary resources, will be cleaned up either when<br/></li>
<li></span><span class="Comment"> * the context is explicitly released, or when the lifetime of<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> ends (usually the end of the current [sub]xact).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>LLVMJitContext *<br/></li>
<li><a id="L235">&#x200c;</a><span class="linkable">llvm_create_context</span>(<span class="Type">int</span> jitFlags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LLVMJitContext *context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_error.cpp.html#L114" title="jit/llvm/llvmjit_error.cpp:114">llvm_assert_in_fatal_section</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L863" title="jit/llvm/llvmjit.c:863">llvm_session_initialize</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L185" title="jit/llvm/llvmjit.c:185">llvm_recreate_llvm_context</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context = <a href="../../utils/mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LLVMJitContext));<br/></li>
<li>&nbsp; &nbsp; context-&gt;base.flags = jitFlags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ensure <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> */<br/></li>
<li></span>&nbsp; &nbsp; context-&gt;base.resowner = <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L146" title="jit/llvm/llvmjit.c:146">ResourceOwnerRememberJIT</a>(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>, context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L96" title="jit/llvm/llvmjit.c:96">llvm_jit_context_in_use_count</a>++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> context;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Release resources required by one llvm context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L264">&#x200c;</a></span><span class="linkable">llvm_release_context</span>(JitContext *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LLVMJitContext *llvm_jit_context = (LLVMJitContext *) context;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Consider as cleaned up even if we <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> doing so below, that way we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * verify the tracking is correct (see <a href="#L992" title="jit/llvm/llvmjit.c:992">llvm_shutdown</a>()).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L96" title="jit/llvm/llvmjit.c:96">llvm_jit_context_in_use_count</a>--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When this backend is exiting, don't clean up LLVM. As an error might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have occurred from within LLVM, we do not want to risk reentering. All<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * resource <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> is going to happen through process exit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/ipc/ipc.c.html#L40" title="storage/ipc/ipc.c:40">proc_exit_inprogress</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_error.cpp.html#L61" title="jit/llvm/llvmjit_error.cpp:61">llvm_enter_fatal_on_oom</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (llvm_jit_context-&gt;module)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMDisposeModule(llvm_jit_context-&gt;module);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; llvm_jit_context-&gt;module = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, llvm_jit_context-&gt;handles)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L51" title="jit/llvm/llvmjit.c:51">LLVMJitHandle</a> *jit_handle = (<a href="#L51" title="jit/llvm/llvmjit.c:51">LLVMJitHandle</a> *) lfirst(lc);<br/></li>
<li><br/></li>
<li><span class="PreProc">#if LLVM_VERSION_MAJOR &gt; </span><span class="Constant">11<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMOrcExecutionSessionRef ee;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMOrcSymbolStringPoolRef sp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMOrcResourceTrackerRemove(jit_handle-&gt;resource_tracker);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMOrcReleaseResourceTracker(jit_handle-&gt;resource_tracker);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Without triggering <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> of the string pool, we'd leak<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * memory. It'd be sufficient to do this far less often, but in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * experiments the required time was small enough to just always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ee = LLVMOrcLLJITGetExecutionSession(jit_handle-&gt;lljit);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sp = LLVMOrcExecutionSessionGetSymbolStringPool(ee);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMOrcSymbolStringPoolClearDeadEntries(sp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* LLVM_VERSION_MAJOR &gt; 11 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMOrcRemoveModule(jit_handle-&gt;stack, jit_handle-&gt;orc_handle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* LLVM_VERSION_MAJOR &gt; 11 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(jit_handle);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(llvm_jit_context-&gt;handles);<br/></li>
<li>&nbsp; &nbsp; llvm_jit_context-&gt;handles = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_error.cpp.html#L76" title="jit/llvm/llvmjit_error.cpp:76">llvm_leave_fatal_on_oom</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;resowner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L151" title="jit/llvm/llvmjit.c:151">ResourceOwnerForgetJIT</a>(context-&gt;resowner, llvm_jit_context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return module which may be modified, e.g. by creating new <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>LLVMModuleRef<br/></li>
<li><a id="L334">&#x200c;</a><span class="linkable">llvm_mutable_module</span>(LLVMJitContext *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_error.cpp.html#L114" title="jit/llvm/llvmjit_error.cpp:114">llvm_assert_in_fatal_section</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there's no in-progress module, create a new one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!context-&gt;module)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;compiled = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;module_generation = <a href="#L93" title="jit/llvm/llvmjit.c:93">llvm_generation</a>++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;module = LLVMModuleCreateWithNameInContext(<span class="Constant">&quot;pg&quot;</span>, <a href="#L102" title="jit/llvm/llvmjit.c:102">llvm_context</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMSetTarget(context-&gt;module, <a href="#L100" title="jit/llvm/llvmjit.c:100">llvm_triple</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMSetDataLayout(context-&gt;module, <a href="#L101" title="jit/llvm/llvmjit.c:101">llvm_layout</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> context-&gt;module;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Expand function name to be non-conflicting. This should be used by code<br/></li>
<li></span><span class="Comment"> * generating code, when adding new externally visible function definitions to<br/></li>
<li></span><span class="Comment"> * a Module.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L359">&#x200c;</a><span class="linkable">llvm_expand_funcname</span>(<span class="Type">struct</span> LLVMJitContext *context, <span class="Type">const</span> <span class="Type">char</span> *basename)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(context-&gt;module != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context-&gt;base.instr.created_functions++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Previously we used dots to separate, but turns out some tools, e.g.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * GDB, don't like that and truncate name.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> psprintf(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"><a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a></span><span class="Special">%zu</span><span class="Constant"><a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a></span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; basename,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;module_generation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;counter++);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return pointer to function funcname, which has to exist. If there's pending<br/></li>
<li></span><span class="Comment"> * code to be optimized and emitted, do so first.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L380">&#x200c;</a><span class="linkable">llvm_get_function</span>(LLVMJitContext *context, <span class="Type">const</span> <span class="Type">char</span> *funcname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_error.cpp.html#L114" title="jit/llvm/llvmjit_error.cpp:114">llvm_assert_in_fatal_section</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is a pending / not emitted module, compile and emit <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise we might not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the [correct] function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!context-&gt;compiled)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L732" title="jit/llvm/llvmjit.c:732">llvm_compile_module</a>(context);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ORC's symbol table is of *unmangled* symbols. Therefore we don't need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to mangle here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#if LLVM_VERSION_MAJOR &gt; </span><span class="Constant">11<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, context-&gt;handles)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L51" title="jit/llvm/llvmjit.c:51">LLVMJitHandle</a> *handle = (<a href="#L51" title="jit/llvm/llvmjit.c:51">LLVMJitHandle</a> *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instr_time&nbsp; &nbsp; starttime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instr_time&nbsp; &nbsp; endtime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMErrorRef error;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMOrcJITTargetAddress addr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_CURRENT(starttime);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; addr = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; error = LLVMOrcLLJITLookup(handle-&gt;lljit, &amp;addr, funcname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (error)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to look up symbol </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; funcname, <a href="#L1357" title="jit/llvm/llvmjit.c:1357">llvm_error_message</a>(error));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * LLJIT only actually emits code the first time a symbol is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * referenced. Thus add lookup time to emission time. That's counting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> more than with older LLVM versions, but unlikely to ever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_CURRENT(endtime);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_ACCUM_DIFF(context-&gt;base.instr.emission_counter,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endtime, starttime);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (addr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">void</span> *) (<span class="Type">uintptr_t</span>) addr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, context-&gt;handles)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMOrcTargetAddress addr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L51" title="jit/llvm/llvmjit.c:51">LLVMJitHandle</a> *handle = (<a href="#L51" title="jit/llvm/llvmjit.c:51">LLVMJitHandle</a> *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; addr = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (LLVMOrcGetSymbolAddressIn(handle-&gt;stack, &amp;addr, handle-&gt;orc_handle, funcname))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to look up symbol </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, funcname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (addr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">void</span> *) (<span class="Type">uintptr_t</span>) addr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to JIT: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, funcname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return type of a variable in llvmjit_types.c. This is useful to keep types<br/></li>
<li></span><span class="Comment"> * in sync between plain C and JIT related code.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>LLVMTypeRef<br/></li>
<li><a id="L454">&#x200c;</a><span class="linkable">llvm_pg_var_type</span>(<span class="Type">const</span> <span class="Type">char</span> *varname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LLVMValueRef v_srcvar;<br/></li>
<li>&nbsp; &nbsp; LLVMTypeRef typ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* this'll return a *pointer* to the global */<br/></li>
<li></span>&nbsp; &nbsp; v_srcvar = LLVMGetNamedGlobal(<a href="#L90" title="jit/llvm/llvmjit.c:90">llvm_types_module</a>, varname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!v_srcvar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;variable </span><span class="Special">%s</span><span class="Constant"> not in llvmjit_types.c&quot;</span>, varname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typ = LLVMGlobalGetValueType(v_srcvar);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> typ;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return function type of a variable in llvmjit_types.c. This is useful to<br/></li>
<li></span><span class="Comment"> * keep function types in sync between C and JITed code.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>LLVMTypeRef<br/></li>
<li><a id="L474">&#x200c;</a><span class="linkable">llvm_pg_var_func_type</span>(<span class="Type">const</span> <span class="Type">char</span> *varname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LLVMValueRef v_srcvar;<br/></li>
<li>&nbsp; &nbsp; LLVMTypeRef typ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; v_srcvar = LLVMGetNamedFunction(<a href="#L90" title="jit/llvm/llvmjit.c:90">llvm_types_module</a>, varname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!v_srcvar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;function </span><span class="Special">%s</span><span class="Constant"> not in llvmjit_types.c&quot;</span>, varname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typ = <a href="llvmjit_wrap.cpp.html#L40" title="jit/llvm/llvmjit_wrap.cpp:40">LLVMGetFunctionType</a>(v_srcvar);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> typ;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return declaration for a function referenced in llvmjit_types.c, adding it<br/></li>
<li></span><span class="Comment"> * to the module if necessary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used to make <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> discovered via <a href="#L1090" title="jit/llvm/llvmjit.c:1090">llvm_create_types</a>() known to<br/></li>
<li></span><span class="Comment"> * the module that's currently being worked on.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>LLVMValueRef<br/></li>
<li><a id="L496">&#x200c;</a><span class="linkable">llvm_pg_func</span>(LLVMModuleRef mod, <span class="Type">const</span> <span class="Type">char</span> *funcname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LLVMValueRef v_srcfn;<br/></li>
<li>&nbsp; &nbsp; LLVMValueRef v_fn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't repeatedly add function */<br/></li>
<li></span>&nbsp; &nbsp; v_fn = LLVMGetNamedFunction(mod, funcname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v_fn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> v_fn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; v_srcfn = LLVMGetNamedFunction(<a href="#L90" title="jit/llvm/llvmjit.c:90">llvm_types_module</a>, funcname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!v_srcfn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;function </span><span class="Special">%s</span><span class="Constant"> not in llvmjit_types.c&quot;</span>, funcname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; v_fn = LLVMAddFunction(mod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; funcname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="llvmjit_wrap.cpp.html#L40" title="jit/llvm/llvmjit_wrap.cpp:40">LLVMGetFunctionType</a>(v_srcfn));<br/></li>
<li>&nbsp; &nbsp; <a href="#L548" title="jit/llvm/llvmjit.c:548">llvm_copy_attributes</a>(v_srcfn, v_fn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> v_fn;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Copy attributes from one function to another, for a specific index (an<br/></li>
<li></span><span class="Comment"> * index can reference return value, function and parameter attributes).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L524">&#x200c;</a></span><span class="linkable">llvm_copy_attributes_at_index</span>(LLVMValueRef v_from, LLVMValueRef v_to, uint32 index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_attributes;<br/></li>
<li>&nbsp; &nbsp; LLVMAttributeRef *attrs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; num_attributes = LLVMGetAttributeCountAtIndex(v_from, index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (num_attributes == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attrs = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LLVMAttributeRef) * num_attributes);<br/></li>
<li>&nbsp; &nbsp; LLVMGetAttributesAtIndex(v_from, index, attrs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> attno = <span class="Constant">0</span>; attno &lt; num_attributes; attno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMAddAttributeAtIndex(v_to, index, attrs[attno]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(attrs);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Copy all attributes from one function to another. I.e. function, return and<br/></li>
<li></span><span class="Comment"> * parameters will be copied.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L548">&#x200c;</a></span><span class="linkable">llvm_copy_attributes</span>(LLVMValueRef v_from, LLVMValueRef v_to)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; param_count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy function attributes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L524" title="jit/llvm/llvmjit.c:524">llvm_copy_attributes_at_index</a>(v_from, v_to, LLVMAttributeFunctionIndex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (LLVMGetTypeKind(<a href="llvmjit_wrap.cpp.html#L34" title="jit/llvm/llvmjit_wrap.cpp:34">LLVMGetFunctionReturnType</a>(v_to)) != LLVMVoidTypeKind)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and the return value attributes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L524" title="jit/llvm/llvmjit.c:524">llvm_copy_attributes_at_index</a>(v_from, v_to, LLVMAttributeReturnIndex);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and each function parameter's attribute */<br/></li>
<li></span>&nbsp; &nbsp; param_count = LLVMCountParams(v_from);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> paramidx = <span class="Constant">1</span>; paramidx &lt;= param_count; paramidx++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L524" title="jit/llvm/llvmjit.c:524">llvm_copy_attributes_at_index</a>(v_from, v_to, paramidx);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return a callable LLVMValueRef for fcinfo.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>LLVMValueRef<br/></li>
<li><a id="L572">&#x200c;</a><span class="linkable">llvm_function_reference</span>(LLVMJitContext *context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMBuilderRef builder,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMModuleRef mod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FunctionCallInfo fcinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *modname;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *basename;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *funcname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LLVMValueRef v_fn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L281" title="utils/fmgr/fmgr.c:281">fmgr_symbol</a>(fcinfo-&gt;flinfo-&gt;fn_oid, &amp;modname, &amp;basename);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (modname != <span class="Constant">NULL</span> &amp;&amp; basename != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* external function in loadable library */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; funcname = psprintf(<span class="Constant">&quot;pgextern.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">&quot;</span>, modname, basename);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (basename != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> function */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; funcname = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(basename);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Function we don't know to handle, return pointer. We do so by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * creating a global constant containing a pointer to the function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Makes IR more readable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; LLVMValueRef v_fn_addr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcname = psprintf(<span class="Constant">&quot;pgoidextern.</span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_oid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v_fn = LLVMGetNamedGlobal(mod, funcname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v_fn != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> l_load(builder, <a href="llvmjit_types.c.html#L48" title="jit/llvm/llvmjit_types.c:48">TypePGFunction</a>, v_fn, <span class="Constant">&quot;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v_fn_addr = l_ptr_const(fcinfo-&gt;flinfo-&gt;fn_addr, <a href="llvmjit_types.c.html#L48" title="jit/llvm/llvmjit_types.c:48">TypePGFunction</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v_fn = LLVMAddGlobal(mod, <a href="llvmjit_types.c.html#L48" title="jit/llvm/llvmjit_types.c:48">TypePGFunction</a>, funcname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMSetInitializer(v_fn, v_fn_addr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMSetGlobalConstant(v_fn, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMSetLinkage(v_fn, LLVMPrivateLinkage);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMSetUnnamedAddr(v_fn, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> l_load(builder, <a href="llvmjit_types.c.html#L48" title="jit/llvm/llvmjit_types.c:48">TypePGFunction</a>, v_fn, <span class="Constant">&quot;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check if function already has been added */<br/></li>
<li></span>&nbsp; &nbsp; v_fn = LLVMGetNamedFunction(mod, funcname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v_fn != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> v_fn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; v_fn = LLVMAddFunction(mod, funcname, <a href="llvmjit_wrap.cpp.html#L40" title="jit/llvm/llvmjit_wrap.cpp:40">LLVMGetFunctionType</a>(<a href="llvmjit_types.c.html#L81" title="jit/llvm/llvmjit_types.c:81">AttributeTemplate</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> v_fn;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Optimize code in module using the flags set in context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L635">&#x200c;</a></span><span class="linkable">llvm_optimize_module</span>(LLVMJitContext *context, LLVMModuleRef module)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#if LLVM_VERSION_MAJOR &lt; </span><span class="Constant">17<br/></li>
<li></span>&nbsp; &nbsp; LLVMPassManagerBuilderRef llvm_pmb;<br/></li>
<li>&nbsp; &nbsp; LLVMPassManagerRef llvm_mpm;<br/></li>
<li>&nbsp; &nbsp; LLVMPassManagerRef llvm_fpm;<br/></li>
<li>&nbsp; &nbsp; LLVMValueRef func;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; compile_optlevel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;base.flags &amp; PGJIT_OPT3)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; compile_optlevel = <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; compile_optlevel = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Have to create a new pass manager builder every pass through, as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inliner has some per-builder state. Otherwise one ends up only inlining<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a function the first time though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; llvm_pmb = LLVMPassManagerBuilderCreate();<br/></li>
<li>&nbsp; &nbsp; LLVMPassManagerBuilderSetOptLevel(llvm_pmb, compile_optlevel);<br/></li>
<li>&nbsp; &nbsp; llvm_fpm = LLVMCreateFunctionPassManagerForModule(module);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;base.flags &amp; PGJIT_OPT3)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">TODO</span><span class="Comment">: Unscientifically determined threshold */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; LLVMPassManagerBuilderUseInlinerWithThreshold(llvm_pmb, <span class="Constant">512</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we rely on mem2reg heavily, so emit even in the O0 case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; LLVMAddPromoteMemoryToRegisterPass(llvm_fpm);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LLVMPassManagerBuilderPopulateFunctionPassManager(llvm_pmb, llvm_fpm);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do function level optimization. This could be moved to the point where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are emitted, to reduce memory usage a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; LLVMInitializeFunctionPassManager(llvm_fpm);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (func = LLVMGetFirstFunction(context-&gt;module);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; func != <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; func = LLVMGetNextFunction(func))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMRunFunctionPassManager(llvm_fpm, func);<br/></li>
<li>&nbsp; &nbsp; LLVMFinalizeFunctionPassManager(llvm_fpm);<br/></li>
<li>&nbsp; &nbsp; LLVMDisposePassManager(llvm_fpm);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Perform module level optimization. We do so even in the non-optimized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case, so always-inline <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> etc get inlined. It's cheap enough.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; llvm_mpm = LLVMCreatePassManager();<br/></li>
<li>&nbsp; &nbsp; LLVMPassManagerBuilderPopulateModulePassManager(llvm_pmb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; llvm_mpm);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* always use always-inliner pass */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(context-&gt;base.flags &amp; PGJIT_OPT3))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMAddAlwaysInlinerPass(llvm_mpm);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if doing inlining, but no expensive optimization, add inlining pass */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;base.flags &amp; PGJIT_INLINE<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; !(context-&gt;base.flags &amp; PGJIT_OPT3))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMAddFunctionInliningPass(llvm_mpm);<br/></li>
<li>&nbsp; &nbsp; LLVMRunPassManager(llvm_mpm, context-&gt;module);<br/></li>
<li>&nbsp; &nbsp; LLVMDisposePassManager(llvm_mpm);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LLVMPassManagerBuilderDispose(llvm_pmb);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; LLVMPassBuilderOptionsRef options;<br/></li>
<li>&nbsp; &nbsp; LLVMErrorRef err;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *passes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;base.flags &amp; PGJIT_OPT3)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; passes = <span class="Constant">&quot;default&lt;O3&gt;&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; passes = <span class="Constant">&quot;default&lt;O0&gt;,mem2reg&quot;</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; options = LLVMCreatePassBuilderOptions();<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef LLVM_PASS_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; LLVMPassBuilderOptionsSetDebugLogging(options, <span class="Constant">1</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; LLVMPassBuilderOptionsSetInlinerThreshold(options, <span class="Constant">512</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; err = LLVMRunPasses(module, passes, <span class="Constant">NULL</span>, options);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (err)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to JIT module: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="#L1357" title="jit/llvm/llvmjit.c:1357">llvm_error_message</a>(err));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LLVMDisposePassBuilderOptions(options);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Emit code for the currently pending module.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L732">&#x200c;</a></span><span class="linkable">llvm_compile_module</span>(LLVMJitContext *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L51" title="jit/llvm/llvmjit.c:51">LLVMJitHandle</a> *handle;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; instr_time&nbsp; &nbsp; starttime;<br/></li>
<li>&nbsp; &nbsp; instr_time&nbsp; &nbsp; endtime;<br/></li>
<li><span class="PreProc">#if LLVM_VERSION_MAJOR &gt; </span><span class="Constant">11<br/></li>
<li></span>&nbsp; &nbsp; LLVMOrcLLJITRef compile_orc;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; LLVMOrcJITStackRef compile_orc;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;base.flags &amp; PGJIT_OPT3)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; compile_orc = <a href="#L109" title="jit/llvm/llvmjit.c:109">llvm_opt3_orc</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; compile_orc = <a href="#L108" title="jit/llvm/llvmjit.c:108">llvm_opt0_orc</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* perform inlining */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;base.flags &amp; PGJIT_INLINE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_CURRENT(starttime);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="llvmjit_inline.cpp.html#L167" title="jit/llvm/llvmjit_inline.cpp:167">llvm_inline</a>(context-&gt;module);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_CURRENT(endtime);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_ACCUM_DIFF(context-&gt;base.instr.inlining_counter,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endtime, starttime);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../jit.c.html#L35" title="jit/jit.c:35">jit_dump_bitcode</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *filename;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; filename = psprintf(<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">.</span><span class="Special">%zu</span><span class="Constant">.bc&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;module_generation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMWriteBitcodeToFile(context-&gt;module, filename);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(filename);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> according to the chosen optimization settings */<br/></li>
<li></span>&nbsp; &nbsp; INSTR_TIME_SET_CURRENT(starttime);<br/></li>
<li>&nbsp; &nbsp; <a href="#L635" title="jit/llvm/llvmjit.c:635">llvm_optimize_module</a>(context, context-&gt;module);<br/></li>
<li>&nbsp; &nbsp; INSTR_TIME_SET_CURRENT(endtime);<br/></li>
<li>&nbsp; &nbsp; INSTR_TIME_ACCUM_DIFF(context-&gt;base.instr.optimization_counter,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endtime, starttime);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../jit.c.html#L35" title="jit/jit.c:35">jit_dump_bitcode</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *filename;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; filename = psprintf(<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">.</span><span class="Special">%zu</span><span class="Constant">.optimized.bc&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;module_generation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMWriteBitcodeToFile(context-&gt;module, filename);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(filename);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; handle = (<a href="#L51" title="jit/llvm/llvmjit.c:51">LLVMJitHandle</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L51" title="jit/llvm/llvmjit.c:51">LLVMJitHandle</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Emit the code. Note that this can, depending on the optimization<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * settings, take noticeable resources as code emission executes low-level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * instruction combining/selection passes etc. Without optimization a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * faster instruction selection mechanism is used.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; INSTR_TIME_SET_CURRENT(starttime);<br/></li>
<li><span class="PreProc">#if LLVM_VERSION_MAJOR &gt; </span><span class="Constant">11<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMOrcThreadSafeModuleRef ts_module;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMErrorRef error;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMOrcJITDylibRef jd = LLVMOrcLLJITGetMainJITDylib(compile_orc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ts_module = LLVMOrcCreateNewThreadSafeModule(context-&gt;module, <a href="#L107" title="jit/llvm/llvmjit.c:107">llvm_ts_context</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; handle-&gt;lljit = compile_orc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; handle-&gt;resource_tracker = LLVMOrcJITDylibCreateResourceTracker(jd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NB: This doesn't actually emit code. That happens lazily the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * time a symbol defined in the module is requested. Due to that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L380" title="jit/llvm/llvmjit.c:380">llvm_get_function</a>() also accounts for emission time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;module = <span class="Constant">NULL</span>; <span class="Comment">/* will be owned by LLJIT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; error = LLVMOrcLLJITAddLLVMIRModuleWithRT(compile_orc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; handle-&gt;resource_tracker,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ts_module);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (error)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to JIT module: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1357" title="jit/llvm/llvmjit.c:1357">llvm_error_message</a>(error));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* LLVMOrcLLJITAddLLVMIRModuleWithRT takes ownership of the module */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; handle-&gt;stack = compile_orc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (LLVMOrcAddEagerlyCompiledIR(compile_orc, &amp;handle-&gt;orc_handle, context-&gt;module,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1178" title="jit/llvm/llvmjit.c:1178">llvm_resolve_symbol</a>, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to JIT module&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* LLVMOrcAddEagerlyCompiledIR takes ownership of the module */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; INSTR_TIME_SET_CURRENT(endtime);<br/></li>
<li>&nbsp; &nbsp; INSTR_TIME_ACCUM_DIFF(context-&gt;base.instr.emission_counter,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endtime, starttime);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context-&gt;module = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; context-&gt;compiled = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* remember emitted code for <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> and lookups */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; context-&gt;handles = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(context-&gt;handles, handle);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;time to inline: </span><span class="Special">%.3f</span><span class="Constant">s, opt: </span><span class="Special">%.3f</span><span class="Constant">s, emit: </span><span class="Special">%.3f</span><span class="Constant">s&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INSTR_TIME_GET_DOUBLE(context-&gt;base.instr.inlining_counter),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INSTR_TIME_GET_DOUBLE(context-&gt;base.instr.optimization_counter),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INSTR_TIME_GET_DOUBLE(context-&gt;base.instr.emission_counter)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1413" title="utils/error/elog.c:1413">errhidestmt</a>(<span class="Constant">true</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1432" title="utils/error/elog.c:1432">errhidecontext</a>(<span class="Constant">true</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Per session initialization.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L863">&#x200c;</a></span><span class="linkable">llvm_session_initialize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *error = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cpu = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *features = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; LLVMTargetMachineRef opt0_tm;<br/></li>
<li>&nbsp; &nbsp; LLVMTargetMachineRef opt3_tm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L92" title="jit/llvm/llvmjit.c:92">llvm_session_initialized</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LLVMInitializeNativeTarget();<br/></li>
<li>&nbsp; &nbsp; LLVMInitializeNativeAsmPrinter();<br/></li>
<li>&nbsp; &nbsp; LLVMInitializeNativeAsmParser();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L102" title="jit/llvm/llvmjit.c:102">llvm_context</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L102" title="jit/llvm/llvmjit.c:102">llvm_context</a> = LLVMContextCreate();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L96" title="jit/llvm/llvmjit.c:96">llvm_jit_context_in_use_count</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L99" title="jit/llvm/llvmjit.c:99">llvm_llvm_context_reuse_count</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When targeting LLVM 15, turn off opaque pointers for the context we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * build our code in.&nbsp; We don't need to do so for other contexts (e.g.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L107" title="jit/llvm/llvmjit.c:107">llvm_ts_context</a>).&nbsp; Once the IR is generated, it carries the necessary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * information.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For 16 and above, opaque pointers must be used, and we have special<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * code for that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#if LLVM_VERSION_MAJOR == </span><span class="Constant">15<br/></li>
<li></span>&nbsp; &nbsp; LLVMContextSetOpaquePointers(LLVMGetGlobalContext(), <span class="Constant">false</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Synchronize types early, as that also includes inferring the target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * triple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1090" title="jit/llvm/llvmjit.c:1090">llvm_create_types</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Extract target information from loaded module.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1071" title="jit/llvm/llvmjit.c:1071">llvm_set_target</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (LLVMGetTargetFromTriple(<a href="#L100" title="jit/llvm/llvmjit.c:100">llvm_triple</a>, &amp;<a href="#L105" title="jit/llvm/llvmjit.c:105">llvm_targetref</a>, &amp;error) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;failed to query triple </span><span class="Special">%s</span><span class="Constant">&quot;</span>, error);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We want the generated code to use all available features. Therefore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * grab the host CPU string and detect features of the current CPU. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * latter is needed because some CPU architectures default to enabling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * features not all CPUs have (weird, huh).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cpu = LLVMGetHostCPUName();<br/></li>
<li>&nbsp; &nbsp; features = LLVMGetHostCPUFeatures();<br/></li>
<li>&nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;LLVMJIT detected CPU </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, with features </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cpu, features);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opt0_tm =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMCreateTargetMachine(<a href="#L105" title="jit/llvm/llvmjit.c:105">llvm_targetref</a>, <a href="#L100" title="jit/llvm/llvmjit.c:100">llvm_triple</a>, cpu, features,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMCodeGenLevelNone,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMRelocDefault,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMCodeModelJITDefault);<br/></li>
<li>&nbsp; &nbsp; opt3_tm =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMCreateTargetMachine(<a href="#L105" title="jit/llvm/llvmjit.c:105">llvm_targetref</a>, <a href="#L100" title="jit/llvm/llvmjit.c:100">llvm_triple</a>, cpu, features,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMCodeGenLevelAggressive,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMRelocDefault,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMCodeModelJITDefault);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LLVMDisposeMessage(cpu);<br/></li>
<li>&nbsp; &nbsp; cpu = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; LLVMDisposeMessage(features);<br/></li>
<li>&nbsp; &nbsp; features = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* force symbols in <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> binary to be loaded */<br/></li>
<li></span>&nbsp; &nbsp; LLVMLoadLibraryPermanently(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#if LLVM_VERSION_MAJOR &gt; </span><span class="Constant">11<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="jit/llvm/llvmjit.c:107">llvm_ts_context</a> = LLVMOrcCreateNewThreadSafeContext();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="jit/llvm/llvmjit.c:108">llvm_opt0_orc</a> = <a href="#L1305" title="jit/llvm/llvmjit.c:1305">llvm_create_jit_instance</a>(opt0_tm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opt0_tm = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L109" title="jit/llvm/llvmjit.c:109">llvm_opt3_orc</a> = <a href="#L1305" title="jit/llvm/llvmjit.c:1305">llvm_create_jit_instance</a>(opt3_tm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opt3_tm = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* LLVM_VERSION_MAJOR &gt; 11 */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="jit/llvm/llvmjit.c:108">llvm_opt0_orc</a> = LLVMOrcCreateInstance(opt0_tm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L109" title="jit/llvm/llvmjit.c:109">llvm_opt3_orc</a> = LLVMOrcCreateInstance(opt3_tm);<br/></li>
<li><br/></li>
<li><span class="PreProc">#if defined(HAVE_DECL_LLVMCREATEGDBREGISTRATIONLISTENER) &amp;&amp; HAVE_DECL_LLVMCREATEGDBREGISTRATIONLISTENER<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../jit.c.html#L34" title="jit/jit.c:34">jit_debugging_support</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMJITEventListenerRef l = LLVMCreateGDBRegistrationListener();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMOrcRegisterJITEventListener(<a href="#L108" title="jit/llvm/llvmjit.c:108">llvm_opt0_orc</a>, l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMOrcRegisterJITEventListener(<a href="#L109" title="jit/llvm/llvmjit.c:109">llvm_opt3_orc</a>, l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#if defined(HAVE_DECL_LLVMCREATEPERFJITEVENTLISTENER) &amp;&amp; HAVE_DECL_LLVMCREATEPERFJITEVENTLISTENER<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../jit.c.html#L37" title="jit/jit.c:37">jit_profiling_support</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMJITEventListenerRef l = LLVMCreatePerfJITEventListener();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMOrcRegisterJITEventListener(<a href="#L108" title="jit/llvm/llvmjit.c:108">llvm_opt0_orc</a>, l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMOrcRegisterJITEventListener(<a href="#L109" title="jit/llvm/llvmjit.c:109">llvm_opt3_orc</a>, l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* LLVM_VERSION_MAJOR &gt; 11 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a>(<a href="#L992" title="jit/llvm/llvmjit.c:992">llvm_shutdown</a>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L92" title="jit/llvm/llvmjit.c:92">llvm_session_initialized</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L992">&#x200c;</a></span><span class="linkable">llvm_shutdown</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="#L992" title="jit/llvm/llvmjit.c:992">llvm_shutdown</a>() is reached while in a fatal-on-oom section an error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has occurred in the middle of LLVM code. It is not safe to call back<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into LLVM (which is why a FATAL error was thrown).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do need to shutdown LLVM in other shutdown cases, otherwise e.g.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * profiling data won't be written out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="llvmjit_error.cpp.html#L92" title="jit/llvm/llvmjit_error.cpp:92">llvm_in_fatal_on_oom</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../storage/ipc/ipc.c.html#L40" title="storage/ipc/ipc.c:40">proc_exit_inprogress</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L96" title="jit/llvm/llvmjit.c:96">llvm_jit_context_in_use_count</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;LLVMJitContext in use count not 0 at exit (is </span><span class="Special">%zu</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L96" title="jit/llvm/llvmjit.c:96">llvm_jit_context_in_use_count</a>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#if LLVM_VERSION_MAJOR &gt; </span><span class="Constant">11<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L109" title="jit/llvm/llvmjit.c:109">llvm_opt3_orc</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMOrcDisposeLLJIT(<a href="#L109" title="jit/llvm/llvmjit.c:109">llvm_opt3_orc</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L109" title="jit/llvm/llvmjit.c:109">llvm_opt3_orc</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L108" title="jit/llvm/llvmjit.c:108">llvm_opt0_orc</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMOrcDisposeLLJIT(<a href="#L108" title="jit/llvm/llvmjit.c:108">llvm_opt0_orc</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="jit/llvm/llvmjit.c:108">llvm_opt0_orc</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L107" title="jit/llvm/llvmjit.c:107">llvm_ts_context</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMOrcDisposeThreadSafeContext(<a href="#L107" title="jit/llvm/llvmjit.c:107">llvm_ts_context</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="jit/llvm/llvmjit.c:107">llvm_ts_context</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* LLVM_VERSION_MAJOR &gt; 11 */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* unregister profiling support, needs to be flushed to be useful */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L109" title="jit/llvm/llvmjit.c:109">llvm_opt3_orc</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMOrcDisposeInstance(<a href="#L109" title="jit/llvm/llvmjit.c:109">llvm_opt3_orc</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L109" title="jit/llvm/llvmjit.c:109">llvm_opt3_orc</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L108" title="jit/llvm/llvmjit.c:108">llvm_opt0_orc</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LLVMOrcDisposeInstance(<a href="#L108" title="jit/llvm/llvmjit.c:108">llvm_opt0_orc</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="jit/llvm/llvmjit.c:108">llvm_opt0_orc</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* LLVM_VERSION_MAJOR &gt; 11 */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* helper for <a href="#L1090" title="jit/llvm/llvmjit.c:1090">llvm_create_types</a>, returning a function's return type */<br/></li>
<li></span><span class="Type">static</span> LLVMTypeRef<br/></li>
<li><a id="L1051">&#x200c;</a><span class="linkable">load_return_type</span>(LLVMModuleRef mod, <span class="Type">const</span> <span class="Type">char</span> *name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LLVMValueRef value;<br/></li>
<li>&nbsp; &nbsp; LLVMTypeRef typ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* this'll return a *pointer* to the function */<br/></li>
<li></span>&nbsp; &nbsp; value = LLVMGetNamedFunction(mod, name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!value)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;function </span><span class="Special">%s</span><span class="Constant"> is unknown&quot;</span>, name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typ = <a href="llvmjit_wrap.cpp.html#L34" title="jit/llvm/llvmjit_wrap.cpp:34">LLVMGetFunctionReturnType</a>(value); <span class="Comment">/* in llvmjit_wrap.cpp */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> typ;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Load triple &amp; layout from clang emitted file so we're guaranteed to be<br/></li>
<li></span><span class="Comment"> * compatible.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1071">&#x200c;</a></span><span class="linkable">llvm_set_target</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L90" title="jit/llvm/llvmjit.c:90">llvm_types_module</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to extract target information, llvmjit_types.c not loaded&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L100" title="jit/llvm/llvmjit.c:100">llvm_triple</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L100" title="jit/llvm/llvmjit.c:100">llvm_triple</a> = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(LLVMGetTarget(<a href="#L90" title="jit/llvm/llvmjit.c:90">llvm_types_module</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L101" title="jit/llvm/llvmjit.c:101">llvm_layout</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L101" title="jit/llvm/llvmjit.c:101">llvm_layout</a> = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(LLVMGetDataLayoutStr(<a href="#L90" title="jit/llvm/llvmjit.c:90">llvm_types_module</a>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Load required information, types, function signatures from llvmjit_types.c<br/></li>
<li></span><span class="Comment"> * and make them available in global variables.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Those global variables are then used while emitting code.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1090">&#x200c;</a></span><span class="linkable">llvm_create_types</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; LLVMMemoryBufferRef buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *msg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(path, MAXPGPATH, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="../../utils/init/globals.c.html#L79" title="utils/init/globals.c:79">pkglib_path</a>, <span class="Constant">&quot;llvmjit_types.bc&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* open file */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (LLVMCreateMemoryBufferWithContentsOfFile(path, &amp;buf, &amp;msg))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;LLVMCreateMemoryBufferWithContentsOfFile(</span><span class="Special">%s</span><span class="Constant">) failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path, msg);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* eagerly load contents, going to need it all */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (LLVMParseBitcodeInContext2(<a href="#L102" title="jit/llvm/llvmjit.c:102">llvm_context</a>, buf, &amp;<a href="#L90" title="jit/llvm/llvmjit.c:90">llvm_types_module</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;LLVMParseBitcodeInContext2 of </span><span class="Special">%s</span><span class="Constant"> failed&quot;</span>, path);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; LLVMDisposeMemoryBuffer(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_types.c.html#L49" title="jit/llvm/llvmjit_types.c:49">TypeSizeT</a> = <a href="#L454" title="jit/llvm/llvmjit.c:454">llvm_pg_var_type</a>(<span class="Constant">&quot;<a href="llvmjit_types.c.html#L49" title="jit/llvm/llvmjit_types.c:49">TypeSizeT</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="jit/llvm/llvmjit.c:65">TypeParamBool</a> = <a href="#L1051" title="jit/llvm/llvmjit.c:1051">load_return_type</a>(<a href="#L90" title="jit/llvm/llvmjit.c:90">llvm_types_module</a>, <span class="Constant">&quot;<a href="llvmjit_types.c.html#L128" title="jit/llvm/llvmjit_types.c:128">FunctionReturningBool</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_types.c.html#L50" title="jit/llvm/llvmjit_types.c:50">TypeStorageBool</a> = <a href="#L454" title="jit/llvm/llvmjit.c:454">llvm_pg_var_type</a>(<span class="Constant">&quot;<a href="llvmjit_types.c.html#L50" title="jit/llvm/llvmjit_types.c:50">TypeStorageBool</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_types.c.html#L48" title="jit/llvm/llvmjit_types.c:48">TypePGFunction</a> = <a href="#L454" title="jit/llvm/llvmjit.c:454">llvm_pg_var_type</a>(<span class="Constant">&quot;<a href="llvmjit_types.c.html#L48" title="jit/llvm/llvmjit_types.c:48">TypePGFunction</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_types.c.html#L55" title="jit/llvm/llvmjit_types.c:55">StructNullableDatum</a> = <a href="#L454" title="jit/llvm/llvmjit.c:454">llvm_pg_var_type</a>(<span class="Constant">&quot;<a href="llvmjit_types.c.html#L55" title="jit/llvm/llvmjit_types.c:55">StructNullableDatum</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_types.c.html#L59" title="jit/llvm/llvmjit_types.c:59">StructExprContext</a> = <a href="#L454" title="jit/llvm/llvmjit.c:454">llvm_pg_var_type</a>(<span class="Constant">&quot;<a href="llvmjit_types.c.html#L59" title="jit/llvm/llvmjit_types.c:59">StructExprContext</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_types.c.html#L60" title="jit/llvm/llvmjit_types.c:60">StructExprEvalStep</a> = <a href="#L454" title="jit/llvm/llvmjit.c:454">llvm_pg_var_type</a>(<span class="Constant">&quot;<a href="llvmjit_types.c.html#L60" title="jit/llvm/llvmjit_types.c:60">StructExprEvalStep</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_types.c.html#L61" title="jit/llvm/llvmjit_types.c:61">StructExprState</a> = <a href="#L454" title="jit/llvm/llvmjit.c:454">llvm_pg_var_type</a>(<span class="Constant">&quot;<a href="llvmjit_types.c.html#L61" title="jit/llvm/llvmjit_types.c:61">StructExprState</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_types.c.html#L62" title="jit/llvm/llvmjit_types.c:62">StructFunctionCallInfoData</a> = <a href="#L454" title="jit/llvm/llvmjit.c:454">llvm_pg_var_type</a>(<span class="Constant">&quot;<a href="llvmjit_types.c.html#L62" title="jit/llvm/llvmjit_types.c:62">StructFunctionCallInfoData</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_types.c.html#L65" title="jit/llvm/llvmjit_types.c:65">StructMemoryContextData</a> = <a href="#L454" title="jit/llvm/llvmjit.c:454">llvm_pg_var_type</a>(<span class="Constant">&quot;<a href="llvmjit_types.c.html#L65" title="jit/llvm/llvmjit_types.c:65">StructMemoryContextData</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_types.c.html#L66" title="jit/llvm/llvmjit_types.c:66">StructTupleTableSlot</a> = <a href="#L454" title="jit/llvm/llvmjit.c:454">llvm_pg_var_type</a>(<span class="Constant">&quot;<a href="llvmjit_types.c.html#L66" title="jit/llvm/llvmjit_types.c:66">StructTupleTableSlot</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_types.c.html#L67" title="jit/llvm/llvmjit_types.c:67">StructHeapTupleTableSlot</a> = <a href="#L454" title="jit/llvm/llvmjit.c:454">llvm_pg_var_type</a>(<span class="Constant">&quot;<a href="llvmjit_types.c.html#L67" title="jit/llvm/llvmjit_types.c:67">StructHeapTupleTableSlot</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_types.c.html#L68" title="jit/llvm/llvmjit_types.c:68">StructMinimalTupleTableSlot</a> = <a href="#L454" title="jit/llvm/llvmjit.c:454">llvm_pg_var_type</a>(<span class="Constant">&quot;<a href="llvmjit_types.c.html#L68" title="jit/llvm/llvmjit_types.c:68">StructMinimalTupleTableSlot</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_types.c.html#L63" title="jit/llvm/llvmjit_types.c:63">StructHeapTupleData</a> = <a href="#L454" title="jit/llvm/llvmjit.c:454">llvm_pg_var_type</a>(<span class="Constant">&quot;<a href="llvmjit_types.c.html#L63" title="jit/llvm/llvmjit_types.c:63">StructHeapTupleData</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_types.c.html#L64" title="jit/llvm/llvmjit_types.c:64">StructHeapTupleHeaderData</a> = <a href="#L454" title="jit/llvm/llvmjit.c:454">llvm_pg_var_type</a>(<span class="Constant">&quot;<a href="llvmjit_types.c.html#L64" title="jit/llvm/llvmjit_types.c:64">StructHeapTupleHeaderData</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_types.c.html#L69" title="jit/llvm/llvmjit_types.c:69">StructTupleDescData</a> = <a href="#L454" title="jit/llvm/llvmjit.c:454">llvm_pg_var_type</a>(<span class="Constant">&quot;<a href="llvmjit_types.c.html#L69" title="jit/llvm/llvmjit_types.c:69">StructTupleDescData</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_types.c.html#L56" title="jit/llvm/llvmjit_types.c:56">StructAggState</a> = <a href="#L454" title="jit/llvm/llvmjit.c:454">llvm_pg_var_type</a>(<span class="Constant">&quot;<a href="llvmjit_types.c.html#L56" title="jit/llvm/llvmjit_types.c:56">StructAggState</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_types.c.html#L57" title="jit/llvm/llvmjit_types.c:57">StructAggStatePerGroupData</a> = <a href="#L454" title="jit/llvm/llvmjit.c:454">llvm_pg_var_type</a>(<span class="Constant">&quot;<a href="llvmjit_types.c.html#L57" title="jit/llvm/llvmjit_types.c:57">StructAggStatePerGroupData</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_types.c.html#L58" title="jit/llvm/llvmjit_types.c:58">StructAggStatePerTransData</a> = <a href="#L454" title="jit/llvm/llvmjit.c:454">llvm_pg_var_type</a>(<span class="Constant">&quot;<a href="llvmjit_types.c.html#L58" title="jit/llvm/llvmjit_types.c:58">StructAggStatePerTransData</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_types.c.html#L70" title="jit/llvm/llvmjit_types.c:70">StructPlanState</a> = <a href="#L454" title="jit/llvm/llvmjit.c:454">llvm_pg_var_type</a>(<span class="Constant">&quot;<a href="llvmjit_types.c.html#L70" title="jit/llvm/llvmjit_types.c:70">StructPlanState</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_types.c.html#L71" title="jit/llvm/llvmjit_types.c:71">StructMinimalTupleData</a> = <a href="#L454" title="jit/llvm/llvmjit.c:454">llvm_pg_var_type</a>(<span class="Constant">&quot;<a href="llvmjit_types.c.html#L71" title="jit/llvm/llvmjit_types.c:71">StructMinimalTupleData</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_types.c.html#L81" title="jit/llvm/llvmjit_types.c:81">AttributeTemplate</a> = LLVMGetNamedFunction(<a href="#L90" title="jit/llvm/llvmjit.c:90">llvm_types_module</a>, <span class="Constant">&quot;<a href="llvmjit_types.c.html#L81" title="jit/llvm/llvmjit_types.c:81">AttributeTemplate</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_types.c.html#L97" title="jit/llvm/llvmjit_types.c:97">ExecEvalSubroutineTemplate</a> = LLVMGetNamedFunction(<a href="#L90" title="jit/llvm/llvmjit.c:90">llvm_types_module</a>, <span class="Constant">&quot;<a href="llvmjit_types.c.html#L97" title="jit/llvm/llvmjit_types.c:97">ExecEvalSubroutineTemplate</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="llvmjit_types.c.html#L109" title="jit/llvm/llvmjit_types.c:109">ExecEvalBoolSubroutineTemplate</a> = LLVMGetNamedFunction(<a href="#L90" title="jit/llvm/llvmjit.c:90">llvm_types_module</a>, <span class="Constant">&quot;<a href="llvmjit_types.c.html#L109" title="jit/llvm/llvmjit_types.c:109">ExecEvalBoolSubroutineTemplate</a>&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Split a symbol into module / function parts.&nbsp; If the function is in the<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> binary (or an external library) *modname will be NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1144">&#x200c;</a></span><span class="linkable">llvm_split_symbol_name</span>(<span class="Type">const</span> <span class="Type">char</span> *name, <span class="Type">char</span> **modname, <span class="Type">char</span> **funcname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; *modname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; *funcname = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Module function names are pgextern.$module.$funcname<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strncmp(name, <span class="Constant">&quot;pgextern.&quot;</span>, strlen(<span class="Constant">&quot;pgextern.&quot;</span>)) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Symbol names cannot contain a ., therefore we can split based on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first and last occurrence of one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *funcname = rindex(name, <span class="Constant">'.'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*funcname)++;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* jump over . */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *modname = <a href="../../utils/mmgr/mcxt.c.html#L1706" title="utils/mmgr/mcxt.c:1706">pnstrdup</a>(name + strlen(<span class="Constant">&quot;pgextern.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *funcname - name - strlen(<span class="Constant">&quot;pgextern.&quot;</span>) - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(funcname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *funcname = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(*funcname);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *modname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *funcname = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(name);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Attempt to resolve symbol, so LLVM can emit a reference to it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">uint64_t<br/></li>
<li><a id="L1178">&#x200c;</a></span><span class="linkable">llvm_resolve_symbol</span>(<span class="Type">const</span> <span class="Type">char</span> *symname, <span class="Type">void</span> *ctx)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">uintptr_t</span>&nbsp; &nbsp; addr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *funcname;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *modname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * macOS <a href="../../regex/regc_lex.c.html#L99" title="regex/regc_lex.c:99">prefixes</a> all object level symbols with an underscore. But neither<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dlsym() nor PG's inliner expect that. So undo.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#if defined(__darwin__)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (symname[<span class="Constant">0</span>] != <span class="Constant">'<a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;expected prefixed symbol name, but got </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, symname);<br/></li>
<li>&nbsp; &nbsp; symname++;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L1144" title="jit/llvm/llvmjit.c:1144">llvm_split_symbol_name</a>(symname, &amp;modname, &amp;funcname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that aren't resolved to names shouldn't ever get here */<br/></li>
<li></span>&nbsp; &nbsp; Assert(funcname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (modname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; addr = (<span class="Type">uintptr_t</span>) <a href="../../utils/fmgr/dfmgr.c.html#L105" title="utils/fmgr/dfmgr.c:105">load_external_function</a>(modname, funcname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; addr = (<span class="Type">uintptr_t</span>) LLVMSearchForAddressOfSymbol(symname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(funcname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (modname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(modname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* let LLVM will error out - should never happen */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!addr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;failed to resolve name </span><span class="Special">%s</span><span class="Constant">&quot;</span>, symname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">uint64_t</span>) addr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#if LLVM_VERSION_MAJOR &gt; </span><span class="Constant">11<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> LLVMErrorRef<br/></li>
<li><a id="L1219">&#x200c;</a><span class="linkable">llvm_resolve_symbols</span>(LLVMOrcDefinitionGeneratorRef GeneratorObj, <span class="Type">void</span> *Ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LLVMOrcLookupStateRef *LookupState, LLVMOrcLookupKind Kind,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LLVMOrcJITDylibRef JD, LLVMOrcJITDylibLookupFlags JDLookupFlags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LLVMOrcCLookupSet LookupSet, <span class="Type">size_t</span> LookupSetSize)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#if LLVM_VERSION_MAJOR &gt; </span><span class="Constant">14<br/></li>
<li></span>&nbsp; &nbsp; LLVMOrcCSymbolMapPairs symbols = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LLVMOrcCSymbolMapPair) * LookupSetSize);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; LLVMOrcCSymbolMapPairs symbols = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LLVMJITCSymbolMapPair) * LookupSetSize);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; LLVMErrorRef error;<br/></li>
<li>&nbsp; &nbsp; LLVMOrcMaterializationUnitRef mu;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; LookupSetSize; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *name = LLVMOrcSymbolStringPoolEntryStr(LookupSet[i].Name);<br/></li>
<li><br/></li>
<li><span class="PreProc">#if LLVM_VERSION_MAJOR &gt; </span><span class="Constant">12<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; LLVMOrcRetainSymbolStringPoolEntry(LookupSet[i].Name);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; symbols[i].Name = LookupSet[i].Name;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; symbols[i].Sym.Address = <a href="#L1178" title="jit/llvm/llvmjit.c:1178">llvm_resolve_symbol</a>(name, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; symbols[i].Sym.Flags.GenericFlags = LLVMJITSymbolGenericFlagsExported;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mu = LLVMOrcAbsoluteSymbols(symbols, LookupSetSize);<br/></li>
<li>&nbsp; &nbsp; error = LLVMOrcJITDylibDefine(JD, mu);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (error != LLVMErrorSuccess)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMOrcDisposeMaterializationUnit(mu);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(symbols);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> error;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We cannot throw errors through LLVM (without causing a FATAL at least), so<br/></li>
<li></span><span class="Comment"> * just use WARNING here. That's OK anyway, as the error is also reported at<br/></li>
<li></span><span class="Comment"> * the top level action (with less detail) and there might be multiple<br/></li>
<li></span><span class="Comment"> * invocations of errors with details.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This doesn't really happen during normal operation, but in cases like<br/></li>
<li></span><span class="Comment"> * symbol resolution breakage. So just using elog(WARNING) is fine.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1264">&#x200c;</a></span><span class="linkable">llvm_log_jit_error</span>(<span class="Type">void</span> *ctx, LLVMErrorRef error)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;error during JITing: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1357" title="jit/llvm/llvmjit.c:1357">llvm_error_message</a>(error));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create our own object layer, so we can add event listeners.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> LLVMOrcObjectLayerRef<br/></li>
<li><a id="L1274">&#x200c;</a><span class="linkable">llvm_create_object_layer</span>(<span class="Type">void</span> *Ctx, LLVMOrcExecutionSessionRef ES, <span class="Type">const</span> <span class="Type">char</span> *Triple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LLVMOrcObjectLayerRef objlayer =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMOrcCreateRTDyldObjectLinkingLayerWithSectionMemoryManager(ES);<br/></li>
<li><br/></li>
<li><span class="PreProc">#if defined(HAVE_DECL_LLVMCREATEGDBREGISTRATIONLISTENER) &amp;&amp; HAVE_DECL_LLVMCREATEGDBREGISTRATIONLISTENER<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../jit.c.html#L34" title="jit/jit.c:34">jit_debugging_support</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMJITEventListenerRef l = LLVMCreateGDBRegistrationListener();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMOrcRTDyldObjectLinkingLayerRegisterJITEventListener(objlayer, l);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#if defined(HAVE_DECL_LLVMCREATEPERFJITEVENTLISTENER) &amp;&amp; HAVE_DECL_LLVMCREATEPERFJITEVENTLISTENER<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../jit.c.html#L37" title="jit/jit.c:37">jit_profiling_support</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMJITEventListenerRef l = LLVMCreatePerfJITEventListener();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LLVMOrcRTDyldObjectLinkingLayerRegisterJITEventListener(objlayer, l);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> objlayer;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create LLJIT instance, using the passed in target machine. Note that the<br/></li>
<li></span><span class="Comment"> * target machine afterwards is owned by the LLJIT instance.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> LLVMOrcLLJITRef<br/></li>
<li><a id="L1305">&#x200c;</a><span class="linkable">llvm_create_jit_instance</span>(LLVMTargetMachineRef tm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LLVMOrcLLJITRef lljit;<br/></li>
<li>&nbsp; &nbsp; LLVMOrcJITTargetMachineBuilderRef tm_builder;<br/></li>
<li>&nbsp; &nbsp; LLVMOrcLLJITBuilderRef lljit_builder;<br/></li>
<li>&nbsp; &nbsp; LLVMErrorRef error;<br/></li>
<li>&nbsp; &nbsp; LLVMOrcDefinitionGeneratorRef main_gen;<br/></li>
<li>&nbsp; &nbsp; LLVMOrcDefinitionGeneratorRef ref_gen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lljit_builder = LLVMOrcCreateLLJITBuilder();<br/></li>
<li>&nbsp; &nbsp; tm_builder = LLVMOrcJITTargetMachineBuilderCreateFromTargetMachine(tm);<br/></li>
<li>&nbsp; &nbsp; LLVMOrcLLJITBuilderSetJITTargetMachineBuilder(lljit_builder, tm_builder);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LLVMOrcLLJITBuilderSetObjectLinkingLayerCreator(lljit_builder,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1274" title="jit/llvm/llvmjit.c:1274">llvm_create_object_layer</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; error = LLVMOrcCreateLLJIT(&amp;lljit, lljit_builder);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (error)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to create lljit instance: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1357" title="jit/llvm/llvmjit.c:1357">llvm_error_message</a>(error));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LLVMOrcExecutionSessionSetErrorReporter(LLVMOrcLLJITGetExecutionSession(lljit),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1264" title="jit/llvm/llvmjit.c:1264">llvm_log_jit_error</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Symbol resolution support for symbols in the postgres binary /<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * libraries already loaded.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; error = LLVMOrcCreateDynamicLibrarySearchGeneratorForProcess(&amp;main_gen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LLVMOrcLLJITGetGlobalPrefix(lljit),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (error)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to create generator: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1357" title="jit/llvm/llvmjit.c:1357">llvm_error_message</a>(error));<br/></li>
<li>&nbsp; &nbsp; LLVMOrcJITDylibAddGenerator(LLVMOrcLLJITGetMainJITDylib(lljit), main_gen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Symbol resolution support for &quot;special&quot; <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, e.g. a call into an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SQL callable function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#if LLVM_VERSION_MAJOR &gt; </span><span class="Constant">14<br/></li>
<li></span>&nbsp; &nbsp; ref_gen = LLVMOrcCreateCustomCAPIDefinitionGenerator(<a href="#L1219" title="jit/llvm/llvmjit.c:1219">llvm_resolve_symbols</a>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; ref_gen = LLVMOrcCreateCustomCAPIDefinitionGenerator(<a href="#L1219" title="jit/llvm/llvmjit.c:1219">llvm_resolve_symbols</a>, <span class="Constant">NULL</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; LLVMOrcJITDylibAddGenerator(LLVMOrcLLJITGetMainJITDylib(lljit), ref_gen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> lljit;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1357">&#x200c;</a><span class="linkable">llvm_error_message</span>(LLVMErrorRef error)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *orig = LLVMGetErrorMessage(error);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *msg = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(orig);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LLVMDisposeErrorMessage(orig);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> msg;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* LLVM_VERSION_MAJOR &gt; 11 */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ResourceOwner callbacks<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1373">&#x200c;</a></span><span class="linkable">ResOwnerReleaseJitContext</span>(Datum res)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JitContext *context = (JitContext *) DatumGetPointer(res);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context-&gt;resowner = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../jit.c.html#L137" title="jit/jit.c:137">jit_release_context</a>(context);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
