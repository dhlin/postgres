<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>replication/walsender.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>replication/walsender.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L112">MyWalSnd</a></li>
<li><a href="#L194">WalSndCaughtUp</a></li>
<li><a href="#L109">WalSndCtl</a></li>
<li><a href="#L116">am_cascading_walsender</a></li>
<li><a href="#L118">am_db_walsender</a></li>
<li><a href="#L115">am_walsender</a></li>
<li><a href="#L197">got_SIGUSR2</a></li>
<li><a href="#L198">got_STOPPING</a></li>
<li><a href="#L230">lag_tracker</a></li>
<li><a href="#L173">last_processing</a></li>
<li><a href="#L179">last_reply_timestamp</a></li>
<li><a href="#L125">log_replication_commands</a></li>
<li><a href="#L208">logical_decoding_ctx</a></li>
<li><a href="#L121">max_wal_senders</a></li>
<li><a href="#L168">output_message</a></li>
<li><a href="#L206">replication_active</a></li>
<li><a href="#L169">reply_message</a></li>
<li><a href="#L156">sendTimeLine</a></li>
<li><a href="#L158">sendTimeLineIsHistoric</a></li>
<li><a href="#L157">sendTimeLineNextTLI</a></li>
<li><a href="#L159">sendTimeLineValidUpto</a></li>
<li><a href="#L165">sentPtr</a></li>
<li><a href="#L191">streamingDoneReceiving</a></li>
<li><a href="#L190">streamingDoneSending</a></li>
<li><a href="#L170">tmpbuf</a></li>
<li><a href="#L147">uploaded_manifest</a></li>
<li><a href="#L148">uploaded_manifest_mcxt</a></li>
<li><a href="#L182">waiting_for_ping_response</a></li>
<li><a href="#L130">wake_wal_senders</a></li>
<li><a href="#L123">wal_sender_timeout</a></li>
<li><a href="#L137">xlogreader</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L228">LagTracker</a></li>
<li><a href="#L236">WalSndSendDataCallback</a></li>
<li><a href="#L215">WalTimeSample</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1439">AlterReplicationSlot</a></li>
<li><a href="#L1200">CreateReplicationSlot</a></li>
<li><a href="#L1405">DropReplicationSlot</a></li>
<li><a href="#L3504">GetStandbyFlushRecPtr</a></li>
<li><a href="#L743">HandleUploadManifestPacket</a></li>
<li><a href="#L3560">HandleWalSndInitStopping</a></li>
<li><a href="#L407">IdentifySystem</a></li>
<li><a href="#L278">InitWalSender</a></li>
<li><a href="#L2893">InitWalSenderSlot</a></li>
<li><a href="#L4160">LagTrackerRead</a></li>
<li><a href="#L4095">LagTrackerWrite</a></li>
<li><a href="#L1758">NeedToWaitForStandbys</a></li>
<li><a href="#L1790">NeedToWaitForWal</a></li>
<li><a href="#L1414">ParseAlterReplSlotOptions</a></li>
<li><a href="#L2354">PhysicalConfirmReceivedLocation</a></li>
<li><a href="#L2492">PhysicalReplicationSlotNewXmin</a></li>
<li><a href="#L1733">PhysicalWakeupLogicalWalSnd</a></li>
<li><a href="#L1614">ProcessPendingWrites</a></li>
<li><a href="#L2210">ProcessRepliesIfAny</a></li>
<li><a href="#L2572">ProcessStandbyHSFeedbackMessage</a></li>
<li><a href="#L2323">ProcessStandbyMessage</a></li>
<li><a href="#L2387">ProcessStandbyReplyMessage</a></li>
<li><a href="#L490">ReadReplicationSlot</a></li>
<li><a href="#L589">SendTimeLineHistory</a></li>
<li><a href="#L1452">StartLogicalReplication</a></li>
<li><a href="#L819">StartReplication</a></li>
<li><a href="#L2541">TransactionIdInRecentPast</a></li>
<li><a href="#L679">UploadManifest</a></li>
<li><a href="#L2740">WalSndCheckTimeOut</a></li>
<li><a href="#L2696">WalSndComputeSleeptime</a></li>
<li><a href="#L3461">WalSndDone</a></li>
<li><a href="#L327">WalSndErrorCleanup</a></li>
<li><a href="#L3828">WalSndGetStateString</a></li>
<li><a href="#L3745">WalSndInitStopping</a></li>
<li><a href="#L4034">WalSndKeepalive</a></li>
<li><a href="#L4057">WalSndKeepaliveIfNecessary</a></li>
<li><a href="#L2970">WalSndKill</a></li>
<li><a href="#L3582">WalSndLastCycleHandler</a></li>
<li><a href="#L2767">WalSndLoop</a></li>
<li><a href="#L1545">WalSndPrepareWrite</a></li>
<li><a href="#L362">WalSndResourceCleanup</a></li>
<li><a href="#L3537">WalSndRqstFileReload</a></li>
<li><a href="#L2988">WalSndSegmentOpen</a></li>
<li><a href="#L3809">WalSndSetState</a></li>
<li><a href="#L3621">WalSndShmemInit</a></li>
<li><a href="#L3609">WalSndShmemSize</a></li>
<li><a href="#L390">WalSndShutdown</a></li>
<li><a href="#L3590">WalSndSignals</a></li>
<li><a href="#L1668">WalSndUpdateProgress</a></li>
<li><a href="#L3687">WalSndWait</a></li>
<li><a href="#L1818">WalSndWaitForWal</a></li>
<li><a href="#L3771">WalSndWaitStopping</a></li>
<li><a href="#L3666">WalSndWakeup</a></li>
<li><a href="#L1572">WalSndWriteData</a></li>
<li><a href="#L3376">XLogSendLogical</a></li>
<li><a href="#L3066">XLogSendPhysical</a></li>
<li><a href="#L1977">exec_replication_command</a></li>
<li><a href="#L1051">logical_read_xlog_page</a></li>
<li><a href="#L3847">offset_to_interval</a></li>
<li><a href="#L1123">parseCreateReplSlotOptions</a></li>
<li><a href="#L3863">pg_stat_get_wal_senders</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L218">LAG_TRACKER_BUFFER_SIZE</a></li>
<li><a href="#L106">MAX_SEND_SIZE</a></li>
<li><a href="#L3865">PG_STAT_GET_WAL_SENDERS_COLS</a></li>
<li><a href="#L492">READ_REPLICATION_SLOT_COLS</a></li>
<li><a href="#L1684">WALSND_LOGICAL_LAG_TRACK_INTERVAL_MS</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * walsender.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The WAL sender process (walsender) is new as of Postgres 9.0. It takes<br/></li>
<li></span><span class="Comment"> * care of sending XLOG from the primary server to a single recipient.<br/></li>
<li></span><span class="Comment"> * (Note that there can be more than one walsender process concurrently.)<br/></li>
<li></span><span class="Comment"> * It is started by the postmaster when the walreceiver of a standby server<br/></li>
<li></span><span class="Comment"> * connects to the primary server and requests XLOG streaming replication.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A walsender is similar to a regular backend, ie. there is a one-to-one<br/></li>
<li></span><span class="Comment"> * relationship between a connection and a walsender process, but instead<br/></li>
<li></span><span class="Comment"> * of processing SQL queries, it understands a small set of special<br/></li>
<li></span><span class="Comment"> * replication-mode commands. The START_REPLICATION command begins streaming<br/></li>
<li></span><span class="Comment"> * WAL to the client. While streaming, the walsender keeps reading XLOG<br/></li>
<li></span><span class="Comment"> * <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> from the disk and sends them to the standby server over the<br/></li>
<li></span><span class="Comment"> * COPY protocol, until either side ends the replication by exiting COPY<br/></li>
<li></span><span class="Comment"> * mode (or until the connection is closed).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Normal termination is by SIGTERM, which instructs the walsender to<br/></li>
<li></span><span class="Comment"> * close the connection and exit(0) at the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> convenient moment. Emergency<br/></li>
<li></span><span class="Comment"> * termination is by SIGQUIT; like <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> backend, the walsender will simply<br/></li>
<li></span><span class="Comment"> * abort and exit on SIGQUIT. A close of the connection and a FATAL error<br/></li>
<li></span><span class="Comment"> * are treated as not a crash but approximately normal termination;<br/></li>
<li></span><span class="Comment"> * the walsender will exit quickly without sending <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more XLOG <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the server is shut down, checkpointer sends us<br/></li>
<li></span><span class="Comment"> * PROCSIG_WALSND_INIT_STOPPING after all regular backends have exited.&nbsp; If<br/></li>
<li></span><span class="Comment"> * the backend is idle or runs an SQL query this causes the backend to<br/></li>
<li></span><span class="Comment"> * shutdown, if logical replication is in progress all existing WAL <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a><br/></li>
<li></span><span class="Comment"> * are processed followed by a shutdown.&nbsp; Otherwise this causes the walsender<br/></li>
<li></span><span class="Comment"> * to switch to the &quot;stopping&quot; state. In this state, the walsender will reject<br/></li>
<li></span><span class="Comment"> * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> further replication commands. The checkpointer begins the shutdown<br/></li>
<li></span><span class="Comment"> * checkpoint once all walsenders are confirmed as stopping. When the shutdown<br/></li>
<li></span><span class="Comment"> * checkpoint finishes, the postmaster sends us SIGUSR2. This instructs<br/></li>
<li></span><span class="Comment"> * walsender to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outstanding WAL, including the shutdown checkpoint<br/></li>
<li></span><span class="Comment"> * record, wait for it to be replicated to the standby, and then exit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 2010-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/replication/walsender.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;signal.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/timeline.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog_internal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/<a href="#L137" title="replication/walsender.c:137">xlogreader</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogrecovery.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;backup/basebackup.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;backup/basebackup_incremental.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_authid.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/dbcommands.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/defrem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/libpq.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/replnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/interrupt.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/decode.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/logical.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/slotsync.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/slot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/snapbuild.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/syncrep.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/walreceiver.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/walsender.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/walsender_private.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/condition_variable.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/pmsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/dest.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/tcopprot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/acl.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pg_lsn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/ps_status.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timeout.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timestamp.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Maximum data payload in a WAL data message.&nbsp; Must be &gt;= XLOG_BLCKSZ.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We don't have a good idea of what a good value would be; there's some<br/></li>
<li></span><span class="Comment"> * overhead per message in both walsender and walreceiver, but on the other<br/></li>
<li></span><span class="Comment"> * hand sending large batches makes walsender less responsive to signals<br/></li>
<li></span><span class="Comment"> * because signals are checked only between messages.&nbsp; 128kB (with<br/></li>
<li></span><span class="Comment"> * default 8k blocks) seems like a reasonable guess for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L106">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_SEND_SIZE</span> (XLOG_BLCKSZ * </span><span class="Constant">16</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Array of WalSnds in shared memory */<br/></li>
<li><a id="L109">&#x200c;</a></span>WalSndCtlData *<span class="linkable">WalSndCtl</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* My slot in the shared memory array */<br/></li>
<li><a id="L112">&#x200c;</a></span>WalSnd&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">MyWalSnd</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Global state */<br/></li>
<li><a id="L115">&#x200c;</a></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">am_walsender</span> = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* Am I a walsender process? */<br/></li>
<li><a id="L116">&#x200c;</a></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">am_cascading_walsender</span> = <span class="Constant">false</span>; <span class="Comment">/* Am I cascading WAL to another<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * standby? */<br/></li>
<li><a id="L118">&#x200c;</a></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">am_db_walsender</span> = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* Connected to a database? */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* GUC variables */<br/></li>
<li><a id="L121">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">max_wal_senders</span> = <span class="Constant">10</span>;&nbsp; &nbsp; <span class="Comment">/* the maximum number of concurrent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * walsenders */<br/></li>
<li><a id="L123">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">wal_sender_timeout</span> = <span class="Constant">60</span> * <span class="Constant">1000</span>; <span class="Comment">/* maximum time to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> one WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * data message */<br/></li>
<li><a id="L125">&#x200c;</a></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">log_replication_commands</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * State for WalSndWakeupRequest<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L130">&#x200c;</a></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">wake_wal_senders</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L137" title="replication/walsender.c:137">xlogreader</a> used for replication.&nbsp; Note that a WAL sender doing physical<br/></li>
<li></span><span class="Comment"> * replication does not need <a href="#L137" title="replication/walsender.c:137">xlogreader</a> to read WAL, but it needs one to<br/></li>
<li></span><span class="Comment"> * keep a state of its work.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L137">&#x200c;</a></span><span class="Type">static</span> XLogReaderState *<span class="linkable">xlogreader</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * If the UPLOAD_MANIFEST command is used to provide a backup manifest in<br/></li>
<li></span><span class="Comment"> * preparation for an incremental backup, <a href="#L147" title="replication/walsender.c:147">uploaded_manifest</a> will be point<br/></li>
<li></span><span class="Comment"> * to an object containing information about its contexts, and<br/></li>
<li></span><span class="Comment"> * <a href="#L148" title="replication/walsender.c:148">uploaded_manifest_mcxt</a> will point to the memory context that contains<br/></li>
<li></span><span class="Comment"> * that object and all of its subordinate data. Otherwise, both <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> will<br/></li>
<li></span><span class="Comment"> * be NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L147">&#x200c;</a></span><span class="Type">static</span> <a href="../backup/basebackup_incremental.c.html#L76" title="backup/basebackup_incremental.c:76">IncrementalBackupInfo</a> *<span class="linkable">uploaded_manifest</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L148">&#x200c;</a><span class="Type">static</span> MemoryContext <span class="linkable">uploaded_manifest_mcxt</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * These variables keep track of the state of the timeline we're currently<br/></li>
<li></span><span class="Comment"> * sending. <a href="#L156" title="replication/walsender.c:156">sendTimeLine</a> identifies the timeline. If <a href="#L158" title="replication/walsender.c:158">sendTimeLineIsHistoric</a>,<br/></li>
<li></span><span class="Comment"> * the timeline is not the latest timeline on this server, and the server's<br/></li>
<li></span><span class="Comment"> * history forked off from that timeline at <a href="#L159" title="replication/walsender.c:159">sendTimeLineValidUpto</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L156">&#x200c;</a></span><span class="Type">static</span> TimeLineID <span class="linkable">sendTimeLine</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L157">&#x200c;</a><span class="Type">static</span> TimeLineID <span class="linkable">sendTimeLineNextTLI</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L158">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">sendTimeLineIsHistoric</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L159">&#x200c;</a><span class="Type">static</span> XLogRecPtr <span class="linkable">sendTimeLineValidUpto</span> = InvalidXLogRecPtr;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * How far have we sent WAL already? This is also advertised in<br/></li>
<li></span><span class="Comment"> * <a href="#L112" title="replication/walsender.c:112">MyWalSnd</a>-&gt;<a href="#L165" title="replication/walsender.c:165">sentPtr</a>.&nbsp; (Actually, this is the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> WAL location to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a>.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L165">&#x200c;</a></span><span class="Type">static</span> XLogRecPtr <span class="linkable">sentPtr</span> = InvalidXLogRecPtr;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Buffers for constructing outgoing messages and processing reply messages. */<br/></li>
<li><a id="L168">&#x200c;</a></span><span class="Type">static</span> StringInfoData <span class="linkable">output_message</span>;<br/></li>
<li><a id="L169">&#x200c;</a><span class="Type">static</span> StringInfoData <span class="linkable">reply_message</span>;<br/></li>
<li><a id="L170">&#x200c;</a><span class="Type">static</span> StringInfoData <span class="linkable">tmpbuf</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Timestamp of last <a href="#L2210" title="replication/walsender.c:2210">ProcessRepliesIfAny</a>(). */<br/></li>
<li><a id="L173">&#x200c;</a></span><span class="Type">static</span> TimestampTz <span class="linkable">last_processing</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Timestamp of last <a href="#L2210" title="replication/walsender.c:2210">ProcessRepliesIfAny</a>() that saw a reply from the<br/></li>
<li></span><span class="Comment"> * standby. Set to 0 if <a href="#L123" title="replication/walsender.c:123">wal_sender_timeout</a> doesn't need to be active.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L179">&#x200c;</a></span><span class="Type">static</span> TimestampTz <span class="linkable">last_reply_timestamp</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Have we sent a heartbeat message asking for reply, since last reply? */<br/></li>
<li><a id="L182">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">waiting_for_ping_response</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * While streaming WAL in Copy mode, <a href="#L190" title="replication/walsender.c:190">streamingDoneSending</a> is set to true<br/></li>
<li></span><span class="Comment"> * after we have sent CopyDone. We should not <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more CopyData messages<br/></li>
<li></span><span class="Comment"> * after that. <a href="#L191" title="replication/walsender.c:191">streamingDoneReceiving</a> is set to true when we receive CopyDone<br/></li>
<li></span><span class="Comment"> * from the other end. When both become true, it's time to exit Copy mode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L190">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">streamingDoneSending</span>;<br/></li>
<li><a id="L191">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">streamingDoneReceiving</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Are we there yet? */<br/></li>
<li><a id="L194">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">WalSndCaughtUp</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Flags set by signal handlers for later service in <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop */<br/></li>
<li><a id="L197">&#x200c;</a></span><span class="Type">static</span> <span class="Type">volatile</span> <span class="Type">sig_atomic_t</span> <span class="linkable">got_SIGUSR2</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L198">&#x200c;</a><span class="Type">static</span> <span class="Type">volatile</span> <span class="Type">sig_atomic_t</span> <span class="linkable">got_STOPPING</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This is set while we are streaming. When not set<br/></li>
<li></span><span class="Comment"> * PROCSIG_WALSND_INIT_STOPPING signal will be handled like SIGTERM. When set,<br/></li>
<li></span><span class="Comment"> * the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop is responsible for checking <a href="#L198" title="replication/walsender.c:198">got_STOPPING</a> and terminating when<br/></li>
<li></span><span class="Comment"> * it's set (after streaming <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining WAL).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L206">&#x200c;</a></span><span class="Type">static</span> <span class="Type">volatile</span> <span class="Type">sig_atomic_t</span> <span class="linkable">replication_active</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><a id="L208">&#x200c;</a><span class="Type">static</span> LogicalDecodingContext *<span class="linkable">logical_decoding_ctx</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* A sample associating a WAL location with the time it was written. */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn;<br/></li>
<li>&nbsp; &nbsp; TimestampTz time;<br/></li>
<li><a id="L215">&#x200c;</a>} <span class="linkable">WalTimeSample</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* The size of our buffer of time samples. */<br/></li>
<li><a id="L218">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LAG_TRACKER_BUFFER_SIZE</span> </span><span class="Constant">8192<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* A mechanism for tracking replication lag. */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; last_lsn;<br/></li>
<li>&nbsp; &nbsp; <a href="#L215" title="replication/walsender.c:215">WalTimeSample</a> buffer[<a href="#L218" title="replication/walsender.c:218">LAG_TRACKER_BUFFER_SIZE</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; write_head;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; read_heads[NUM_SYNC_REP_WAIT_MODE];<br/></li>
<li>&nbsp; &nbsp; <a href="#L215" title="replication/walsender.c:215">WalTimeSample</a> last_read[NUM_SYNC_REP_WAIT_MODE];<br/></li>
<li><a id="L228">&#x200c;</a>} <span class="linkable">LagTracker</span>;<br/></li>
<li><br/></li>
<li><a id="L230">&#x200c;</a><span class="Type">static</span> <a href="#L228" title="replication/walsender.c:228">LagTracker</a> *<span class="linkable">lag_tracker</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Signal handlers */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L3582" title="replication/walsender.c:3582">WalSndLastCycleHandler</a>(SIGNAL_ARGS);<br/></li>
<li><br/></li>
<li><span class="Comment">/* Prototypes for private <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li><a id="L236">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">void</span> (*<span class="linkable">WalSndSendDataCallback</span>) (<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2767" title="replication/walsender.c:2767">WalSndLoop</a>(<a href="#L236" title="replication/walsender.c:236">WalSndSendDataCallback</a> send_data);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2893" title="replication/walsender.c:2893">InitWalSenderSlot</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2970" title="replication/walsender.c:2970">WalSndKill</a>(<span class="Type">int</span> code, Datum arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L390" title="replication/walsender.c:390">WalSndShutdown</a>(<span class="Type">void</span>) pg_attribute_noreturn();<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3066" title="replication/walsender.c:3066">XLogSendPhysical</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3376" title="replication/walsender.c:3376">XLogSendLogical</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3461" title="replication/walsender.c:3461">WalSndDone</a>(<a href="#L236" title="replication/walsender.c:236">WalSndSendDataCallback</a> send_data);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L407" title="replication/walsender.c:407">IdentifySystem</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L679" title="replication/walsender.c:679">UploadManifest</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L743" title="replication/walsender.c:743">HandleUploadManifestPacket</a>(StringInfo buf, <span class="Type">off_t</span> *offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../backup/basebackup_incremental.c.html#L76" title="backup/basebackup_incremental.c:76">IncrementalBackupInfo</a> *ib);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L490" title="replication/walsender.c:490">ReadReplicationSlot</a>(ReadReplicationSlotCmd *cmd);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1200" title="replication/walsender.c:1200">CreateReplicationSlot</a>(CreateReplicationSlotCmd *cmd);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1405" title="replication/walsender.c:1405">DropReplicationSlot</a>(DropReplicationSlotCmd *cmd);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L819" title="replication/walsender.c:819">StartReplication</a>(StartReplicationCmd *cmd);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1452" title="replication/walsender.c:1452">StartLogicalReplication</a>(StartReplicationCmd *cmd);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2323" title="replication/walsender.c:2323">ProcessStandbyMessage</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2387" title="replication/walsender.c:2387">ProcessStandbyReplyMessage</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2572" title="replication/walsender.c:2572">ProcessStandbyHSFeedbackMessage</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2210" title="replication/walsender.c:2210">ProcessRepliesIfAny</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1614" title="replication/walsender.c:1614">ProcessPendingWrites</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4034" title="replication/walsender.c:4034">WalSndKeepalive</a>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> requestReply, XLogRecPtr writePtr);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4057" title="replication/walsender.c:4057">WalSndKeepaliveIfNecessary</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2740" title="replication/walsender.c:2740">WalSndCheckTimeOut</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">long</span> <a href="#L2696" title="replication/walsender.c:2696">WalSndComputeSleeptime</a>(TimestampTz <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3687" title="replication/walsender.c:3687">WalSndWait</a>(uint32 socket_events, <span class="Type">long</span> timeout, uint32 wait_event);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1545" title="replication/walsender.c:1545">WalSndPrepareWrite</a>(LogicalDecodingContext *ctx, XLogRecPtr lsn, TransactionId xid, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> last_write);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1572" title="replication/walsender.c:1572">WalSndWriteData</a>(LogicalDecodingContext *ctx, XLogRecPtr lsn, TransactionId xid, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> last_write);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1668" title="replication/walsender.c:1668">WalSndUpdateProgress</a>(LogicalDecodingContext *ctx, XLogRecPtr lsn, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skipped_xact);<br/></li>
<li><span class="Type">static</span> XLogRecPtr <a href="#L1818" title="replication/walsender.c:1818">WalSndWaitForWal</a>(XLogRecPtr loc);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4095" title="replication/walsender.c:4095">LagTrackerWrite</a>(XLogRecPtr lsn, TimestampTz local_flush_time);<br/></li>
<li><span class="Type">static</span> TimeOffset <a href="#L4160" title="replication/walsender.c:4160">LagTrackerRead</a>(<span class="Type">int</span> head, XLogRecPtr lsn, TimestampTz <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2541" title="replication/walsender.c:2541">TransactionIdInRecentPast</a>(TransactionId xid, uint32 epoch);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2988" title="replication/walsender.c:2988">WalSndSegmentOpen</a>(XLogReaderState *state, XLogSegNo nextSegNo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeLineID *tli_p);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* Initialize walsender process <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> entering the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> command loop */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L278">&#x200c;</a></span><span class="linkable">InitWalSender</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L116" title="replication/walsender.c:116">am_cascading_walsender</a> = <a href="../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create a per-walsender data structure in shared memory */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2893" title="replication/walsender.c:2893">InitWalSenderSlot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't currently need <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> ResourceOwner in a walsender process, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we did, we could call <a href="../utils/resowner/resowner.c.html#L982" title="utils/resowner/resowner.c:982">CreateAuxProcessResourceOwner</a> here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Let postmaster know that we're a WAL sender. Once we've declared us as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a WAL sender process, postmaster will let us outlive the bgwriter and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * kill us last in the shutdown sequence, so we get a chance to stream all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * remaining WAL at shutdown, including the shutdown checkpoint. Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there's no going back, and we mustn't write <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> WAL <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> after this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/ipc/pmsignal.c.html#L339" title="storage/ipc/pmsignal.c:339">MarkPostmasterChildWalSender</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/pmsignal.c.html#L181" title="storage/ipc/pmsignal.c:181">SendPostmasterSignal</a>(PMSIGNAL_ADVANCE_STATE_MACHINE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the client didn't specify a database to <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to, show in PGPROC<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that our advertised xmin should affect <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> horizons in all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * databases.&nbsp; This allows physical replication clients to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> hot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * standby feedback that will delay <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> in all databases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a> == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin == InvalidTransactionId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;statusFlags |= PROC_AFFECTS_ALL_HORIZONS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags[<a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;pgxactoff] = <a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;statusFlags;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize empty timestamp buffer for lag tracking. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L230" title="replication/walsender.c:230">lag_tracker</a> = <a href="../utils/mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L228" title="replication/walsender.c:228">LagTracker</a>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Clean up after an error.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * WAL sender processes don't use transactions like regular backends do.<br/></li>
<li></span><span class="Comment"> * This function does <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> required after an error in a WAL sender<br/></li>
<li></span><span class="Comment"> * process, similar to what transaction abort does in a regular backend.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L327">&#x200c;</a></span><span class="linkable">WalSndErrorCleanup</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1878" title="storage/lmgr/lwlock.c:1878">LWLockReleaseAll</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L230" title="storage/lmgr/condition_variable.c:230">ConditionVariableCancelSleep</a>();<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L137" title="replication/walsender.c:137">xlogreader</a> != <span class="Constant">NULL</span> &amp;&amp; <a href="#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;seg.ws_file &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlogutils.c.html#L842" title="access/transam/xlogutils.c:842">wal_segment_close</a>(<a href="#L137" title="replication/walsender.c:137">xlogreader</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L652" title="replication/slot.c:652">ReplicationSlotRelease</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="slot.c.html#L745" title="replication/slot.c:745">ReplicationSlotCleanup</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L206" title="replication/walsender.c:206">replication_active</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is a transaction in progress, it will clean up our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ResourceOwner, but if a replication command set up a resource owner<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * without a transaction, we've got to clean that up <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../access/transam/xact.c.html#L4933" title="access/transam/xact.c:4933">IsTransactionOrTransactionBlock</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L362" title="replication/walsender.c:362">WalSndResourceCleanup</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L198" title="replication/walsender.c:198">got_STOPPING</a> || <a href="#L197" title="replication/walsender.c:197">got_SIGUSR2</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Revert back to startup state */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3809" title="replication/walsender.c:3809">WalSndSetState</a>(WALSNDSTATE_STARTUP);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Clean up <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> ResourceOwner we created.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L362">&#x200c;</a></span><span class="linkable">WalSndResourceCleanup</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ResourceOwner resowner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Deleting <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> is not allowed, so we must save a pointer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in a local variable and clear it first.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; resowner = <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we can release resources and delete it. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/resowner/resowner.c.html#L648" title="utils/resowner/resowner.c:648">ResourceOwnerRelease</a>(resowner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RESOURCE_RELEASE_BEFORE_LOCKS, isCommit, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/resowner/resowner.c.html#L648" title="utils/resowner/resowner.c:648">ResourceOwnerRelease</a>(resowner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RESOURCE_RELEASE_LOCKS, isCommit, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/resowner/resowner.c.html#L648" title="utils/resowner/resowner.c:648">ResourceOwnerRelease</a>(resowner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RESOURCE_RELEASE_AFTER_LOCKS, isCommit, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/resowner/resowner.c.html#L854" title="utils/resowner/resowner.c:854">ResourceOwnerDelete</a>(resowner);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle a client's connection abort in an orderly manner.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L390">&#x200c;</a></span><span class="linkable">WalSndShutdown</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset <a href="../tcop/postgres.c.html#L90" title="tcop/postgres.c:90">whereToSendOutput</a> to prevent ereport from attempting to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more messages to the standby.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../tcop/postgres.c.html#L90" title="tcop/postgres.c:90">whereToSendOutput</a> == DestRemote)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/postgres.c.html#L90" title="tcop/postgres.c:90">whereToSendOutput</a> = DestNone;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; abort();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep the compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle the IDENTIFY_SYSTEM command.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L407">&#x200c;</a></span><span class="linkable">IdentifySystem</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; sysid[<span class="Constant">32</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; xloc[MAXFNAMELEN];<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; logptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *dbname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; DestReceiver *dest;<br/></li>
<li>&nbsp; &nbsp; TupOutputState *tstate;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">4</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">4</span>] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; currTLI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reply with a result set with one row, four columns. First col is system<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ID, second is timeline ID, third is current xlog location and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fourth contains the database name if we are connected to one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; snprintf(sysid, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(sysid), UINT64_FORMAT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../access/transam/xlog.c.html#L4535" title="access/transam/xlog.c:4535">GetSystemIdentifier</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L116" title="replication/walsender.c:116">am_cascading_walsender</a> = <a href="../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L116" title="replication/walsender.c:116">am_cascading_walsender</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; logptr = <a href="#L3504" title="replication/walsender.c:3504">GetStandbyFlushRecPtr</a>(&amp;currTLI);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; logptr = <a href="../access/transam/xlog.c.html#L6455" title="access/transam/xlog.c:6455">GetFlushRecPtr</a>(&amp;currTLI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(xloc, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xloc), <span class="Constant">&quot;</span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>, LSN_FORMAT_ARGS(logptr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a> != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext cur = <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* syscache access needs a transaction env. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make dbname live outside TX context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dbname = <a href="../commands/dbcommands.c.html#L3153" title="commands/dbcommands.c:3153">get_database_name</a>(<a href="../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a> switches to <a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(cur);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dest = <a href="../tcop/dest.c.html#L113" title="tcop/dest.c:113">CreateDestReceiver</a>(DestRemoteSimple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* need a tuple descriptor representing four columns */<br/></li>
<li></span>&nbsp; &nbsp; tupdesc = <a href="../access/common/tupdesc.c.html#L67" title="access/common/tupdesc.c:67">CreateTemplateTupleDesc</a>(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/tupdesc.c.html#L726" title="access/common/tupdesc.c:726">TupleDescInitBuiltinEntry</a>(tupdesc, (AttrNumber) <span class="Constant">1</span>, <span class="Constant">&quot;systemid&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TEXTOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/tupdesc.c.html#L726" title="access/common/tupdesc.c:726">TupleDescInitBuiltinEntry</a>(tupdesc, (AttrNumber) <span class="Constant">2</span>, <span class="Constant">&quot;timeline&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INT8OID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/tupdesc.c.html#L726" title="access/common/tupdesc.c:726">TupleDescInitBuiltinEntry</a>(tupdesc, (AttrNumber) <span class="Constant">3</span>, <span class="Constant">&quot;xlogpos&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TEXTOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/tupdesc.c.html#L726" title="access/common/tupdesc.c:726">TupleDescInitBuiltinEntry</a>(tupdesc, (AttrNumber) <span class="Constant">4</span>, <span class="Constant">&quot;dbname&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TEXTOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* prepare for projection of tuples */<br/></li>
<li></span>&nbsp; &nbsp; tstate = <a href="../executor/execTuples.c.html#L2342" title="executor/execTuples.c:2342">begin_tup_output_tupdesc</a>(dest, tupdesc, &amp;<a href="../executor/execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* column 1: system identifier */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = CStringGetTextDatum(sysid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* column 2: timeline */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = <a href="../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(currTLI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* column 3: wal location */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>] = CStringGetTextDatum(xloc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* column 4: database name, or NULL if <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dbname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">3</span>] = CStringGetTextDatum(dbname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">3</span>] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> it to dest */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../executor/execTuples.c.html#L2362" title="executor/execTuples.c:2362">do_tup_output</a>(tstate, <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../executor/execTuples.c.html#L2420" title="executor/execTuples.c:2420">end_tup_output</a>(tstate);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Handle READ_REPLICATION_SLOT command */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L490">&#x200c;</a></span><span class="linkable">ReadReplicationSlot</span>(ReadReplicationSlotCmd *cmd)<br/></li>
<li>{<br/></li>
<li><a id="L492">&#x200c;</a><span class="PreProc">#define <span class="linkable">READ_REPLICATION_SLOT_COLS</span> </span><span class="Constant">3<br/></li>
<li></span>&nbsp; &nbsp; ReplicationSlot *slot;<br/></li>
<li>&nbsp; &nbsp; DestReceiver *dest;<br/></li>
<li>&nbsp; &nbsp; TupOutputState *tstate;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<a href="#L492" title="replication/walsender.c:492">READ_REPLICATION_SLOT_COLS</a>] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<a href="#L492" title="replication/walsender.c:492">READ_REPLICATION_SLOT_COLS</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tupdesc = <a href="../access/common/tupdesc.c.html#L67" title="access/common/tupdesc.c:67">CreateTemplateTupleDesc</a>(<a href="#L492" title="replication/walsender.c:492">READ_REPLICATION_SLOT_COLS</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/tupdesc.c.html#L726" title="access/common/tupdesc.c:726">TupleDescInitBuiltinEntry</a>(tupdesc, (AttrNumber) <span class="Constant">1</span>, <span class="Constant">&quot;slot_type&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TEXTOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/tupdesc.c.html#L726" title="access/common/tupdesc.c:726">TupleDescInitBuiltinEntry</a>(tupdesc, (AttrNumber) <span class="Constant">2</span>, <span class="Constant">&quot;restart_lsn&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TEXTOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* TimeLineID is unsigned, so int4 is not wide enough. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/common/tupdesc.c.html#L726" title="access/common/tupdesc.c:726">TupleDescInitBuiltinEntry</a>(tupdesc, (AttrNumber) <span class="Constant">3</span>, <span class="Constant">&quot;restart_tli&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INT8OID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(nulls, <span class="Constant">true</span>, <a href="#L492" title="replication/walsender.c:492">READ_REPLICATION_SLOT_COLS</a> * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ReplicationSlotControlLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; slot = <a href="slot.c.html#L464" title="replication/slot.c:464">SearchNamedReplicationSlot</a>(cmd-&gt;slotname, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (slot == <span class="Constant">NULL</span> || !slot-&gt;in_use)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ReplicationSlotControlLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReplicationSlot slot_contents;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy slot contents while holding spinlock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;slot-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot_contents = *slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;slot-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ReplicationSlotControlLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(slot_contents.data.database))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot use </span><span class="Special">%s</span><span class="Constant"> with a logical replication slot&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;READ_REPLICATION_SLOT&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* slot type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] = CStringGetTextDatum(<span class="Constant">&quot;physical&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nulls[i] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* start LSN */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!XLogRecPtrIsInvalid(slot_contents.data.restart_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; xloc[<span class="Constant">64</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(xloc, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xloc), <span class="Constant">&quot;</span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(slot_contents.data.restart_lsn));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] = CStringGetTextDatum(xloc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* timeline this WAL was produced on */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!XLogRecPtrIsInvalid(slot_contents.data.restart_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeLineID&nbsp; &nbsp; slots_position_timeline;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeLineID&nbsp; &nbsp; current_timeline;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *timeline_history = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * While in recovery, use as timeline the currently-replaying one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to get the LSN position's history.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../access/transam/xlogrecovery.c.html#L4539" title="access/transam/xlogrecovery.c:4539">GetXLogReplayRecPtr</a>(&amp;current_timeline);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_timeline = <a href="../access/transam/xlog.c.html#L6476" title="access/transam/xlog.c:6476">GetWALInsertionTimeLine</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeline_history = <a href="../access/transam/timeline.c.html#L76" title="access/transam/timeline.c:76">readTimeLineHistory</a>(current_timeline);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slots_position_timeline = <a href="../access/transam/timeline.c.html#L544" title="access/transam/timeline.c:544">tliOfPointInHistory</a>(slot_contents.data.restart_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeline_history);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] = <a href="../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>((int64) slots_position_timeline);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(i == <a href="#L492" title="replication/walsender.c:492">READ_REPLICATION_SLOT_COLS</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dest = <a href="../tcop/dest.c.html#L113" title="tcop/dest.c:113">CreateDestReceiver</a>(DestRemoteSimple);<br/></li>
<li>&nbsp; &nbsp; tstate = <a href="../executor/execTuples.c.html#L2342" title="executor/execTuples.c:2342">begin_tup_output_tupdesc</a>(dest, tupdesc, &amp;<a href="../executor/execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../executor/execTuples.c.html#L2362" title="executor/execTuples.c:2362">do_tup_output</a>(tstate, <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li>&nbsp; &nbsp; <a href="../executor/execTuples.c.html#L2420" title="executor/execTuples.c:2420">end_tup_output</a>(tstate);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle TIMELINE_HISTORY command.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L589">&#x200c;</a></span><span class="linkable">SendTimeLineHistory</span>(TimeLineHistoryCmd *cmd)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DestReceiver *dest;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; histfname[MAXFNAMELEN];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">off_t</span>&nbsp; &nbsp; &nbsp; &nbsp; histfilelen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">off_t</span>&nbsp; &nbsp; &nbsp; &nbsp; bytesleft;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dest = <a href="../tcop/dest.c.html#L113" title="tcop/dest.c:113">CreateDestReceiver</a>(DestRemoteSimple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reply with a result set with one row, and two columns. The first col is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the name of the history file, 2nd is the contents.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tupdesc = <a href="../access/common/tupdesc.c.html#L67" title="access/common/tupdesc.c:67">CreateTemplateTupleDesc</a>(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/tupdesc.c.html#L726" title="access/common/tupdesc.c:726">TupleDescInitBuiltinEntry</a>(tupdesc, (AttrNumber) <span class="Constant">1</span>, <span class="Constant">&quot;filename&quot;</span>, TEXTOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/tupdesc.c.html#L726" title="access/common/tupdesc.c:726">TupleDescInitBuiltinEntry</a>(tupdesc, (AttrNumber) <span class="Constant">2</span>, <span class="Constant">&quot;content&quot;</span>, TEXTOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TLHistoryFileName(histfname, cmd-&gt;timeline);<br/></li>
<li>&nbsp; &nbsp; TLHistoryFilePath(path, cmd-&gt;timeline);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Send a RowDescription message */<br/></li>
<li></span>&nbsp; &nbsp; dest-&gt;rStartup(dest, CMD_SELECT, tupdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Send a DataRow message */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L88" title="libpq/pqformat.c:88">pq_beginmessage</a>(&amp;buf, PqMsg_DataRow);<br/></li>
<li>&nbsp; &nbsp; pq_sendint16(&amp;buf, <span class="Constant">2</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* # of columns */<br/></li>
<li></span>&nbsp; &nbsp; len = strlen(histfname);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(&amp;buf, len);&nbsp; &nbsp; <span class="Comment">/* col1 len */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L126" title="libpq/pqformat.c:126">pq_sendbytes</a>(&amp;buf, histfname, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fd = <a href="../storage/file/fd.c.html#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>(path, O_RDONLY | PG_BINARY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine file length and <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> it to client */<br/></li>
<li></span>&nbsp; &nbsp; histfilelen = lseek(fd, <span class="Constant">0</span>, <span class="Constant">SEEK_END</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (histfilelen &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not seek to end of file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lseek(fd, <span class="Constant">0</span>, <span class="Constant">SEEK_SET</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not seek to beginning of file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pq_sendint32(&amp;buf, histfilelen);&nbsp; &nbsp; <span class="Comment">/* col2 len */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; bytesleft = histfilelen;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (bytesleft &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGAlignedBlock rbuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nread;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_WALSENDER_TIMELINE_HISTORY_READ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nread = read(fd, rbuf.data, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(rbuf));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nread &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (nread == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: read </span><span class="Special">%d</span><span class="Constant"> of </span><span class="Special">%zu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path, nread, (Size) bytesleft)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L126" title="libpq/pqformat.c:126">pq_sendbytes</a>(&amp;buf, rbuf.data, nread);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bytesleft -= nread;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not close file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L296" title="libpq/pqformat.c:296">pq_endmessage</a>(&amp;buf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle UPLOAD_MANIFEST command.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L679">&#x200c;</a></span><span class="linkable">UploadManifest</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext mcxt;<br/></li>
<li>&nbsp; &nbsp; <a href="../backup/basebackup_incremental.c.html#L76" title="backup/basebackup_incremental.c:76">IncrementalBackupInfo</a> *ib;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">off_t</span>&nbsp; &nbsp; &nbsp; &nbsp; offset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parsing the manifest will use the cryptohash stuff, which requires a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * resource owner<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = <a href="../utils/resowner/resowner.c.html#L413" title="utils/resowner/resowner.c:413">ResourceOwnerCreate</a>(<span class="Constant">NULL</span>, <span class="Constant">&quot;base backup&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare to read manifest data into a temporary context. */<br/></li>
<li></span>&nbsp; &nbsp; mcxt = AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;incremental backup information&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; ib = <a href="../backup/basebackup_incremental.c.html#L154" title="backup/basebackup_incremental.c:154">CreateIncrementalBackupInfo</a>(mcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Send a CopyInResponse message */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L88" title="libpq/pqformat.c:88">pq_beginmessage</a>(&amp;buf, <span class="Constant">'G'</span>);<br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(&amp;buf, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; pq_sendint16(&amp;buf, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L314" title="libpq/pqformat.c:314">pq_endmessage_reuse</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; pq_flush();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Receive packets from client until done. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L743" title="replication/walsender.c:743">HandleUploadManifestPacket</a>(&amp;buf, &amp;offset, ib))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finish up manifest processing. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../backup/basebackup_incremental.c.html#L229" title="backup/basebackup_incremental.c:229">FinalizeIncrementalManifest</a>(ib);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Discard <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> old manifest information and arrange to preserve the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * information we just got.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We assume that <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a> and <a href="../utils/mmgr/mcxt.c.html#L637" title="utils/mmgr/mcxt.c:637">MemoryContextSetParent</a> won't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fail, and thus we shouldn't end up bailing out of here in such a way as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to leave dangling pointers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L148" title="replication/walsender.c:148">uploaded_manifest_mcxt</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(<a href="#L148" title="replication/walsender.c:148">uploaded_manifest_mcxt</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L637" title="utils/mmgr/mcxt.c:637">MemoryContextSetParent</a>(mcxt, <a href="../utils/mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L147" title="replication/walsender.c:147">uploaded_manifest</a> = ib;<br/></li>
<li>&nbsp; &nbsp; <a href="#L148" title="replication/walsender.c:148">uploaded_manifest_mcxt</a> = mcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* clean up the resource owner we created */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L362" title="replication/walsender.c:362">WalSndResourceCleanup</a>(<span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Process one packet received during the handling of an UPLOAD_MANIFEST<br/></li>
<li></span><span class="Comment"> * operation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'buf' is scratch space. This function expects it to be initialized, doesn't<br/></li>
<li></span><span class="Comment"> * care what the current contents are, and may override them with completely<br/></li>
<li></span><span class="Comment"> * new contents.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The return value is true if the caller should continue processing<br/></li>
<li></span><span class="Comment"> * additional packets and false if the UPLOAD_MANIFEST operation is complete.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L743">&#x200c;</a></span><span class="linkable">HandleUploadManifestPacket</span>(StringInfo buf, <span class="Type">off_t</span> *offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../backup/basebackup_incremental.c.html#L76" title="backup/basebackup_incremental.c:76">IncrementalBackupInfo</a> *ib)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mtype;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxmsglen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; HOLD_CANCEL_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../libpq/pqcomm.c.html#L1140" title="libpq/pqcomm.c:1140">pq_startmsgread</a>();<br/></li>
<li>&nbsp; &nbsp; mtype = <a href="../libpq/pqcomm.c.html#L963" title="libpq/pqcomm.c:963">pq_getbyte</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mtype == <span class="Constant">EOF</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONNECTION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unexpected EOF on client connection with an open transaction&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (mtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'d'</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* CopyData */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxmsglen = PQ_LARGE_MESSAGE_LIMIT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'c'</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* CopyDone */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'f'</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* CopyFail */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'H'</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Flush */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'S'</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sync */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxmsglen = PQ_SMALL_MESSAGE_LIMIT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unexpected message type 0x</span><span class="Special">%02X</span><span class="Constant"> during COPY from stdin&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mtype)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxmsglen = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now collect the message body */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../libpq/pqcomm.c.html#L1202" title="libpq/pqcomm.c:1202">pq_getmessage</a>(buf, maxmsglen))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONNECTION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unexpected EOF on client connection with an open transaction&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; RESUME_CANCEL_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process the message */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (mtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'d'</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* CopyData */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../backup/basebackup_incremental.c.html#L196" title="backup/basebackup_incremental.c:196">AppendIncrementalManifestData</a>(ib, buf-&gt;data, buf-&gt;len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'c'</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* CopyDone */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'H'</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sync */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'S'</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Flush */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore these while in CopyOut mode as we do elsewhere. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'f'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_QUERY_CANCELED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;COPY from stdin failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L579" title="libpq/pqformat.c:579">pq_getmsgstring</a>(buf))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Not reached. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle START_REPLICATION command.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At the moment, this never returns, but an ereport(ERROR) will take us back<br/></li>
<li></span><span class="Comment"> * to the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L819">&#x200c;</a></span><span class="linkable">StartReplication</span>(StartReplicationCmd *cmd)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; FlushPtr;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; FlushTLI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* create <a href="#L137" title="replication/walsender.c:137">xlogreader</a> for physical replication */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L137" title="replication/walsender.c:137">xlogreader</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlogreader.c.html#L106" title="access/transam/xlogreader.c:106">XLogReaderAllocate</a>(<a href="../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XL_ROUTINE(.segment_open = <a href="#L2988" title="replication/walsender.c:2988">WalSndSegmentOpen</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .segment_close = <a href="../access/transam/xlogutils.c.html#L842" title="access/transam/xlogutils.c:842">wal_segment_close</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L137" title="replication/walsender.c:137">xlogreader</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failed while allocating a WAL reading processor.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We assume here that we're logging enough information in the WAL for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * log-shipping, since this is checked in <a href="../postmaster/postmaster.c.html#L489" title="postmaster/postmaster.c:489">PostmasterMain</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: <a href="../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a> can only change at shutdown, so in most cases it is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * difficult for there to be WAL data that we can still see that was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * written at <a href="../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a>='minimal'.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cmd-&gt;slotname)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L540" title="replication/slot.c:540">ReplicationSlotAcquire</a>(cmd-&gt;slotname, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (SlotIsLogical(<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot use a logical replication slot for physical replication&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't need to verify the slot's restart_lsn here; instead we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rely on the caller requesting the starting point to use.&nbsp; If the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL segment doesn't exist, we'll fail later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Select the timeline. If it was given explicitly by the client, use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that. Otherwise use the timeline of the last replayed record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L116" title="replication/walsender.c:116">am_cascading_walsender</a> = <a href="../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L116" title="replication/walsender.c:116">am_cascading_walsender</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FlushPtr = <a href="#L3504" title="replication/walsender.c:3504">GetStandbyFlushRecPtr</a>(&amp;FlushTLI);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; FlushPtr = <a href="../access/transam/xlog.c.html#L6455" title="access/transam/xlog.c:6455">GetFlushRecPtr</a>(&amp;FlushTLI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cmd-&gt;timeline != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; switchpoint;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L156" title="replication/walsender.c:156">sendTimeLine</a> = cmd-&gt;timeline;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L156" title="replication/walsender.c:156">sendTimeLine</a> == FlushTLI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L158" title="replication/walsender.c:158">sendTimeLineIsHistoric</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L159" title="replication/walsender.c:159">sendTimeLineValidUpto</a> = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *timeLineHistory;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L158" title="replication/walsender.c:158">sendTimeLineIsHistoric</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check that the timeline the client requested exists, and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * requested start location is on that timeline.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeLineHistory = <a href="../access/transam/timeline.c.html#L76" title="access/transam/timeline.c:76">readTimeLineHistory</a>(FlushTLI);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; switchpoint = <a href="../access/transam/timeline.c.html#L572" title="access/transam/timeline.c:572">tliSwitchPoint</a>(cmd-&gt;timeline, timeLineHistory,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="#L157" title="replication/walsender.c:157">sendTimeLineNextTLI</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L1560" title="nodes/list.c:1560">list_free_deep</a>(timeLineHistory);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Found the requested timeline in the history. Check that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * requested startpoint is on that timeline in our history.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is quite loose on purpose. We only check that we didn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fork off the requested timeline <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the switchpoint. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't check that we switched *to* it <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the requested<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * starting point. This is because the client can legitimately<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * request to start replication from the beginning of the WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * segment that contains switchpoint, but on the new timeline, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that it doesn't end up with a partial segment. If you ask for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * too old a starting point, you'll get an error later when we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fail to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the requested WAL segment in pg_wal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: we could be more strict here and only allow a startpoint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that's older than the switchpoint, if it's still in the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL segment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!XLogRecPtrIsInvalid(switchpoint) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; switchpoint &lt; cmd-&gt;startpoint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;requested starting point </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> on timeline </span><span class="Special">%u</span><span class="Constant"> is not in this server's history&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(cmd-&gt;startpoint),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;timeline),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;This server's history forked from timeline </span><span class="Special">%u</span><span class="Constant"> at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cmd-&gt;timeline,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(switchpoint))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L159" title="replication/walsender.c:159">sendTimeLineValidUpto</a> = switchpoint;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L156" title="replication/walsender.c:156">sendTimeLine</a> = FlushTLI;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L159" title="replication/walsender.c:159">sendTimeLineValidUpto</a> = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L158" title="replication/walsender.c:158">sendTimeLineIsHistoric</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L190" title="replication/walsender.c:190">streamingDoneSending</a> = <a href="#L191" title="replication/walsender.c:191">streamingDoneReceiving</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there is nothing to stream, don't even enter COPY mode */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L158" title="replication/walsender.c:158">sendTimeLineIsHistoric</a> || cmd-&gt;startpoint &lt; <a href="#L159" title="replication/walsender.c:159">sendTimeLineValidUpto</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When we first start replication the standby will be behind the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * primary. For some applications, for example synchronous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * replication, it is important to have a clear state for this initial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * catchup mode, so we can <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> actions when we change streaming<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * state later. We may stay in this state for a long time, which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exactly why we want to be able to monitor whether or not we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * still here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3809" title="replication/walsender.c:3809">WalSndSetState</a>(WALSNDSTATE_CATCHUP);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Send a CopyBothResponse message, and start streaming */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L88" title="libpq/pqformat.c:88">pq_beginmessage</a>(&amp;buf, PqMsg_CopyBothResponse);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(&amp;buf, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint16(&amp;buf, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L296" title="libpq/pqformat.c:296">pq_endmessage</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_flush();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't allow a request to stream from a future point in WAL that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hasn't been flushed to disk in this server yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (FlushPtr &lt; cmd-&gt;startpoint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;requested starting point </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> is ahead of the WAL flush position of this server </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(cmd-&gt;startpoint),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(FlushPtr))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Start streaming from the requested point */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L165" title="replication/walsender.c:165">sentPtr</a> = cmd-&gt;startpoint;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize shared memory status, too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L112" title="replication/walsender.c:112">MyWalSnd</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L112" title="replication/walsender.c:112">MyWalSnd</a>-&gt;<a href="#L165" title="replication/walsender.c:165">sentPtr</a> = <a href="#L165" title="replication/walsender.c:165">sentPtr</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L112" title="replication/walsender.c:112">MyWalSnd</a>-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syncrep.c.html#L402" title="replication/syncrep.c:402">SyncRepInitConfig</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Main loop of walsender */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L206" title="replication/walsender.c:206">replication_active</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2767" title="replication/walsender.c:2767">WalSndLoop</a>(<a href="#L3066" title="replication/walsender.c:3066">XLogSendPhysical</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L206" title="replication/walsender.c:206">replication_active</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L198" title="replication/walsender.c:198">got_STOPPING</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3809" title="replication/walsender.c:3809">WalSndSetState</a>(WALSNDSTATE_STARTUP);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L190" title="replication/walsender.c:190">streamingDoneSending</a> &amp;&amp; <a href="#L191" title="replication/walsender.c:191">streamingDoneReceiving</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cmd-&gt;slotname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L652" title="replication/slot.c:652">ReplicationSlotRelease</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy is finished <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. Send a single-row result set indicating the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * timeline.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L158" title="replication/walsender.c:158">sendTimeLineIsHistoric</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; startpos_str[<span class="Constant">8</span> + <span class="Constant">1</span> + <span class="Constant">8</span> + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DestReceiver *dest;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupOutputState *tstate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">2</span>] = {<span class="Constant">0</span>};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(startpos_str, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(startpos_str), <span class="Constant">&quot;</span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(<a href="#L159" title="replication/walsender.c:159">sendTimeLineValidUpto</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dest = <a href="../tcop/dest.c.html#L113" title="tcop/dest.c:113">CreateDestReceiver</a>(DestRemoteSimple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Need a tuple descriptor representing two columns. int8 may seem<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * like a surprising data type for this, but in theory int4 would not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be wide enough for this, as TimeLineID is unsigned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tupdesc = <a href="../access/common/tupdesc.c.html#L67" title="access/common/tupdesc.c:67">CreateTemplateTupleDesc</a>(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/tupdesc.c.html#L726" title="access/common/tupdesc.c:726">TupleDescInitBuiltinEntry</a>(tupdesc, (AttrNumber) <span class="Constant">1</span>, <span class="Constant">&quot;next_tli&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INT8OID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/tupdesc.c.html#L726" title="access/common/tupdesc.c:726">TupleDescInitBuiltinEntry</a>(tupdesc, (AttrNumber) <span class="Constant">2</span>, <span class="Constant">&quot;next_tli_startpos&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TEXTOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* prepare for projection of tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tstate = <a href="../executor/execTuples.c.html#L2342" title="executor/execTuples.c:2342">begin_tup_output_tupdesc</a>(dest, tupdesc, &amp;<a href="../executor/execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = <a href="../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>((int64) <a href="#L157" title="replication/walsender.c:157">sendTimeLineNextTLI</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = CStringGetTextDatum(startpos_str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> it to dest */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../executor/execTuples.c.html#L2362" title="executor/execTuples.c:2362">do_tup_output</a>(tstate, <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../executor/execTuples.c.html#L2420" title="executor/execTuples.c:2420">end_tup_output</a>(tstate);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Send CommandComplete message */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../tcop/dest.c.html#L205" title="tcop/dest.c:205">EndReplicationCommand</a>(<span class="Constant">&quot;START_STREAMING&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * XLogReaderRoutine-&gt;page_read callback for logical decoding contexts, as a<br/></li>
<li></span><span class="Comment"> * walsender process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Inside the walsender we can do better than <a href="../access/transam/xlogutils.c.html#L861" title="access/transam/xlogutils.c:861">read_local_xlog_page</a>,<br/></li>
<li></span><span class="Comment"> * which has to do a plain sleep/busy loop, because the walsender's latch gets<br/></li>
<li></span><span class="Comment"> * set every time WAL is flushed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1051">&#x200c;</a></span><span class="linkable">logical_read_xlog_page</span>(XLogReaderState *state, XLogRecPtr targetPagePtr, <span class="Type">int</span> reqLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr targetRecPtr, <span class="Type">char</span> *cur_page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; flushptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count;<br/></li>
<li>&nbsp; &nbsp; WALReadError errinfo;<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; segno;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; currTLI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure we have enough WAL available <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> retrieving the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * timeline. This is needed to determine <a href="#L116" title="replication/walsender.c:116">am_cascading_walsender</a> accurately<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which is needed to determine the current timeline.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; flushptr = <a href="#L1818" title="replication/walsender.c:1818">WalSndWaitForWal</a>(targetPagePtr + reqLen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since logical decoding is also permitted on a standby server, we need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to check if the server is in recovery to decide how to get the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * timeline ID (so that it also cover the promotion or timeline change<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L116" title="replication/walsender.c:116">am_cascading_walsender</a> = <a href="../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L116" title="replication/walsender.c:116">am_cascading_walsender</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlogrecovery.c.html#L4539" title="access/transam/xlogrecovery.c:4539">GetXLogReplayRecPtr</a>(&amp;currTLI);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; currTLI = <a href="../access/transam/xlog.c.html#L6476" title="access/transam/xlog.c:6476">GetWALInsertionTimeLine</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/transam/xlogutils.c.html#L718" title="access/transam/xlogutils.c:718">XLogReadDetermineTimeline</a>(state, targetPagePtr, reqLen, currTLI);<br/></li>
<li>&nbsp; &nbsp; <a href="#L158" title="replication/walsender.c:158">sendTimeLineIsHistoric</a> = (state-&gt;currTLI != currTLI);<br/></li>
<li>&nbsp; &nbsp; <a href="#L156" title="replication/walsender.c:156">sendTimeLine</a> = state-&gt;currTLI;<br/></li>
<li>&nbsp; &nbsp; <a href="#L159" title="replication/walsender.c:159">sendTimeLineValidUpto</a> = state-&gt;currTLIValidUntil;<br/></li>
<li>&nbsp; &nbsp; <a href="#L157" title="replication/walsender.c:157">sendTimeLineNextTLI</a> = state-&gt;nextTLI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fail if not (implies we are going to shut down) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flushptr &lt; targetPagePtr + reqLen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (targetPagePtr + XLOG_BLCKSZ &lt;= flushptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; count = XLOG_BLCKSZ;&nbsp; &nbsp; <span class="Comment">/* more than one block available */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; count = flushptr - targetPagePtr;&nbsp; &nbsp; <span class="Comment">/* part of the page available */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> actually read the data, we know it's there */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../access/transam/xlogreader.c.html#L1503" title="access/transam/xlogreader.c:1503">WALRead</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur_page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; targetPagePtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; currTLI,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Pass the current TLI because only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L2988" title="replication/walsender.c:2988">WalSndSegmentOpen</a> controls whether new TLI<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is needed. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;errinfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlogutils.c.html#L1020" title="access/transam/xlogutils.c:1020">WALReadRaiseError</a>(&amp;errinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * After reading into the buffer, check that what we read was valid. We do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this after reading, because even though the segment was present when we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * opened it, it might get recycled or removed while we read it. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * read() succeeds in that case, but the data we tried to read might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already have been overwritten with new WAL <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; XLByteToSeg(targetPagePtr, segno, state-&gt;segcxt.ws_segsize);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/transam/xlog.c.html#L3716" title="access/transam/xlog.c:3716">CheckXLogRemoved</a>(segno, state-&gt;seg.ws_tli);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> count;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Process extra options given to CREATE_REPLICATION_SLOT.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1123">&#x200c;</a></span><span class="linkable">parseCreateReplSlotOptions</span>(CreateReplicationSlotCmd *cmd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *reserve_wal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CRSSnapshotAction *snapshot_action,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *two_phase, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *failover)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; snapshot_action_given = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; reserve_wal_given = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; two_phase_given = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; failover_given = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Parse options */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, cmd-&gt;options)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DefElem&nbsp; &nbsp; *defel = (DefElem *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(defel-&gt;defname, <span class="Constant">&quot;snapshot&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *action;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (snapshot_action_given || cmd-&gt;kind != REPLICATION_KIND_LOGICAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;conflicting or redundant options&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; action = <a href="../commands/define.c.html#L48" title="commands/define.c:48">defGetString</a>(defel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snapshot_action_given = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(action, <span class="Constant">&quot;export&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *snapshot_action = CRS_EXPORT_SNAPSHOT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(action, <span class="Constant">&quot;nothing&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *snapshot_action = CRS_NOEXPORT_SNAPSHOT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(action, <span class="Constant">&quot;use&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *snapshot_action = CRS_USE_SNAPSHOT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unrecognized value for CREATE_REPLICATION_SLOT option </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defel-&gt;defname, action)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(defel-&gt;defname, <span class="Constant">&quot;reserve_wal&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (reserve_wal_given || cmd-&gt;kind != REPLICATION_KIND_PHYSICAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;conflicting or redundant options&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reserve_wal_given = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *reserve_wal = <a href="../commands/define.c.html#L107" title="commands/define.c:107">defGetBoolean</a>(defel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(defel-&gt;defname, <span class="Constant">&quot;two_phase&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (two_phase_given || cmd-&gt;kind != REPLICATION_KIND_LOGICAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;conflicting or redundant options&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; two_phase_given = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *two_phase = <a href="../commands/define.c.html#L107" title="commands/define.c:107">defGetBoolean</a>(defel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(defel-&gt;defname, <span class="Constant">&quot;failover&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (failover_given || cmd-&gt;kind != REPLICATION_KIND_LOGICAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;conflicting or redundant options&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; failover_given = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *failover = <a href="../commands/define.c.html#L107" title="commands/define.c:107">defGetBoolean</a>(defel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized option: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, defel-&gt;defname);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a new replication slot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1200">&#x200c;</a></span><span class="linkable">CreateReplicationSlot</span>(CreateReplicationSlotCmd *cmd)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *snapshot_name = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; xloc[MAXFNAMELEN];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *slot_name;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; reserve_wal = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; two_phase = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; failover = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; CRSSnapshotAction snapshot_action = CRS_EXPORT_SNAPSHOT;<br/></li>
<li>&nbsp; &nbsp; DestReceiver *dest;<br/></li>
<li>&nbsp; &nbsp; TupOutputState *tstate;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">4</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">4</span>] = {<span class="Constant">0</span>};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1123" title="replication/walsender.c:1123">parseCreateReplSlotOptions</a>(cmd, &amp;reserve_wal, &amp;snapshot_action, &amp;two_phase,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;failover);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cmd-&gt;kind == REPLICATION_KIND_PHYSICAL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L309" title="replication/slot.c:309">ReplicationSlotCreate</a>(cmd-&gt;slotname, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;temporary ? RS_TEMPORARY : RS_PERSISTENT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (reserve_wal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L1401" title="replication/slot.c:1401">ReplicationSlotReserveWal</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L1010" title="replication/slot.c:1010">ReplicationSlotMarkDirty</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Write this slot to disk if it's a permanent one. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!cmd-&gt;temporary)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L992" title="replication/slot.c:992">ReplicationSlotSave</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LogicalDecodingContext *ctx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; need_full_snapshot = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(cmd-&gt;kind == REPLICATION_KIND_LOGICAL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="logical/logical.c.html#L109" title="replication/logical/logical.c:109">CheckLogicalDecodingRequirements</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Initially create persistent slot as ephemeral - that allows us to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nicely handle errors during initialization because it'll get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dropped if this transaction fails. We'll make it persistent at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end. Temporary slots can be created as temporary from beginning as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * they get dropped on error as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L309" title="replication/slot.c:309">ReplicationSlotCreate</a>(cmd-&gt;slotname, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;temporary ? RS_TEMPORARY : RS_EPHEMERAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; two_phase, failover, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do options check early so that we can bail <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="logical/logical.c.html#L649" title="replication/logical/logical.c:649">DecodingContextFindStartpoint</a> which can take long time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (snapshot_action == CRS_EXPORT_SNAPSHOT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xact.c.html#L4915" title="access/transam/xact.c:4915">IsTransactionBlock</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*- translator: %s is a CREATE_REPLICATION_SLOT statement */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> must not be called inside a transaction&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;CREATE_REPLICATION_SLOT ... (SNAPSHOT 'export')&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; need_full_snapshot = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (snapshot_action == CRS_USE_SNAPSHOT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../access/transam/xact.c.html#L4915" title="access/transam/xact.c:4915">IsTransactionBlock</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*- translator: %s is a CREATE_REPLICATION_SLOT statement */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> must be called inside a transaction&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;CREATE_REPLICATION_SLOT ... (SNAPSHOT 'use')&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xact.c.html#L77" title="access/transam/xact.c:77">XactIsoLevel</a> != XACT_REPEATABLE_READ)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*- translator: %s is a CREATE_REPLICATION_SLOT statement */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> must be called in REPEATABLE READ isolation mode transaction&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;CREATE_REPLICATION_SLOT ... (SNAPSHOT 'use')&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../access/transam/xact.c.html#L80" title="access/transam/xact.c:80">XactReadOnly</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*- translator: %s is a CREATE_REPLICATION_SLOT statement */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> must be called in a read-only transaction&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;CREATE_REPLICATION_SLOT ... (SNAPSHOT 'use')&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/time/snapmgr.c.html#L135" title="utils/time/snapmgr.c:135">FirstSnapshotSet</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*- translator: %s is a CREATE_REPLICATION_SLOT statement */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> must be called <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> query&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;CREATE_REPLICATION_SLOT ... (SNAPSHOT 'use')&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xact.c.html#L4988" title="access/transam/xact.c:4988">IsSubTransaction</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*- translator: %s is a CREATE_REPLICATION_SLOT statement */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> must not be called in a subtransaction&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;CREATE_REPLICATION_SLOT ... (SNAPSHOT 'use')&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; need_full_snapshot = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctx = <a href="logical/logical.c.html#L329" title="replication/logical/logical.c:329">CreateInitDecodingContext</a>(cmd-&gt;plugin, NIL, need_full_snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidXLogRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XL_ROUTINE(.page_read = <a href="#L1051" title="replication/walsender.c:1051">logical_read_xlog_page</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; .segment_open = <a href="#L2988" title="replication/walsender.c:2988">WalSndSegmentOpen</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; .segment_close = <a href="../access/transam/xlogutils.c.html#L842" title="access/transam/xlogutils.c:842">wal_segment_close</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1545" title="replication/walsender.c:1545">WalSndPrepareWrite</a>, <a href="#L1572" title="replication/walsender.c:1572">WalSndWriteData</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1668" title="replication/walsender.c:1668">WalSndUpdateProgress</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Signal that we don't need the timeout mechanism. We're just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * creating the replication slot and don't yet <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> feedback<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * messages or <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> keepalives. As we possibly need to wait for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * further WAL the walsender would otherwise possibly be killed too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * soon.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L179" title="replication/walsender.c:179">last_reply_timestamp</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* build initial snapshot, might take a while */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="logical/logical.c.html#L649" title="replication/logical/logical.c:649">DecodingContextFindStartpoint</a>(ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Export or use the snapshot if we've been asked to do so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NB. We will convert the snapbuild.c kind of snapshot to normal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * snapshot when doing this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (snapshot_action == CRS_EXPORT_SNAPSHOT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snapshot_name = <a href="logical/snapbuild.c.html#L668" title="replication/logical/snapbuild.c:668">SnapBuildExportSnapshot</a>(ctx-&gt;snapshot_builder);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (snapshot_action == CRS_USE_SNAPSHOT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Snapshot&nbsp; &nbsp; snap;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snap = <a href="logical/snapbuild.c.html#L569" title="replication/logical/snapbuild.c:569">SnapBuildInitialSnapshot</a>(ctx-&gt;snapshot_builder);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L1840" title="utils/time/snapmgr.c:1840">RestoreTransactionSnapshot</a>(snap, <a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't need the decoding context anymore */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="logical/logical.c.html#L693" title="replication/logical/logical.c:693">FreeDecodingContext</a>(ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!cmd-&gt;temporary)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L1027" title="replication/slot.c:1027">ReplicationSlotPersist</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(xloc, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xloc), <span class="Constant">&quot;</span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.confirmed_flush));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dest = <a href="../tcop/dest.c.html#L113" title="tcop/dest.c:113">CreateDestReceiver</a>(DestRemoteSimple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Need a tuple descriptor representing four columns:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * - first field: the slot name<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * - second field: LSN at which we became consistent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * - third field: exported snapshot's name<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * - fourth field: output plugin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tupdesc = <a href="../access/common/tupdesc.c.html#L67" title="access/common/tupdesc.c:67">CreateTemplateTupleDesc</a>(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/tupdesc.c.html#L726" title="access/common/tupdesc.c:726">TupleDescInitBuiltinEntry</a>(tupdesc, (AttrNumber) <span class="Constant">1</span>, <span class="Constant">&quot;slot_name&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TEXTOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/tupdesc.c.html#L726" title="access/common/tupdesc.c:726">TupleDescInitBuiltinEntry</a>(tupdesc, (AttrNumber) <span class="Constant">2</span>, <span class="Constant">&quot;consistent_point&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TEXTOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/tupdesc.c.html#L726" title="access/common/tupdesc.c:726">TupleDescInitBuiltinEntry</a>(tupdesc, (AttrNumber) <span class="Constant">3</span>, <span class="Constant">&quot;snapshot_name&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TEXTOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/tupdesc.c.html#L726" title="access/common/tupdesc.c:726">TupleDescInitBuiltinEntry</a>(tupdesc, (AttrNumber) <span class="Constant">4</span>, <span class="Constant">&quot;output_plugin&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TEXTOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* prepare for projection of tuples */<br/></li>
<li></span>&nbsp; &nbsp; tstate = <a href="../executor/execTuples.c.html#L2342" title="executor/execTuples.c:2342">begin_tup_output_tupdesc</a>(dest, tupdesc, &amp;<a href="../executor/execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* slot_name */<br/></li>
<li></span>&nbsp; &nbsp; slot_name = NameStr(<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.name);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = CStringGetTextDatum(slot_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* consistent wal location */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = CStringGetTextDatum(xloc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* snapshot name, or NULL if <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (snapshot_name != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>] = CStringGetTextDatum(snapshot_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">2</span>] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* plugin, or NULL if <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cmd-&gt;plugin != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">3</span>] = CStringGetTextDatum(cmd-&gt;plugin);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">3</span>] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> it to dest */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../executor/execTuples.c.html#L2362" title="executor/execTuples.c:2362">do_tup_output</a>(tstate, <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li>&nbsp; &nbsp; <a href="../executor/execTuples.c.html#L2420" title="executor/execTuples.c:2420">end_tup_output</a>(tstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="slot.c.html#L652" title="replication/slot.c:652">ReplicationSlotRelease</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get rid of a replication slot that is no longer wanted.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1405">&#x200c;</a></span><span class="linkable">DropReplicationSlot</span>(DropReplicationSlotCmd *cmd)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="slot.c.html#L784" title="replication/slot.c:784">ReplicationSlotDrop</a>(cmd-&gt;slotname, !cmd-&gt;wait);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Process extra options given to ALTER_REPLICATION_SLOT.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1414">&#x200c;</a></span><span class="linkable">ParseAlterReplSlotOptions</span>(AlterReplicationSlotCmd *cmd, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *failover)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; failover_given = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Parse options */<br/></li>
<li></span>&nbsp; &nbsp; foreach_ptr(DefElem, defel, cmd-&gt;options)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(defel-&gt;defname, <span class="Constant">&quot;failover&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (failover_given)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;conflicting or redundant options&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; failover_given = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *failover = <a href="../commands/define.c.html#L107" title="commands/define.c:107">defGetBoolean</a>(defel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized option: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, defel-&gt;defname);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Change the definition of a replication slot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1439">&#x200c;</a></span><span class="linkable">AlterReplicationSlot</span>(AlterReplicationSlotCmd *cmd)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; failover = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1414" title="replication/walsender.c:1414">ParseAlterReplSlotOptions</a>(cmd, &amp;failover);<br/></li>
<li>&nbsp; &nbsp; <a href="slot.c.html#L807" title="replication/slot.c:807">ReplicationSlotAlter</a>(cmd-&gt;slotname, failover);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Load previously initiated logical slot and prepare for sending data (via<br/></li>
<li></span><span class="Comment"> * <a href="#L2767" title="replication/walsender.c:2767">WalSndLoop</a>).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1452">&#x200c;</a></span><span class="linkable">StartLogicalReplication</span>(StartReplicationCmd *cmd)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; QueryCompletion qc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure that our requirements are still fulfilled */<br/></li>
<li></span>&nbsp; &nbsp; <a href="logical/logical.c.html#L109" title="replication/logical/logical.c:109">CheckLogicalDecodingRequirements</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="slot.c.html#L540" title="replication/slot.c:540">ReplicationSlotAcquire</a>(cmd-&gt;slotname, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Force a disconnect, so that the decoding code doesn't need to care<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * about an eventual switch from running in recovery, to running in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * normal environment. Client code is expected to handle reconnects.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L116" title="replication/walsender.c:116">am_cascading_walsender</a> &amp;&amp; !<a href="../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;terminating walsender process after promotion&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L198" title="replication/walsender.c:198">got_STOPPING</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create our decoding context, making it start at the previously ack'ed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * position.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do this <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> sending a CopyBothResponse message, so that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> errors<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are reported early.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L208" title="replication/walsender.c:208">logical_decoding_ctx</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="logical/logical.c.html#L495" title="replication/logical/logical.c:495">CreateDecodingContext</a>(cmd-&gt;startpoint, cmd-&gt;options, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XL_ROUTINE(.page_read = <a href="#L1051" title="replication/walsender.c:1051">logical_read_xlog_page</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; .segment_open = <a href="#L2988" title="replication/walsender.c:2988">WalSndSegmentOpen</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; .segment_close = <a href="../access/transam/xlogutils.c.html#L842" title="access/transam/xlogutils.c:842">wal_segment_close</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1545" title="replication/walsender.c:1545">WalSndPrepareWrite</a>, <a href="#L1572" title="replication/walsender.c:1572">WalSndWriteData</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1668" title="replication/walsender.c:1668">WalSndUpdateProgress</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L137" title="replication/walsender.c:137">xlogreader</a> = <a href="#L208" title="replication/walsender.c:208">logical_decoding_ctx</a>-&gt;reader;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3809" title="replication/walsender.c:3809">WalSndSetState</a>(WALSNDSTATE_CATCHUP);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Send a CopyBothResponse message, and start streaming */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L88" title="libpq/pqformat.c:88">pq_beginmessage</a>(&amp;buf, PqMsg_CopyBothResponse);<br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(&amp;buf, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; pq_sendint16(&amp;buf, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L296" title="libpq/pqformat.c:296">pq_endmessage</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; pq_flush();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Start reading WAL from the oldest required WAL. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xlogreader.c.html#L231" title="access/transam/xlogreader.c:231">XLogBeginRead</a>(<a href="#L208" title="replication/walsender.c:208">logical_decoding_ctx</a>-&gt;reader,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.restart_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Report the location after which we'll <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> out further commits as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current <a href="#L165" title="replication/walsender.c:165">sentPtr</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L165" title="replication/walsender.c:165">sentPtr</a> = <a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.confirmed_flush;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Also update the sent position status in shared memory */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L112" title="replication/walsender.c:112">MyWalSnd</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; <a href="#L112" title="replication/walsender.c:112">MyWalSnd</a>-&gt;<a href="#L165" title="replication/walsender.c:165">sentPtr</a> = <a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.restart_lsn;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L112" title="replication/walsender.c:112">MyWalSnd</a>-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L206" title="replication/walsender.c:206">replication_active</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="syncrep.c.html#L402" title="replication/syncrep.c:402">SyncRepInitConfig</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Main loop of walsender */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2767" title="replication/walsender.c:2767">WalSndLoop</a>(<a href="#L3376" title="replication/walsender.c:3376">XLogSendLogical</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="logical/logical.c.html#L693" title="replication/logical/logical.c:693">FreeDecodingContext</a>(<a href="#L208" title="replication/walsender.c:208">logical_decoding_ctx</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="slot.c.html#L652" title="replication/slot.c:652">ReplicationSlotRelease</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L206" title="replication/walsender.c:206">replication_active</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L198" title="replication/walsender.c:198">got_STOPPING</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L3809" title="replication/walsender.c:3809">WalSndSetState</a>(WALSNDSTATE_STARTUP);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get out of COPY mode (CommandComplete). */<br/></li>
<li></span>&nbsp; &nbsp; SetQueryCompletion(&amp;qc, CMDTAG_COPY, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../tcop/dest.c.html#L169" title="tcop/dest.c:169">EndCommand</a>(&amp;qc, DestRemote, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * LogicalDecodingContext 'prepare_write' callback.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Prepare a write into a StringInfo.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Don't do anything lasting in here, it's quite possible that nothing will be done<br/></li>
<li></span><span class="Comment"> * with the data.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1545">&#x200c;</a></span><span class="linkable">WalSndPrepareWrite</span>(LogicalDecodingContext *ctx, XLogRecPtr lsn, TransactionId xid, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> last_write)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* can't have sync rep confused by sending the same LSN several times */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!last_write)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lsn = InvalidXLogRecPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; resetStringInfo(ctx-&gt;out);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(ctx-&gt;out, <span class="Constant">'w'</span>);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(ctx-&gt;out, lsn);&nbsp; &nbsp; <span class="Comment">/* dataStart */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(ctx-&gt;out, lsn);&nbsp; &nbsp; <span class="Comment">/* walEnd */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fill out the sendtime later, just as it's done in <a href="#L3066" title="replication/walsender.c:3066">XLogSendPhysical</a>, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reserve space here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(ctx-&gt;out, <span class="Constant">0</span>);&nbsp; &nbsp; <span class="Comment">/* sendtime */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * LogicalDecodingContext 'write' callback.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Actually write out data previously prepared by <a href="#L1545" title="replication/walsender.c:1545">WalSndPrepareWrite</a> out to<br/></li>
<li></span><span class="Comment"> * the network. Take as long as needed, but process replies from the other<br/></li>
<li></span><span class="Comment"> * side and check timeouts during that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1572">&#x200c;</a></span><span class="linkable">WalSndWriteData</span>(LogicalDecodingContext *ctx, XLogRecPtr lsn, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> last_write)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fill the <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> timestamp last, so that it is taken as late as possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is somewhat ugly, but the protocol is set as it's already used for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * several releases by streaming physical replication.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; resetStringInfo(&amp;<a href="#L170" title="replication/walsender.c:170">tmpbuf</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(&amp;<a href="#L170" title="replication/walsender.c:170">tmpbuf</a>, <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>);<br/></li>
<li>&nbsp; &nbsp; memcpy(&amp;ctx-&gt;out-&gt;data[<span class="Constant">1</span> + <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64) + <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64)],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L170" title="replication/walsender.c:170">tmpbuf</a>.data, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* output previously gathered data in a CopyData packet */<br/></li>
<li></span>&nbsp; &nbsp; pq_putmessage_noblock(<span class="Constant">'d'</span>, ctx-&gt;out-&gt;data, ctx-&gt;out-&gt;len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try to flush pending output to the client */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pq_flush_if_writable() != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L390" title="replication/walsender.c:390">WalSndShutdown</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try taking fast path unless we get too close to walsender timeout. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> &lt; TimestampTzPlusMilliseconds(<a href="#L179" title="replication/walsender.c:179">last_reply_timestamp</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L123" title="replication/walsender.c:123">wal_sender_timeout</a> / <span class="Constant">2</span>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !pq_is_send_pending())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we have pending write here, go to slow path */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1614" title="replication/walsender.c:1614">ProcessPendingWrites</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait until there is no pending write. Also process replies from the other<br/></li>
<li></span><span class="Comment"> * side and check timeouts during that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1614">&#x200c;</a></span><span class="linkable">ProcessPendingWrites</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; sleeptime;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for input from the client */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2210" title="replication/walsender.c:2210">ProcessRepliesIfAny</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> if timeout was reached */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2740" title="replication/walsender.c:2740">WalSndCheckTimeOut</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Send keepalive if the time has come */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4057" title="replication/walsender.c:4057">WalSndKeepaliveIfNecessary</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pq_is_send_pending())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sleeptime = <a href="#L2696" title="replication/walsender.c:2696">WalSndComputeSleeptime</a>(<a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sleep until something happens or we time out */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3687" title="replication/walsender.c:3687">WalSndWait</a>(WL_SOCKET_WRITEABLE | WL_SOCKET_READABLE, sleeptime,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_WAL_SENDER_WRITE_DATA);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Clear <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> already-pending wakeups */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Process <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> requests or signals received recently */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../postmaster/interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../postmaster/interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ProcessConfigFile(PGC_SIGHUP);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="syncrep.c.html#L402" title="replication/syncrep.c:402">SyncRepInitConfig</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to flush pending output to the client */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pq_flush_if_writable() != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L390" title="replication/walsender.c:390">WalSndShutdown</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* reactivate latch so <a href="#L2767" title="replication/walsender.c:2767">WalSndLoop</a> knows to continue */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * LogicalDecodingContext 'update_progress' callback.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Write the current position to the lag tracker (see <a href="#L3066" title="replication/walsender.c:3066">XLogSendPhysical</a>).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When skipping empty transactions, <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a keepalive message if necessary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1668">&#x200c;</a></span><span class="linkable">WalSndUpdateProgress</span>(LogicalDecodingContext *ctx, XLogRecPtr lsn, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skipped_xact)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> TimestampTz sendTime = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; TimestampTz <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; pending_writes = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; end_xact = ctx-&gt;end_xact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Track lag no more than once per <a href="#L1684" title="replication/walsender.c:1684">WALSND_LOGICAL_LAG_TRACK_INTERVAL_MS</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * avoid flooding the lag tracker when we commit frequently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't have a mechanism to get the ack for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> LSN other than end<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xact LSN from the downstream. So, we track lag only for end of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction LSN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li><a id="L1684">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WALSND_LOGICAL_LAG_TRACK_INTERVAL_MS</span>&nbsp; &nbsp; </span><span class="Constant">1000<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (end_xact &amp;&amp; <a href="../utils/adt/timestamp.c.html#L1790" title="utils/adt/timestamp.c:1790">TimestampDifferenceExceeds</a>(sendTime, <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1684" title="replication/walsender.c:1684">WALSND_LOGICAL_LAG_TRACK_INTERVAL_MS</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4095" title="replication/walsender.c:4095">LagTrackerWrite</a>(lsn, <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sendTime = <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When skipping empty transactions in synchronous replication, we <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * keepalive message to avoid delaying such transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It is okay to check sync_standbys_defined flag without lock here as in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the worst case we will just <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> an extra keepalive message when it is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * really not required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (skipped_xact &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SyncRepRequested() &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((<span class="Type">volatile</span> WalSndCtlData *) <a href="#L109" title="replication/walsender.c:109">WalSndCtl</a>)-&gt;sync_standbys_defined)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4034" title="replication/walsender.c:4034">WalSndKeepalive</a>(<span class="Constant">false</span>, lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to flush pending output to the client */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pq_flush_if_writable() != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L390" title="replication/walsender.c:390">WalSndShutdown</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we have pending write here, make sure it's actually flushed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pq_is_send_pending())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pending_writes = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Process pending writes if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> or try to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a keepalive if required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't need to try sending keep alive messages at the transaction end<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as that will be done at a later point in time. This is required only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for large transactions where we don't <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> changes to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * downstream and the receiver can timeout due to that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pending_writes || (!end_xact &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> &gt;= TimestampTzPlusMilliseconds(<a href="#L179" title="replication/walsender.c:179">last_reply_timestamp</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L123" title="replication/walsender.c:123">wal_sender_timeout</a> / <span class="Constant">2</span>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1614" title="replication/walsender.c:1614">ProcessPendingWrites</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wake up the logical walsender processes with logical failover slots if the<br/></li>
<li></span><span class="Comment"> * currently acquired physical slot is specified in <a href="slot.c.html#L148" title="replication/slot.c:148">standby_slot_names</a> GUC.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1733">&#x200c;</a></span><span class="linkable">PhysicalWakeupLogicalWalSnd</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a> &amp;&amp; SlotIsPhysical(<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are running in a standby, there is no need to wake up walsenders.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is because we do not support syncing slots to cascading standbys,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so, there are no walsenders <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for standbys to catch up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="slot.c.html#L2549" title="replication/slot.c:2549">SlotExistsInStandbySlotNames</a>(NameStr(<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.name)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L282" title="storage/lmgr/condition_variable.c:282">ConditionVariableBroadcast</a>(&amp;<a href="#L109" title="replication/walsender.c:109">WalSndCtl</a>-&gt;wal_confirm_rcv_cv);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns true if not all standbys have caught up to the flushed position<br/></li>
<li></span><span class="Comment"> * (flushed_lsn) when the current acquired slot is a logical failover<br/></li>
<li></span><span class="Comment"> * slot and we are streaming; otherwise, returns false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If returning true, the function sets the appropriate wait event in<br/></li>
<li></span><span class="Comment"> * wait_event; otherwise, wait_event is set to 0.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1758">&#x200c;</a></span><span class="linkable">NeedToWaitForStandbys</span>(XLogRecPtr flushed_lsn, uint32 *wait_event)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elevel = <a href="#L198" title="replication/walsender.c:198">got_STOPPING</a> ? ERROR : WARNING;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; failover_slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; failover_slot = (<a href="#L206" title="replication/walsender.c:206">replication_active</a> &amp;&amp; <a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.failover);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that after receiving the shutdown signal, an ERROR is reported if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> slots are dropped, invalidated, or inactive. This measure is taken<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to prevent the walsender from <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> indefinitely.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (failover_slot &amp;&amp; !<a href="slot.c.html#L2582" title="replication/slot.c:2582">StandbySlotsHaveCaughtup</a>(flushed_lsn, elevel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *wait_event = WAIT_EVENT_WAIT_FOR_STANDBY_CONFIRMATION;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *wait_event = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns true if we need to wait for WALs to be flushed to disk, or if not<br/></li>
<li></span><span class="Comment"> * all standbys have caught up to the flushed position (flushed_lsn) when the<br/></li>
<li></span><span class="Comment"> * current acquired slot is a logical failover slot and we are<br/></li>
<li></span><span class="Comment"> * streaming; otherwise, returns false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If returning true, the function sets the appropriate wait event in<br/></li>
<li></span><span class="Comment"> * wait_event; otherwise, wait_event is set to 0.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1790">&#x200c;</a></span><span class="linkable">NeedToWaitForWal</span>(XLogRecPtr target_lsn, XLogRecPtr flushed_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint32 *wait_event)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if we need to wait for WALs to be flushed to disk */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (target_lsn &gt; flushed_lsn)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *wait_event = WAIT_EVENT_WAL_SENDER_WAIT_FOR_WAL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if the standby slots have caught up to the flushed position */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1758" title="replication/walsender.c:1758">NeedToWaitForStandbys</a>(flushed_lsn, wait_event);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait till WAL &lt; loc is flushed to disk so it can be safely sent to client.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the walsender holds a logical failover slot, we also wait for all the<br/></li>
<li></span><span class="Comment"> * specified streaming replication standby servers to confirm receipt of WAL<br/></li>
<li></span><span class="Comment"> * up to RecentFlushPtr. It is beneficial to wait here for the confirmation<br/></li>
<li></span><span class="Comment"> * up to RecentFlushPtr rather than <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> transmitting each change<br/></li>
<li></span><span class="Comment"> * to logical subscribers, which is already covered by RecentFlushPtr.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns end LSN of flushed WAL.&nbsp; Normally this will be &gt;= loc, but if we<br/></li>
<li></span><span class="Comment"> * detect a shutdown request (either from postmaster or client) we will return<br/></li>
<li></span><span class="Comment"> * early, so caller must always check.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> XLogRecPtr<br/></li>
<li><a id="L1818">&#x200c;</a><span class="linkable">WalSndWaitForWal</span>(XLogRecPtr loc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wakeEvents;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; wait_event = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> XLogRecPtr RecentFlushPtr = InvalidXLogRecPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fast path to avoid acquiring the spinlock in case we already know we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have enough WAL available and all the standby servers have confirmed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * receipt of WAL up to RecentFlushPtr. This is particularly interesting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we're far behind.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!XLogRecPtrIsInvalid(RecentFlushPtr) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L1790" title="replication/walsender.c:1790">NeedToWaitForWal</a>(loc, RecentFlushPtr, &amp;wait_event))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> RecentFlushPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Within the loop, we wait for the necessary WALs to be flushed to disk<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first, followed by <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for standbys to catch up if there are enough<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WALs (see <a href="#L1790" title="replication/walsender.c:1790">NeedToWaitForWal</a>()) or upon receiving the shutdown signal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; wait_for_standby_at_stop = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; sleeptime;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Clear <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> already-pending wakeups */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Process <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> requests or signals received recently */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../postmaster/interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../postmaster/interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ProcessConfigFile(PGC_SIGHUP);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="syncrep.c.html#L402" title="replication/syncrep.c:402">SyncRepInitConfig</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for input from the client */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2210" title="replication/walsender.c:2210">ProcessRepliesIfAny</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're shutting down, <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> pending WAL to be written out,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise we'd possibly end up <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for WAL that never gets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * written, because walwriter has shut down already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L198" title="replication/walsender.c:198">got_STOPPING</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlog.c.html#L2979" title="access/transam/xlog.c:2979">XLogBackgroundFlush</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To avoid the scenario where standbys need to catch up to a newer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL location in each iteration, we update our idea of the currently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * flushed position only if we are not <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for standbys to catch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (wait_event != WAIT_EVENT_WAIT_FOR_STANDBY_CONFIRMATION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RecentFlushPtr = <a href="../access/transam/xlog.c.html#L6455" title="access/transam/xlog.c:6455">GetFlushRecPtr</a>(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RecentFlushPtr = <a href="../access/transam/xlogrecovery.c.html#L4539" title="access/transam/xlogrecovery.c:4539">GetXLogReplayRecPtr</a>(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If postmaster asked us to stop and the standby slots have caught up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the flushed position, don't wait anymore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's important to do this check after the recomputation of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * RecentFlushPtr, so we can <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> all remaining data <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> shutting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * down.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L198" title="replication/walsender.c:198">got_STOPPING</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1758" title="replication/walsender.c:1758">NeedToWaitForStandbys</a>(RecentFlushPtr, &amp;wait_event))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wait_for_standby_at_stop = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We only <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> regular messages to the client for full decoded<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transactions, but a synchronous replication and walsender shutdown<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possibly are <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for a later location. So, <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> sleeping, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a ping containing the flush location. If the receiver is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise idle, this keepalive will <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> a reply. Processing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reply will update these <a href="#L112" title="replication/walsender.c:112">MyWalSnd</a> locations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L112" title="replication/walsender.c:112">MyWalSnd</a>-&gt;flush &lt; <a href="#L165" title="replication/walsender.c:165">sentPtr</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L112" title="replication/walsender.c:112">MyWalSnd</a>-&gt;write &lt; <a href="#L165" title="replication/walsender.c:165">sentPtr</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L182" title="replication/walsender.c:182">waiting_for_ping_response</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4034" title="replication/walsender.c:4034">WalSndKeepalive</a>(<span class="Constant">false</span>, InvalidXLogRecPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Exit the loop if already caught up and doesn't need to wait for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * standby slots.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!wait_for_standby_at_stop &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L1790" title="replication/walsender.c:1790">NeedToWaitForWal</a>(loc, RecentFlushPtr, &amp;wait_event))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Waiting for new WAL or <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for standbys to catch up. Since we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to wait, we're <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> caught up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L194" title="replication/walsender.c:194">WalSndCaughtUp</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to flush <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending output to the client.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pq_flush_if_writable() != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L390" title="replication/walsender.c:390">WalSndShutdown</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have received CopyDone from the client, sent CopyDone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ourselves, and the output buffer is empty, it's time to exit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * streaming, so fail the current WAL fetch request.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L191" title="replication/walsender.c:191">streamingDoneReceiving</a> &amp;&amp; <a href="#L190" title="replication/walsender.c:190">streamingDoneSending</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !pq_is_send_pending())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> if timeout was reached */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2740" title="replication/walsender.c:2740">WalSndCheckTimeOut</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Send keepalive if the time has come */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4057" title="replication/walsender.c:4057">WalSndKeepaliveIfNecessary</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sleep until something happens or we time out.&nbsp; Also wait for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> becoming writable, if there's still pending output.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise we might sit on sendable output data while <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * new WAL to be generated.&nbsp; (But if we have nothing to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a>, we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * want to wake on <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>-writable.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sleeptime = <a href="#L2696" title="replication/walsender.c:2696">WalSndComputeSleeptime</a>(<a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; wakeEvents = WL_SOCKET_READABLE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pq_is_send_pending())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wakeEvents |= WL_SOCKET_WRITEABLE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(wait_event != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3687" title="replication/walsender.c:3687">WalSndWait</a>(wakeEvents, sleeptime, wait_event);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* reactivate latch so <a href="#L2767" title="replication/walsender.c:2767">WalSndLoop</a> knows to continue */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> RecentFlushPtr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Execute an incoming replication command.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if the cmd_string was recognized as WalSender command, false<br/></li>
<li></span><span class="Comment"> * if not.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1977">&#x200c;</a></span><span class="linkable">exec_replication_command</span>(<span class="Type">const</span> <span class="Type">char</span> *cmd_string)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parse_rc;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *cmd_node;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *cmdtag;<br/></li>
<li>&nbsp; &nbsp; MemoryContext cmd_context;<br/></li>
<li>&nbsp; &nbsp; MemoryContext old_context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If WAL sender has been told that shutdown is getting close, switch its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * status accordingly to handle the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> replication commands correctly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L198" title="replication/walsender.c:198">got_STOPPING</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3809" title="replication/walsender.c:3809">WalSndSetState</a>(WALSNDSTATE_STOPPING);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Throw error if in stopping mode.&nbsp; We need prevent commands that could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * generate WAL while the shutdown checkpoint is being written.&nbsp; To be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * safe, we just prohibit all new commands.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L112" title="replication/walsender.c:112">MyWalSnd</a>-&gt;state == WALSNDSTATE_STOPPING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot execute new commands while WAL sender is in stopping mode&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CREATE_REPLICATION_SLOT ... LOGICAL exports a snapshot until the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * command arrives. Clean up the old stuff if there's anything.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="logical/snapbuild.c.html#L729" title="replication/logical/snapbuild.c:729">SnapBuildClearExportedSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare to <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> and execute the command.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cmd_context = AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;Replication command context&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; old_context = MemoryContextSwitchTo(cmd_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; replication_scanner_init(cmd_string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Is it a WalSender command?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!replication_scanner_is_replication_command())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Nope; clean up and get out. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; replication_scanner_finish();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(old_context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(cmd_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> this is a pretty random place to make this check */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a> == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot execute SQL commands in WAL sender for physical replication&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Tell the caller that this wasn't a WalSender command. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Looks like a WalSender command, so <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; parse_rc = replication_yyparse();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (parse_rc != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;replication command parser returned </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parse_rc)));<br/></li>
<li>&nbsp; &nbsp; replication_scanner_finish();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cmd_node = replication_parse_result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Report query to various monitoring facilities.&nbsp; For this purpose, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * report replication commands just like SQL commands.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../tcop/postgres.c.html#L87" title="tcop/postgres.c:87">debug_query_string</a> = cmd_string;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_RUNNING, cmd_string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Log replication command if <a href="#L125" title="replication/walsender.c:125">log_replication_commands</a> is enabled. Even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when it's disabled, log the command with DEBUG1 level for backward<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * compatibility.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ereport(<a href="#L125" title="replication/walsender.c:125">log_replication_commands</a> ? LOG : DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;received replication command: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, cmd_string)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Disallow replication commands in aborted transaction blocks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xact.c.html#L404" title="access/transam/xact.c:404">IsAbortedTransactionBlockState</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_IN_FAILED_SQL_TRANSACTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;current transaction is aborted, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;commands ignored until end of transaction block&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate buffers that will be used for each outgoing and incoming<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * message.&nbsp; We do this just once per command to reduce <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> overhead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; initStringInfo(&amp;<a href="#L168" title="replication/walsender.c:168">output_message</a>);<br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;<a href="walreceiver.c.html#L131" title="replication/walreceiver.c:131">reply_message</a>);<br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;<a href="#L170" title="replication/walsender.c:170">tmpbuf</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (cmd_node-&gt;type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IdentifySystemCmd:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmdtag = <span class="Constant">&quot;IDENTIFY_SYSTEM&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_ps_display(cmdtag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L407" title="replication/walsender.c:407">IdentifySystem</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/dest.c.html#L205" title="tcop/dest.c:205">EndReplicationCommand</a>(cmdtag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ReadReplicationSlotCmd:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmdtag = <span class="Constant">&quot;READ_REPLICATION_SLOT&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_ps_display(cmdtag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L490" title="replication/walsender.c:490">ReadReplicationSlot</a>((ReadReplicationSlotCmd *) cmd_node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/dest.c.html#L205" title="tcop/dest.c:205">EndReplicationCommand</a>(cmdtag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_BaseBackupCmd:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmdtag = <span class="Constant">&quot;BASE_BACKUP&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_ps_display(cmdtag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3584" title="access/transam/xact.c:3584">PreventInTransactionBlock</a>(<span class="Constant">true</span>, cmdtag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../backup/basebackup.c.html#L988" title="backup/basebackup.c:988">SendBaseBackup</a>((BaseBackupCmd *) cmd_node, <a href="#L147" title="replication/walsender.c:147">uploaded_manifest</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/dest.c.html#L205" title="tcop/dest.c:205">EndReplicationCommand</a>(cmdtag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_CreateReplicationSlotCmd:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmdtag = <span class="Constant">&quot;CREATE_REPLICATION_SLOT&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_ps_display(cmdtag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1200" title="replication/walsender.c:1200">CreateReplicationSlot</a>((CreateReplicationSlotCmd *) cmd_node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/dest.c.html#L205" title="tcop/dest.c:205">EndReplicationCommand</a>(cmdtag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_DropReplicationSlotCmd:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmdtag = <span class="Constant">&quot;DROP_REPLICATION_SLOT&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_ps_display(cmdtag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1405" title="replication/walsender.c:1405">DropReplicationSlot</a>((DropReplicationSlotCmd *) cmd_node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/dest.c.html#L205" title="tcop/dest.c:205">EndReplicationCommand</a>(cmdtag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_AlterReplicationSlotCmd:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmdtag = <span class="Constant">&quot;ALTER_REPLICATION_SLOT&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_ps_display(cmdtag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1439" title="replication/walsender.c:1439">AlterReplicationSlot</a>((AlterReplicationSlotCmd *) cmd_node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/dest.c.html#L205" title="tcop/dest.c:205">EndReplicationCommand</a>(cmdtag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_StartReplicationCmd:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StartReplicationCmd *cmd = (StartReplicationCmd *) cmd_node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmdtag = <span class="Constant">&quot;START_REPLICATION&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_ps_display(cmdtag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3584" title="access/transam/xact.c:3584">PreventInTransactionBlock</a>(<span class="Constant">true</span>, cmdtag);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cmd-&gt;kind == REPLICATION_KIND_PHYSICAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L819" title="replication/walsender.c:819">StartReplication</a>(cmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1452" title="replication/walsender.c:1452">StartLogicalReplication</a>(cmd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dupe, but necessary per <a href="libpqwalreceiver/libpqwalreceiver.c.html#L655" title="replication/libpqwalreceiver/libpqwalreceiver.c:655">libpqrcv_endstreaming</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/dest.c.html#L205" title="tcop/dest.c:205">EndReplicationCommand</a>(cmdtag);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L137" title="replication/walsender.c:137">xlogreader</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_TimeLineHistoryCmd:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmdtag = <span class="Constant">&quot;TIMELINE_HISTORY&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_ps_display(cmdtag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3584" title="access/transam/xact.c:3584">PreventInTransactionBlock</a>(<span class="Constant">true</span>, cmdtag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L589" title="replication/walsender.c:589">SendTimeLineHistory</a>((TimeLineHistoryCmd *) cmd_node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/dest.c.html#L205" title="tcop/dest.c:205">EndReplicationCommand</a>(cmdtag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_VariableShowStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DestReceiver *dest = <a href="../tcop/dest.c.html#L113" title="tcop/dest.c:113">CreateDestReceiver</a>(DestRemoteSimple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VariableShowStmt *n = (VariableShowStmt *) cmd_node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmdtag = <span class="Constant">&quot;SHOW&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_ps_display(cmdtag);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* syscache access needs a transaction environment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc_funcs.c.html#L382" title="utils/misc/guc_funcs.c:382">GetPGVariable</a>(n-&gt;name, dest);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/dest.c.html#L205" title="tcop/dest.c:205">EndReplicationCommand</a>(cmdtag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_UploadManifestCmd:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmdtag = <span class="Constant">&quot;UPLOAD_MANIFEST&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_ps_display(cmdtag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3584" title="access/transam/xact.c:3584">PreventInTransactionBlock</a>(<span class="Constant">true</span>, cmdtag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L679" title="replication/walsender.c:679">UploadManifest</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/dest.c.html#L205" title="tcop/dest.c:205">EndReplicationCommand</a>(cmdtag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized replication command node tag: </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cmd_node-&gt;type);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* done */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(old_context);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(cmd_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need not update ps display or pg_stat_activity, because <a href="../tcop/postgres.c.html#L4152" title="tcop/postgres.c:4152">PostgresMain</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will reset those to &quot;idle&quot;.&nbsp; But we must reset <a href="../tcop/postgres.c.html#L87" title="tcop/postgres.c:87">debug_query_string</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensure it doesn't become a dangling pointer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../tcop/postgres.c.html#L87" title="tcop/postgres.c:87">debug_query_string</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Process <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> incoming messages while streaming. Also checks if the remote<br/></li>
<li></span><span class="Comment"> * end has closed the connection.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2210">&#x200c;</a></span><span class="linkable">ProcessRepliesIfAny</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> firstchar;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxmsglen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; received = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L173" title="replication/walsender.c:173">last_processing</a> = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we already received a CopyDone from the frontend, <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subsequent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * message is the beginning of a new command, and should be processed in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> processing loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (!<a href="#L191" title="replication/walsender.c:191">streamingDoneReceiving</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/pqcomm.c.html#L1140" title="libpq/pqcomm.c:1140">pq_startmsgread</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r = <a href="../libpq/pqcomm.c.html#L1003" title="libpq/pqcomm.c:1003">pq_getbyte_if_available</a>(&amp;firstchar);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* unexpected error or EOF */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(COMMERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unexpected EOF on standby connection&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no data available without blocking */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/pqcomm.c.html#L1164" title="libpq/pqcomm.c:1164">pq_endmsgread</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Validate message type and set packet size limit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (firstchar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_CopyData:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxmsglen = PQ_LARGE_MESSAGE_LIMIT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_CopyDone:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_Terminate:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxmsglen = PQ_SMALL_MESSAGE_LIMIT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid standby message type </span><span class="Special">\&quot;%c\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstchar)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxmsglen = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Read the message contents */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; resetStringInfo(&amp;<a href="walreceiver.c.html#L131" title="replication/walreceiver.c:131">reply_message</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../libpq/pqcomm.c.html#L1202" title="libpq/pqcomm.c:1202">pq_getmessage</a>(&amp;<a href="walreceiver.c.html#L131" title="replication/walreceiver.c:131">reply_message</a>, maxmsglen))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(COMMERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unexpected EOF on standby connection&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and process it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (firstchar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 'd' means a standby reply wrapped in a CopyData packet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_CopyData:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2323" title="replication/walsender.c:2323">ProcessStandbyMessage</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; received = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * CopyDone means the standby requested to finish streaming.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reply with CopyDone, if we had not sent that already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_CopyDone:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L190" title="replication/walsender.c:190">streamingDoneSending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_putmessage_noblock(<span class="Constant">'c'</span>, <span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L190" title="replication/walsender.c:190">streamingDoneSending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L191" title="replication/walsender.c:191">streamingDoneReceiving</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; received = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 'X' means that the standby is closing down the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_Terminate:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);&nbsp; &nbsp; <span class="Comment">/* NOT REACHED */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Save the last reply timestamp if we've received at least one reply.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (received)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L179" title="replication/walsender.c:179">last_reply_timestamp</a> = <a href="#L173" title="replication/walsender.c:173">last_processing</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L182" title="replication/walsender.c:182">waiting_for_ping_response</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Process a status update message received from standby.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2323">&#x200c;</a></span><span class="linkable">ProcessStandbyMessage</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; msgtype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check message type from the first byte.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; msgtype = <a href="../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(&amp;<a href="walreceiver.c.html#L131" title="replication/walreceiver.c:131">reply_message</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (msgtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'r'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2387" title="replication/walsender.c:2387">ProcessStandbyReplyMessage</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'h'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2572" title="replication/walsender.c:2572">ProcessStandbyHSFeedbackMessage</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(COMMERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unexpected message type </span><span class="Special">\&quot;%c\&quot;</span><span class="Constant">&quot;</span>, msgtype)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remember that a walreceiver just confirmed receipt of lsn `lsn`.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2354">&#x200c;</a></span><span class="linkable">PhysicalConfirmReceivedLocation</span>(XLogRecPtr lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; changed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ReplicationSlot *slot = <a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(lsn != InvalidXLogRecPtr);<br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;slot-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;data.restart_lsn != lsn)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; changed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;data.restart_lsn = lsn;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;slot-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (changed)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L1010" title="replication/slot.c:1010">ReplicationSlotMarkDirty</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L1105" title="replication/slot.c:1105">ReplicationSlotsComputeRequiredLSN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1733" title="replication/walsender.c:1733">PhysicalWakeupLogicalWalSnd</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * One could argue that the slot should be saved to disk <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, but that'd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be energy wasted - the worst thing lost information could cause here is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to give wrong information in a statistics view - we'll just potentially<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be more conservative in removing files.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Regular reply from standby advising of WAL locations on standby server.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2387">&#x200c;</a></span><span class="linkable">ProcessStandbyReplyMessage</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; writePtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flushPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; applyPtr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; replyRequested;<br/></li>
<li>&nbsp; &nbsp; TimeOffset&nbsp; &nbsp; writeLag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flushLag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; applyLag;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; clearLagTimes;<br/></li>
<li>&nbsp; &nbsp; TimestampTz <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; TimestampTz replyTime;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> fullyAppliedLastTime = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the caller already consumed the msgtype byte */<br/></li>
<li></span>&nbsp; &nbsp; writePtr = <a href="../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;<a href="walreceiver.c.html#L131" title="replication/walreceiver.c:131">reply_message</a>);<br/></li>
<li>&nbsp; &nbsp; flushPtr = <a href="../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;<a href="walreceiver.c.html#L131" title="replication/walreceiver.c:131">reply_message</a>);<br/></li>
<li>&nbsp; &nbsp; applyPtr = <a href="../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;<a href="walreceiver.c.html#L131" title="replication/walreceiver.c:131">reply_message</a>);<br/></li>
<li>&nbsp; &nbsp; replyTime = <a href="../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;<a href="walreceiver.c.html#L131" title="replication/walreceiver.c:131">reply_message</a>);<br/></li>
<li>&nbsp; &nbsp; replyRequested = <a href="../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(&amp;<a href="walreceiver.c.html#L131" title="replication/walreceiver.c:131">reply_message</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/error/elog.c.html#L276" title="utils/error/elog.c:276">message_level_is_interesting</a>(DEBUG2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *replyTimeStr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy because <a href="../utils/adt/timestamp.c.html#L1853" title="utils/adt/timestamp.c:1853">timestamptz_to_str</a> returns a static buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; replyTimeStr = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<a href="../utils/adt/timestamp.c.html#L1853" title="utils/adt/timestamp.c:1853">timestamptz_to_str</a>(replyTime));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;write </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> flush </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> apply </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X%s</span><span class="Constant"> reply_time </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(writePtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(flushPtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(applyPtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; replyRequested ? <span class="Constant">&quot; (reply requested)&quot;</span> : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; replyTimeStr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(replyTimeStr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* See if we can compute the round-trip lag for these positions. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; writeLag = <a href="#L4160" title="replication/walsender.c:4160">LagTrackerRead</a>(SYNC_REP_WAIT_WRITE, writePtr, <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>);<br/></li>
<li>&nbsp; &nbsp; flushLag = <a href="#L4160" title="replication/walsender.c:4160">LagTrackerRead</a>(SYNC_REP_WAIT_FLUSH, flushPtr, <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>);<br/></li>
<li>&nbsp; &nbsp; applyLag = <a href="#L4160" title="replication/walsender.c:4160">LagTrackerRead</a>(SYNC_REP_WAIT_APPLY, applyPtr, <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the standby reports that it has fully replayed the WAL in two<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consecutive reply messages, then the second such message must result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from <a href="walreceiver.c.html#L87" title="replication/walreceiver.c:87">wal_receiver_status_interval</a> expiring on the standby.&nbsp; This is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * convenient time to forget the lag times measured when it last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wrote/flushed/applied a WAL record, to avoid displaying stale lag data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * until more WAL traffic arrives.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; clearLagTimes = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (applyPtr == <a href="#L165" title="replication/walsender.c:165">sentPtr</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fullyAppliedLastTime)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clearLagTimes = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fullyAppliedLastTime = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fullyAppliedLastTime = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Send a reply if the standby requested one. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (replyRequested)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4034" title="replication/walsender.c:4034">WalSndKeepalive</a>(<span class="Constant">false</span>, InvalidXLogRecPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update shared state for this WalSender process based on reply data from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * standby.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WalSnd&nbsp; &nbsp; &nbsp;&nbsp; *walsnd = <a href="#L112" title="replication/walsender.c:112">MyWalSnd</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;walsnd-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; walsnd-&gt;write = writePtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; walsnd-&gt;flush = flushPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; walsnd-&gt;apply = applyPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (writeLag != -<span class="Constant">1</span> || clearLagTimes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walsnd-&gt;writeLag = writeLag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flushLag != -<span class="Constant">1</span> || clearLagTimes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walsnd-&gt;flushLag = flushLag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (applyLag != -<span class="Constant">1</span> || clearLagTimes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walsnd-&gt;applyLag = applyLag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; walsnd-&gt;replyTime = replyTime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;walsnd-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L116" title="replication/walsender.c:116">am_cascading_walsender</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syncrep.c.html#L431" title="replication/syncrep.c:431">SyncRepReleaseWaiters</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Advance our local xmin horizon when the client confirmed a flush.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a> &amp;&amp; flushPtr != InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (SlotIsLogical(<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="logical/logical.c.html#L1834" title="replication/logical/logical.c:1834">LogicalConfirmReceivedLocation</a>(flushPtr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2354" title="replication/walsender.c:2354">PhysicalConfirmReceivedLocation</a>(flushPtr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* compute new replication slot xmin horizon if needed */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2492">&#x200c;</a></span><span class="linkable">PhysicalReplicationSlotNewXmin</span>(TransactionId feedbackXmin, TransactionId feedbackCatalogXmin)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; changed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ReplicationSlot *slot = <a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;slot-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For physical replication we don't need the interlock provided by xmin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and effective_xmin since the consequences of a missed increase are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * limited to query cancellations, so set both at once.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsNormal(slot-&gt;data.xmin) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !TransactionIdIsNormal(feedbackXmin) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(slot-&gt;data.xmin, feedbackXmin))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; changed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;data.xmin = feedbackXmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;effective_xmin = feedbackXmin;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsNormal(slot-&gt;data.catalog_xmin) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !TransactionIdIsNormal(feedbackCatalogXmin) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(slot-&gt;data.catalog_xmin, feedbackCatalogXmin))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; changed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;data.catalog_xmin = feedbackCatalogXmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;effective_catalog_xmin = feedbackCatalogXmin;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;slot-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (changed)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L1010" title="replication/slot.c:1010">ReplicationSlotMarkDirty</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L1049" title="replication/slot.c:1049">ReplicationSlotsComputeRequiredXmin</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check that the provided xmin/epoch are sane, that is, not in the future<br/></li>
<li></span><span class="Comment"> * and not so far back as to be already wrapped around.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Epoch of nextXid should be same as standby, or if the counter has<br/></li>
<li></span><span class="Comment"> * wrapped, then one greater than standby.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This check doesn't care about whether clog exists for these xids<br/></li>
<li></span><span class="Comment"> * at all.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2541">&#x200c;</a></span><span class="linkable">TransactionIdInRecentPast</span>(TransactionId xid, uint32 epoch)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FullTransactionId nextFullXid;<br/></li>
<li>&nbsp; &nbsp; TransactionId nextXid;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; nextEpoch;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nextFullXid = <a href="../access/transam/varsup.c.html#L288" title="access/transam/varsup.c:288">ReadNextFullTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; nextXid = XidFromFullTransactionId(nextFullXid);<br/></li>
<li>&nbsp; &nbsp; nextEpoch = EpochFromFullTransactionId(nextFullXid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xid &lt;= nextXid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (epoch != nextEpoch)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (epoch + <span class="Constant">1</span> != nextEpoch)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../access/transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(xid, nextXid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* epoch OK, but it's wrapped around */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Hot Standby feedback<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2572">&#x200c;</a></span><span class="linkable">ProcessStandbyHSFeedbackMessage</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId feedbackXmin;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; feedbackEpoch;<br/></li>
<li>&nbsp; &nbsp; TransactionId feedbackCatalogXmin;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; feedbackCatalogEpoch;<br/></li>
<li>&nbsp; &nbsp; TimestampTz replyTime;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Decipher the reply message. The caller already consumed the msgtype<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * byte. See <a href="walreceiver.c.html#L1169" title="replication/walreceiver.c:1169">XLogWalRcvSendHSFeedback</a>() in walreceiver.c for the creation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of this message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; replyTime = <a href="../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;<a href="walreceiver.c.html#L131" title="replication/walreceiver.c:131">reply_message</a>);<br/></li>
<li>&nbsp; &nbsp; feedbackXmin = <a href="../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(&amp;<a href="walreceiver.c.html#L131" title="replication/walreceiver.c:131">reply_message</a>, <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; feedbackEpoch = <a href="../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(&amp;<a href="walreceiver.c.html#L131" title="replication/walreceiver.c:131">reply_message</a>, <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; feedbackCatalogXmin = <a href="../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(&amp;<a href="walreceiver.c.html#L131" title="replication/walreceiver.c:131">reply_message</a>, <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; feedbackCatalogEpoch = <a href="../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(&amp;<a href="walreceiver.c.html#L131" title="replication/walreceiver.c:131">reply_message</a>, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/error/elog.c.html#L276" title="utils/error/elog.c:276">message_level_is_interesting</a>(DEBUG2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *replyTimeStr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy because <a href="../utils/adt/timestamp.c.html#L1853" title="utils/adt/timestamp.c:1853">timestamptz_to_str</a> returns a static buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; replyTimeStr = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<a href="../utils/adt/timestamp.c.html#L1853" title="utils/adt/timestamp.c:1853">timestamptz_to_str</a>(replyTime));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;hot standby feedback xmin </span><span class="Special">%u</span><span class="Constant"> epoch </span><span class="Special">%u</span><span class="Constant">, catalog_xmin </span><span class="Special">%u</span><span class="Constant"> epoch </span><span class="Special">%u</span><span class="Constant"> reply_time </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; feedbackXmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; feedbackEpoch,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; feedbackCatalogXmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; feedbackCatalogEpoch,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; replyTimeStr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(replyTimeStr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update shared state for this WalSender process based on reply data from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * standby.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WalSnd&nbsp; &nbsp; &nbsp;&nbsp; *walsnd = <a href="#L112" title="replication/walsender.c:112">MyWalSnd</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;walsnd-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; walsnd-&gt;replyTime = replyTime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;walsnd-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unset WalSender's xmins if the feedback message <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are invalid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This happens when the downstream turned <a href="walreceiver.c.html#L89" title="replication/walreceiver.c:89">hot_standby_feedback</a> off.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsNormal(feedbackXmin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; !TransactionIdIsNormal(feedbackCatalogXmin))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2492" title="replication/walsender.c:2492">PhysicalReplicationSlotNewXmin</a>(feedbackXmin, feedbackCatalogXmin);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that the provided xmin/epoch are sane, that is, not in the future<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and not so far back as to be already wrapped around.&nbsp; Ignore if not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsNormal(feedbackXmin) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L2541" title="replication/walsender.c:2541">TransactionIdInRecentPast</a>(feedbackXmin, feedbackEpoch))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsNormal(feedbackCatalogXmin) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L2541" title="replication/walsender.c:2541">TransactionIdInRecentPast</a>(feedbackCatalogXmin, feedbackCatalogEpoch))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set the WalSender's xmin <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the standby's requested xmin, so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the xmin will be taken into account by <a href="../storage/ipc/procarray.c.html#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a>() /<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../storage/ipc/procarray.c.html#L1723" title="storage/ipc/procarray.c:1723">ComputeXidHorizons</a>().&nbsp; This will hold back the removal of dead rows and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * thereby prevent the generation of <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> conflicts on the standby<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * server.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There is a small window for a race condition here: although we just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checked that feedbackXmin precedes nextXid, the nextXid could have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * gotten advanced between our fetching it and applying the xmin below,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * perhaps far enough to make feedbackXmin wrap around.&nbsp; In that case the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xmin we set here would be &quot;in the future&quot; and have no effect.&nbsp; No point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in worrying about this since it's too late to save the desired data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anyway.&nbsp; Assuming that the standby sends us an increasing sequence of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xmins, this could only happen during the first reply cycle, else our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * own xmin would prevent nextXid from advancing so far.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't bother taking the ProcArrayLock here.&nbsp; Setting the xmin field<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is assumed atomic, and there's no real need to prevent concurrent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * horizon determinations.&nbsp; (If we're moving our xmin forward, this is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * obviously safe, and if we're moving it backwards, well, the data is at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * risk already since a VACUUM could already have determined the horizon.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're using a replication slot we reserve the xmin via that,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otherwise via the walsender's PGPROC entry. We can only track the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catalog xmin separately when using a slot, so we store the least of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * two provided when not using a slot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: It might make sense to generalize the ephemeral slot concept and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * always use the slot mechanism to handle the feedback xmin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a> != <span class="Constant">NULL</span>)&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment">: persistency configurable? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2492" title="replication/walsender.c:2492">PhysicalReplicationSlotNewXmin</a>(feedbackXmin, feedbackCatalogXmin);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsNormal(feedbackCatalogXmin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; <a href="../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(feedbackCatalogXmin, feedbackXmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin = feedbackCatalogXmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin = feedbackXmin;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute how long <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a>/receive loops should sleep.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If <a href="#L123" title="replication/walsender.c:123">wal_sender_timeout</a> is enabled we want to wake up in time to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a><br/></li>
<li></span><span class="Comment"> * keepalives and to abort the connection if <a href="#L123" title="replication/walsender.c:123">wal_sender_timeout</a> has been<br/></li>
<li></span><span class="Comment"> * reached.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">long<br/></li>
<li><a id="L2696">&#x200c;</a></span><span class="linkable">WalSndComputeSleeptime</span>(TimestampTz <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; sleeptime = <span class="Constant">10000</span>;&nbsp; &nbsp; <span class="Comment">/* 10 s */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L123" title="replication/walsender.c:123">wal_sender_timeout</a> &gt; <span class="Constant">0</span> &amp;&amp; <a href="#L179" title="replication/walsender.c:179">last_reply_timestamp</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz wakeup_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At the latest stop sleeping once <a href="#L123" title="replication/walsender.c:123">wal_sender_timeout</a> has been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reached.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; wakeup_time = TimestampTzPlusMilliseconds(<a href="#L179" title="replication/walsender.c:179">last_reply_timestamp</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L123" title="replication/walsender.c:123">wal_sender_timeout</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If no ping has been sent yet, <a href="walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a> when it's time to do so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L4057" title="replication/walsender.c:4057">WalSndKeepaliveIfNecessary</a>() wants to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a keepalive once half of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the timeout passed without a response.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L182" title="replication/walsender.c:182">waiting_for_ping_response</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wakeup_time = TimestampTzPlusMilliseconds(<a href="#L179" title="replication/walsender.c:179">last_reply_timestamp</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L123" title="replication/walsender.c:123">wal_sender_timeout</a> / <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute relative time until <a href="walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sleeptime = <a href="../utils/adt/timestamp.c.html#L1766" title="utils/adt/timestamp.c:1766">TimestampDifferenceMilliseconds</a>(<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, wakeup_time);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> sleeptime;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether there have been responses by the client within<br/></li>
<li></span><span class="Comment"> * <a href="#L123" title="replication/walsender.c:123">wal_sender_timeout</a> and shutdown if not.&nbsp; Using <a href="#L173" title="replication/walsender.c:173">last_processing</a> as the<br/></li>
<li></span><span class="Comment"> * reference point avoids counting server-side stalls against the client.<br/></li>
<li></span><span class="Comment"> * However, a long server-side stall can make <a href="#L4057" title="replication/walsender.c:4057">WalSndKeepaliveIfNecessary</a>()<br/></li>
<li></span><span class="Comment"> * postdate <a href="#L173" title="replication/walsender.c:173">last_processing</a> by more than <a href="#L123" title="replication/walsender.c:123">wal_sender_timeout</a>.&nbsp; If that happens,<br/></li>
<li></span><span class="Comment"> * the client must reply almost immediately to avoid a timeout.&nbsp; This rarely<br/></li>
<li></span><span class="Comment"> * affects the default configuration, under which clients spontaneously <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a<br/></li>
<li></span><span class="Comment"> * message every standby_message_timeout = <a href="#L123" title="replication/walsender.c:123">wal_sender_timeout</a>/6 = 10s.&nbsp; We<br/></li>
<li></span><span class="Comment"> * could eliminate that problem by recognizing timeout expiration at<br/></li>
<li></span><span class="Comment"> * <a href="#L123" title="replication/walsender.c:123">wal_sender_timeout</a>/2 after the keepalive.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2740">&#x200c;</a></span><span class="linkable">WalSndCheckTimeOut</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz timeout;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't bail out if we're doing something that doesn't require timeouts */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L179" title="replication/walsender.c:179">last_reply_timestamp</a> &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; timeout = TimestampTzPlusMilliseconds(<a href="#L179" title="replication/walsender.c:179">last_reply_timestamp</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L123" title="replication/walsender.c:123">wal_sender_timeout</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L123" title="replication/walsender.c:123">wal_sender_timeout</a> &gt; <span class="Constant">0</span> &amp;&amp; <a href="#L173" title="replication/walsender.c:173">last_processing</a> &gt;= timeout)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since typically expiration of replication timeout means<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * communication problem, we don't <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the error message to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * standby.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(COMMERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;terminating walsender process due to replication timeout&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L390" title="replication/walsender.c:390">WalSndShutdown</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Main loop of walsender process that streams the WAL over Copy messages. */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2767">&#x200c;</a></span><span class="linkable">WalSndLoop</span>(<a href="#L236" title="replication/walsender.c:236">WalSndSendDataCallback</a> send_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize the last reply timestamp. That enables timeout processing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from hereon.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L179" title="replication/walsender.c:179">last_reply_timestamp</a> = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L182" title="replication/walsender.c:182">waiting_for_ping_response</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop until we reach the end of this timeline or the client requests to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stop streaming.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Clear <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> already-pending wakeups */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Process <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> requests or signals received recently */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../postmaster/interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../postmaster/interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ProcessConfigFile(PGC_SIGHUP);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="syncrep.c.html#L402" title="replication/syncrep.c:402">SyncRepInitConfig</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for input from the client */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2210" title="replication/walsender.c:2210">ProcessRepliesIfAny</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have received CopyDone from the client, sent CopyDone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ourselves, and the output buffer is empty, it's time to exit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * streaming.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L191" title="replication/walsender.c:191">streamingDoneReceiving</a> &amp;&amp; <a href="#L190" title="replication/walsender.c:190">streamingDoneSending</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !pq_is_send_pending())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we don't have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending data in the output buffer, try to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * some more.&nbsp; If there is some, we don't bother to call send_data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * again until we've flushed it ... but we'd better assume we are not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caught up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pq_is_send_pending())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; send_data();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L194" title="replication/walsender.c:194">WalSndCaughtUp</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to flush pending output to the client */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pq_flush_if_writable() != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L390" title="replication/walsender.c:390">WalSndShutdown</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If nothing remains to be sent right <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L194" title="replication/walsender.c:194">WalSndCaughtUp</a> &amp;&amp; !pq_is_send_pending())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're in catchup state, move to streaming.&nbsp; This is an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * important state change for users to know about, since <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this point data loss might occur if the primary dies and we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to failover to the standby. The state change is also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * important for synchronous replication, since commits that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * started to wait at that point might wait for some time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L112" title="replication/walsender.c:112">MyWalSnd</a>-&gt;state == WALSNDSTATE_CATCHUP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> caught up with upstream server&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/misc/guc_tables.c.html#L546" title="utils/misc/guc_tables.c:546">application_name</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3809" title="replication/walsender.c:3809">WalSndSetState</a>(WALSNDSTATE_STREAMING);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When SIGUSR2 arrives, we <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outstanding logs up to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shutdown checkpoint record (i.e., the latest record), wait for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * them to be replicated to the standby, and exit. This may be a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * normal termination at shutdown, or a promotion, the walsender<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is not sure which.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L197" title="replication/walsender.c:197">got_SIGUSR2</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3461" title="replication/walsender.c:3461">WalSndDone</a>(send_data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for replication timeout. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2740" title="replication/walsender.c:2740">WalSndCheckTimeOut</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Send keepalive if the time has come */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4057" title="replication/walsender.c:4057">WalSndKeepaliveIfNecessary</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Block if we have unsent data.&nbsp; </span><span class="Todo">XXX</span><span class="Comment"> For logical replication, let<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1818" title="replication/walsender.c:1818">WalSndWaitForWal</a>() handle <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other blocking; idle receivers need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * its additional actions.&nbsp; For physical replication, also block if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caught up; its send_data does not block.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((<a href="#L194" title="replication/walsender.c:194">WalSndCaughtUp</a> &amp;&amp; send_data != <a href="#L3376" title="replication/walsender.c:3376">XLogSendLogical</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="#L190" title="replication/walsender.c:190">streamingDoneSending</a>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_is_send_pending())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; sleeptime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wakeEvents;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L191" title="replication/walsender.c:191">streamingDoneReceiving</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wakeEvents = WL_SOCKET_READABLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wakeEvents = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use fresh timestamp, not <a href="#L173" title="replication/walsender.c:173">last_processing</a>, to reduce the chance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of reaching <a href="#L123" title="replication/walsender.c:123">wal_sender_timeout</a> <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> sending a keepalive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sleeptime = <a href="#L2696" title="replication/walsender.c:2696">WalSndComputeSleeptime</a>(<a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pq_is_send_pending())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wakeEvents |= WL_SOCKET_WRITEABLE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sleep until something happens or we time out */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3687" title="replication/walsender.c:3687">WalSndWait</a>(wakeEvents, sleeptime, WAIT_EVENT_WAL_SENDER_MAIN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Initialize a per-walsender data structure for this walsender process */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2893">&#x200c;</a></span><span class="linkable">InitWalSenderSlot</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L109" title="replication/walsender.c:109">WalSndCtl</a> should be set up already (we inherit this by fork() or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * EXEC_BACKEND mechanism from the postmaster).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L109" title="replication/walsender.c:109">WalSndCtl</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L112" title="replication/walsender.c:112">MyWalSnd</a> == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find a free walsender slot and reserve it. This must not fail due to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the prior check for free WAL senders in <a href="../storage/lmgr/proc.c.html#L296" title="storage/lmgr/proc.c:296">InitProcess</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L121" title="replication/walsender.c:121">max_wal_senders</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WalSnd&nbsp; &nbsp; &nbsp;&nbsp; *walsnd = &amp;<a href="#L109" title="replication/walsender.c:109">WalSndCtl</a>-&gt;walsnds[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;walsnd-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (walsnd-&gt;pid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;walsnd-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Found a free slot. Reserve it for us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walsnd-&gt;pid = <a href="../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walsnd-&gt;state = WALSNDSTATE_STARTUP;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walsnd-&gt;<a href="#L165" title="replication/walsender.c:165">sentPtr</a> = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walsnd-&gt;needreload = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walsnd-&gt;write = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walsnd-&gt;flush = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walsnd-&gt;apply = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walsnd-&gt;writeLag = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walsnd-&gt;flushLag = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walsnd-&gt;applyLag = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walsnd-&gt;sync_standby_priority = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walsnd-&gt;latch = &amp;<a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;procLatch;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walsnd-&gt;replyTime = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The kind assignment is done here and not in <a href="#L819" title="replication/walsender.c:819">StartReplication</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and <a href="#L1452" title="replication/walsender.c:1452">StartLogicalReplication</a>(). Indeed, the logical walsender<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * needs to read WAL <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> (like snapshot of running<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transactions) during the slot creation. So it needs to be woken<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * up based on its kind.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The kind assignment could also be done in <a href="#L819" title="replication/walsender.c:819">StartReplication</a>(),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1452" title="replication/walsender.c:1452">StartLogicalReplication</a>() and CREATE_REPLICATION_SLOT but it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * seems better to set it on one place.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a> == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walsnd-&gt;kind = REPLICATION_KIND_PHYSICAL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walsnd-&gt;kind = REPLICATION_KIND_LOGICAL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;walsnd-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't need the lock anymore */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L112" title="replication/walsender.c:112">MyWalSnd</a> = (WalSnd *) walsnd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L112" title="replication/walsender.c:112">MyWalSnd</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Arrange to clean up at walsender exit */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a>(<a href="#L2970" title="replication/walsender.c:2970">WalSndKill</a>, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Destroy the per-walsender data structure for this walsender process */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2970">&#x200c;</a></span><span class="linkable">WalSndKill</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WalSnd&nbsp; &nbsp; &nbsp;&nbsp; *walsnd = <a href="#L112" title="replication/walsender.c:112">MyWalSnd</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(walsnd != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L112" title="replication/walsender.c:112">MyWalSnd</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;walsnd-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* clear latch while holding the spinlock, so it can safely be read */<br/></li>
<li></span>&nbsp; &nbsp; walsnd-&gt;latch = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark WalSnd struct as no longer being in use. */<br/></li>
<li></span>&nbsp; &nbsp; walsnd-&gt;pid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;walsnd-&gt;mutex);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* XLogReaderRoutine-&gt;segment_open callback */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2988">&#x200c;</a></span><span class="linkable">WalSndSegmentOpen</span>(XLogReaderState *state, XLogSegNo nextSegNo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeLineID *tli_p)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*-------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When reading from a historic timeline, and there is a timeline switch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * within this segment, read from the WAL segment belonging to the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * timeline.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For example, imagine that this server is currently on timeline 5, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're streaming timeline 4. The switch from timeline 4 to 5 happened at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 0/13002088. In pg_wal, we have these files:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 000000040000000000000012<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 000000040000000000000013<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 000000050000000000000013<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 000000050000000000000014<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In this situation, when requested to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the WAL from segment 0x13, on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * timeline 4, we read the WAL from file 000000050000000000000013. Archive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recovery prefers files from newer timelines, so if the segment was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restored from the archive on this server, the file belonging to the old<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * timeline, 000000040000000000000013, might not exist. Their contents are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> up to the switchpoint, because at a timeline switch, the used<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * portion of the old segment is copied to the new file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *tli_p = <a href="#L156" title="replication/walsender.c:156">sendTimeLine</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L158" title="replication/walsender.c:158">sendTimeLineIsHistoric</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; endSegNo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLByteToSeg(<a href="#L159" title="replication/walsender.c:159">sendTimeLineValidUpto</a>, endSegNo, state-&gt;segcxt.ws_segsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nextSegNo == endSegNo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tli_p = <a href="#L157" title="replication/walsender.c:157">sendTimeLineNextTLI</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; XLogFilePath(path, *tli_p, nextSegNo, state-&gt;segcxt.ws_segsize);<br/></li>
<li>&nbsp; &nbsp; state-&gt;seg.ws_file = <a href="../storage/file/fd.c.html#L1087" title="storage/file/fd.c:1087">BasicOpenFile</a>(path, O_RDONLY | PG_BINARY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;seg.ws_file &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the file is not found, assume it's because the standby asked for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * too old WAL segment that has already been removed or recycled.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; xlogfname[MAXFNAMELEN];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogFileName(xlogfname, *tli_p, nextSegNo, <a href="../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;requested WAL segment </span><span class="Special">%s</span><span class="Constant"> has already been removed&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlogfname)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Send out the WAL in its normal physical/stored form.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Read up to <a href="#L106" title="replication/walsender.c:106">MAX_SEND_SIZE</a> bytes of WAL that's been flushed to disk,<br/></li>
<li></span><span class="Comment"> * but not yet sent to the client, and buffer it in the libpq output<br/></li>
<li></span><span class="Comment"> * buffer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If there is no unsent WAL remaining, <a href="#L194" title="replication/walsender.c:194">WalSndCaughtUp</a> is set to true,<br/></li>
<li></span><span class="Comment"> * otherwise <a href="#L194" title="replication/walsender.c:194">WalSndCaughtUp</a> is set to false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3066">&#x200c;</a></span><span class="linkable">XLogSendPhysical</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; SendRqstPtr;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; startptr;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; endptr;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; segno;<br/></li>
<li>&nbsp; &nbsp; WALReadError errinfo;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; rbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If requested switch the WAL sender to the stopping state. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L198" title="replication/walsender.c:198">got_STOPPING</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3809" title="replication/walsender.c:3809">WalSndSetState</a>(WALSNDSTATE_STOPPING);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L190" title="replication/walsender.c:190">streamingDoneSending</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L194" title="replication/walsender.c:194">WalSndCaughtUp</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Figure out how far we can safely <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the WAL. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L158" title="replication/walsender.c:158">sendTimeLineIsHistoric</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Streaming an old timeline that's in this server's history, but is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not the one we're currently inserting or replaying. It can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * streamed up to the point where we switched off that timeline.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SendRqstPtr = <a href="#L159" title="replication/walsender.c:159">sendTimeLineValidUpto</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L116" title="replication/walsender.c:116">am_cascading_walsender</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimeLineID&nbsp; &nbsp; SendRqstTLI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Streaming the latest timeline on a standby.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Attempt to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> all WAL that has already been replayed, so that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * know it's valid. If we're receiving WAL through streaming<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * replication, it's also OK to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> WAL that has been received<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but not replayed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The timeline we're recovering from can change, or we can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * promoted. In either case, the current timeline becomes historic. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to detect that so that we don't try to stream past the point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * where we switched to another timeline. We check for promotion or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * timeline switch after calculating FlushPtr, to avoid a race<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * condition: if the timeline becomes historic just after we checked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that it was still current, it's still be OK to stream it up to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * FlushPtr that was calculated <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it became historic.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; becameHistoric = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SendRqstPtr = <a href="#L3504" title="replication/walsender.c:3504">GetStandbyFlushRecPtr</a>(&amp;SendRqstTLI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We have been promoted. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SendRqstTLI = <a href="../access/transam/xlog.c.html#L6476" title="access/transam/xlog.c:6476">GetWALInsertionTimeLine</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L116" title="replication/walsender.c:116">am_cascading_walsender</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; becameHistoric = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Still a cascading standby. But is the timeline we're sending<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * still the one recovery is recovering from?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L156" title="replication/walsender.c:156">sendTimeLine</a> != SendRqstTLI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; becameHistoric = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (becameHistoric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The timeline we were sending has become historic. Read the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * timeline history file of the new timeline to see where exactly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we forked off from the timeline we were sending.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *history;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; history = <a href="../access/transam/timeline.c.html#L76" title="access/transam/timeline.c:76">readTimeLineHistory</a>(SendRqstTLI);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L159" title="replication/walsender.c:159">sendTimeLineValidUpto</a> = <a href="../access/transam/timeline.c.html#L572" title="access/transam/timeline.c:572">tliSwitchPoint</a>(<a href="#L156" title="replication/walsender.c:156">sendTimeLine</a>, history, &amp;<a href="#L157" title="replication/walsender.c:157">sendTimeLineNextTLI</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L156" title="replication/walsender.c:156">sendTimeLine</a> &lt; <a href="#L157" title="replication/walsender.c:157">sendTimeLineNextTLI</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L1560" title="nodes/list.c:1560">list_free_deep</a>(history);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L158" title="replication/walsender.c:158">sendTimeLineIsHistoric</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SendRqstPtr = <a href="#L159" title="replication/walsender.c:159">sendTimeLineValidUpto</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Streaming the current timeline on a primary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Attempt to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> all data that's already been written out and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fsync'd to disk.&nbsp; We cannot go further than what's been written out<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * given the current implementation of <a href="../access/transam/xlogreader.c.html#L1503" title="access/transam/xlogreader.c:1503">WALRead</a>().&nbsp; And in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's unsafe to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> WAL that is not securely down to disk on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * primary: if the primary subsequently crashes and restarts, standbys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must not have applied <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> WAL that got lost on the primary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SendRqstPtr = <a href="../access/transam/xlog.c.html#L6455" title="access/transam/xlog.c:6455">GetFlushRecPtr</a>(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Record the current system time as an approximation of the time at which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this WAL location was written for the purposes of lag tracking.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In theory we could make <a href="../access/transam/xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>() record a time in shmem whenever WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is flushed and we could get that time as well as the LSN when we call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../access/transam/xlog.c.html#L6455" title="access/transam/xlog.c:6455">GetFlushRecPtr</a>() above (and likewise for the cascading standby<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * equivalent), but rather than putting <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> new code into the hot WAL path<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it seems good enough to capture the time here.&nbsp; We should reach this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after <a href="../access/transam/xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>() runs WalSndWakeupProcessRequests(), and although that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * may take some time, we read the WAL flush pointer and take the time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * very close to together here so that we'll get a later position if it is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * still moving.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Because <a href="#L4095" title="replication/walsender.c:4095">LagTrackerWrite</a> ignores samples when the LSN hasn't advanced,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this gives us a cheap approximation for the WAL flush time for this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LSN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that the LSN is not necessarily the LSN for the data contained in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the present message; it's the end of the WAL, which might be further<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ahead.&nbsp; All the lag tracking machinery cares about is finding out when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that arbitrary LSN is eventually reported as written, flushed and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * applied, so that it can measure the elapsed time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4095" title="replication/walsender.c:4095">LagTrackerWrite</a>(SendRqstPtr, <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is a historic timeline and we've reached the point where we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * forked to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> timeline, stop streaming.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: We might already have sent WAL &gt; <a href="#L159" title="replication/walsender.c:159">sendTimeLineValidUpto</a>. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * startup process will normally replay all WAL that has been received<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the primary, <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> promoting, but if the WAL streaming is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * terminated at a WAL page boundary, the valid portion of the timeline<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might end in the middle of a WAL record. We might've already sent the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first half of that partial WAL record to the cascading standby, so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L165" title="replication/walsender.c:165">sentPtr</a> &gt; <a href="#L159" title="replication/walsender.c:159">sendTimeLineValidUpto</a>. That's OK; the cascading standby can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replay the partial WAL record either, so it can still follow our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * timeline switch.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L158" title="replication/walsender.c:158">sendTimeLineIsHistoric</a> &amp;&amp; <a href="#L159" title="replication/walsender.c:159">sendTimeLineValidUpto</a> &lt;= <a href="#L165" title="replication/walsender.c:165">sentPtr</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* close the current file. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;seg.ws_file &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlogutils.c.html#L842" title="access/transam/xlogutils.c:842">wal_segment_close</a>(<a href="#L137" title="replication/walsender.c:137">xlogreader</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Send CopyDone */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pq_putmessage_noblock(<span class="Constant">'c'</span>, <span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L190" title="replication/walsender.c:190">streamingDoneSending</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L194" title="replication/walsender.c:194">WalSndCaughtUp</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;walsender reached end of timeline at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> (sent up to </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(<a href="#L159" title="replication/walsender.c:159">sendTimeLineValidUpto</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(<a href="#L165" title="replication/walsender.c:165">sentPtr</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do we have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> work to do? */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L165" title="replication/walsender.c:165">sentPtr</a> &lt;= SendRqstPtr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (SendRqstPtr &lt;= <a href="#L165" title="replication/walsender.c:165">sentPtr</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L194" title="replication/walsender.c:194">WalSndCaughtUp</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Figure out how much to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> in one message. If there's no more than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L106" title="replication/walsender.c:106">MAX_SEND_SIZE</a> bytes to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a>, <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> everything. Otherwise <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L106" title="replication/walsender.c:106">MAX_SEND_SIZE</a> bytes, but round back to logfile or page boundary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The rounding is not only for performance reasons. Walreceiver relies on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the fact that we never split a WAL record across two messages. Since a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * long WAL record is split at page boundary into continuation <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page boundary is always a safe cut-off point. We also assume that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SendRqstPtr never points to the middle of a WAL record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; startptr = <a href="#L165" title="replication/walsender.c:165">sentPtr</a>;<br/></li>
<li>&nbsp; &nbsp; endptr = startptr;<br/></li>
<li>&nbsp; &nbsp; endptr += <a href="#L106" title="replication/walsender.c:106">MAX_SEND_SIZE</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if we went beyond SendRqstPtr, back off */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (SendRqstPtr &lt;= endptr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; endptr = SendRqstPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L158" title="replication/walsender.c:158">sendTimeLineIsHistoric</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L194" title="replication/walsender.c:194">WalSndCaughtUp</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L194" title="replication/walsender.c:194">WalSndCaughtUp</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* round down to page boundary. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; endptr -= (endptr % XLOG_BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L194" title="replication/walsender.c:194">WalSndCaughtUp</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nbytes = endptr - startptr;<br/></li>
<li>&nbsp; &nbsp; Assert(nbytes &lt;= <a href="#L106" title="replication/walsender.c:106">MAX_SEND_SIZE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK to read and <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the slice.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; resetStringInfo(&amp;<a href="#L168" title="replication/walsender.c:168">output_message</a>);<br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(&amp;<a href="#L168" title="replication/walsender.c:168">output_message</a>, <span class="Constant">'w'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pq_sendint64(&amp;<a href="#L168" title="replication/walsender.c:168">output_message</a>, startptr);&nbsp; &nbsp; <span class="Comment">/* dataStart */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(&amp;<a href="#L168" title="replication/walsender.c:168">output_message</a>, SendRqstPtr); <span class="Comment">/* walEnd */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(&amp;<a href="#L168" title="replication/walsender.c:168">output_message</a>, <span class="Constant">0</span>);&nbsp; &nbsp; <span class="Comment">/* sendtime, filled in last */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read the log directly into the output buffer to avoid extra memcpy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calls.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; enlargeStringInfo(&amp;<a href="#L168" title="replication/walsender.c:168">output_message</a>, nbytes);<br/></li>
<li><br/></li>
<li><span class="Statement">retry</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* attempt to read WAL from WAL buffers first */<br/></li>
<li></span>&nbsp; &nbsp; rbytes = <a href="../access/transam/xlog.c.html#L1743" title="access/transam/xlog.c:1743">WALReadFromBuffers</a>(&amp;<a href="#L168" title="replication/walsender.c:168">output_message</a>.data[<a href="#L168" title="replication/walsender.c:168">output_message</a>.len],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startptr, nbytes, <a href="#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;seg.ws_tli);<br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="replication/walsender.c:168">output_message</a>.len += rbytes;<br/></li>
<li>&nbsp; &nbsp; startptr += rbytes;<br/></li>
<li>&nbsp; &nbsp; nbytes -= rbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> read the remaining WAL from WAL file */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nbytes &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../access/transam/xlogreader.c.html#L1503" title="access/transam/xlogreader.c:1503">WALRead</a>(<a href="#L137" title="replication/walsender.c:137">xlogreader</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="#L168" title="replication/walsender.c:168">output_message</a>.data[<a href="#L168" title="replication/walsender.c:168">output_message</a>.len],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; startptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nbytes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;seg.ws_tli,&nbsp; &nbsp; <span class="Comment">/* Pass the current TLI because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only <a href="#L2988" title="replication/walsender.c:2988">WalSndSegmentOpen</a> controls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whether new TLI is needed. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;errinfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlogutils.c.html#L1020" title="access/transam/xlogutils.c:1020">WALReadRaiseError</a>(&amp;errinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* See <a href="#L1051" title="replication/walsender.c:1051">logical_read_xlog_page</a>(). */<br/></li>
<li></span>&nbsp; &nbsp; XLByteToSeg(startptr, segno, <a href="#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;segcxt.ws_segsize);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/transam/xlog.c.html#L3716" title="access/transam/xlog.c:3716">CheckXLogRemoved</a>(segno, <a href="#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;seg.ws_tli);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During recovery, the currently-open WAL file might be replaced with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * file of the same name retrieved from archive. So we always need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check what we read was valid after reading into the buffer. If it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * invalid, we try to open and read the file again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L116" title="replication/walsender.c:116">am_cascading_walsender</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WalSnd&nbsp; &nbsp; &nbsp;&nbsp; *walsnd = <a href="#L112" title="replication/walsender.c:112">MyWalSnd</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; reload;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;walsnd-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reload = walsnd-&gt;needreload;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; walsnd-&gt;needreload = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;walsnd-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (reload &amp;&amp; <a href="#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;seg.ws_file &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlogutils.c.html#L842" title="access/transam/xlogutils.c:842">wal_segment_close</a>(<a href="#L137" title="replication/walsender.c:137">xlogreader</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> retry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="replication/walsender.c:168">output_message</a>.len += nbytes;<br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="replication/walsender.c:168">output_message</a>.data[<a href="#L168" title="replication/walsender.c:168">output_message</a>.len] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fill the <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> timestamp last, so that it is taken as late as possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; resetStringInfo(&amp;<a href="#L170" title="replication/walsender.c:170">tmpbuf</a>);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(&amp;<a href="#L170" title="replication/walsender.c:170">tmpbuf</a>, <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>());<br/></li>
<li>&nbsp; &nbsp; memcpy(&amp;<a href="#L168" title="replication/walsender.c:168">output_message</a>.data[<span class="Constant">1</span> + <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64) + <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64)],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L170" title="replication/walsender.c:170">tmpbuf</a>.data, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pq_putmessage_noblock(<span class="Constant">'d'</span>, <a href="#L168" title="replication/walsender.c:168">output_message</a>.data, <a href="#L168" title="replication/walsender.c:168">output_message</a>.len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L165" title="replication/walsender.c:165">sentPtr</a> = endptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update shared memory status */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WalSnd&nbsp; &nbsp; &nbsp;&nbsp; *walsnd = <a href="#L112" title="replication/walsender.c:112">MyWalSnd</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;walsnd-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; walsnd-&gt;<a href="#L165" title="replication/walsender.c:165">sentPtr</a> = <a href="#L165" title="replication/walsender.c:165">sentPtr</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;walsnd-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report progress of XLOG streaming in PS display */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/ps_status.c.html#L29" title="utils/misc/ps_status.c:29">update_process_title</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; activitymsg[<span class="Constant">50</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(activitymsg, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(activitymsg), <span class="Constant">&quot;streaming </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(<a href="#L165" title="replication/walsender.c:165">sentPtr</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set_ps_display(activitymsg);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Stream out logically decoded data.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3376">&#x200c;</a></span><span class="linkable">XLogSendLogical</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecord *record;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *errm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We'll use the current flush point to determine whether we've caught up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This variable is static in order to cache it across calls.&nbsp; Caching is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * helpful because <a href="../access/transam/xlog.c.html#L6455" title="access/transam/xlog.c:6455">GetFlushRecPtr</a>() needs to acquire a heavily-contended<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * spinlock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">static</span> XLogRecPtr flushPtr = InvalidXLogRecPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't know whether we've caught up yet. We'll set <a href="#L194" title="replication/walsender.c:194">WalSndCaughtUp</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * true in <a href="#L1818" title="replication/walsender.c:1818">WalSndWaitForWal</a>, if we're actually <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>. We also set to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * true if <a href="../access/transam/xlogreader.c.html#L389" title="access/transam/xlogreader.c:389">XLogReadRecord</a>() had to stop reading but <a href="#L1818" title="replication/walsender.c:1818">WalSndWaitForWal</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * didn't wait - i.e. when we're shutting down.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L194" title="replication/walsender.c:194">WalSndCaughtUp</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; record = <a href="../access/transam/xlogreader.c.html#L389" title="access/transam/xlogreader.c:389">XLogReadRecord</a>(<a href="#L208" title="replication/walsender.c:208">logical_decoding_ctx</a>-&gt;reader, &amp;errm);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* xlog record was invalid */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (errm != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> record while sending logically-decoded data: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errm);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (record != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note the lack of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> call to <a href="#L4095" title="replication/walsender.c:4095">LagTrackerWrite</a>() which is handled by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1668" title="replication/walsender.c:1668">WalSndUpdateProgress</a> which is called by output plugin through<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * logical decoding write api.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="logical/decode.c.html#L88" title="replication/logical/decode.c:88">LogicalDecodingProcessRecord</a>(<a href="#L208" title="replication/walsender.c:208">logical_decoding_ctx</a>, <a href="#L208" title="replication/walsender.c:208">logical_decoding_ctx</a>-&gt;reader);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L165" title="replication/walsender.c:165">sentPtr</a> = <a href="#L208" title="replication/walsender.c:208">logical_decoding_ctx</a>-&gt;reader-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If first time through in this session, <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> flushPtr.&nbsp; Otherwise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we only need to update flushPtr if EndRecPtr is past it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flushPtr == InvalidXLogRecPtr ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L208" title="replication/walsender.c:208">logical_decoding_ctx</a>-&gt;reader-&gt;EndRecPtr &gt;= flushPtr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L116" title="replication/walsender.c:116">am_cascading_walsender</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flushPtr = <a href="#L3504" title="replication/walsender.c:3504">GetStandbyFlushRecPtr</a>(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flushPtr = <a href="../access/transam/xlog.c.html#L6455" title="access/transam/xlog.c:6455">GetFlushRecPtr</a>(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If EndRecPtr is still past our flushPtr, it means we caught up. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L208" title="replication/walsender.c:208">logical_decoding_ctx</a>-&gt;reader-&gt;EndRecPtr &gt;= flushPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L194" title="replication/walsender.c:194">WalSndCaughtUp</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're caught up and have been requested to stop, have <a href="#L2767" title="replication/walsender.c:2767">WalSndLoop</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * terminate the connection in an orderly manner, after writing out all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the pending data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L194" title="replication/walsender.c:194">WalSndCaughtUp</a> &amp;&amp; <a href="#L198" title="replication/walsender.c:198">got_STOPPING</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L197" title="replication/walsender.c:197">got_SIGUSR2</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update shared memory status */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WalSnd&nbsp; &nbsp; &nbsp;&nbsp; *walsnd = <a href="#L112" title="replication/walsender.c:112">MyWalSnd</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;walsnd-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; walsnd-&gt;<a href="#L165" title="replication/walsender.c:165">sentPtr</a> = <a href="#L165" title="replication/walsender.c:165">sentPtr</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;walsnd-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../postmaster/postmaster.c.html#L269" title="postmaster/postmaster.c:269">Shutdown</a> if the sender is caught up.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: This should only be called when the shutdown signal has been received<br/></li>
<li></span><span class="Comment"> * from postmaster.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that if we determine that there's still more data to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a>, this<br/></li>
<li></span><span class="Comment"> * function will return control to the caller.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3461">&#x200c;</a></span><span class="linkable">WalSndDone</span>(<a href="#L236" title="replication/walsender.c:236">WalSndSendDataCallback</a> send_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; replicatedPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... let's just be real sure we're caught up ... */<br/></li>
<li></span>&nbsp; &nbsp; send_data();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To figure out whether all WAL has successfully been replicated, check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * flush location if valid, write otherwise. Tools like pg_receivewal will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * usually (unless in synchronous mode) return an invalid flush location.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; replicatedPtr = XLogRecPtrIsInvalid(<a href="#L112" title="replication/walsender.c:112">MyWalSnd</a>-&gt;flush) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L112" title="replication/walsender.c:112">MyWalSnd</a>-&gt;write : <a href="#L112" title="replication/walsender.c:112">MyWalSnd</a>-&gt;flush;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L194" title="replication/walsender.c:194">WalSndCaughtUp</a> &amp;&amp; <a href="#L165" title="replication/walsender.c:165">sentPtr</a> == replicatedPtr &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !pq_is_send_pending())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; QueryCompletion qc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Inform the standby that XLOG streaming is done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SetQueryCompletion(&amp;qc, CMDTAG_COPY, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/dest.c.html#L169" title="tcop/dest.c:169">EndCommand</a>(&amp;qc, DestRemote, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_flush();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L182" title="replication/walsender.c:182">waiting_for_ping_response</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4034" title="replication/walsender.c:4034">WalSndKeepalive</a>(<span class="Constant">true</span>, InvalidXLogRecPtr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns the latest point in WAL that has been safely flushed to disk.<br/></li>
<li></span><span class="Comment"> * This should only be called when in recovery.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called either by cascading walsender to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> WAL position to be sent<br/></li>
<li></span><span class="Comment"> * to a cascaded standby or by slot synchronization operation to validate remote<br/></li>
<li></span><span class="Comment"> * slot's lsn <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> syncing it locally.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As a side-effect, *tli is updated to the TLI of the last<br/></li>
<li></span><span class="Comment"> * replayed WAL record.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L3504">&#x200c;</a><span class="linkable">GetStandbyFlushRecPtr</span>(TimeLineID *tli)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; replayPtr;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; replayTLI;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; receivePtr;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; <a href="../access/transam/xlogrecovery.c.html#L263" title="access/transam/xlogrecovery.c:263">receiveTLI</a>;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L116" title="replication/walsender.c:116">am_cascading_walsender</a> || <a href="logical/slotsync.c.html#L1650" title="replication/logical/slotsync.c:1650">IsSyncingReplicationSlots</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can safely <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> what's already been replayed. Also, if walreceiver<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is streaming WAL from the same timeline, we can <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> anything that it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has streamed, but hasn't been replayed yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; receivePtr = <a href="walreceiverfuncs.c.html#L331" title="replication/walreceiverfuncs.c:331">GetWalRcvFlushRecPtr</a>(<span class="Constant">NULL</span>, &amp;<a href="../access/transam/xlogrecovery.c.html#L263" title="access/transam/xlogrecovery.c:263">receiveTLI</a>);<br/></li>
<li>&nbsp; &nbsp; replayPtr = <a href="../access/transam/xlogrecovery.c.html#L4539" title="access/transam/xlogrecovery.c:4539">GetXLogReplayRecPtr</a>(&amp;replayTLI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tli)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *tli = replayTLI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = replayPtr;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xlogrecovery.c.html#L263" title="access/transam/xlogrecovery.c:263">receiveTLI</a> == replayTLI &amp;&amp; receivePtr &gt; replayPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = receivePtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Request walsenders to reload the currently-open WAL file<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3537">&#x200c;</a></span><span class="linkable">WalSndRqstFileReload</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L121" title="replication/walsender.c:121">max_wal_senders</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WalSnd&nbsp; &nbsp; &nbsp;&nbsp; *walsnd = &amp;<a href="#L109" title="replication/walsender.c:109">WalSndCtl</a>-&gt;walsnds[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;walsnd-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (walsnd-&gt;pid == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;walsnd-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; walsnd-&gt;needreload = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;walsnd-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle PROCSIG_WALSND_INIT_STOPPING signal.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3560">&#x200c;</a></span><span class="linkable">HandleWalSndInitStopping</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L115" title="replication/walsender.c:115">am_walsender</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If replication has not yet started, <a href="../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> like with SIGTERM. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replication is active, only set a flag and wake up the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop. It<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outstanding WAL, wait for it to be replicated to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * standby, and then exit gracefully.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L206" title="replication/walsender.c:206">replication_active</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; kill(<a href="../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>, <span class="Constant">SIGTERM</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L198" title="replication/walsender.c:198">got_STOPPING</a> = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SIGUSR2: set flag to do a last cycle and shut down afterwards. The WAL<br/></li>
<li></span><span class="Comment"> * sender should already have been switched to WALSNDSTATE_STOPPING at<br/></li>
<li></span><span class="Comment"> * this point.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3582">&#x200c;</a></span><span class="linkable">WalSndLastCycleHandler</span>(SIGNAL_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L197" title="replication/walsender.c:197">got_SIGUSR2</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Set up signal handlers */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3590">&#x200c;</a></span><span class="linkable">WalSndSignals</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up signal handlers */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGHUP</span>, <a href="../postmaster/interrupt.c.html#L61" title="postmaster/interrupt.c:61">SignalHandlerForConfigReload</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGINT</span>, <a href="../tcop/postgres.c.html#L3002" title="tcop/postgres.c:3002">StatementCancelHandler</a>);&nbsp; &nbsp; <span class="Comment">/* query cancel */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGTERM</span>, <a href="../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* request shutdown */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* SIGQUIT handler was already set up by <a href="../utils/init/miscinit.c.html#L95" title="utils/init/miscinit.c:95">InitPostmasterChild</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/misc/timeout.c.html#L470" title="utils/misc/timeout.c:470">InitializeTimeouts</a>();&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* establishes SIGALRM handler */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGPIPE</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGUSR1</span>, <a href="../storage/ipc/procsignal.c.html#L635" title="storage/ipc/procsignal.c:635">procsignal_sigusr1_handler</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGUSR2</span>, <a href="#L3582" title="replication/walsender.c:3582">WalSndLastCycleHandler</a>);&nbsp; &nbsp; <span class="Comment">/* request a last cycle and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shutdown */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset some signals that are accepted by postmaster but not here */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGCHLD</span>, <span class="Constant">SIG_DFL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Report shared-memory space needed by <a href="#L3621" title="replication/walsender.c:3621">WalSndShmemInit</a> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L3609">&#x200c;</a><span class="linkable">WalSndShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = offsetof(WalSndCtlData, walsnds);<br/></li>
<li>&nbsp; &nbsp; size = <a href="../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<a href="#L121" title="replication/walsender.c:121">max_wal_senders</a>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(WalSnd)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Allocate and <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> walsender-related shared memory */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3621">&#x200c;</a></span><span class="linkable">WalSndShmemInit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L109" title="replication/walsender.c:109">WalSndCtl</a> = (WalSndCtlData *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;Wal Sender Ctl&quot;</span>, <a href="#L3609" title="replication/walsender.c:3609">WalSndShmemSize</a>(), &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First time through, so <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(<a href="#L109" title="replication/walsender.c:109">WalSndCtl</a>, <span class="Constant">0</span>, <a href="#L3609" title="replication/walsender.c:3609">WalSndShmemSize</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; NUM_SYNC_REP_WAIT_MODE; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_init(&amp;(<a href="#L109" title="replication/walsender.c:109">WalSndCtl</a>-&gt;SyncRepQueue[i]));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L121" title="replication/walsender.c:121">max_wal_senders</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WalSnd&nbsp; &nbsp; &nbsp;&nbsp; *walsnd = &amp;<a href="#L109" title="replication/walsender.c:109">WalSndCtl</a>-&gt;walsnds[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockInit(&amp;walsnd-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L35" title="storage/lmgr/condition_variable.c:35">ConditionVariableInit</a>(&amp;<a href="#L109" title="replication/walsender.c:109">WalSndCtl</a>-&gt;wal_flush_cv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L35" title="storage/lmgr/condition_variable.c:35">ConditionVariableInit</a>(&amp;<a href="#L109" title="replication/walsender.c:109">WalSndCtl</a>-&gt;wal_replay_cv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L35" title="storage/lmgr/condition_variable.c:35">ConditionVariableInit</a>(&amp;<a href="#L109" title="replication/walsender.c:109">WalSndCtl</a>-&gt;wal_confirm_rcv_cv);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wake up physical, logical or both kinds of walsenders<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The distinction between physical and logical walsenders is done, because:<br/></li>
<li></span><span class="Comment"> * - physical walsenders can't <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> data until it's been flushed<br/></li>
<li></span><span class="Comment"> * - logical walsenders on standby can't decode and <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> data until it's been<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; applied<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For cascading replication we need to wake up physical walsenders separately<br/></li>
<li></span><span class="Comment"> * from logical walsenders (see the comment <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling <a href="#L3666" title="replication/walsender.c:3666">WalSndWakeup</a>() in<br/></li>
<li></span><span class="Comment"> * <a href="../access/transam/xlogrecovery.c.html#L1908" title="access/transam/xlogrecovery.c:1908">ApplyWalRecord</a>() for more details).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This will be called inside critical sections, so throwing an error is not<br/></li>
<li></span><span class="Comment"> * advisable.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3666">&#x200c;</a></span><span class="linkable">WalSndWakeup</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> physical, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> logical)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Wake up all the walsenders <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> on WAL being flushed or replayed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * respectively.&nbsp; Note that <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> walsender would have prepared to sleep<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on the CV (i.e., added itself to the CV's waitlist) in <a href="#L3687" title="replication/walsender.c:3687">WalSndWait</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> actually <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (physical)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L282" title="storage/lmgr/condition_variable.c:282">ConditionVariableBroadcast</a>(&amp;<a href="#L109" title="replication/walsender.c:109">WalSndCtl</a>-&gt;wal_flush_cv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (logical)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L282" title="storage/lmgr/condition_variable.c:282">ConditionVariableBroadcast</a>(&amp;<a href="#L109" title="replication/walsender.c:109">WalSndCtl</a>-&gt;wal_replay_cv);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait for readiness on the FeBe <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>, or a timeout.&nbsp; The mask should be<br/></li>
<li></span><span class="Comment"> * composed of optional WL_SOCKET_WRITEABLE and WL_SOCKET_READABLE flags.&nbsp; Exit<br/></li>
<li></span><span class="Comment"> * on postmaster death.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3687">&#x200c;</a></span><span class="linkable">WalSndWait</span>(uint32 socket_events, <span class="Type">long</span> timeout, uint32 wait_event)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WaitEvent&nbsp; &nbsp; event;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L1049" title="storage/ipc/latch.c:1049">ModifyWaitEvent</a>(<a href="../libpq/pqcomm.c.html#L165" title="libpq/pqcomm.c:165">FeBeWaitSet</a>, FeBeWaitSetSocketPos, socket_events, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use a condition variable to efficiently wake up walsenders in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L3666" title="replication/walsender.c:3666">WalSndWakeup</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Every walsender prepares to sleep on a shared memory CV. Note that it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just prepares to sleep on the CV (i.e., adds itself to the CV's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * waitlist), but does not actually wait on the CV (IOW, it never calls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../storage/lmgr/condition_variable.c.html#L96" title="storage/lmgr/condition_variable.c:96">ConditionVariableSleep</a>()). It still uses <a href="../storage/ipc/latch.c.html#L1424" title="storage/ipc/latch.c:1424">WaitEventSetWait</a>() for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>, because we also need to wait for <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> events. The processes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (startup process, walreceiver etc.) wanting to wake up walsenders use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../storage/lmgr/condition_variable.c.html#L282" title="storage/lmgr/condition_variable.c:282">ConditionVariableBroadcast</a>(), which in turn calls <a href="../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(), helping<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * walsenders come out of <a href="../storage/ipc/latch.c.html#L1424" title="storage/ipc/latch.c:1424">WaitEventSetWait</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This approach is simple and efficient because, one doesn't have to loop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * through all the walsenders slots, with a spinlock acquisition and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * release for every iteration, just to wake up only the <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * walsenders. It makes <a href="#L3666" title="replication/walsender.c:3666">WalSndWakeup</a>() callers' life easy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: A desirable future improvement would be to add support for CVs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into <a href="../storage/ipc/latch.c.html#L1424" title="storage/ipc/latch.c:1424">WaitEventSetWait</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And, we use separate shared memory CVs for physical and logical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * walsenders for selective wake ups, see <a href="#L3666" title="replication/walsender.c:3666">WalSndWakeup</a>() for more details.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the wait event is WAIT_FOR_STANDBY_CONFIRMATION, wait on another CV<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * until awakened by physical walsenders after the walreceiver confirms<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the receipt of the LSN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (wait_event == WAIT_EVENT_WAIT_FOR_STANDBY_CONFIRMATION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L56" title="storage/lmgr/condition_variable.c:56">ConditionVariablePrepareToSleep</a>(&amp;<a href="#L109" title="replication/walsender.c:109">WalSndCtl</a>-&gt;wal_confirm_rcv_cv);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L112" title="replication/walsender.c:112">MyWalSnd</a>-&gt;kind == REPLICATION_KIND_PHYSICAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L56" title="storage/lmgr/condition_variable.c:56">ConditionVariablePrepareToSleep</a>(&amp;<a href="#L109" title="replication/walsender.c:109">WalSndCtl</a>-&gt;wal_flush_cv);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L112" title="replication/walsender.c:112">MyWalSnd</a>-&gt;kind == REPLICATION_KIND_LOGICAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L56" title="storage/lmgr/condition_variable.c:56">ConditionVariablePrepareToSleep</a>(&amp;<a href="#L109" title="replication/walsender.c:109">WalSndCtl</a>-&gt;wal_replay_cv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../storage/ipc/latch.c.html#L1424" title="storage/ipc/latch.c:1424">WaitEventSetWait</a>(<a href="../libpq/pqcomm.c.html#L165" title="libpq/pqcomm.c:165">FeBeWaitSet</a>, timeout, &amp;event, <span class="Constant">1</span>, wait_event) == <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (event.events &amp; WL_POSTMASTER_DEATH))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L230" title="storage/lmgr/condition_variable.c:230">ConditionVariableCancelSleep</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L230" title="storage/lmgr/condition_variable.c:230">ConditionVariableCancelSleep</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Signal all walsenders to move to stopping state.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This will <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> walsenders to move to a state where no further WAL can be<br/></li>
<li></span><span class="Comment"> * generated. See this file's header for details.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3745">&#x200c;</a></span><span class="linkable">WalSndInitStopping</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L121" title="replication/walsender.c:121">max_wal_senders</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WalSnd&nbsp; &nbsp; &nbsp;&nbsp; *walsnd = &amp;<a href="#L109" title="replication/walsender.c:109">WalSndCtl</a>-&gt;walsnds[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;walsnd-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pid = walsnd-&gt;pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;walsnd-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pid == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/procsignal.c.html#L257" title="storage/ipc/procsignal.c:257">SendProcSignal</a>(pid, PROCSIG_WALSND_INIT_STOPPING, INVALID_PROC_NUMBER);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait that all the WAL senders have quit or reached the stopping state. This<br/></li>
<li></span><span class="Comment"> * is used by the checkpointer to control when the shutdown checkpoint can<br/></li>
<li></span><span class="Comment"> * safely be performed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3771">&#x200c;</a></span><span class="linkable">WalSndWaitStopping</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; all_stopped = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L121" title="replication/walsender.c:121">max_wal_senders</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WalSnd&nbsp; &nbsp; &nbsp;&nbsp; *walsnd = &amp;<a href="#L109" title="replication/walsender.c:109">WalSndCtl</a>-&gt;walsnds[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;walsnd-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (walsnd-&gt;pid == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;walsnd-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (walsnd-&gt;state != WALSNDSTATE_STOPPING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all_stopped = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;walsnd-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;walsnd-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* safe to leave if confirmation is done for all WAL senders */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (all_stopped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<span class="Constant">10000L</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* wait for 10 msec */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Set state for current walsender (only called in walsender) */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3809">&#x200c;</a></span><span class="linkable">WalSndSetState</span>(WalSndState state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WalSnd&nbsp; &nbsp; &nbsp;&nbsp; *walsnd = <a href="#L112" title="replication/walsender.c:112">MyWalSnd</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L115" title="replication/walsender.c:115">am_walsender</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (walsnd-&gt;state == state)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;walsnd-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; walsnd-&gt;state = state;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;walsnd-&gt;mutex);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return a string constant representing the state. This is used<br/></li>
<li></span><span class="Comment"> * in system views, and should *not* be translated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L3828">&#x200c;</a><span class="linkable">WalSndGetStateString</span>(WalSndState state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (state)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WALSNDSTATE_STARTUP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;startup&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WALSNDSTATE_BACKUP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;backup&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WALSNDSTATE_CATCHUP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;catchup&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WALSNDSTATE_STREAMING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;streaming&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WALSNDSTATE_STOPPING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;stopping&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;UNKNOWN&quot;</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Interval *<br/></li>
<li><a id="L3847">&#x200c;</a><span class="linkable">offset_to_interval</span>(TimeOffset offset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *result = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;month = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;day = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;time = offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns activity of walsenders, including pids and xlog locations sent to<br/></li>
<li></span><span class="Comment"> * standby servers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3863">&#x200c;</a><span class="linkable">pg_stat_get_wal_senders</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li><a id="L3865">&#x200c;</a><span class="PreProc">#define <span class="linkable">PG_STAT_GET_WAL_SENDERS_COLS</span>&nbsp; &nbsp; </span><span class="Constant">12<br/></li>
<li></span>&nbsp; &nbsp; ReturnSetInfo *rsinfo = (ReturnSetInfo *) fcinfo-&gt;resultinfo;<br/></li>
<li>&nbsp; &nbsp; SyncRepStandbyData *sync_standbys;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_standbys;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/fmgr/funcapi.c.html#L76" title="utils/fmgr/funcapi.c:76">InitMaterializedSRF</a>(fcinfo, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the currently active synchronous standbys.&nbsp; This could be out of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * date <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we're done, but we'll use the data anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; num_standbys = <a href="syncrep.c.html#L711" title="replication/syncrep.c:711">SyncRepGetCandidateStandbys</a>(&amp;sync_standbys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L121" title="replication/walsender.c:121">max_wal_senders</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WalSnd&nbsp; &nbsp; &nbsp;&nbsp; *walsnd = &amp;<a href="#L109" title="replication/walsender.c:109">WalSndCtl</a>-&gt;walsnds[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; sent_ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; write;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; flush;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; apply;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimeOffset&nbsp; &nbsp; writeLag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimeOffset&nbsp; &nbsp; flushLag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimeOffset&nbsp; &nbsp; applyLag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; priority;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WalSndState state;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz replyTime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_sync_standby;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<a href="#L3865" title="replication/walsender.c:3865">PG_STAT_GET_WAL_SENDERS_COLS</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<a href="#L3865" title="replication/walsender.c:3865">PG_STAT_GET_WAL_SENDERS_COLS</a>] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Collect data from shared memory */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;walsnd-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (walsnd-&gt;pid == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;walsnd-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pid = walsnd-&gt;pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sent_ptr = walsnd-&gt;<a href="#L165" title="replication/walsender.c:165">sentPtr</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state = walsnd-&gt;state;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; write = walsnd-&gt;write;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flush = walsnd-&gt;flush;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; apply = walsnd-&gt;apply;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; writeLag = walsnd-&gt;writeLag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flushLag = walsnd-&gt;flushLag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; applyLag = walsnd-&gt;applyLag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; priority = walsnd-&gt;sync_standby_priority;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; replyTime = walsnd-&gt;replyTime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;walsnd-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Detect whether walsender is/was considered synchronous.&nbsp; We can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * provide some protection against stale data by checking the PID<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * along with walsnd_index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; is_sync_standby = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; num_standbys; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sync_standbys[j].walsnd_index == i &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sync_standbys[j].pid == pid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_sync_standby = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = Int32GetDatum(pid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/adt/acl.c.html#L5128" title="utils/adt/acl.c:5128">has_privs_of_role</a>(<a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(), ROLE_PG_READ_ALL_STATS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Only superusers and roles with privileges of pg_read_all_stats<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can see details. Other users only get the pid value to know<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's a walsender, but no details.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemSet(&amp;nulls[<span class="Constant">1</span>], <span class="Constant">true</span>, <a href="#L3865" title="replication/walsender.c:3865">PG_STAT_GET_WAL_SENDERS_COLS</a> - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = CStringGetTextDatum(<a href="#L3828" title="replication/walsender.c:3828">WalSndGetStateString</a>(state));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(sent_ptr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">2</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>] = LSNGetDatum(sent_ptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(write))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">3</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">3</span>] = LSNGetDatum(write);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(flush))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">4</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">4</span>] = LSNGetDatum(flush);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(apply))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">5</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">5</span>] = LSNGetDatum(apply);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Treat a standby such as a pg_basebackup background process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which always returns an invalid flush location, as an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * asynchronous standby.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; priority = XLogRecPtrIsInvalid(flush) ? <span class="Constant">0</span> : priority;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (writeLag &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">6</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">6</span>] = IntervalPGetDatum(<a href="#L3847" title="replication/walsender.c:3847">offset_to_interval</a>(writeLag));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flushLag &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">7</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">7</span>] = IntervalPGetDatum(<a href="#L3847" title="replication/walsender.c:3847">offset_to_interval</a>(flushLag));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (applyLag &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">8</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">8</span>] = IntervalPGetDatum(<a href="#L3847" title="replication/walsender.c:3847">offset_to_interval</a>(applyLag));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">9</span>] = Int32GetDatum(priority);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * More easily understood version of standby state. This is purely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * informational.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In quorum-based sync replication, the role of each standby<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * listed in synchronous_standby_names can be changing very<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * frequently. Any standbys considered as &quot;sync&quot; at one moment can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be switched to &quot;potential&quot; ones at the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> moment. So, it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * basically useless to report &quot;sync&quot; or &quot;potential&quot; as their sync<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * states. We report just &quot;quorum&quot; for them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (priority == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">10</span>] = CStringGetTextDatum(<span class="Constant">&quot;async&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (is_sync_standby)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">10</span>] = <a href="syncrep.c.html#L97" title="replication/syncrep.c:97">SyncRepConfig</a>-&gt;syncrep_method == SYNC_REP_PRIORITY ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CStringGetTextDatum(<span class="Constant">&quot;sync&quot;</span>) : CStringGetTextDatum(<span class="Constant">&quot;quorum&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">10</span>] = CStringGetTextDatum(<span class="Constant">&quot;potential&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (replyTime == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">11</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">11</span>] = TimestampTzGetDatum(replyTime);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplestore.c.html#L750" title="utils/sort/tuplestore.c:750">tuplestore_putvalues</a>(rsinfo-&gt;setResult, rsinfo-&gt;setDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Send a keepalive message to standby.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If requestReply is set, the message requests the other party to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a><br/></li>
<li></span><span class="Comment"> * a message back to us, for heartbeat purposes.&nbsp; We also set a flag to<br/></li>
<li></span><span class="Comment"> * let nearby code know that we're <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for that response, to avoid<br/></li>
<li></span><span class="Comment"> * repeated requests.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * writePtr is the location up to which the WAL is sent. It is essentially<br/></li>
<li></span><span class="Comment"> * the same as <a href="#L165" title="replication/walsender.c:165">sentPtr</a> but in some cases, we need to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> keep alive <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * <a href="#L165" title="replication/walsender.c:165">sentPtr</a> is updated like when skipping empty transactions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4034">&#x200c;</a></span><span class="linkable">WalSndKeepalive</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> requestReply, XLogRecPtr writePtr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;sending replication keepalive&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* construct the message... */<br/></li>
<li></span>&nbsp; &nbsp; resetStringInfo(&amp;<a href="#L168" title="replication/walsender.c:168">output_message</a>);<br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(&amp;<a href="#L168" title="replication/walsender.c:168">output_message</a>, <span class="Constant">'k'</span>);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(&amp;<a href="#L168" title="replication/walsender.c:168">output_message</a>, XLogRecPtrIsInvalid(writePtr) ? <a href="#L165" title="replication/walsender.c:165">sentPtr</a> : writePtr);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(&amp;<a href="#L168" title="replication/walsender.c:168">output_message</a>, <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>());<br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(&amp;<a href="#L168" title="replication/walsender.c:168">output_message</a>, requestReply ? <span class="Constant">1</span> : <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... and <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> it wrapped in CopyData */<br/></li>
<li></span>&nbsp; &nbsp; pq_putmessage_noblock(<span class="Constant">'d'</span>, <a href="#L168" title="replication/walsender.c:168">output_message</a>.data, <a href="#L168" title="replication/walsender.c:168">output_message</a>.len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set local flag */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (requestReply)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L182" title="replication/walsender.c:182">waiting_for_ping_response</a> = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Send keepalive message if too much time has elapsed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4057">&#x200c;</a></span><span class="linkable">WalSndKeepaliveIfNecessary</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz ping_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> keepalive messages if timeouts are globally disabled or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're doing something not partaking in timeouts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L123" title="replication/walsender.c:123">wal_sender_timeout</a> &lt;= <span class="Constant">0</span> || <a href="#L179" title="replication/walsender.c:179">last_reply_timestamp</a> &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L182" title="replication/walsender.c:182">waiting_for_ping_response</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If half of <a href="#L123" title="replication/walsender.c:123">wal_sender_timeout</a> has lapsed without receiving <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> reply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the standby, <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a keep-alive message to the standby requesting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an immediate reply.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ping_time = TimestampTzPlusMilliseconds(<a href="#L179" title="replication/walsender.c:179">last_reply_timestamp</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L123" title="replication/walsender.c:123">wal_sender_timeout</a> / <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L173" title="replication/walsender.c:173">last_processing</a> &gt;= ping_time)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4034" title="replication/walsender.c:4034">WalSndKeepalive</a>(<span class="Constant">true</span>, InvalidXLogRecPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to flush pending output to the client */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pq_flush_if_writable() != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L390" title="replication/walsender.c:390">WalSndShutdown</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Record the end of the WAL and the time it was flushed locally, so that<br/></li>
<li></span><span class="Comment"> * <a href="#L4160" title="replication/walsender.c:4160">LagTrackerRead</a> can compute the elapsed time (lag) when this WAL location is<br/></li>
<li></span><span class="Comment"> * eventually reported to have been written, flushed and applied by the<br/></li>
<li></span><span class="Comment"> * standby in a reply message.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4095">&#x200c;</a></span><span class="linkable">LagTrackerWrite</span>(XLogRecPtr lsn, TimestampTz local_flush_time)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; buffer_full;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_write_head;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L115" title="replication/walsender.c:115">am_walsender</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the lsn hasn't advanced since last time, then do nothing.&nbsp; This way<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we only record a new sample when new WAL has been written.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;last_lsn == lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;last_lsn = lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If advancing the write head of the circular buffer would crash into <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the read heads, then the buffer is full.&nbsp; In other words, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slowest reader (presumably apply) is the one that controls the release<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of space.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; new_write_head = (<a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;write_head + <span class="Constant">1</span>) % <a href="#L218" title="replication/walsender.c:218">LAG_TRACKER_BUFFER_SIZE</a>;<br/></li>
<li>&nbsp; &nbsp; buffer_full = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; NUM_SYNC_REP_WAIT_MODE; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (new_write_head == <a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;read_heads[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer_full = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the buffer is full, for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we just rewind by one slot and overwrite<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the last sample, as a simple (if somewhat uneven) way to <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sampling rate.&nbsp; There may be better adaptive compaction algorithms.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (buffer_full)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_write_head = <a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;write_head;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;write_head &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;write_head--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;write_head = <a href="#L218" title="replication/walsender.c:218">LAG_TRACKER_BUFFER_SIZE</a> - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Store a sample at the current write head position. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;buffer[<a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;write_head].lsn = lsn;<br/></li>
<li>&nbsp; &nbsp; <a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;buffer[<a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;write_head].time = local_flush_time;<br/></li>
<li>&nbsp; &nbsp; <a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;write_head = new_write_head;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find out how much time has elapsed between the moment WAL location 'lsn'<br/></li>
<li></span><span class="Comment"> * (or the highest known earlier LSN) was flushed locally and the time '<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>'.<br/></li>
<li></span><span class="Comment"> * We have a separate read head for each of the reported LSN locations we<br/></li>
<li></span><span class="Comment"> * receive in replies from standby; 'head' controls which read head is<br/></li>
<li></span><span class="Comment"> * used.&nbsp; Whenever a read head crosses an LSN which was written into the<br/></li>
<li></span><span class="Comment"> * lag buffer with <a href="#L4095" title="replication/walsender.c:4095">LagTrackerWrite</a>, we can use the associated timestamp to<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out the time this LSN (or an earlier one) was flushed locally, and<br/></li>
<li></span><span class="Comment"> * therefore compute the lag.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return -1 if no new sample data is available, and otherwise the elapsed<br/></li>
<li></span><span class="Comment"> * time in microseconds.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TimeOffset<br/></li>
<li><a id="L4160">&#x200c;</a><span class="linkable">LagTrackerRead</span>(<span class="Type">int</span> head, XLogRecPtr lsn, TimestampTz <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz time = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Read all unread samples up to this LSN or end of buffer. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;read_heads[head] != <a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;write_head &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;buffer[<a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;read_heads[head]].lsn &lt;= lsn)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; time = <a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;buffer[<a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;read_heads[head]].time;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;last_read[head] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;buffer[<a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;read_heads[head]];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;read_heads[head] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;read_heads[head] + <span class="Constant">1</span>) % <a href="#L218" title="replication/walsender.c:218">LAG_TRACKER_BUFFER_SIZE</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the lag tracker is empty, that means the standby has processed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * everything we've ever sent so we should <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> clear 'last_read'.&nbsp; If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * didn't do that, we'd risk using a stale and irrelevant sample for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interpolation at the beginning of the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> burst of WAL after a period<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of idleness.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;read_heads[head] == <a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;write_head)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;last_read[head].time = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (time &gt; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If the clock somehow went backwards, treat as not found. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (time == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We didn't cross a time.&nbsp; If there is a future sample that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * haven't reached yet, and we've already reached at least one sample,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * let's interpolate the local flushed time.&nbsp; This is mainly useful<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for reporting a completely stuck apply position as having<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * increasing lag, since otherwise we'd have to wait for it to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * eventually start moving again and cross one of our samples <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we can show the lag increasing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;read_heads[head] == <a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;write_head)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* There are no future samples, so we can't interpolate. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;last_read[head].time != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can interpolate between last_read and the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> sample. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; fraction;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L215" title="replication/walsender.c:215">WalTimeSample</a> prev = <a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;last_read[head];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L215" title="replication/walsender.c:215">WalTimeSample</a> <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;buffer[<a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;read_heads[head]];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lsn &lt; prev.lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reported LSNs shouldn't normally go backwards, but it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible when there is a timeline change.&nbsp; Treat as not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * found.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(prev.lsn &lt; <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>.lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prev.time &gt; <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>.time)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If the clock somehow went backwards, treat as not found. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See how far we are between the previous and <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> samples. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fraction =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">double</span>) (lsn - prev.lsn) / (<span class="Type">double</span>) (<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>.lsn - prev.lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Scale the local flush time proportionally. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; time = (TimestampTz)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((<span class="Type">double</span>) prev.time + (<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>.time - prev.time) * fraction);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have only a future sample, implying that we were entirely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caught up but and <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> there is a new burst of WAL and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * standby hasn't processed the first sample yet.&nbsp; Until the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * standby reaches the future sample the best we can do is report<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the hypothetical lag if that sample were to be replayed <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; time = <a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;buffer[<a href="#L230" title="replication/walsender.c:230">lag_tracker</a>-&gt;read_heads[head]].time;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return the elapsed time since local flush time in microseconds. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(time != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> - time;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
