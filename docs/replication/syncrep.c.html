<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>replication/syncrep.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>replication/syncrep.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L97">SyncRepConfig</a></li>
<li><a href="#L90">SyncRepStandbyNames</a></li>
<li><a href="#L98">SyncRepWaitMode</a></li>
<li><a href="#L95">announce_next_takeover</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L363">SyncRepCancelWait</a></li>
<li><a href="#L373">SyncRepCleanupAtProcExit</a></li>
<li><a href="#L711">SyncRepGetCandidateStandbys</a></li>
<li><a href="#L650">SyncRepGetNthLatestSyncRecPtr</a></li>
<li><a href="#L617">SyncRepGetOldestSyncRecPtr</a></li>
<li><a href="#L817">SyncRepGetStandbyPriority</a></li>
<li><a href="#L543">SyncRepGetSyncRecPtr</a></li>
<li><a href="#L402">SyncRepInitConfig</a></li>
<li><a href="#L329">SyncRepQueueInsert</a></li>
<li><a href="#L957">SyncRepQueueIsOrderedByLSN</a></li>
<li><a href="#L431">SyncRepReleaseWaiters</a></li>
<li><a href="#L921">SyncRepUpdateSyncStandbysDefined</a></li>
<li><a href="#L148">SyncRepWaitForLSN</a></li>
<li><a href="#L864">SyncRepWakeQueue</a></li>
<li><a href="#L1054">assign_synchronous_commit</a></li>
<li><a href="#L1048">assign_synchronous_standby_names</a></li>
<li><a href="#L991">check_synchronous_standby_names</a></li>
<li><a href="#L695">cmp_lsn</a></li>
<li><a href="#L790">standby_priority_comparator</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L92">SyncStandbysDefined</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * syncrep.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Synchronous replication is new as of PostgreSQL 9.1.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If requested, transaction commits wait until their commit LSN are<br/></li>
<li></span><span class="Comment"> * acknowledged by the synchronous standbys.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This module contains the code for <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> and release of backends.<br/></li>
<li></span><span class="Comment"> * All code in this module executes on the primary. The core streaming<br/></li>
<li></span><span class="Comment"> * replication transport remains within WALreceiver/WALsender modules.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The essence of this design is that it isolates all logic about<br/></li>
<li></span><span class="Comment"> * <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>/releasing onto the primary. The primary defines which standbys<br/></li>
<li></span><span class="Comment"> * it wishes to wait for. The standbys are completely unaware of the<br/></li>
<li></span><span class="Comment"> * durability requirements of transactions on the primary, reducing the<br/></li>
<li></span><span class="Comment"> * complexity of the code and streamlining both standby operations and<br/></li>
<li></span><span class="Comment"> * network bandwidth because there is no requirement to ship<br/></li>
<li></span><span class="Comment"> * per-transaction state information.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Replication is either synchronous or not synchronous (async). If it is<br/></li>
<li></span><span class="Comment"> * async, we just fastpath out of here. If it is sync, then we wait for<br/></li>
<li></span><span class="Comment"> * the write, flush or apply location on the standby <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> releasing<br/></li>
<li></span><span class="Comment"> * the <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> backend. Further complexity in that interaction is<br/></li>
<li></span><span class="Comment"> * expected in later releases.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The best performing way to manage the <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> backends is to have a<br/></li>
<li></span><span class="Comment"> * single ordered queue of <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> backends, so that we can avoid<br/></li>
<li></span><span class="Comment"> * searching the through all waiters each time we receive a reply.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In 9.5 or <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> only a single standby could be considered as<br/></li>
<li></span><span class="Comment"> * synchronous. In 9.6 we support a priority-based multiple synchronous<br/></li>
<li></span><span class="Comment"> * standbys. In 10.0 a quorum-based multiple synchronous standbys is also<br/></li>
<li></span><span class="Comment"> * supported. The number of synchronous standbys that transactions<br/></li>
<li></span><span class="Comment"> * must wait for replies from is specified in synchronous_standby_names.<br/></li>
<li></span><span class="Comment"> * This parameter also specifies a list of standby names and the method<br/></li>
<li></span><span class="Comment"> * (FIRST and ANY) to choose synchronous standbys from the listed ones.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The method FIRST specifies a priority-based synchronous replication<br/></li>
<li></span><span class="Comment"> * and makes transaction commits wait until their WAL <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> are<br/></li>
<li></span><span class="Comment"> * replicated to the requested number of synchronous standbys chosen based<br/></li>
<li></span><span class="Comment"> * on their priorities. The standbys whose names appear earlier in the list<br/></li>
<li></span><span class="Comment"> * are given higher priority and will be considered as synchronous.<br/></li>
<li></span><span class="Comment"> * Other standby servers appearing later in this list represent potential<br/></li>
<li></span><span class="Comment"> * synchronous standbys. If <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the current synchronous standbys<br/></li>
<li></span><span class="Comment"> * disconnects for whatever reason, it will be replaced immediately with<br/></li>
<li></span><span class="Comment"> * the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-highest-priority standby.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The method ANY specifies a quorum-based synchronous replication<br/></li>
<li></span><span class="Comment"> * and makes transaction commits wait until their WAL <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> are<br/></li>
<li></span><span class="Comment"> * replicated to at least the requested number of synchronous standbys<br/></li>
<li></span><span class="Comment"> * in the list. All the standbys appearing in the list are considered as<br/></li>
<li></span><span class="Comment"> * candidates for quorum synchronous standbys.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If neither FIRST nor ANY is specified, FIRST is used as the method.<br/></li>
<li></span><span class="Comment"> * This is for backward compatibility with 9.6 or <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> where only a<br/></li>
<li></span><span class="Comment"> * priority-based sync replication was supported.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Before the standbys chosen from synchronous_standby_names can<br/></li>
<li></span><span class="Comment"> * become the synchronous standbys they must have caught up with<br/></li>
<li></span><span class="Comment"> * the primary; that may take some time. Once caught up,<br/></li>
<li></span><span class="Comment"> * the standbys which are considered as synchronous at that moment<br/></li>
<li></span><span class="Comment"> * will release waiters from the queue.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 2010-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/replication/syncrep.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/int.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/syncrep.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/walsender.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/walsender_private.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/tcopprot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc_hooks.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/ps_status.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* User-settable parameters for sync rep */<br/></li>
<li><a id="L90">&#x200c;</a></span><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">SyncRepStandbyNames</span>;<br/></li>
<li><br/></li>
<li><a id="L92">&#x200c;</a><span class="PreProc">#define <span class="linkable">SyncStandbysDefined</span>() \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (<a href="#L90" title="replication/syncrep.c:90">SyncRepStandbyNames</a> != </span><span class="Constant">NULL</span><span class="PreProc"> &amp;&amp; <a href="#L90" title="replication/syncrep.c:90">SyncRepStandbyNames</a>[</span><span class="Constant">0</span><span class="PreProc">] != </span><span class="Special">'\0'</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L95">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">announce_next_takeover</span> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li><a id="L97">&#x200c;</a>SyncRepConfigData *<span class="linkable">SyncRepConfig</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L98">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">SyncRepWaitMode</span> = SYNC_REP_NO_WAIT;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L329" title="replication/syncrep.c:329">SyncRepQueueInsert</a>(<span class="Type">int</span> mode);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L363" title="replication/syncrep.c:363">SyncRepCancelWait</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L864" title="replication/syncrep.c:864">SyncRepWakeQueue</a>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> all, <span class="Type">int</span> mode);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L543" title="replication/syncrep.c:543">SyncRepGetSyncRecPtr</a>(XLogRecPtr *writePtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr *flushPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr *applyPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *am_sync);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L617" title="replication/syncrep.c:617">SyncRepGetOldestSyncRecPtr</a>(XLogRecPtr *writePtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr *flushPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr *applyPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SyncRepStandbyData *sync_standbys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> num_standbys);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L650" title="replication/syncrep.c:650">SyncRepGetNthLatestSyncRecPtr</a>(XLogRecPtr *writePtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr *flushPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr *applyPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SyncRepStandbyData *sync_standbys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> num_standbys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8 nth);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L817" title="replication/syncrep.c:817">SyncRepGetStandbyPriority</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L790" title="replication/syncrep.c:790">standby_priority_comparator</a>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L695" title="replication/syncrep.c:695">cmp_lsn</a>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L957" title="replication/syncrep.c:957">SyncRepQueueIsOrderedByLSN</a>(<span class="Type">int</span> mode);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ===========================================================<br/></li>
<li></span><span class="Comment"> * Synchronous Replication <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for normal user backends<br/></li>
<li></span><span class="Comment"> * ===========================================================<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait for synchronous replication, if requested by user.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Initially backends start in state SYNC_REP_NOT_WAITING and then<br/></li>
<li></span><span class="Comment"> * change that state to SYNC_REP_WAITING <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> adding ourselves<br/></li>
<li></span><span class="Comment"> * to the wait queue. During <a href="#L864" title="replication/syncrep.c:864">SyncRepWakeQueue</a>() a WALSender changes<br/></li>
<li></span><span class="Comment"> * the state to SYNC_REP_WAIT_COMPLETE once replication is confirmed.<br/></li>
<li></span><span class="Comment"> * This backend then resets its state to SYNC_REP_NOT_WAITING.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'lsn' represents the LSN to wait for.&nbsp; 'commit' indicates whether this LSN<br/></li>
<li></span><span class="Comment"> * represents a commit record.&nbsp; If it doesn't, then we wait only for the WAL<br/></li>
<li></span><span class="Comment"> * to be flushed if <a href="../access/transam/xact.c.html#L85" title="access/transam/xact.c:85">synchronous_commit</a> is set to the higher level of<br/></li>
<li></span><span class="Comment"> * remote_apply, because only commit <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> provide apply feedback.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L148">&#x200c;</a></span><span class="linkable">SyncRepWaitForLSN</span>(XLogRecPtr lsn, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> commit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This should be called while holding interrupts during a transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commit to prevent the follow-up shared memory queue cleanups to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * influenced by external interruptions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../utils/init/globals.c.html#L41" title="utils/init/globals.c:41">InterruptHoldoffCount</a> &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fast exit if user has not requested sync replication, or there are no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sync replication standby names defined.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since this routine gets called every commit time, it's important to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exit quickly if sync replication is not requested. So we check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="walsender.c.html#L109" title="replication/walsender.c:109">WalSndCtl</a>-&gt;sync_standbys_defined flag without the lock and exit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * immediately if it's false. If it's true, we need to check it again<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * later while holding the lock, to check the flag and operate the sync<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rep queue atomically. This is necessary to avoid the race condition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * described in <a href="#L921" title="replication/syncrep.c:921">SyncRepUpdateSyncStandbysDefined</a>(). On the other hand, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's false, the lock is not necessary because we don't touch the queue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!SyncRepRequested() ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !((<span class="Type">volatile</span> WalSndCtlData *) <a href="walsender.c.html#L109" title="replication/walsender.c:109">WalSndCtl</a>)-&gt;sync_standbys_defined)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cap the level for anything other than commit to remote flush only. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (commit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mode = <a href="#L98" title="replication/syncrep.c:98">SyncRepWaitMode</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mode = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(<a href="#L98" title="replication/syncrep.c:98">SyncRepWaitMode</a>, SYNC_REP_WAIT_FLUSH);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(dlist_node_is_detached(&amp;<a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;syncRepLinks));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="walsender.c.html#L109" title="replication/walsender.c:109">WalSndCtl</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SyncRepLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;syncRepState == SYNC_REP_NOT_WAITING);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't wait for sync rep if <a href="walsender.c.html#L109" title="replication/walsender.c:109">WalSndCtl</a>-&gt;sync_standbys_defined is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set.&nbsp; See <a href="#L921" title="replication/syncrep.c:921">SyncRepUpdateSyncStandbysDefined</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also check that the standby hasn't already replied. Unlikely race<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * condition but we'll be fetching that cache line anyway so it's likely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to be a low cost check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="walsender.c.html#L109" title="replication/walsender.c:109">WalSndCtl</a>-&gt;sync_standbys_defined ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lsn &lt;= <a href="walsender.c.html#L109" title="replication/walsender.c:109">WalSndCtl</a>-&gt;lsn[mode])<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SyncRepLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set our waitLSN so WALSender will know when to wake us, and add<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ourselves to the queue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitLSN = lsn;<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;syncRepState = SYNC_REP_WAITING;<br/></li>
<li>&nbsp; &nbsp; <a href="#L329" title="replication/syncrep.c:329">SyncRepQueueInsert</a>(mode);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L957" title="replication/syncrep.c:957">SyncRepQueueIsOrderedByLSN</a>(mode));<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SyncRepLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Alter ps display to show <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for sync rep. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/ps_status.c.html#L29" title="utils/misc/ps_status.c:29">update_process_title</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buffer[<span class="Constant">32</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sprintf(buffer, <span class="Constant">&quot;<a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>, LSN_FORMAT_ARGS(lsn));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/ps_status.c.html#L369" title="utils/misc/ps_status.c:369">set_ps_display_suffix</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Wait for specified LSN to be confirmed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Each proc has its own wait latch, so we perform a normal latch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check/wait loop here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must reset the latch <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> testing state. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Acquiring the lock is not needed, the latch ensures proper<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * barriers. If it looks like we're done, we must really be done,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because once walsender changes the state to SYNC_REP_WAIT_COMPLETE,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it will never update it again, so we can't be seeing a stale value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in that case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;syncRepState == SYNC_REP_WAIT_COMPLETE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If a wait for synchronous replication is pending, we can neither<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * acknowledge the commit nor raise ERROR or FATAL.&nbsp; The latter would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lead the client to believe that the transaction aborted, which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not true: it's already committed locally. The former is no good<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * either: the client has requested synchronous replication, and is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entitled to assume that an acknowledged commit is also replicated,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which might not be true. So in this case we issue a WARNING (which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * some clients may be able to interpret) and shut off further output.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We do NOT reset <a href="../utils/init/globals.c.html#L32" title="utils/init/globals.c:32">ProcDiePending</a>, so that the process will <a href="../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the commit is cleaned up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L32" title="utils/init/globals.c:32">ProcDiePending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ADMIN_SHUTDOWN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;canceling the wait for synchronous replication and terminating connection due to administrator command&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The transaction has already committed locally, but might not have been replicated to the standby.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/postgres.c.html#L90" title="tcop/postgres.c:90">whereToSendOutput</a> = DestNone;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L363" title="replication/syncrep.c:363">SyncRepCancelWait</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's unclear what to do if a query cancel interrupt arrives.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can't actually abort at this point, but ignoring the interrupt<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * altogether is not helpful, so we just terminate the wait with a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * suitable warning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L31" title="utils/init/globals.c:31">QueryCancelPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L31" title="utils/init/globals.c:31">QueryCancelPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;canceling wait for synchronous replication due to user request&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The transaction has already committed locally, but might not have been replicated to the standby.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L363" title="replication/syncrep.c:363">SyncRepCancelWait</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Wait on latch.&nbsp; Any condition that should wake us up will set the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * latch, so no need for timeout.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rc = <a href="../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>, WL_LATCH_SET | WL_POSTMASTER_DEATH, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_SYNC_REP);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the postmaster dies, we'll probably never get an acknowledgment,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because all the wal sender processes will exit. So just bail out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc &amp; WL_POSTMASTER_DEATH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L32" title="utils/init/globals.c:32">ProcDiePending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/postgres.c.html#L90" title="tcop/postgres.c:90">whereToSendOutput</a> = DestNone;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L363" title="replication/syncrep.c:363">SyncRepCancelWait</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WalSender has checked our LSN and has removed us from queue. Clean up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * state and leave.&nbsp; It's OK to reset these shared memory fields without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * holding SyncRepLock, because <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> walsenders will ignore us anyway when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're not on the queue.&nbsp; We need a read barrier to make sure we see the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * changes to the queue link (this might be unnecessary without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assertions, but better safe than sorry).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_read_barrier();<br/></li>
<li>&nbsp; &nbsp; Assert(dlist_node_is_detached(&amp;<a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;syncRepLinks));<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;syncRepState = SYNC_REP_NOT_WAITING;<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitLSN = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* reset ps display to remove the suffix */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/ps_status.c.html#L29" title="utils/misc/ps_status.c:29">update_process_title</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/ps_status.c.html#L421" title="utils/misc/ps_status.c:421">set_ps_display_remove_suffix</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> <a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a> into the specified SyncRepQueue, maintaining sorted invariant.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Usually we will go at tail of queue, though it's possible that we arrive<br/></li>
<li></span><span class="Comment"> * here out of order, so start at tail and work back to insertion point.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L329">&#x200c;</a></span><span class="linkable">SyncRepQueueInsert</span>(<span class="Type">int</span> mode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_head *queue;<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(mode &gt;= <span class="Constant">0</span> &amp;&amp; mode &lt; NUM_SYNC_REP_WAIT_MODE);<br/></li>
<li>&nbsp; &nbsp; queue = &amp;<a href="walsender.c.html#L109" title="replication/walsender.c:109">WalSndCtl</a>-&gt;SyncRepQueue[mode];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_reverse_foreach(iter, queue)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = dlist_container(PGPROC, syncRepLinks, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Stop at the queue <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> that we should insert after to ensure the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * queue is ordered by LSN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;waitLSN &lt; <a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;waitLSN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_insert_after(&amp;proc-&gt;syncRepLinks, &amp;<a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;syncRepLinks);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we get here, the list was either empty, or this process needs to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * at the head.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dlist_push_head(queue, &amp;<a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;syncRepLinks);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Acquire SyncRepLock and cancel <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> wait currently in progress.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L363">&#x200c;</a></span><span class="linkable">SyncRepCancelWait</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SyncRepLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!dlist_node_is_detached(&amp;<a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;syncRepLinks))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_delete_thoroughly(&amp;<a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;syncRepLinks);<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;syncRepState = SYNC_REP_NOT_WAITING;<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SyncRepLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L373">&#x200c;</a></span><span class="linkable">SyncRepCleanupAtProcExit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First check if we are removed from the queue without the lock to not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slow down backend exit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!dlist_node_is_detached(&amp;<a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;syncRepLinks))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SyncRepLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* maybe we have just been removed, so recheck */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!dlist_node_is_detached(&amp;<a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;syncRepLinks))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete_thoroughly(&amp;<a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;syncRepLinks);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SyncRepLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ===========================================================<br/></li>
<li></span><span class="Comment"> * Synchronous Replication <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for wal sender processes<br/></li>
<li></span><span class="Comment"> * ===========================================================<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Take <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> action required to initialise sync rep state from config<br/></li>
<li></span><span class="Comment"> * data. Called at WALSender startup and after each SIGHUP.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L402">&#x200c;</a></span><span class="linkable">SyncRepInitConfig</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; priority;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine if we are a potential sync standby and remember the result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for handling replies from standby.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; priority = <a href="#L817" title="replication/syncrep.c:817">SyncRepGetStandbyPriority</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="walsender.c.html#L112" title="replication/walsender.c:112">MyWalSnd</a>-&gt;sync_standby_priority != priority)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="walsender.c.html#L112" title="replication/walsender.c:112">MyWalSnd</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="walsender.c.html#L112" title="replication/walsender.c:112">MyWalSnd</a>-&gt;sync_standby_priority = priority;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="walsender.c.html#L112" title="replication/walsender.c:112">MyWalSnd</a>-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;standby </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> has synchronous standby priority </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/misc/guc_tables.c.html#L546" title="utils/misc/guc_tables.c:546">application_name</a>, priority)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update the LSNs on each queue based upon our latest state. This<br/></li>
<li></span><span class="Comment"> * implements a simple policy of first-valid-sync-standby-releases-waiter.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Other policies are possible, which would change what we do here and<br/></li>
<li></span><span class="Comment"> * perhaps also which information we store as well.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L431">&#x200c;</a></span><span class="linkable">SyncRepReleaseWaiters</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> WalSndCtlData *walsndctl = <a href="walsender.c.html#L109" title="replication/walsender.c:109">WalSndCtl</a>;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; writePtr;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; flushPtr;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; applyPtr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; got_recptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; am_sync;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numwrite = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numflush = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numapply = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this WALSender is serving a standby that is not on the list of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * potential sync standbys then we have nothing to do. If we are still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * starting up, still running base backup or the current flush position is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * still invalid, then leave quickly also.&nbsp; Streaming or stopping WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * senders are allowed to release waiters.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="walsender.c.html#L112" title="replication/walsender.c:112">MyWalSnd</a>-&gt;sync_standby_priority == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="walsender.c.html#L112" title="replication/walsender.c:112">MyWalSnd</a>-&gt;state != WALSNDSTATE_STREAMING &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="walsender.c.html#L112" title="replication/walsender.c:112">MyWalSnd</a>-&gt;state != WALSNDSTATE_STOPPING) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtrIsInvalid(<a href="walsender.c.html#L112" title="replication/walsender.c:112">MyWalSnd</a>-&gt;flush))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L95" title="replication/syncrep.c:95">announce_next_takeover</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We're a potential sync standby. Release waiters if there are enough<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sync standbys and we are considered as sync.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SyncRepLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check whether we are a sync standby or not, and calculate the synced<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * positions among all sync standbys.&nbsp; (Note: although this step does not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of itself require holding SyncRepLock, it seems like a good idea to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it after acquiring the lock.&nbsp; This ensures that the WAL pointers we use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to release waiters are newer than <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> previous execution of this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * routine used.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; got_recptr = <a href="#L543" title="replication/syncrep.c:543">SyncRepGetSyncRecPtr</a>(&amp;writePtr, &amp;flushPtr, &amp;applyPtr, &amp;am_sync);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are managing a sync standby, though we weren't prior to this,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then announce we are <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> a sync standby.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L95" title="replication/syncrep.c:95">announce_next_takeover</a> &amp;&amp; am_sync)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L95" title="replication/syncrep.c:95">announce_next_takeover</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L97" title="replication/syncrep.c:97">SyncRepConfig</a>-&gt;syncrep_method == SYNC_REP_PRIORITY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;standby </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> a synchronous standby with priority </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc_tables.c.html#L546" title="utils/misc/guc_tables.c:546">application_name</a>, <a href="walsender.c.html#L112" title="replication/walsender.c:112">MyWalSnd</a>-&gt;sync_standby_priority)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;standby </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> a candidate for quorum synchronous standby&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc_tables.c.html#L546" title="utils/misc/guc_tables.c:546">application_name</a>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the number of sync standbys is less than requested or we aren't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * managing a sync standby then just leave.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!got_recptr || !am_sync)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SyncRepLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L95" title="replication/syncrep.c:95">announce_next_takeover</a> = !am_sync;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set the lsn first so that when we wake backends they will release up to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this location.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (walsndctl-&gt;lsn[SYNC_REP_WAIT_WRITE] &lt; writePtr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; walsndctl-&gt;lsn[SYNC_REP_WAIT_WRITE] = writePtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numwrite = <a href="#L864" title="replication/syncrep.c:864">SyncRepWakeQueue</a>(<span class="Constant">false</span>, SYNC_REP_WAIT_WRITE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (walsndctl-&gt;lsn[SYNC_REP_WAIT_FLUSH] &lt; flushPtr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; walsndctl-&gt;lsn[SYNC_REP_WAIT_FLUSH] = flushPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numflush = <a href="#L864" title="replication/syncrep.c:864">SyncRepWakeQueue</a>(<span class="Constant">false</span>, SYNC_REP_WAIT_FLUSH);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (walsndctl-&gt;lsn[SYNC_REP_WAIT_APPLY] &lt; applyPtr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; walsndctl-&gt;lsn[SYNC_REP_WAIT_APPLY] = applyPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numapply = <a href="#L864" title="replication/syncrep.c:864">SyncRepWakeQueue</a>(<span class="Constant">false</span>, SYNC_REP_WAIT_APPLY);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SyncRepLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG3, <span class="Constant">&quot;released </span><span class="Special">%d</span><span class="Constant"> procs up to write </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, </span><span class="Special">%d</span><span class="Constant"> procs up to flush </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, </span><span class="Special">%d</span><span class="Constant"> procs up to apply </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numwrite, LSN_FORMAT_ARGS(writePtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numflush, LSN_FORMAT_ARGS(flushPtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numapply, LSN_FORMAT_ARGS(applyPtr));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Calculate the synced Write, Flush and Apply positions among sync standbys.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return false if the number of sync standbys is less than<br/></li>
<li></span><span class="Comment"> * synchronous_standby_names specifies. Otherwise return true and<br/></li>
<li></span><span class="Comment"> * store the positions into *writePtr, *flushPtr and *applyPtr.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On return, *am_sync is set to true if this walsender is connecting to<br/></li>
<li></span><span class="Comment"> * sync standby. Otherwise it's set to false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L543">&#x200c;</a></span><span class="linkable">SyncRepGetSyncRecPtr</span>(XLogRecPtr *writePtr, XLogRecPtr *flushPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr *applyPtr, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *am_sync)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SyncRepStandbyData *sync_standbys;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_standbys;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize default results */<br/></li>
<li></span>&nbsp; &nbsp; *writePtr = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; *flushPtr = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; *applyPtr = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; *am_sync = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick out if not even configured to be synchronous */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L97" title="replication/syncrep.c:97">SyncRepConfig</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get standbys that are considered as synchronous at this moment */<br/></li>
<li></span>&nbsp; &nbsp; num_standbys = <a href="#L711" title="replication/syncrep.c:711">SyncRepGetCandidateStandbys</a>(&amp;sync_standbys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Am I among the candidate sync standbys? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_standbys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sync_standbys[i].is_me)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *am_sync = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Nothing more to do if we are not managing a sync standby or there are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not enough synchronous standbys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(*am_sync) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; num_standbys &lt; <a href="#L97" title="replication/syncrep.c:97">SyncRepConfig</a>-&gt;num_sync)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(sync_standbys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In a priority-based sync replication, the synced positions are the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * oldest ones among sync standbys. In a quorum-based, they are the Nth<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * latest ones.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L650" title="replication/syncrep.c:650">SyncRepGetNthLatestSyncRecPtr</a>() also can calculate the oldest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * positions. But we use <a href="#L617" title="replication/syncrep.c:617">SyncRepGetOldestSyncRecPtr</a>() for that calculation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because it's a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> more efficient.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> If the numbers of current and requested sync standbys are the same,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we can use <a href="#L617" title="replication/syncrep.c:617">SyncRepGetOldestSyncRecPtr</a>() to calculate the synced<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * positions even in a quorum-based sync replication.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L97" title="replication/syncrep.c:97">SyncRepConfig</a>-&gt;syncrep_method == SYNC_REP_PRIORITY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L617" title="replication/syncrep.c:617">SyncRepGetOldestSyncRecPtr</a>(writePtr, flushPtr, applyPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sync_standbys, num_standbys);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L650" title="replication/syncrep.c:650">SyncRepGetNthLatestSyncRecPtr</a>(writePtr, flushPtr, applyPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sync_standbys, num_standbys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="replication/syncrep.c:97">SyncRepConfig</a>-&gt;num_sync);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(sync_standbys);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Calculate the oldest Write, Flush and Apply positions among sync standbys.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L617">&#x200c;</a></span><span class="linkable">SyncRepGetOldestSyncRecPtr</span>(XLogRecPtr *writePtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr *flushPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr *applyPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SyncRepStandbyData *sync_standbys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> num_standbys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan through all sync standbys and calculate the oldest Write, Flush<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and Apply positions.&nbsp; We assume *writePtr et al were initialized to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * InvalidXLogRecPtr.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_standbys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; write = sync_standbys[i].write;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; flush = sync_standbys[i].flush;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; apply = sync_standbys[i].apply;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(*writePtr) || *writePtr &gt; write)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *writePtr = write;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(*flushPtr) || *flushPtr &gt; flush)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *flushPtr = flush;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(*applyPtr) || *applyPtr &gt; apply)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *applyPtr = apply;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Calculate the Nth latest Write, Flush and Apply positions among sync<br/></li>
<li></span><span class="Comment"> * standbys.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L650">&#x200c;</a></span><span class="linkable">SyncRepGetNthLatestSyncRecPtr</span>(XLogRecPtr *writePtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr *flushPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr *applyPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SyncRepStandbyData *sync_standbys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> num_standbys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8 nth)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr *write_array;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr *flush_array;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr *apply_array;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should have enough candidates, or somebody messed up */<br/></li>
<li></span>&nbsp; &nbsp; Assert(nth &gt; <span class="Constant">0</span> &amp;&amp; nth &lt;= num_standbys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; write_array = (XLogRecPtr *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(XLogRecPtr) * num_standbys);<br/></li>
<li>&nbsp; &nbsp; flush_array = (XLogRecPtr *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(XLogRecPtr) * num_standbys);<br/></li>
<li>&nbsp; &nbsp; apply_array = (XLogRecPtr *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(XLogRecPtr) * num_standbys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_standbys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; write_array[i] = sync_standbys[i].write;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flush_array[i] = sync_standbys[i].flush;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; apply_array[i] = sync_standbys[i].apply;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort each array in descending order */<br/></li>
<li></span>&nbsp; &nbsp; qsort(write_array, num_standbys, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(XLogRecPtr), <a href="#L695" title="replication/syncrep.c:695">cmp_lsn</a>);<br/></li>
<li>&nbsp; &nbsp; qsort(flush_array, num_standbys, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(XLogRecPtr), <a href="#L695" title="replication/syncrep.c:695">cmp_lsn</a>);<br/></li>
<li>&nbsp; &nbsp; qsort(apply_array, num_standbys, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(XLogRecPtr), <a href="#L695" title="replication/syncrep.c:695">cmp_lsn</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get Nth latest Write, Flush, Apply positions */<br/></li>
<li></span>&nbsp; &nbsp; *writePtr = write_array[nth - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; *flushPtr = flush_array[nth - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; *applyPtr = apply_array[nth - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(write_array);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(flush_array);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(apply_array);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compare lsn in order to sort array in descending order.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L695">&#x200c;</a></span><span class="linkable">cmp_lsn</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn1 = *((<span class="Type">const</span> XLogRecPtr *) a);<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn2 = *((<span class="Type">const</span> XLogRecPtr *) b);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_cmp_u64(lsn2, lsn1);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return data about walsenders that are candidates to be sync standbys.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *standbys is set to a <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d array of structs of per-walsender data,<br/></li>
<li></span><span class="Comment"> * and the number of valid entries (candidate sync senders) is returned.<br/></li>
<li></span><span class="Comment"> * (This might be more or fewer than num_sync; caller must check.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L711">&#x200c;</a></span><span class="linkable">SyncRepGetCandidateStandbys</span>(SyncRepStandbyData **standbys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create result array */<br/></li>
<li></span>&nbsp; &nbsp; *standbys = (SyncRepStandbyData *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<a href="walsender.c.html#L121" title="replication/walsender.c:121">max_wal_senders</a> * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SyncRepStandbyData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick exit if sync replication is not requested */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L97" title="replication/syncrep.c:97">SyncRepConfig</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Collect raw data from shared memory */<br/></li>
<li></span>&nbsp; &nbsp; n = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="walsender.c.html#L121" title="replication/walsender.c:121">max_wal_senders</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">volatile</span> WalSnd *walsnd;&nbsp; &nbsp; <span class="Comment">/* Use volatile pointer to prevent code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rearrangement */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SyncRepStandbyData *stby;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WalSndState state;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not included in SyncRepStandbyData */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; walsnd = &amp;<a href="walsender.c.html#L109" title="replication/walsender.c:109">WalSndCtl</a>-&gt;walsnds[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stby = *standbys + n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;walsnd-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stby-&gt;pid = walsnd-&gt;pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state = walsnd-&gt;state;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stby-&gt;write = walsnd-&gt;write;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stby-&gt;flush = walsnd-&gt;flush;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stby-&gt;apply = walsnd-&gt;apply;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stby-&gt;sync_standby_priority = walsnd-&gt;sync_standby_priority;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;walsnd-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must be active */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stby-&gt;pid == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must be streaming or stopping */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state != WALSNDSTATE_STREAMING &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state != WALSNDSTATE_STOPPING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must be synchronous */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stby-&gt;sync_standby_priority == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must have a valid flush position */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(stby-&gt;flush))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, it's a candidate */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stby-&gt;walsnd_index = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stby-&gt;is_me = (walsnd == <a href="walsender.c.html#L112" title="replication/walsender.c:112">MyWalSnd</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In quorum mode, we return all the candidates.&nbsp; In priority mode, if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have too many candidates then return only the num_sync ones of highest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * priority.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L97" title="replication/syncrep.c:97">SyncRepConfig</a>-&gt;syncrep_method == SYNC_REP_PRIORITY &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n &gt; <a href="#L97" title="replication/syncrep.c:97">SyncRepConfig</a>-&gt;num_sync)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sort by priority ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qsort(*standbys, n, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SyncRepStandbyData),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L790" title="replication/syncrep.c:790">standby_priority_comparator</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... then report just the first num_sync ones */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; n = <a href="#L97" title="replication/syncrep.c:97">SyncRepConfig</a>-&gt;num_sync;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> n;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * qsort comparator to sort SyncRepStandbyData entries by priority<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L790">&#x200c;</a></span><span class="linkable">standby_priority_comparator</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> SyncRepStandbyData *sa = (<span class="Type">const</span> SyncRepStandbyData *) a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> SyncRepStandbyData *sb = (<span class="Type">const</span> SyncRepStandbyData *) b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First, sort by increasing priority value */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sa-&gt;sync_standby_priority != sb-&gt;sync_standby_priority)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> sa-&gt;sync_standby_priority - sb-&gt;sync_standby_priority;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We might have <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> priority <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>; arbitrarily break ties by position<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the WalSnd array.&nbsp; (This is utterly bogus, since that is arrival<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * order dependent, but there are regression tests that rely on it.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> sa-&gt;walsnd_index - sb-&gt;walsnd_index;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check if we are in the list of sync standbys, and if so, determine<br/></li>
<li></span><span class="Comment"> * priority sequence. Return priority if set, or zero to indicate that<br/></li>
<li></span><span class="Comment"> * we are not a potential sync standby.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Compare the parameter <a href="#L90" title="replication/syncrep.c:90">SyncRepStandbyNames</a> against the <a href="../utils/misc/guc_tables.c.html#L546" title="utils/misc/guc_tables.c:546">application_name</a><br/></li>
<li></span><span class="Comment"> * for this WALSender, or allow <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> name if we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a wildcard &quot;*&quot;.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L817">&#x200c;</a></span><span class="linkable">SyncRepGetStandbyPriority</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *standby_name;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; priority;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since synchronous cascade replication is not allowed, we always set the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * priority of cascading walsender to zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="walsender.c.html#L116" title="replication/walsender.c:116">am_cascading_walsender</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L92" title="replication/syncrep.c:92">SyncStandbysDefined</a>() || <a href="#L97" title="replication/syncrep.c:97">SyncRepConfig</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; standby_name = <a href="#L97" title="replication/syncrep.c:97">SyncRepConfig</a>-&gt;member_names;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (priority = <span class="Constant">1</span>; priority &lt;= <a href="#L97" title="replication/syncrep.c:97">SyncRepConfig</a>-&gt;nmembers; priority++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_strcasecmp(standby_name, <a href="../utils/misc/guc_tables.c.html#L546" title="utils/misc/guc_tables.c:546">application_name</a>) == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcmp(standby_name, <span class="Constant">&quot;*&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; standby_name += strlen(standby_name) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In quorum-based sync replication, all the standbys in the list have the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same priority, one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="#L97" title="replication/syncrep.c:97">SyncRepConfig</a>-&gt;syncrep_method == SYNC_REP_PRIORITY) ? priority : <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Walk the specified queue from head.&nbsp; Set the state of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> backends that<br/></li>
<li></span><span class="Comment"> * need to be woken, remove them from the queue, and then wake them.<br/></li>
<li></span><span class="Comment"> * Pass all = true to wake whole queue; otherwise, just wake up to<br/></li>
<li></span><span class="Comment"> * the walsender's LSN.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must hold SyncRepLock in exclusive mode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L864">&#x200c;</a></span><span class="linkable">SyncRepWakeQueue</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> all, <span class="Type">int</span> mode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> WalSndCtlData *walsndctl = <a href="walsender.c.html#L109" title="replication/walsender.c:109">WalSndCtl</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numprocs = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; dlist_mutable_iter iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(mode &gt;= <span class="Constant">0</span> &amp;&amp; mode &lt; NUM_SYNC_REP_WAIT_MODE);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../storage/lmgr/lwlock.c.html#L1939" title="storage/lmgr/lwlock.c:1939">LWLockHeldByMeInMode</a>(SyncRepLock, LW_EXCLUSIVE));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L957" title="replication/syncrep.c:957">SyncRepQueueIsOrderedByLSN</a>(mode));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_foreach_modify(iter, &amp;<a href="walsender.c.html#L109" title="replication/walsender.c:109">WalSndCtl</a>-&gt;SyncRepQueue[mode])<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = dlist_container(PGPROC, syncRepLinks, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Assume the queue is ordered by LSN<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!all &amp;&amp; walsndctl-&gt;lsn[mode] &lt; proc-&gt;waitLSN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> numprocs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remove from queue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dlist_delete_thoroughly(&amp;proc-&gt;syncRepLinks);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L148" title="replication/syncrep.c:148">SyncRepWaitForLSN</a>() reads syncRepState without holding the lock, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * make sure that it sees the queue link being removed <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * syncRepState change.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pg_write_barrier();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set state to complete; see <a href="#L148" title="replication/syncrep.c:148">SyncRepWaitForLSN</a>() for discussion of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the various states.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;syncRepState = SYNC_REP_WAIT_COMPLETE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Wake only when we have set state and removed from queue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(&amp;(proc-&gt;procLatch));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numprocs++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> numprocs;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The checkpointer calls this as needed to update the shared<br/></li>
<li></span><span class="Comment"> * sync_standbys_defined flag, so that backends don't remain permanently wedged<br/></li>
<li></span><span class="Comment"> * if synchronous_standby_names is unset.&nbsp; It's safe to check the current value<br/></li>
<li></span><span class="Comment"> * without the lock, because it's only ever updated by one process.&nbsp; But we<br/></li>
<li></span><span class="Comment"> * must take the lock to change it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L921">&#x200c;</a></span><span class="linkable">SyncRepUpdateSyncStandbysDefined</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sync_standbys_defined = <a href="#L92" title="replication/syncrep.c:92">SyncStandbysDefined</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sync_standbys_defined != <a href="walsender.c.html#L109" title="replication/walsender.c:109">WalSndCtl</a>-&gt;sync_standbys_defined)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SyncRepLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If synchronous_standby_names has been reset to empty, it's futile<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for backends to continue <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>.&nbsp; Since the user no longer wants<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * synchronous replication, we'd better wake them up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!sync_standbys_defined)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; NUM_SYNC_REP_WAIT_MODE; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L864" title="replication/syncrep.c:864">SyncRepWakeQueue</a>(<span class="Constant">true</span>, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Only allow people to join the queue when there are synchronous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * standbys defined.&nbsp; Without this interlock, there's a race<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * condition: we might wake up all the current waiters; then, some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backend that hasn't yet reloaded its config might go to sleep on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the queue (and never wake up).&nbsp; This prevents that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="walsender.c.html#L109" title="replication/walsender.c:109">WalSndCtl</a>-&gt;sync_standbys_defined = sync_standbys_defined;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SyncRepLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L957">&#x200c;</a></span><span class="linkable">SyncRepQueueIsOrderedByLSN</span>(<span class="Type">int</span> mode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lastLSN;<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(mode &gt;= <span class="Constant">0</span> &amp;&amp; mode &lt; NUM_SYNC_REP_WAIT_MODE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lastLSN = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_foreach(iter, &amp;<a href="walsender.c.html#L109" title="replication/walsender.c:109">WalSndCtl</a>-&gt;SyncRepQueue[mode])<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = dlist_container(PGPROC, syncRepLinks, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check the queue is ordered by LSN and that multiple procs don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have matching LSNs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (proc-&gt;waitLSN &lt;= lastLSN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lastLSN = proc-&gt;waitLSN;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ===========================================================<br/></li>
<li></span><span class="Comment"> * Synchronous Replication <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> executed by <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> process<br/></li>
<li></span><span class="Comment"> * ===========================================================<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L991">&#x200c;</a></span><span class="linkable">check_synchronous_standby_names</span>(<span class="Type">char</span> **<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> != <span class="Constant">NULL</span> &amp;&amp; (*<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>)[<span class="Constant">0</span>] != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parse_rc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SyncRepConfigData *pconf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset communication variables to ensure a fresh start */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; syncrep_parse_result = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; syncrep_parse_error_msg = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Parse the synchronous_standby_names string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; syncrep_scanner_init(*<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parse_rc = syncrep_yyparse();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; syncrep_scanner_finish();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parse_rc != <span class="Constant">0</span> || syncrep_parse_result == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L6744" title="utils/misc/guc.c:6744">GUC_check_errcode</a>(ERRCODE_SYNTAX_ERROR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (syncrep_parse_error_msg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GUC_check_errdetail(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, syncrep_parse_error_msg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GUC_check_errdetail(<span class="Constant">&quot;synchronous_standby_names parser failed&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (syncrep_parse_result-&gt;num_sync &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GUC_check_errmsg(<span class="Constant">&quot;number of synchronous standbys (</span><span class="Special">%d</span><span class="Constant">) must be greater than zero&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; syncrep_parse_result-&gt;num_sync);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* GUC extra value must be <a href="../utils/misc/guc.c.html#L640" title="utils/misc/guc.c:640">guc_malloc</a>'d, not <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pconf = (SyncRepConfigData *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L640" title="utils/misc/guc.c:640">guc_malloc</a>(LOG, syncrep_parse_result-&gt;config_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pconf == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(pconf, syncrep_parse_result, syncrep_parse_result-&gt;config_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *extra = (<span class="Type">void</span> *) pconf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need not explicitly clean up syncrep_parse_result.&nbsp; It, and <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other cruft generated during parsing, will be freed when the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current memory context is deleted.&nbsp; (This code is generally run in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a short-lived context used for config file processing, so that will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not be very long.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *extra = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1048">&#x200c;</a></span><span class="linkable">assign_synchronous_standby_names</span>(<span class="Type">const</span> <span class="Type">char</span> *<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="replication/syncrep.c:97">SyncRepConfig</a> = (SyncRepConfigData *) extra;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1054">&#x200c;</a></span><span class="linkable">assign_synchronous_commit</span>(<span class="Type">int</span> <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SYNCHRONOUS_COMMIT_REMOTE_WRITE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L98" title="replication/syncrep.c:98">SyncRepWaitMode</a> = SYNC_REP_WAIT_WRITE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SYNCHRONOUS_COMMIT_REMOTE_FLUSH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L98" title="replication/syncrep.c:98">SyncRepWaitMode</a> = SYNC_REP_WAIT_FLUSH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SYNCHRONOUS_COMMIT_REMOTE_APPLY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L98" title="replication/syncrep.c:98">SyncRepWaitMode</a> = SYNC_REP_WAIT_APPLY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L98" title="replication/syncrep.c:98">SyncRepWaitMode</a> = SYNC_REP_NO_WAIT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
